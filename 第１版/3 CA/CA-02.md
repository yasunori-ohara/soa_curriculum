# CA-02: 🔵 Entities レイヤーの実装 (domain)

`CA-01` で示した設計図に基づき、「内側から」の実装を開始します。
最初のステップは、アプリケーションの「魂」であり、同心円の最も中心に位置する **Entities（エンティティ）** レイヤーです。「守るべき宝物」が何であるかを最初に定義します。

このレイヤーに対応するのは `domain/` ディレクトリです。

## 🎯 この章のゴール

  * クリーンアーキテクチャの最も内側のレイヤー（Entities）の役割を理解する。
  * `domain/` ディレクトリに、外部（`use_cases` や `infrastructure`）から一切依存しない、純粋なビジネスルール（クラス）を実装する。
  * `OOP` の章で完成させた `Product` と `Order` のクラスを、`domain` レイヤーに配置する。

-----

## 🏛️ このレイヤーの鉄則

1.  **外部への依存は許されない:**
    このレイヤーのファイル（`.py`）の中には、`use_cases` や `interface_adapters` など、自分より外側のレイヤーからの `import` 文は**絶対に現れません**。依存が許されるのは、Pythonの標準ライブラリ（`abc` など）だけです。
2.  **純粋なビジネスロジックに徹する:**
    `print()` でエラーメッセージを表示したり、データベースに接続したり、`JSON` を作成したりといった、ビジネスの本質と関係ない処理（＝技術的詳細）は一切書きません。
3.  **安定しているべき:**
    このレイヤーは、ビジネスのルールそのものを表現しているため、技術の流行り廃りの影響を受けません。最も安定した、変更頻度の低いレイヤーでなければなりません。

-----

## 📄 `domain/product.py` の実装

`OOP` の章でリファクタリングを重ね、LSP（リスコフの置換原則）まで修正した `Product` 関連のクラス群を、そのまま配置します。

```python:domain/product.py
# 依存性のルール:
# このファイルは Entities レイヤーです。
# 外部のレイヤーに一切依存せず、Python標準ライブラリ(abc)のみ使用します。

from abc import ABC, abstractmethod

class Product(ABC):
    """
    【Entitiesレイヤー】
    商品というビジネスオブジェクトの「概念」を定義する抽象基底クラス。
    これはアプリケーションのユースケース（どう使われるか）には依存しない、
    最も中心的で普遍的なビジネスルール（エンティティ）を表現します。
    """
    def __init__(self, product_id: str, name: str, price: int):
        self.product_id = product_id
        self.name = name
        self.price = price

    @abstractmethod
    def check_stock(self, quantity: int) -> bool:
        """【契約】在庫を確認する"""
        pass

    @abstractmethod
    def reduce_stock(self, quantity: int):
        """【契約】在庫を減らす"""
        pass

    @abstractmethod
    def get_stock(self) -> int:
        """
        【契約】現在の在庫数を「数値」で取得する
        ※ OOP-06で学んだLSP（リスコフの置換原則）を遵守するため、
        　 戻り値は int に統一します。
        """
        pass
    
    @abstractmethod
    def is_stock_managed(self) -> bool:
        """
        【契約】在庫管理の対象商品かどうかを返す
        ※ これもLSPを遵守し、利用側(use_cases)が安全に
           振る舞いを判断できるようにするための契約です。
        """
        pass

class PhysicalProduct(Product):
    """
    【Entitiesレイヤー】
    物理的な在庫を持つ商品。Productという「契約」を具体的に実装します。
    """
    def __init__(self, product_id: str, name: str, price: int, stock: int):
        super().__init__(product_id, name, price)
        self._stock = stock

    def check_stock(self, quantity: int) -> bool:
        """【実装】物理的な在庫数と注文数を比較します。"""
        return self._stock >= quantity

    def reduce_stock(self, quantity: int):
        """【実装】在庫が十分にあれば、物理的な在庫数を減らします。"""
        if self.check_stock(quantity):
            self._stock -= quantity

    def get_stock(self) -> int:
        """【実装】現在の物理的な在庫数を数値として返します。"""
        return self._stock
    
    def is_stock_managed(self) -> bool:
        """【実装】物理商品は在庫管理の対象です。"""
        return True

class DigitalProduct(Product):
    """
    【Entitiesレイヤー】
    在庫の概念がないダウンロード商品。同じくProductという「契約」を実装します。
    """
    def __init__(self, product_id: str, name: str, price: int):
        super().__init__(product_id, name, price)
        
    def check_stock(self, quantity: int) -> bool:
        """【実装】ダウンロード商品は常に在庫があるので、Trueを返します。"""
        return True

    def reduce_stock(self, quantity: int):
        """【実装】在庫を減らすという概念がないため、何も処理を行いません。"""
        pass

    def get_stock(self) -> int:
        """
        【実装】LSPを遵守するため、「数値」を返します。
        在庫の概念がないため、0 を返します。
        """
        return 0
    
    def is_stock_managed(self) -> bool:
        """【実装】ダウンロード商品は在庫管理の対象外です。"""
        return False
```

-----

## 📄 `domain/order.py` の実装

`Product` と同様に、「注文 (`Order`)」もビジネスの核心的な概念（エンティティ）です。`OOP-05` で作成した `Order` クラスを、この `domain` レイヤーに配置します。

```python:domain/order.py
# 依存性のルール:
# このファイルも Entities レイヤーです。
# Python標準ライブラリ(datetime)のみ使用します。

import datetime

class Order:
    """
    【Entitiesレイヤー】
    「注文」というビジネス概念を表すクラス（エンティティ）。
    注文が成立した際に作成される、ビジネスルール上の「モノ」です。
    """
    def __init__(self, product_name: str, quantity: int, total_price: int):
        self.product_name = product_name
        self.quantity = quantity
        self.total_price = total_price
        # 注文日時は、注文エンティティが生成される際のビジネスルール
        self.order_date = datetime.datetime.now().isoformat()
        
    def __repr__(self):
        # print() で表示したときに見やすくするためのメソッド
        return f"<Order: {self.product_name}, Qty: {self.quantity}, Price: {self.total_price}>"

```

これで「宝物庫（`domain` レイヤー）」の準備が整いました。
次のステップ（`CA-03`）では、この宝物庫の「扉の鍵穴（インターフェース）」を `use_cases` レイヤーに定義していきます。