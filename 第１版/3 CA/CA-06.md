# CA-06: 🔴 Infrastructure レイヤー
### 組立と実行 (main.py)

`CA-05` で、内側の世界（`use_cases`）が要求した「鍵穴（インターフェース）」に合う「具体的な鍵（リポジトリの実装）」が完成しました。

これで、`domain`, `use_cases`, `interface_adapters` という、アプリケーションを構成する「部品」がすべて揃いました。
この `CA-06` では、クリーンアーキテクチャの同心円の中で最も外側に位置する `Infrastructure` レイヤー（`main.py`）を実装します。

## 🎯 この章のゴール

  * 最も外側のレイヤー（`main.py`）の役割が「組立工場（Composition Root）」であることを理解する。
  * **依存性の注入 (DI)** を行い、`use_cases`（抽象）と `interface_adapters`（具象）を「接続」する。
  * アプリケーションを起動し、ユースケースを実行する。
  * 「技術的詳細（`InMemory` を使うなど）」が `main.py` に集約され、内側のレイヤーが守られていることを確認する。

-----

## 🏭 このファイルの役割：すべてを組み立てる「組立工場」

この `main.py` ファイルは、クリーンアーキテクチャの「組立工場」です。この場所を特別に \*\*Composition Root（コンポジションルート）\*\*と呼びます。

その役割は、これまで各レイヤーで作ってきたすべての「抽象的な部品」と「具体的な部品」を、ここで初めて結合し、アプリケーション全体を組み立てて、命を吹き込むことです。

  * `OOP` の `main.py`（`OOP-07`）は `ProductFactory` を使って「部品の**生成**」を分離しました。
  * `CA` の `main.py` は、さらに進んで「部品の**組立**」と「ロジックの**実行**」を完全に分離します。

-----

## 💻 ソースコードの詳細解説

### `import`文: 唯一、すべてを知る場所

`import`文に注目してください。この `main.py` は、`domain`, `use_cases`, `interface_adapters` というすべての内側レイヤーから**具体的なクラス**をインポートしています。これは、この組立工場だけが持つ特権です。

### 1\. 依存性の注入 (Dependency Injection)

ここがこのファイルの心臓部です。

1.  `InMemoryProductRepository()` と `InMemoryOrderRepository()` という「**具体的な鍵（アダプター）**」のインスタンスを作成します。ここで初めて、このアプリケーションが「インメモリDBを使う」という技術的な決定が下されます。
2.  `ProcessOrderUseCase(...)` という「**指揮者（ユースケース）**」のインスタンスを作成します。
3.  その際、コンストラクタに、先ほど作成した具体的なリポジトリを\*\*「注入（DI）」\*\*します。

`ProcessOrderUseCase` は、自分が受け取った `repo` が `InMemory...` であるという事実を一切知りません。ただ、それが `IProductRepository` という「契約書（鍵穴）」を守っていることだけを信頼して動作します。

### 2\. 初期データの設定

組立工場では、車を組み立てるだけでなく、出荷前にガソリンを入れたりもします。この部分も同様に、アプリケーションが動作するための具体的な準備（初期データの投入）を行っています。

### 3\. アプリケーションの実行

`use_case.execute(...)` を呼び出している部分が、実際にアプリケーションの機能を実行している箇所です。これは、Web APIのエンドポイントが叩かれたり、ユーザーがボタンをクリックしたりする「外部からのトリガー」を模倣しています。

-----

## 🏛️ このレイヤーの鉄則

1.  **ビジネスロジックを書かない:**
    このファイルは部品を組み立てることに専念します。`if`文などを使ったビジネス上の判断（在庫チェックなど）は、ここには一切書きません。
2.  **すべての「具象」を知っている:**
    どの「インターフェース」にどの「実装クラス」を割り当てるか、そのすべての組み合わせを知っている唯一の場所です。
3.  **最も変更されやすい:**
    データベースを `InMemory` から `MySQL` に変える、`print` を `Webフレームワーク` に変える、といった技術的な変更があった場合、主に修正されるのはこのファイルです。しかし、このファイルが変更されても、**内側のレイヤーは一切影響を受けません**。

-----

## 📄 `infrastructure/main.py` の実装

```python:infrastructure/main.py
# 依存性のルール:
# このファイルは最も外側の Infrastructure レイヤーに属します。
# アプリケーション全体を組み立てるため、すべての内側のレイヤーから
# クラスをインポートすることが許される、唯一の場所です。

# 🔵 domain から「エンティティ」をインポート (初期データ設定のため)
from domain.product import PhysicalProduct, DigitalProduct

# 🟢 use_cases から「ユースケース（指揮者）」をインポート
from use_cases.process_order_use_case import ProcessOrderUseCase

# 🟡 interface_adapters から「具体的な実装（リポジトリ）」をインポート
from interface_adapters.repositories import (
    InMemoryProductRepository, 
    InMemoryOrderRepository
)

def main():
    """
    【Infrastructureレイヤー / Composition Root】
    アプリケーションのすべての部品を組み立て、起動するためのメイン関数。
    """
    print("--- アプリケーション組立開始 (Composition Root) ---")
    
    # --- 1. 依存性の注入 (Dependency Injection) ---
    # ここで初めて、どの「抽象（鍵穴）」にどの「具象（鍵）」を使うかを決定します。
    
    # 「具体的な鍵」のインスタンスを生成
    product_repo = InMemoryProductRepository()
    order_repo = InMemoryOrderRepository()
    
    # 「指揮者（Use Case）」に、具体的な鍵（リポジトリ）を注入（DI）します。
    # UseCaseは、渡されたものが「InMemory」であることは知りません。
    use_case = ProcessOrderUseCase(
        product_repo=product_repo, 
        order_repo=order_repo
    )
    
    print("--- 組立完了 ---")

    # --- 2. 初期データの設定 (インフラ層の責任) ---
    # アプリケーションの動作に必要な初期データを準備します。
    print("\n--- 初期在庫データ投入 ---")
    mouse = PhysicalProduct("p-001", "高機能マウス", 4000, 10)
    ebook = DigitalProduct("d-001", "Python入門 eBook", 3000)
    product_repo.save(mouse)
    product_repo.save(ebook)
    
    # --- 3. アプリケーションの実行 (インフラ層の責任) ---
    # 外部からのトリガー（例：Webリクエスト）を模倣し、ユースケースを実行します。
    print("\n--- ユースケース実行 ---")
    
    # シナリオ1: 正常な注文
    print("\n[シナリオ1: 正常な注文 (マウス x 3)]")
    # このレイヤー(main)は、CA-04で設計した通り、辞書(dict)を受け取ります
    result1 = use_case.execute(product_id="p-001", quantity=3)
    if result1["success"]:
        print(f"成功: {result1['product_name']} を {result1['quantity']}個注文")
    else:
        print(f"失敗: {result1['error']}")

    # シナリオ2: 在庫不足
    print("\n[シナリオ2: 在庫不足 (マウス x 10)]")
    result2 = use_case.execute(product_id="p-001", quantity=10)
    if result2["success"]:
        print(f"成功: {result2['product_name']} を {result2['quantity']}個注文")
    else:
        print(f"失敗: {result2['error']}")
        
    # シナリオ3: ダウンロード商品の注文
    print("\n[シナリオ3: ダウンロード商品 (eBook x 1)]")
    result3 = use_case.execute(product_id="d-001", quantity=1)
    if result3["success"]:
        print(f"成功: {result3['product_name']} を {result3['quantity']}個注文")
    else:
        print(f"失敗: {result3['error']}")

    # --- 4. 結果の確認 (インフラ層の責任) ---
    print("\n--- 最終状態の確認 ---")
    final_mouse = product_repo.find_by_id("p-001")
    if final_mouse:
        print(f"{final_mouse.name}の最終在庫: {final_mouse.get_stock()}")
        
    print("\n--- 注文履歴 ---")
    all_orders = order_repo.get_all()
    for order in all_orders:
        print(order)

if __name__ == "__main__":
    main()
```