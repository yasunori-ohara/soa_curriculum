# PP-02: モジュール分割による「カプセル化」の試み

`PP-01` では、データ（`PRODUCTS_DB`）とロジック（関数群）が同じファイルにあり、誰でもデータを直接変更できてしまう問題がありました。

この章では、その問題を解決する手続き型プログラミングの一般的なテクニックとして、「モジュール分割」を試みます。これは、データとロジックを別のファイルに分離し、意図しないアクセスを防ごうとするアプローチです。

## 🎯 この章のゴール

  * `PP-01`の問題（データとロジックの分離）を、ファイルを分割することで改善しようと試みる。
  * Pythonの「モジュール」の概念を理解する。
  * アンダースコア（`_`）を使った「紳士協定」による情報隠蔽（カプセル化の真似事）とその限界を学ぶ。

-----

## 📦 ファイル分割： `logic.py` と `main.py`

プログラムを以下の2つのファイルに分割します。

1.  **`logic.py`**: 在庫データと、それを操作するための一連の関数（ロジック）を格納します。このファイルが「部品」の役割を果たします。
2.  **`main.py`**: `logic.py` という「部品」を利用して、実際の注文処理を実行するファイルです。

-----

## 👨‍💼 `logic.py` : 「紳士協定」によるデータの隠蔽

`logic.py` では、「このデータ（`_PRODUCTS_DB`）は外部から直接触らないでください」という意図を込めて、変数名や内部関数名の先頭にアンダースコア（`_`）を付けます。

これはPythonにおける\*\*「紳士協定」\*\*と呼ばれ、「これは内部用の変数・関数なので、外部から直接呼び出さないでね」という開発者間の目印（規約）です。

```python:logic.py
import datetime

# --- 1. データベースの代わりとなるデータ構造 ---
# 変数名の先頭にアンダースコア(_)を付ける。
# これにより「この変数はモジュール内部でのみ使用されるべき」
# という「紳士協定」を示す。
_PRODUCTS_DB = {
    "p-001": {"name": "高機能マウス", "price": 4000, "stock": 10},
    "p-002": {"name": "静音キーボード", "price": 6000, "stock": 5},
    "p-003": {"name": "24インチモニター", "price": 25000, "stock": 3},
}

# 注文記録も同様に(_)で隠蔽する
_ORDERS_LOG = []

# --- 2. 内部処理用の関数 ---
# これらの関数も(_)を付け、外部から呼び出されることを意図しない
# (process_orderからのみ使われる)

def _find_product(product_id: str) -> dict | None:
    """商品IDを元に商品データを検索する（内部用）"""
    # 隠蔽された _PRODUCTS_DB を参照する
    return _PRODUCTS_DB.get(product_id)

def _check_stock(product_data: dict, quantity: int) -> bool:
    """商品の在庫が十分か確認する（内部用）"""
    return product_data["stock"] >= quantity

def _reduce_stock(product_data: dict, quantity: int):
    """商品の在庫を減らす（内部用・副作用あり）"""
    product_data["stock"] -= quantity
    print(f"在庫更新: {product_data['name']}の在庫が{product_data['stock']}になりました。")

def _create_order_record(product_data: dict, quantity: int) -> dict:
    """注文記録を作成する（内部用）"""
    return {
        "product_name": product_data["name"],
        "quantity": quantity,
        "total_price": product_data["price"] * quantity,
        "order_date": datetime.datetime.now().isoformat()
    }

# --- 3. 外部に公開するインターフェース（API） ---
# これら(_)の付かない関数が、main.pyから呼び出される「窓口」となる

def process_order(product_id: str, quantity: int):
    """
    注文処理のメインフローを管理する唯一の「公開」関数
    データ（_PRODUCTS_DB）への変更は、必ずこの関数を通して行われるべき。
    """
    print(f"\n--- 注文処理開始: 商品ID={product_id}, 数量={quantity} ---")

    # 内部用関数を正しい順序で呼び出す
    product = _find_product(product_id)
    if not product:
        print("エラー: 指定された商品が見つかりません。")
        return

    if not _check_stock(product, quantity):
        print(f"エラー: {product['name']}の在庫が不足しています。（在庫: {product['stock']}）")
        return

    # 内部関数を経由して、隠蔽されたデータ(_PRODUCTS_DB)を安全に変更する
    _reduce_stock(product, quantity)
    order_record = _create_order_record(product, quantity)
    # 隠蔽されたデータ(_ORDERS_LOG)に安全にデータを追加する
    _ORDERS_LOG.append(order_record)

    print(f"注文成功: {product['name']}を{quantity}個受け付けました。")

def get_current_stock_info() -> dict:
    """
    現在の在庫情報を取得するための「公開」関数
    外部は「参照」のみ可能とし、直接データを触らせないようにする。
    """
    # 在庫数だけを抜き出した新しい辞書を返し、元のDBを直接返さない
    return {
        pid: pdata["stock"] 
        for pid, pdata in _PRODUCTS_DB.items()
    }
```

*（補足: `get_order_log()` など、注文履歴を参照する関数も同様に作成できますが、ここでは省略しています。）*

-----

## 🏛️ `main.py` : 「紳士協定」の限界

`logic.py` を作ったことで、`main.py` からは `process_order` 関数だけを呼び出せば良くなり、`PP-01` よりは見通しが良くなりました。

しかし、**「紳士協定」はあくまで「規約」であり、プログラム的な強制力を持ちません**。
`main.py` の開発者がルールを無視すれば、簡単にデータを壊せてしまいます。

```python:main.py
# 作成した logic モジュールをインポートする
import logic

if __name__ == "__main__":
    print("--- 初期在庫 ---")
    # 公開関数 get_current_stock_info() を使って安全に在庫を参照
    print(logic.get_current_stock_info())

    # --- 紳士協定の限界を実演 ---
    print("\n--- ルール違反の直接アクセス ---")
    
    # logicモジュールの開発者は、_PRODUCTS_DBが
    # process_orderを通じてのみ変更されることを意図している。
    
    # しかし、Pythonでは(_)が付いていてもアクセスできてしまう！
    try:
        print(f"変更前のマウスの在庫: {logic._PRODUCTS_DB['p-001']['stock']}")
        
        # 在庫チェックのロジック（_check_stock）を無視して、不正に在庫を書き換える
        # これが「紳士協定の破棄」
        logic._PRODUCTS_DB["p-001"]["stock"] = 9999 
        
        print(f"変更後のマウスの在庫: {logic._PRODUCTS_DB['p-001']['stock']} ※不正な値")
    except AttributeError:
        # 実際にはPythonはアクセスを許可するため、このエラーは通常発生しない
        print("アクセスできませんでした（これが理想だが、現実は違う）")
    # --------------------------------

    print("\n--- 注文処理の実行 ---")
    # シナリオ1: 正常な注文
    logic.process_order("p-002", 2)

    # シナリオ2: 不正な在庫操作の影響
    # 本来は在庫不足(在庫10)のはずが、直接9999に書き換えられたため
    # 在庫チェック（_check_stock）がTrueになり、不正な注文が通ってしまう
    logic.process_order("p-001", 100) 

    print("\n--- 最終在庫 ---")
    print(logic.get_current_stock_info())
    
    # 不正な注文(100個)が処理された結果、在庫が 9899 になっている
    # 本来あるべき姿（在庫不足エラー）とは異なる結果になってしまった
```

-----

## 🚧 モジュール分割アプローチの限界

今回の改善（`logic.py` と `main.py` への分割）によって、`PP-01` と比べて以下の点は改善しました。

  * **改善点:**
    `main.py` を書く人は、`_PRODUCTS_DB` の詳細を知らなくても、`process_order` を呼び出すだけで良くなりました。データとロジックの「物理的な距離」は離れました。

しかし、根本的な問題は解決していません。

### 1\. 🔗 データとロジックの分離（不完全）

データ（`_PRODUCTS_DB`）とロジック（`process_order`）を「紳士協定」で守ろうとしましたが、`main.py` から**簡単に協定を破ってデータを直接書き換えられ、システム全体が不正な状態になってしまいました。**
これでは、大規模な開発でデータの安全性を保証できません。

### 2. 🌱 拡張性の低さ（未解決）
`PP-01` と同じ問題が残っています。
もし「**複数店舗**」に対応したい場合、`logic.py` の内部に隠蔽した `_PRODUCTS_DB` を、`_STORES_DATA = {"tokyo": {...}, "osaka": {...}}` のような複雑な辞書に作り変える必要があります。

**問題点:**
結局、`logic.py` の `process_order` や `get_current_stock_info` といった**公開関数**のシグネチャ（引数）を `process_order(store_id, product_id, ...)` のように変更する必要があり、`main.py` 側の大幅な修正も必要になります。モジュールに隠蔽しても、この根本的な「拡張性の低さ」の問題は解決していません。

-----

このように、手続き的なアプローチ（関数とモジュール分割）だけでは、「データ」と「それを操作するルール（ロジック）」を**強制的に**結びつけ、安全に保つことが困難です。

この「**データと、それに関連するロジックを、一つの安全な『カプセル』にまとめたい**」という要求こそが、次のステップである**オブジェクト指向プログラミング**を生み出す原動力となりました。