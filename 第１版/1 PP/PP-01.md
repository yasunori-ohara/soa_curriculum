# PP-01: 手続き型プログラミングと在庫管理

この章では、私たちの旅の出発点として、多くのプログラミング学習で最初に触れる「手続き型プログラミング」スタイルを使って、簡単な在庫管理システムを構築します。

## 🎯 この章のゴール

  * 手続き型プログラミングの基本的な考え方（処理を関数に分割する）を理解する。
  * Pythonの基本的な機能（辞書、リスト、関数）だけでビジネスロジックを実装する方法を学ぶ。
  * このスタイルの限界点、特に「データとロジックの分離」がもたらす問題を明確に認識する。

-----

## 🤔 なぜ「手続き型」から始めるのか？

最終的なゴールは **SOA (サービス指向アーキテクチャ)** のような高度な設計を学ぶことです。では、なぜ遠回りなように見える手続き型プログラミングから始めるのでしょうか？

理由は2つあります。

1.  **限界を知るため:** オブジェクト指向やDDD、SOAといった技術は、すべて「過去のプログラミングスタイルが直面した問題を解決するため」に生まれました。手続き型の「何が問題だったのか」を実体験することで、次のステップ（オブジェクト指向）がなぜ必要なのかを深く理解できます。
2.  **現実のコードを理解するため:**
    多くの既存システムや小規模なスクリプトは、今でもこの手続き型スタイルで書かれています。このスタイルを理解することは、現実のコードを読み解き、リファクタリングするための基礎体力となります。

-----

## 🛒 なぜ「在庫管理と注文」なのか？

この題材は、システム設計の基本的な要素を学ぶのに最適です。

  * **データ（状態）:** 商品リストや在庫数（`PRODUCTS_DB`）
  * **ロジック（手続き）:** 在庫を確認し（`check_stock`）、減らす（`reduce_stock`）
  * **ビジネスプロセス:** 注文を受け付け、記録する（`process_order`）

このシンプルな題材をベースに、機能拡張（例：複数店舗、新しい商品タイプ）を試みることで、設計がどのように複雑化し、それをどう乗り越えていくかを段階的に学んでいきます。

-----

## 💻 サンプルコード：手続き型での実装

それでは、Pythonの基本的な機能（クラスを使わずに）だけで実装した在庫管理と注文受付のプログラムを見てみましょう。

```python
import datetime

# --- 1. グローバルな「状態」としてのデータ ---
# これらはデータベースの代わりとなる、プログラム全体で共有されるデータです。
# Pythonでは辞書やリストとして表現します。

# 商品データを格納する辞書 (キーは商品ID)
# この辞書がプログラムの「現在の状態(state)」を保持します。
PRODUCTS_DB = {
    "p-001": {"name": "高機能マウス", "price": 4000, "stock": 10},
    "p-002": {"name": "静音キーボード", "price": 6000, "stock": 5},
    "p-003": {"name": "24インチモニター", "price": 25000, "stock": 3},
}

# 注文記録を格納するリスト
# 注文処理が成功するたびに、このリストにデータが追加されていきます。
ORDERS_LOG = []

# --- 2. 処理を分割した「関数」群 ---
# ビジネスロジックを、再利用可能な小さな「手続き = 関数」として定義します。

def find_product(product_id: str, products_data: dict) -> dict | None:
    """商品IDを元に商品データを検索する"""
    # 辞書の .get() メソッドは、キーが存在すれば値を、しなければ None を返す
    return products_data.get(product_id)

def check_stock(product_data: dict, quantity: int) -> bool:
    """商品の在庫が十分か確認する"""
    # 商品データ（辞書）から "stock" キーで在庫数を取得し、注文数と比較
    return product_data["stock"] >= quantity

def reduce_stock(product_data: dict, quantity: int):
    """
    商品の在庫を減らす（副作用あり）
    
    注意: この関数は受け取った `product_data`（辞書）を直接変更します。
    これは「副作用」と呼ばれ、関数が外部の状態（この場合は PRODUCTS_DB の中の辞書）
    を直接書き換えることを意味します。
    """
    product_data["stock"] -= quantity
    print(f"在庫更新: {product_data['name']}の在庫が{product_data['stock']}になりました。")

def create_order_record(product_data: dict, quantity: int) -> dict:
    """注文記録（辞書データ）を作成する"""
    # 注文が成功した証拠として、新しい辞書を作成して返す
    return {
        "product_name": product_data["name"],
        "quantity": quantity,
        "total_price": product_data["price"] * quantity,
        "order_date": datetime.datetime.now().isoformat()
    }

def process_order(product_id: str, quantity: int, products_data: dict, orders_data: list):
    """
    注文処理のメインフローを管理する関数
    複数の関数（手続き）を正しい順序で呼び出します。
    """
    print(f"\n--- 注文処理開始: 商品ID={product_id}, 数量={quantity} ---")

    # 1. 商品存在チェック
    product = find_product(product_id, products_data)
    if not product:
        print("エラー: 指定された商品が見つかりません。")
        return # 処理を中断

    # 2. 在庫チェック
    if not check_stock(product, quantity):
        print(f"エラー: {product['name']}の在庫が不足しています。（在庫: {product['stock']}）")
        return # 処理を中断

    # 3. 在庫を減らす (ここで副作用が発生)
    reduce_stock(product, quantity)

    # 4. 注文を記録する
    order_record = create_order_record(product, quantity)
    orders_data.append(order_record) # ここも副作用（グローバルなリストを変更）

    print(f"注文成功: {product['name']}を{quantity}個受け付けました。")

# --- 3. メイン処理 (アプリケーションの実行) ---

# `if __name__ == "__main__":` は、このファイルがスクリプトとして
# 直接実行されたときにだけ、以下のコードを実行するというPythonのお作法です。
if __name__ == "__main__":
    print("--- 初期在庫 ---")
    for pid, pdata in PRODUCTS_DB.items():
        print(f"{pdata['name']}: {pdata['stock']}個")

    # シナリオ1: 正常な注文
    # PRODUCTS_DB と ORDERS_LOG を引数として渡し、関数に処理を依頼する
    process_order("p-001", 2, PRODUCTS_DB, ORDERS_LOG)

    # シナリオ2: 在庫不足による注文失敗
    process_order("p-002", 10, PRODUCTS_DB, ORDERS_LOG)

    # シナリオ3: 存在しない商品による注文失敗
    process_order("p-999", 1, PRODUCTS_DB, ORDERS_LOG)

    # シナリオ4: 別の正常な注文
    process_order("p-003", 3, PRODUCTS_DB, ORDERS_LOG)

    print("\n--- 最終在庫 ---")
    for pid, pdata in PRODUCTS_DB.items():
        print(f"{pdata['name']}: {pdata['stock']}個")

    print("\n--- 注文記録 ---")
    for order in ORDERS_LOG:
        print(order)
```

-----

## 🚧 手続き型プログラミングの限界

このコードは適切に関数が分割されており、問題なく動作します。しかし、ビジネスが成長し、仕様が複雑になるにつれて、以下のような限界がすぐに露呈します。

### 1\. 🔗 データとロジックの分離

商品データ（`PRODUCTS_DB`辞書）と、それを操作するロジック（`check_stock`や`reduce_stock`関数）は、物理的に全く別の場所に存在します。

**問題点:**
`PRODUCTS_DB` を、本来想定されていない別の関数（例えば、`process_order`以外の関数）が誤って直接書き換えてしまうことを、プログラムの構造として防ぐことができません。これが、次の章で学ぶ\*\*オブジェクト指向の「カプセル化」\*\*が解決しようとする中心的な課題です。

### 2\. 🤯 状態管理の複雑さ

`PRODUCTS_DB` や `ORDERS_LOG` は、アプリケーション全体で共有される「グローバルな状態」です。

**問題点:**
プログラムが大規模化すると、多くの関数がこの共有データを参照・変更するため、「いつ、どこで、誰が」データを変更したのかを追跡するのが非常に困難になります。バグの温床となりやすい構造です。

### 3. 🌱 拡張性の低さ
もし「**複数店舗（例：東京店と大阪店）**」に対応する必要が出てきたら、どうなるでしょうか？

**問題点:**
`PRODUCTS_DB` や `ORDERS_LOG` を店舗ごと（例：`TOKYO_PRODUCTS_DB`, `OSAKA_PRODUCTS_DB`）に用意する必要があるかもしれません。
そうなると、`process_order` 関数は、「どの店舗のDBを操作するか」を指定するために、`process_order("tokyo", "p-001", ...)` のように、追加の引数を必要とするようになります。機能を追加するたびに、既存の多くの関数（`check_stock` なども）の設計に根本的な変更が必要となり、コードはどんどん複雑で脆くなっていきます。

