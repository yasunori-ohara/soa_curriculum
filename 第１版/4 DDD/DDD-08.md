# DDD-08 : 補足
### 貧血ドメインモデル vs 豊かなドメインモデル と 上位/下位の逆転

`DDD-05` では、`UseCase` がスリムになり、`Domain`（`Order` 集約）が賢くなりました。
この変更は、DDDにおける「**貧血ドメインモデル (Anemic Domain Model)**」というアンチパターン（悪い設計）を「**豊かなドメインモデル (Rich Domain Model)**」へと「治療」する、非常に重要なプロセスでした。

この章では、この「治療」の意味を深掘りし、それに伴って起きた「上位」と「下位」の役割の変化について解説します。

## 🎯 この章のゴール

  * 「貧血ドメインモデル」がどのような悪い設計かを理解する。
  * `CA` から `DDD` へのリファクタリングが、この「貧血」を「治療」するプロセスであったことを、コードの Before/After で明確に理解する。
  * なぜ貧血ドメインモデルが問題なのか（カプセル化の喪失、ロジックの重複）を学ぶ。
  * DDDの適用により、「上位（方針）」と「下位（詳細）」の役割が `UseCase` と `Domain` の間で逆転したことを理解する。

-----

## 🩸 1. 貧血ドメインモデルの「治療」

`DDD` へのリファクタリングの最大の目的は、`CA` の時点では「貧血ドメインモデル」だった `Order` を、「豊かなドメインモデル」に治療することでした。

### 貧血ドメインモデルとは？

貧血ドメインモデルとは、ドメインオブジェクト（`Order` クラスなど）が**振る舞い（ビジネスロジック）をほとんど持たず、単なるデータの入れ物になってしまっている状態**を指す、アンチパターン（悪い設計）の一つです。その結果、本来ドメインオブジェクトが担うべきだったビジネスロジックは、**`UseCases` レイヤーに漏れ出してしまいます**。

#### Before: 貧血な状態 (CA-04)

`CA` の `UseCase` は「賢く」、`Order` は「データの入れ物」でした。ビジネスロジック（在庫チェック、在庫削減、`Order` の作成方法）がすべて `UseCase` に集中していました。

```python
# --- CA (貧血な状態) ---
class Order: # ただのデータの入れ物
    # ... (属性のみ)

class ProcessOrderUseCase: # UseCase がロジックを持つ
    def execute(...):
        # UseCase が在庫チェック
        if not product.check_stock(quantity): ...
        # UseCase が在庫削減
        product.reduce_stock(quantity)
        # UseCase が Order の作り方を知っている
        order = Order(...)
        # ...
```

#### After: 豊かな状態 (DDD-05)

`DDD` のリファクタリングによって、この貧血状態を「治療」しました。ビジネスロジックを `Domain`（`Order` 集約）に移譲し、`Order` が「賢く」なりました。

```python
# --- DDD (豊かな状態) ---
class Order: # Order がロジックを持つ
    def add_line_item(self, product, quantity):
        # Domain が在庫チェック
        if not product.check_stock(quantity): ...
        # ...
    def confirm(self):
        # Domain が在庫削減
        for item in self._line_items:
            item.product.reduce_stock(...)
        # ...

class ProcessOrderUseCase: # UseCase は調整役に
    def execute(...):
        order = Order(...)
        # Domain に依頼するだけ
        order.add_line_item(...)
        order.confirm()
        # ...
```

### なぜ貧血ドメインモデルは問題なのか？

1.  **カプセル化の喪失:** データと振る舞いが分離し、OOPの利点が失われます。
2.  **ロジックの重複:** 似たロジックが複数の `UseCase` にコピペされる危険があります。
3.  **知識の埋没:** ビジネスルールが `Domain` ではなく `UseCases` に散らばってしまいます。

`DDD` は、`Domain` こそがビジネスルールを知るべき、という思想を徹底します。

-----

## 🔄 2. 「上位」と「下位」の逆転

このリファクタリングの結果、`CA` の時と「上位（方針）」と「下位（詳細）」の関係が**逆転**したことに気づいたでしょうか？

  * **`CA` の時点では:**
    `ProcessOrderUseCase` が「**上位（方針）**」でした。「注文とは、①在庫を確認し、②在庫を減らし、③注文記録を作ることである」という**方針**を決定していたからです。
    `Order` エンティティは、`UseCase` に使われる「**下位（詳細）**」でした。
  * **`DDD` の時点では:**
    `Order` 集約が「**上位（方針）**」に変わりました。「注文とは何か」「有効な注文（`confirm`）とはどのような状態か」という、ビジネスの最も核心的で不変の**方針**を定義しているからです。
    `ProcessOrderUseCase` は「**下位（詳細）**」になりました。`Order` 集約という厳格な方針（`add_line_item` や `confirm` メソッド）を守りながら、注文を成立させるための**詳細な手順**を実装する、数あるクライアント（`Order` を使う側）の一つにすぎません。

`UseCase` は `Order` 集約の公開されたメソッドという「抽象」に依存しており、その内部でどのように整合性が保たれているかという「詳細」には関与しません。

私たちは、クリーンアーキテクチャという金庫室（アプリケーション構造）の中に、DDDによってさらに小さな、しかし最も強固な「貴重品ボックス（集約）」を見つけたのです。

-----

## 🧱 マトリョーシカ人形の視点

この「上位」と「下位」の考え方は相対的です。

では、このアプリケーション全体（金庫室）自体が、より大きなシステム（例：会社全体の業務プロセス）から見れば、一つの「下位レベル（詳細）」だとしたらどうでしょう？

会社全体のビジネスプロセスという、最も大きなマトリョーシカ人形 🪆 の視点からシステムを捉え、システム間の連携を考えるのが、次の `SOA`（サービス指向アーキテクチャ）のテーマとなります。