# OOP-05 : インターフェースと継承の役割（復習）

`OOP-03`（DIP）と`OOP-04`（OCP）では、「インターフェース（抽象クラス）」と「継承」というOOPの重要な概念を連携させて使用しました。

なぜ`Store`は`PhysicalProduct`と`DigitalProduct`を、`if`文で区別せずに扱えたのでしょうか？
それは、「インターフェース」と「継承」が、車の両輪のような関係で機能しているからです。

この関係を、`OOP-04`までの内容を振り返りながら、\*\*「契約書」\*\*に例えて整理しましょう。

## 🎯 この章のゴール

  * 「インターフェース」の役割が「**契約の定義**」であることを理解する。
  * 「継承」の役割が「**契約の履行（実装）**」であることを理解する。
  * ポリモーフィズムが、この2つの仕組みの上になりたっていることを再確認する。

-----

## 📜 1. インターフェースの役割：「契約書」を定義する

`OOP-03`で定義（`OOP-04`で修正）した`Product(ABC)`という抽象基底クラスは、**インターフェース**として機能しています。

これは、「これから『商品』として扱われるクラスは、以下の項目（メソッド）を必ず持たなければならない」という**契約書**を定義しているのと同じです。

#### logic.py (Product 抽象クラスの契約)

```python
class Product(ABC):
    # ...
    @abstractmethod
    def check_stock(self, quantity: int) -> bool:
        """【契約】在庫を確認する能力"""
        pass

    @abstractmethod
    def reduce_stock(self, quantity: int):
        """【契約】在庫を減らす能力"""
        pass
    
    @abstractmethod
    def get_stock_info(self) -> str:
        """【契約】在庫情報を文字列で報告する能力"""
        pass
```

*（※`OOP-04`で確定した契約内容）*

この契約書があるおかげで、`Store`クラス（利用者側）は安心できます。
`Store`は、「`_products`に入っているオブジェクト（`product`変数）の中身が何であれ、**『商品』の契約を守っているはずだ**。だから、安心して`product.check_stock()`や`product.get_stock_info()`を呼び出そう」と、相手を信頼して仕事を任せることができます。

-----

## ✍️ 2. 継承の役割：契約書に「署名」し「実装」する

`PhysicalProduct`や`DigitalProduct`が`Product`を**継承**する (`class PhysicalProduct(Product):`) というコードは、この契約書に**署名する行為**に相当します。

署名したクラス（具象クラス）は、契約書で定められた全ての抽象メソッド（`@abstractmethod`）を、具体的に実装する**義務**を負います。

  * **`PhysicalProduct` の署名と実装:**
    「私は『商品』契約に署名します。契約書通り、`check_stock`は物理在庫（`_stock`）と比較し、`get_stock_info`はその数値を**文字列で**返します」
  * **`DigitalProduct` の署名と実装:**
    「私も『商品』契約に署名します。契約書通り、`check_stock`は常に`True`を返し、`get_stock_info`は\*\*"N/A"という文字列\*\*を返します」

### (補足) 継承の2つの側面

「継承」には大きく2つの側面があります。

1.  **実装の継承**: 親クラスの具体的なコード（実装）を再利用する。
2.  **インターフェースの継承**: 親クラスが定めた「契約（メソッドのシグネチャ）」だけを引き継ぎ、実装は自分で行う。

今回の`Product(ABC)`からの継承は、(2)の「**インターフェースの継承**」が主な目的です。（`__init__`の共通コード再利用など、(1)の側面も一部含んでいますが）

**継承**は、この契約（インターフェース）を守ることを宣言し、その具体的な内容を実装するための\*\*メカニズム（手段）\*\*なのです。

-----

## ✨ まとめ：ポリモーフィズムの土台

| 概念 | 役割 | コード上の表現 | 例え |
| :--- | :--- | :--- | :--- |
| **インターフェース** | **ルール・契約**を定義する | `Product(ABC)` | 壁のコンセントの「規格」 |
| **継承** | その契約を**守ることを宣言**し、実装する | `class PhysicalProduct(Product):` | 「規格」に合わせてプラグを作る行為 |
| **ポリモーフィズム** | 契約を守るモノなら区別なく**同一視**して扱う | `Store`が`product.check_stock()`を呼ぶ | コンセントが相手を区別せず電気を供給する |

結論として、`OOP-04`の変更は\*\*「`Product`というインターフェース（契約）を、継承というメカニズムを使って、`PhysicalProduct`と`DigitalProduct`がそれぞれ独自に実装した」\*\*と言うことができます。

`Store`は「契約書（インターフェース）」だけを見て仕事をするため、相手の「実装（`Physical`か`Digital`か）」を気にする必要がありません。これこそが、OCP（オープン・クローズドの原則）とポリモーフィズムが実現される仕組みの核心です。