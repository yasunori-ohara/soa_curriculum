# SOA-01 : サービス指向アーキテクチャ (SOA) への招待

`DDD`（ドメイン駆動設計）によってビジネスの核心を洗練されたモデルとして構築した今、いよいよこのカリキュラムの最終目的である\*\*サービス指向アーキテクチャ（SOA: Service-Oriented Architecture）\*\*へと進みます。

## 🎯 この章のゴール

  * `DDD` の次になぜ `SOA` が必要なのか（＝ドメイン間の連携）を理解する。
  * `SOA` の重要な概念（サービス、契約、疎結合）を知る。
  * アプリケーションを「サービス」として捉え直し、外部サービスと連携するようにリファクタリングする方針を学ぶ。
  * `SOA` リファクタリングの推奨される実装順序とその理由を理解する。

-----

## 🤔 なぜDDDの次にSOAが必要なのか？

`DDD` は、一つの明確なビジネス領域（境界づけられたコンテキスト）の内部をモデル化するのに非常に強力です。私たちは「注文管理」というコンテキストを見事にモデル化しました。

しかし、現実の企業活動は、複数の異なるビジネス領域が連携して成り立っています。

  * **注文管理** (私たちが作ったもの)
  * **在庫管理** (倉庫チームが管轄)
  * **顧客管理** (営業チームが管轄)
  * **配送管理** (物流チームが管轄)

現在の私たちのアプリケーション（`DDD-08`）は、`Order` 集約が `Product` エンティティの `reduce_stock()` を直接呼び出すことで、暗黙的に**在庫管理**の責任まで負ってしまっています。これでは、在庫管理のルールが複雑になった場合（例：倉庫ごとに在庫を持つ）、注文管理システムまで修正が必要になり、せっかく分離した関心事が再び癒着してしまいます。

**サービス指向アーキテクチャ（SOA）は、このように異なるビジネス領域（コンテキスト）を、それぞれが独立した「サービス」として捉え、明確に定義された「契約（API）」を通じて疎結合**に連携させるための、システム全体の設計思想です。

-----

## 💡 SOAの重要な概念

  * **サービス (Service):**
    特定のビジネス機能（例：「在庫を引き当てる」）を提供する、自己完結したコンポーネント。「在庫管理サービス」「顧客情報サービス」など。
  * **契約 (Contract / API):**
    サービスが外部に提供する機能の仕様書（例：「商品IDと数量を渡せば、在庫引当の結果を返す」）。この契約さえ守られていれば、サービスの内部実装（DBの種類など）は自由に変更できます。
  * **疎結合 (Loose Coupling):**
    各サービスは互いの内部実装を知りません。契約を通じてのみ連携するため、片方のサービスが更新されても、他方のサービスへの影響を最小限に抑えられます。

-----

## 🔁 ECサイト注文処理（SOA適用版）

これから、私たちのアプリケーションを「**注文受付サービス**」として再定義し、これまで内包していた在庫管理のロジックを、外部の独立した「**在庫管理サービス**」（今回は模擬的なもの）に問い合わせる形にリファクタリングします。

### リファクタリングのポイント

1.  模擬的な「在庫管理サービス」を独立したコンポーネントとして作成します。
2.  「注文受付サービス」の中に、在庫管理サービスと通信するための新しい**アダプター**を作成します。
3.  `ProcessOrderUseCase` は、在庫に関する処理（`check_stock`, `reduce_stock`）を、この新しいアダプターを通じて外部サービスに**委譲**するようになります。

### 📁 新しいファイル構造

`interface_adapters` に、外部サービスと通信するためのアダプターを追加します。また、模擬的な外部サービスを `external_services` ディレクトリに作成します。

```bash
soa_project/
├── domain/                  # (変更なし)
│   ├── product.py
│   └── order.py
│
├── use_cases/               # (インターフェース追加, UseCase修正)
│   ├── process_order.py
│   └── interfaces.py
│
├── interface_adapters/      # (アダプター追加)
│   ├── repositories.py
│   └── inventory_service_adapter.py  # ⬅️ 外部サービスと通信するアダプター
│
├── external_services/       # ⬅️ 模擬的な外部サービス (新規)
│   └── inventory_service.py
│
└── infrastructure/          # (main.py 修正)
    └── main.py
```

-----

## 🚶‍♂️ 推奨される実装の順番

`SOA` へのリファクタリングは、依存関係をクリーンに保ち、各コンポーネントを独立してテストしながら進めることが重要です。以下の順番で実装を進めることを推奨します。

1.  **`external_services/inventory_service.py`** （外部サービスの定義）
2.  **`use_cases/interfaces.py`** （内部の接続口（ポート）の定義）
3.  **`interface_adapters/inventory_service_adapter.py`** （アダプターの実装）
4.  **`use_cases/process_order.py`** （ユースケースの修正）
5.  **`infrastructure/main.py`** （全体の組み立て）

### 🤔 なぜこの順番なのか？

1.  **外部サービスの定義から:**
    まずは\*\*連携先となる相手の仕様（契約）\*\*を確定させる必要があります。どのような機能（API）を提供してくれるのかが分からなければ、接続方法を決められません。（接続する水道管の場所を確認）
2.  **内部のポート（インターフェース）定義へ:**
    次に、私たちのアプリケーション（`UseCase`）側で、「**自分たちは、在庫管理機能に対して、どのような形でアクセスしたいか**」という理想のインターフェース（ポート）を定義します。（依存性逆転の原則：自分たちの都合で鍵穴の形を決める）
3.  **アダプターの実装:**
    「外部サービスの仕様」と「自分たちが望むインターフェース」が揃ったので、両者を\*\*つなぐ「変換プラグ（アダプター）」\*\*を実装できます。
4.  **ユースケースの修正:**
    外部サービスに接続するための**理想のインターフェース（ポート）が定義された**ので、`UseCase` 本体を修正します。`UseCase` は、具体的なアダプターではなく、**抽象的なインターフェースにのみ依存**するようにします。（ユースケースは外部接続方法から隔離される）
5.  **全体の組み立て:**
    最後に**組立工場である `main.py`** で、すべての具体的な部品（`UseCase`、具体的なアダプター、外部サービスの実体）を結合（DI）し、アプリケーション全体を起動します。

この順番で開発を進めることで、「依存性のルール」を守りながら、テスト容易性の高い、疎結合なシステムを構築することができます。次のページ（`SOA-02`）から、このステップに従って実装を進めましょう。