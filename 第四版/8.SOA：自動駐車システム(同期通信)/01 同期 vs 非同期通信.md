# 01 同期 vs 非同期通信

# 理論：同期 vs 非同期通信

サービス間の連携方法を考える上で、「同期」と「非同期」の違いを理解することは非常に重要です。この2つの通信モデルは、システムの設計思想、パフォーマンス、堅牢性に直結します。

## 📞 同期通信 (Synchronous) とは？

同期通信とは、処理をリクエスト（要求）した側が、その処理が完了し、レスポンス（応答）が返ってくるまで、次の動作に進まずに待機する方式です。

最も分かりやすい例は「電話」です。
あなたが相手に電話をかけ（リクエスト）、相手が「もしもし」と応答する（レスポンス）まで、あなたは受話器を耳に当てて待ち続けます。相手が応答して初めて、次の会話（処理）に進むことができます。

## 📧 非同期通信 (Asynchronous) とは？

非同期通信とは、処理をリクエストした側が、相手からの応答を待たずに、すぐに自分の次の動作に移る方式です。リクエストは「送りっぱなし」になります。

例えるなら「メール」や「郵便」です。
あなたはメールを送信し（リクエスト）、送信ボタンを押したらすぐに別の作業（次の処理）を始められます。相手がいつメールを読み、いつ返信するか（レスポンス）を待機する必要はありません。返信は、相手の都合の良いタイミングで後から届きます。

## ⚖️ メリット・デメリットの比較

どちらの方式にも一長一短があり、システムの要件に応じて使い分ける必要があります。

### 🎯 同期通信 (RESTなどで主流)

- **メリット:**
    - **即時性・シンプルさ:** リクエストとその結果が直結しているため、処理の流れが直線的で理解しやすいです。「データを要求し、受け取ってから次へ進む」という流れは直感的です。
    - **即時エラー検知:** 処理が失敗した場合、その場ですぐにエラーレスポンスを受け取ることができるため、エラーハンドリングが比較的容易です。
- **デメリット:**
    - **待機による遅延 (ブロッキング):** 応答を返す側の処理が遅い場合、リクエストした側もその間ずっと待たされ（ブロックされ）、システム全体のパフォーマンスが低下します。
    - **高い結合度:** リクエスト側とレスポンス側が、お互いの稼働状態や応答速度に直接影響を受けるため、サービス間の依存関係（結合度）が強くなります。片方の障害が、もう片方の障害に直結しやすいです。

### 🎯 非同期通信 (MQTTなどで主流)

- **メリット:**
    - **高い応答性 (ノンブロッキング):** リクエスト側は応答を待たないため、重い処理を依頼した後も、すぐに別の作業を継続できます。ユーザーから見たシステムの応答性が向上します。
    - **耐障害性・低い結合度:** 中間にブローカー（郵便局のようなもの）を挟むことで、お互いが直接通信しません。片方のサービスが一時的に停止していても、もう片方はメッセージを送信（投函）し続けることができます。サービス間の結合度が低くなります。
- **デメリット:**
    - **設計の複雑さ:** 処理の結果を即座に得られないため、「いつ処理が終わるか」「失敗した場合にどう知るか」といった状態管理やエラーハンドリングの設計が複雑になりがちです。
    - **結果の非即時性:** リクエストしてから結果が返ってくるまでに時間がかかるため、即時性が求められる処理には向きません。

## 📍 RESTとMQTTの位置づけ

今回の巡回で扱う技術は、この分類に当てはめることができます。

- **REST (主に同期):** HTTPプロトコルを基盤としており、基本は「リクエストを送り、レスポンスを待つ」同期モデルです。今回の第6巡で実装する対象です。
- **MQTT (非同期):** 第5巡で扱ったMQTTは、Pub/Sub（出版/購読）モデルを採用しており、メッセージをブローカーに送るだけの「送りっぱなし」非同期モデルの典型です。