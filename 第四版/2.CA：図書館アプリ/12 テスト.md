# 12 テストまとめ

# 🚀 テストまとめ — pytestでクリーンアーキテクチャを検証する

## 🎯 この章の目的

ここまでで、図書館アプリをクリーンアーキテクチャのレイヤーごとに作ってきました。

* **Entity（ドメインの中心：Book / Member / Loan）**
* **Use Case（ユースケース：本を貸し出す）**
* **Presenter / Controller / View（UIまわり）**
* **Repository（データ永続化アダプタ）**

この章では、それぞれの層が「単独でテストできるように設計されている」ことを実際にpytestで確認します。
レイヤーごとに責務が分離されているので、UIを起動せずにビジネスルールだけをテストできるし、DBを用意しなくても貸出処理のユースケースを検証できます。これはクリーンアーキテクチャ最大のご褒美です ✨

---

## 🧭 テストの全体像

クリーンアーキテクチャの特徴は、ひとつの巨大な結合テストではなく、レイヤーごとの独立テストが可能になることです。

それぞれのレイヤーでは、次のようなことを確認します：

| テスト対象           | テストで確認する内容                                                   | 使用するテストダブル                             |
| --------------- | ------------------------------------------------------------ | -------------------------------------- |
| Entity          | ドメインのビジネスルール（状態遷移・日付計算など）が正しいか                               | なし（生のEntityをそのままテスト）                   |
| Use Case        | 貸出フロー全体が正しく進むか／リポジトリやPresenterを正しく呼ぶか                        | Fake Repository / Spy Presenter        |
| Presenter       | `CheckOutBookOutputData` が `BookViewModel` に正しく翻訳されるか        | なし（ViewModelだけ）                        |
| Controller      | Viewから渡された生データが公式入力型`CheckOutBookInputData`に詰められてUseCaseに渡るか | Spy Use Case（InputBoundary実装のダミー）      |
| View            | 入力をControllerに渡し、ViewModelの内容を表示できるか                         | Spy Controller（check_out呼び出しだけ監視するスパイ） |
| Repositoryの具体実装 | InMemory実装が、保存・検索・ID採番などを期待通りに行うか                            | なし（実体を直接テスト）                           |

---

## 🗂 ディレクトリ構成（テスト込みの最終版）

```text
clean_architecture_library/
├─ core/
│   ├─ domain/
│   │   ├─ book.py                      # Book, BookStatus
│   │   ├─ member.py                    # Member
│   │   ├─ loan.py                      # Loan
│   │   └─ repository.py                # Repositoryインターフェース一式
│   │
│   └─ usecase/
│       ├─ boundary/
│       │   ├─ dto.py                   # CheckOutBookInputData / OutputData / BookViewModel
│       │   ├─ input_boundary.py        # CheckOutBookInputBoundary
│       │   └─ output_boundary.py       # CheckOutBookOutputBoundary
│       │
│       └─ interactor/
│           └─ check_out_book.py        # CheckOutBookUseCase
│
├─ interface_adapters/
│   ├─ data_access/
│   │   └─ in_memory_repositories.py    # InMemoryBookRepository / MemberRepository / LoanRepository
│   ├─ presenters/
│   │   └─ checkout_presenter.py        # CheckOutBookPresenter
│   ├─ controllers/
│   │   └─ checkout_controller.py       # CheckOutBookController
│   └─ views/
│       └─ view_console.py              # ConsoleView
│
├─ main.py
│
└─ tests/
    ├─ conftest.py
    └─ unit/
        ├─ test_entities.py
        ├─ test_usecase_checkout.py
        ├─ test_presenter.py
        ├─ test_controller.py
        ├─ test_view_console.py
        └─ test_in_memory_repositories.py
```

---

## 🧩 conftest.py — 共通フィクスチャ（Spy / Fake）

pytestでは、`tests/conftest.py` に共通のテスト用クラス（フェイクやスパイ）を置いておくと、他のテストから自動で使えます。

ここでは、

* Presenterのスパイ（呼び出されたかを記録する）
* Repositoryのフェイク（メモリ内で`Book`や`Member`を返す簡易実装）
* Loan保存用フェイク

…などをまとめて用意します。

```python
# tests/conftest.py
import pytest
from datetime import date
from typing import Optional, Dict

from core.domain.book import Book, BookStatus
from core.domain.member import Member
from core.domain.loan import Loan
from core.domain.repository import (
    BookRepository,
    MemberRepository,
    LoanRepository,
)
from core.usecase.boundary.dto import (
    CheckOutBookOutputData,
)
from core.usecase.boundary.output_boundary import CheckOutBookOutputBoundary


# --- Presenterのスパイ（呼び出し監視用） ---
class SpyPresenter(CheckOutBookOutputBoundary):
    def __init__(self):
        self.called_times = 0
        self.last_output: Optional[CheckOutBookOutputData] = None

    def present(self, output_data: CheckOutBookOutputData):
        self.called_times += 1
        self.last_output = output_data


# --- BookRepositoryのフェイク ---
class FakeBookRepository(BookRepository):
    def __init__(self, preset: Optional[Dict[int, Book]] = None):
        # 事前に登録された本を持つ辞書。テストごとに差し替え可
        self._books = preset or {}

    def find_by_id(self, book_id: int) -> Optional[Book]:
        return self._books.get(book_id)

    def save(self, book: Book) -> Book:
        self._books[book.id] = book
        return book


# --- MemberRepositoryのフェイク ---
class FakeMemberRepository(MemberRepository):
    def __init__(self, preset: Optional[Dict[int, Member]] = None):
        self._members = preset or {}

    def find_by_id(self, member_id: int) -> Optional[Member]:
        return self._members.get(member_id)


# --- LoanRepositoryのフェイク ---
class FakeLoanRepository(LoanRepository):
    def __init__(self):
        self._loans: Dict[int, Loan] = {}
        self._next_id = 1
        self.save_called_times = 0
        self.last_saved_loan: Optional[Loan] = None

    def save(self, loan: Loan) -> Loan:
        self.save_called_times += 1
        if loan.id is None:
            loan.id = self._next_id
            self._next_id += 1
        self._loans[loan.id] = loan
        self.last_saved_loan = loan
        return loan


# ---- pytest フィクスチャ ----

@pytest.fixture
def available_book():
    # 貸出可能な本
    return Book(id=1, title="クリーンアーキテクチャ", author="Robert C. Martin", status=BookStatus.AVAILABLE)

@pytest.fixture
def checked_out_book():
    # すでに貸出中の本
    return Book(id=2, title="リファクタリング", author="Martin Fowler", status=BookStatus.CHECKED_OUT)

@pytest.fixture
def active_member():
    return Member(id=100, name="Alice")

@pytest.fixture
def spy_presenter():
    return SpyPresenter()

@pytest.fixture
def fake_book_repo(available_book):
    # book_id=1 を返せるリポジトリ
    return FakeBookRepository(preset={available_book.id: available_book})

@pytest.fixture
def fake_member_repo(active_member):
    return FakeMemberRepository(preset={active_member.id: active_member})

@pytest.fixture
def fake_loan_repo():
    return FakeLoanRepository()
```

---

## ✅ Entity のテスト

Entityは最も内側の層なので、他のレイヤーに依存しません。
ここでは、`Book` の状態遷移と `Loan` の期日計算など、ビジネスルールそのものをテストします。

```python
# tests/unit/test_entities.py
from datetime import date, timedelta
from core.domain.book import Book, BookStatus
from core.domain.loan import Loan
import pytest

def test_book_can_be_checked_out_if_available():
    book = Book(id=1, title="達人プログラマー", author="Andrew Hunt", status=BookStatus.AVAILABLE)
    book.check_out()
    assert book.status == BookStatus.CHECKED_OUT

def test_book_cannot_be_checked_out_if_already_checked_out():
    book = Book(id=1, title="リファクタリング", author="Martin Fowler", status=BookStatus.CHECKED_OUT)
    with pytest.raises(ValueError):
        book.check_out()

def test_loan_due_date_defaults_to_14_days_after_loan_date():
    loan_date = date(2025, 10, 1)
    loan = Loan(id=None, book_id=1, member_id=100, loan_date=loan_date)
    assert loan.due_date == loan_date + timedelta(days=14)

def test_loan_overdue_detection():
    loan_date = date(2025, 10, 1)
    loan = Loan(id=None, book_id=1, member_id=100, loan_date=loan_date)
    assert loan.is_overdue(date(2025, 10, 20)) is True
    assert loan.is_overdue(date(2025, 10, 10)) is False
```

---

## ✅ Use Case のテスト（CheckOutBookUseCase）

ここが一番おいしいところです 😋
`CheckOutBookUseCase` が、貸出シナリオ全体を正しく指揮するかを検証します。

* 本と会員をリポジトリから取得する
* 本に `check_out()` を呼ぶ（＝状態遷移をEntityに委譲する）
* `Loan` を作る
* `Book` と `Loan` を永続化する
* `presenter.present()` を呼ぶ

```python
# tests/unit/test_usecase_checkout.py
from datetime import date
from core.usecase.boundary.dto import CheckOutBookInputData
from core.usecase.interactor.check_out_book import CheckOutBookUseCase

def test_checkout_successful_flow(
    spy_presenter,
    fake_book_repo,
    fake_member_repo,
    fake_loan_repo,
):
    use_case = CheckOutBookUseCase(
        presenter=spy_presenter,
        book_repository=fake_book_repo,
        member_repository=fake_member_repo,
        loan_repository=fake_loan_repo,
    )

    # このInputDataは Controller が組み立てる想定
    input_data = CheckOutBookInputData(book_id=1, member_id=100)

    use_case.handle(input_data)

    # 1. Book は CHECKED_OUT に変わっているはず
    saved_book = fake_book_repo.find_by_id(1)
    assert saved_book is not None
    assert saved_book.status.name == "CHECKED_OUT"

    # 2. LoanRepository.save() が呼ばれていて、新しい貸出記録が保存されている
    assert fake_loan_repo.save_called_times == 1
    assert fake_loan_repo.last_saved_loan is not None
    assert fake_loan_repo.last_saved_loan.book_id == 1
    assert fake_loan_repo.last_saved_loan.member_id == 100
    assert isinstance(fake_loan_repo.last_saved_loan.loan_date, date)

    # 3. Presenterが呼ばれていて、出力データを受け取っている
    assert spy_presenter.called_times == 1
    assert spy_presenter.last_output is not None
    assert spy_presenter.last_output.book_title is not None
    assert spy_presenter.last_output.member_name is not None
    assert spy_presenter.last_output.due_date is not None
```

---

## ✅ Presenter のテスト（CheckOutBookPresenter）

Presenterは、Use Case の生の結果（`CheckOutBookOutputData`）を、画面表示用の文字列に整形して `BookViewModel` に書き込みます。
ここでは、その「翻訳」が正しいかだけをチェックします。

```python
# tests/unit/test_presenter.py
from datetime import date
from core.usecase.boundary.dto import (
    CheckOutBookOutputData,
    BookViewModel,
)
from interface_adapters.presenters.checkout_presenter import CheckOutBookPresenter

def test_presenter_updates_view_model_with_human_readable_message():
    view_model = BookViewModel(display_text="")
    presenter = CheckOutBookPresenter(view_model)

    output_data = CheckOutBookOutputData(
        book_title="クリーンアーキテクチャ",
        member_name="Alice",
        due_date=date(2025, 10, 27),
    )

    presenter.present(output_data)

    # ViewModel が人間向けの丁寧なメッセージで更新されているか？
    assert "貸出処理が完了しました" in view_model.display_text
    assert "クリーンアーキテクチャ" in view_model.display_text
    assert "Alice" in view_model.display_text
    assert "2025年10月27日" in view_model.display_text  # 日付フォーマット済み
```

---

## ✅ Controller のテスト（CheckOutBookController）

Controllerは、Viewから受け取った素の入力（数値IDなど）を、公式な入力データ型 `CheckOutBookInputData` に変換して、Use Case を呼び出すだけの交通整理員でした。

その変換と呼び出しが正しく行われるかを確認します。

```python
# tests/unit/test_controller.py
from core.usecase.boundary.input_boundary import CheckOutBookInputBoundary
from core.usecase.boundary.dto import CheckOutBookInputData
from interface_adapters.controllers.checkout_controller import CheckOutBookController

class SpyUseCase(CheckOutBookInputBoundary):
    def __init__(self):
        self.called_times = 0
        self.last_input_data: CheckOutBookInputData | None = None

    def handle(self, input_data: CheckOutBookInputData):
        self.called_times += 1
        self.last_input_data = input_data

def test_controller_builds_inputdata_and_calls_usecase():
    spy_use_case = SpyUseCase()
    controller = CheckOutBookController(use_case=spy_use_case)

    controller.check_out(book_id=10, member_id=20)

    # Use Case が呼ばれていること
    assert spy_use_case.called_times == 1

    # 渡されたのが CheckOutBookInputData で、値も正しいこと
    assert isinstance(spy_use_case.last_input_data, CheckOutBookInputData)
    assert spy_use_case.last_input_data.book_id == 10
    assert spy_use_case.last_input_data.member_id == 20
```

---

## ✅ View のテスト（ConsoleView）

`ConsoleView` はユーザーと直接やり取りする層です。
テストでは、本物の `input()` / `print()` は使わず、pytestの `monkeypatch` と `capsys` を使ってエミュレートします。

* ユーザーが入力した値が Controller に渡るか？
* View が ViewModel の中身をちゃんと表示しているか？

```python
# tests/unit/test_view_console.py
from interface_adapters.views.view_console import ConsoleView
from core.usecase.boundary.dto import BookViewModel
from unittest.mock import MagicMock
from pytest import MonkeyPatch

def test_view_passes_input_to_controller_and_renders(monkeypatch: MonkeyPatch, capsys):
    # 1. Controllerのスパイを用意
    spy_controller = MagicMock()
    view_model = BookViewModel(display_text="初期メッセージ")

    # 2. ConsoleViewを準備
    view = ConsoleView(spy_controller, view_model)

    # 3. ユーザー入力を差し替える
    #    input() が2回呼ばれるので、2つ分を side_effect で返す
    monkeypatch.setattr(
        "builtins.input",
        lambda prompt: "123" if "本のID" in prompt else "456"
    )

    # 4. 実行
    view.run()

    # 5. Controller が正しい引数で呼ばれたか？
    spy_controller.check_out.assert_called_once_with(book_id=123, member_id=456)

    # 6. 画面表示（print）の内容を検証
    captured = capsys.readouterr()
    assert "初期メッセージ" in captured.out
    assert "--- 処理結果 ---" in captured.out
```

---

## ✅ Repository実装（InMemory） のテスト

`interface_adapters.data_access.in_memory_repositories` は、実際のDBの代わりにメモリ上の辞書を使うリポジトリ（Data Access）でした。
ここではその具体実装が、契約どおり動いているか（保存・検索・採番など）を確認します。

```python
# tests/unit/test_in_memory_repositories.py
from interface_adapters.data_access.in_memory_repositories import (
    InMemoryBookRepository,
    InMemoryMemberRepository,
    InMemoryLoanRepository,
)
from core.domain.book import Book, BookStatus
from core.domain.member import Member
from core.domain.loan import Loan
from datetime import date

def test_in_memory_book_repository_can_save_and_find():
    repo = InMemoryBookRepository()
    new_book = Book(id=99, title="テスト駆動開発", author="ケント・ベック", status=BookStatus.AVAILABLE)

    repo.save(new_book)
    found = repo.find_by_id(99)

    assert found is not None
    assert found.title == "テスト駆動開発"

def test_in_memory_member_repository_can_find_member():
    repo = InMemoryMemberRepository()
    # コンストラクタで会員を初期登録している想定（Alice, Bobなど）
    found = repo.find_by_id(1)
    assert isinstance(found, Member)

def test_in_memory_loan_repository_assigns_ids_and_persists():
    repo = InMemoryLoanRepository()
    loan = Loan(id=None, book_id=1, member_id=100, loan_date=date(2025, 10, 1))

    saved = repo.save(loan)

    assert saved.id == 1  # 自動採番された
    assert repo._database[1].book_id == 1
```

---

## 🧪 テストの実行方法

ターミナルで以下を実行します。

```bash
cd clean_architecture_library
pytest -v
```

`-v` は verbose（詳細表示）モードです。どのテストが走って何が通ったかが一覧で見えます。

出力イメージ：

```text
=================== test session starts ===================
collected 6 items

tests/unit/test_entities.py ......................   PASSED
tests/unit/test_usecase_checkout.py ..............   PASSED
tests/unit/test_presenter.py .....................   PASSED
tests/unit/test_controller.py ....................   PASSED
tests/unit/test_view_console.py ..................   PASSED
tests/unit/test_in_memory_repositories.py ........   PASSED

==================== 6 passed in 0.20s =====================
```

---

## 🧠 まとめ：テストで見える「クリーンアーキテクチャの本質」

* 各レイヤーを**単独で**テストできる
  → UIを立ち上げずにViewをテストできる
  → DBを用意せずに貸出ユースケース全体を検証できる

* Use Case のテストで、PresenterやRepositoryはフェイク／スパイに差し替えできる
  → つまり、業務フローそのものを“真空状態”で検証できる

* エンティティ（Book / Loan）のルールは、それ単体でテストできる
  → もっとも内側のルールほど、もっともテストしやすい

> テスト容易性は偶然の副産物ではありません。
> 「依存性は内側へ向かう」という設計ルールのおかげで、自然に手に入る成果です。
> **いい設計は、いいテストを呼ぶ。**

---

## 🚀 次のステップ

* 新しいユースケース（返却処理・延滞チェックなど）を追加しても、このテストスタイルをそのまま踏襲できます。
* さらに、ViewをコンソールからWeb（例：FastAPI）に差し替えたり、RepositoryをインメモリからPostgreSQL実装に差し替えたりしても、**Use Case のテストは壊れません**。

これが「ビジネスルールを中心に据える」ということです 📚💪
