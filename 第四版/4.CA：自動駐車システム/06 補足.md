# 06 補足

## 🎓 補足：第5巡（実通信）へ進む前に

第4巡では、SOA（サービス指向アーキテクチャ）のシミュレーションとして、サービス間の連携を「ファイル（JSON）」で行いました。

```
[サービスA] --> [ file.json ] --> [サービスB]
```

これは、「関心の分離」「インターフェース（契約）の重要性」「アダプタの差し替え」を学ぶ上で、完璧な題材でした。

第5巡では、いよいよこのファイルI/Oアダプタを、**gRPC**や**MQTT**といった「実ネットワーク通信アダプタ」に差し替えます。

```
[サービスA] --(ネットワーク)--> [サービスB]
```

この差し替えは、UseCaseを変更せずに行えるはずです。しかし、この変更によって、私たちは\*\*4つの新しい「現実の課題」\*\*と向き合うことになります。第4巡の最後に、これらの課題を予習しておきましょう。

### 📜 課題1：契約（インターフェース）の「厳格化」

第4巡では、`world_model.json` の中身（どのキーがあり、値が何か）は、私たちが口頭で決めた「暗黙の契約」でした。

第5巡では、**Protocol Buffers (protobuf)** のような **IDL (Interface Definition Language)** を使います。
これは、サービス間で交換するデータの「構造」を、`world_model.proto` という専用の「契約書ファイル」に厳格に定義する技術です。

- **第4巡**: JSON（テキスト、柔軟だが曖昧）
- **第5巡**: Protobuf（バイナリ、厳格・高速）

SDV（ソフトウェア定義車両）のような高性能が求められる分野では、テキスト（JSON）よりも遥かに高速に送受信できるバイナリ形式（Protobuf）が主流です。

### 🔌 課題2：通信パターン（同期 vs 非同期）

第4巡のファイル連携は、完全に**非同期**でした。認識サービスは「書きたい時」に書き、経路計算サービスは「読みたい時」に読みました。

第5巡では、この非同期性をどう実現するか、設計パターンを選ぶ必要があります。

1. **非同期（Pub/Sub）パターン (MQTTなど)**
    - 第4巡のファイル連携に最も近い方式です。
    - 「ブローカー」と呼ばれる中継サーバを立て、各サービスはそこに対して「公開（Publish）」したり「購読（Subscribe）」したりします。
    - サービス同士が直接お互いを知らなくても良い（疎結合）のが利点です。
2. **同期（Request/Response）パターン (gRPC, RESTなど)**
    - 経路計算サービスが、「今すぐ世界モデルをください」と認識サービスを**直接呼び出す**（リクエストする）方式です。
    - 相手の応答を待つ（同期的）必要がありますが、データが確実に渡ったことを確認しやすい利点があります。

第5巡では、このどちら（あるいは両方）を採用するかが、大きな設計上の選択となります。

### 💥 課題3：ネットワークの「不安定さ」

ファイルI/Oは、基本的に「失敗しません」（空き容量エラーを除く）。

しかし、ネットワーク通信は**本質的に不安定**です。第5巡では、以下の「現実の失敗」に常に対応しなければなりません。

- **相手がダウンしている**（接続できない）
- **通信が途中で切れる**（タイムアウト）
- **相手からの応答が遅い**（遅延）

これらの「失敗」を前提とし、失敗してもシステム全体が停止しないように、「リトライ（再試行）処理」や「サーキットブレーカー（失敗し続ける相手を一時的に切り離す）」といった、より高度な設計（回復性）が必要になります。

### 🧭 課題4：サービスの「発見」

第4巡では、ファイルの場所（`world_model.json`）は全員が知っていました。

第5巡では、各サービスは独立したコンピュータ（またはコンテナ）で動きます。経路計算サービスは、「認識サービスが、今どのIPアドレスの、どのポート番号で動いているか」を知る必要があります。

これを*サービスディスカバリ（Service Discovery）*と呼びます。
IPアドレスをコードに直接書き込む（ハードコーディング）のは最悪の設計です。そのため、KubernetesやConsulのような「住所録」を管理する仕組みを使い、相手の「住所」を動的に見つけ出す必要があります。

