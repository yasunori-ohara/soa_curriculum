# 第6章：契約テスト（Contract Test）の雛形

**「契約テスト」とは？**

> **契約テスト**は、「**約束した振る舞い**（＝インターフェース／契約）に対して、**どの実装でも同じ結果になるか**を検証するテスト」です。
> たとえば `ReservationRepository`（保存の約束）に対して、**SQLite実装**と**メモリ実装**が**同じ入力→同じ出力**になるかを、**同じテストケースを使って**確認します。
> これにより、**UseCase層のコードを一切変えず**に、DBや外部サービスの実装を差し替えられることを**テストで保証**できます。

---

## 🧩 図との対応（どの箱をテストする？）

![クリーンアーキテクチャ](../クリーンアーキテクチャ・依存と制御.png)

| 図の箱                            | 何をテストする？                            | どんな観点？                      |
| ------------------------------ | ----------------------------------- | --------------------------- |
| **UseCase層：Repository契約（I）**   | `ReservationRepository` の**契約**     | 「同じ契約を満たすなら実装が違っても同じ振る舞い」   |
| **InterfaceAdapter層：Gateway**  | Repository契約の**実装**（Entity⇔行データの変換） | 変換の正しさ（時刻ISO→datetime/逆など）  |
| **Infrastructure層：DataAccess** | Port（Protocol）の**実装**（SQLite/メモリなど） | SQL/トランザクション/インデックス等の技術的正しさ |

> 契約テストでは、**同じテスト群**を「SQLite版」「メモリ版」の**両方に適用**します。

---

## 🧱 推奨フォルダ構成（テスト側）

```
project_round3/
├── tests/
│   ├── contracts/
│   │   └── test_reservation_repository_contract.py  ← 契約テスト（共通テスト）
│   ├── fakes/
│   │   └── memory_reservation_data_access.py        ← メモリ版 DataAccess（Port実装）
│   └── conftest.py                                  ← pytest 共通fixture（DB初期化 等）
└── ...
```

---

## 🧪 メモリ版 DataAccess（Port のフェイク実装）

`tests/fakes/memory_reservation_data_access.py`

```python
# --------------------------------------------------------------------
# [クラス図] Data Access（Portのフェイク）
# [同心円] テスト補助（実運用の層には含めない）
# 役割：ReservationDataAccessPort をメモリで実装。契約テストでSQLite実装と比較対象にする。
# --------------------------------------------------------------------
from datetime import datetime
from typing import List, Optional, Dict
from interface.gateway.data_access_ports import ReservationDataAccessPort, ReservationRecord

class MemoryReservationDataAccess(ReservationDataAccessPort):
    def __init__(self):
        self._rows: Dict[int, ReservationRecord] = {}
        self._next = 1
        self._idempotency: Dict[str, int] = {}

    def next_id(self) -> int:
        nid = self._next
        self._next += 1
        return nid

    def insert(self, rec: ReservationRecord) -> None:
        self._rows[rec.id] = rec

    def find_overlaps(self, room_id: int, start_at: datetime, end_at: datetime) -> List[ReservationRecord]:
        s, e = start_at.isoformat(), end_at.isoformat()
        out = []
        for r in self._rows.values():
            if r.room_id != room_id:
                continue
            # 区間重複: NOT (end <= s OR start >= e)
            if not (r.end_at_iso <= s or r.start_at_iso >= e):
                out.append(r)
        out.sort(key=lambda r: r.start_at_iso)
        return out

    def check_idempotency(self, key: str) -> Optional[int]:
        return self._idempotency.get(key)

    def upsert_idempotency(self, key: str, reservation_id: int) -> None:
        self._idempotency[key] = reservation_id

    def find_by_id(self, reservation_id: int) -> Optional[ReservationRecord]:
        return self._rows.get(reservation_id)

    def delete(self, reservation_id: int) -> None:
        self._rows.pop(reservation_id, None)
```

---

## ⚙ pytest 共通フィクスチャ（SQLite初期化）

`tests/conftest.py`

```python
# --------------------------------------------------------------------
# [クラス図] Test Fixture
# 役割：SQLiteの初期化。rooms/members の最小データを投入（FK制約対応）。
# --------------------------------------------------------------------
import pytest
from infrastructure.db.sqlite_conn import init_db, get_connection

@pytest.fixture(scope="session", autouse=True)
def _init_sqlite_db():
    init_db()
    # 参照整合のための最低限データ
    with get_connection() as conn:
        conn.execute("INSERT OR IGNORE INTO rooms(id,name,capacity,equipments_csv) VALUES (1,'A',6,'whiteboard')")
        conn.execute("INSERT OR IGNORE INTO members(id,name,email) VALUES (1,'Taro','taro@example.com')")
    yield
    # セッション終わりに掃除しても良い（任意）
```

---

## 🧪 契約テスト本体（共通テストケース）

`tests/contracts/test_reservation_repository_contract.py`

```python
# --------------------------------------------------------------------
# [クラス図] Contract Test（共通テスト群）
# [同心円] テスト補助
# 役割：ReservationRepository 契約を満たすあらゆる実装に適用し、同じ結果になることを保証。
# --------------------------------------------------------------------
import pytest
from datetime import datetime, timedelta
from domain.reservation import Reservation
from interface.gateway.reservation_gateway import ReservationRepositoryGateway
from tests.fakes.memory_reservation_data_access import MemoryReservationDataAccess
from infrastructure.db.reservation_data_access import SqliteReservationDataAccess

# ---- 被テスト対象のFactory（実装差替えのために2種類用意） -------------------
def make_memory_repo():
    dao = MemoryReservationDataAccess()
    repo = ReservationRepositoryGateway(dao)
    return repo, dao  # daoを返すのは掃除用途（必要なら）

def make_sqlite_repo():
    dao = SqliteReservationDataAccess()
    repo = ReservationRepositoryGateway(dao)
    return repo, dao

@pytest.fixture(params=["memory", "sqlite"])
def repo_pair(request):
    if request.param == "memory":
        return make_memory_repo()
    elif request.param == "sqlite":
        return make_sqlite_repo()
    else:
        raise RuntimeError

# ---- 共通ユーティリティ ------------------------------------------------------
def dt(y, m, d, hh, mm=0):
    return datetime(y, m, d, hh, mm)

# ---- テストケース（すべての実装に適用） --------------------------------------
def test_roundtrip_save_and_find_by_id(repo_pair):
    repo, _ = repo_pair
    rid = repo.next_id()
    r = Reservation(id=rid, room_id=1, member_id=1,
                    start_at=dt(2025,1,1,10), end_at=dt(2025,1,1,11),
                    attendees=3)
    repo.save(r)
    got = repo.find_by_id(rid)
    assert got is not None
    assert got.id == rid
    assert got.start_at == r.start_at
    assert got.end_at == r.end_at
    assert got.attendees == 3

def test_next_id_increments(repo_pair):
    repo, _ = repo_pair
    a = repo.next_id()
    b = repo.next_id()
    assert b == a + 1

def test_find_overlaps_detects_overlap_and_non_overlap(repo_pair):
    repo, _ = repo_pair
    a = Reservation(id=repo.next_id(), room_id=1, member_id=1,
                    start_at=dt(2025,1,1,10), end_at=dt(2025,1,1,11), attendees=2)
    repo.save(a)

    # 重ならない（終端接触はOK）
    non = repo.find_overlaps(1, dt(2025,1,1,11), dt(2025,1,1,12))
    assert len(non) == 0

    # 重なる
    ov = repo.find_overlaps(1, dt(2025,1,1,10,30), dt(2025,1,1,11,30))
    assert any(r.id == a.id for r in ov)

def test_idempotency_returns_existing_id(repo_pair):
    repo, dao = repo_pair

    # 先に予約を作って、冪等キー表にも同値を登録する（Port経由）
    rid = repo.next_id()
    r = Reservation(id=rid, room_id=1, member_id=1,
                    start_at=dt(2025,1,1,9), end_at=dt(2025,1,1,10), attendees=2)
    repo.save(r)

    # Portが提供する upsert_idempotency を使ってキー→IDを登録
    dao.upsert_idempotency("req-123", rid)

    # Repository契約の check_idempotency で同じIDを取得できる
    existed = repo.check_idempotency("req-123")
    assert existed == rid

def test_delete_removes_record(repo_pair):
    repo, _ = repo_pair
    rid = repo.next_id()
    r = Reservation(id=rid, room_id=1, member_id=1,
                    start_at=dt(2025,1,1,14), end_at=dt(2025,1,1,15), attendees=2)
    repo.save(r)
    assert repo.find_by_id(rid) is not None
    repo.delete(rid)
    assert repo.find_by_id(rid) is None
```

**ここで保証している契約（例）**

* `next_id()` は**単調増加**である
* `save()` → `find_by_id()` で**同値復元**できる（時刻のISO↔datetime変換も）
* `find_overlaps()` が `[start, end)` の**重なり**を正しく返す（終端接触は重ならない）
* `check_idempotency()` が**同じ操作の結果（予約ID）**を返せる
* `delete()` が**確実に削除**する

> これらの**同じテスト**が **Memory版** と **SQLite版** の**両方**で**緑**になる ⇒
> **「契約が守られている」**と判断できます。

---

## ✅ 契約テストで得られる安心

* **実装差し替えの自由**：SQLite→PostgreSQL／メモリ→本番DB でも **UseCaseは無変更**
* **退行防止**：SQL最適化やインデックス変更で、**振る舞いが変わっていない**ことを自動検証
* **ドキュメントとしての価値**：**テスト名＝契約の要点**。新規実装者への明確なガイド

---

## 💡 応用：他の契約にも広げる

* `RoomRepository` の契約テスト

  * `find_by_id`／`search_candidates(min_capacity, required_equipments)`
  * **設備フィルタの最終確認**は Gateway 側で担保（DBが完全一致できない場合の保険）
* `MemberRepository` の契約テスト

  * `find_by_id` の往復確認、メール重複などの制約があるならそのケースも

> いずれも「**共通テスト群**」＋「**実装を作るファクトリ**」という形にしておくと、
> 新しい実装（別DB・モック）を追加するたびに**テストが自動適用**されます。

---

## 📝 まとめ

* **契約テスト**＝「**約束（インターフェース）の振る舞い**を**実装間で共通**に保てているか」を確かめるテスト
* **同じテストを複数実装に適用**するのがコツ（pytest の `@fixture(params=...)` が便利）
* 第３巡ではまず `ReservationRepository` から始め、**Room／Member** にも広げると堅牢になります

この雛形でスタートしておけば、以降の拡張（PostgreSQL化・Redis併用・メッセージング導入など）でも、**UseCaseを壊さずに**進化させられます。
