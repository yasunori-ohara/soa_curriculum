# 05 リファクタリングの実装

# ステップ５：リファクタリングの実装：リポジトリとUseCaseの調整 💾⚙️

Step 3 で値オブジェクトを導入し、Step 4 でエンティティ/集約の責務を明確化しました。この最終ステップでは、これらのドメインモデルの変更に合わせて、**リポジトリ (Repository)** のインターフェースと実装、そして**UseCase** を調整します。最後に `main.py` で動作を確認します。

---

## 💾 1. リポジトリ (Repository) の調整

📝 **課題**: リポジトリのインターフェースと実装が、新しい値オブジェクト (`ISBN`, `LoanPeriod`) や集約の変更に対応していない。また、Step 2 で必要と判断された「利用者のアクティブな貸出数を数える」メソッドがない。

💡 **改善**:

1. `BookRepositoryInterface` の検索メソッドを `isbn` (`ISBN` VO) で行えるように修正します（既にそうなっているかもしれませんが確認）。
2. `LoanRepositoryInterface` に `find_active_by_user_id` や `count_active_by_user_id` のようなメソッドを追加します。
3. `InMemory...Repository` の実装を、これらの変更に合わせて修正します。値オブジェクトをキーや比較に使うようにします。

**ファイル:** `application/boundaries.py` (修正)

```python
# application/boundaries.py
from abc import ABC, abstractmethod
# 👈 集約と値オブジェクトをインポート
from domain.aggregates import Book, User, Loan
from domain.value_objects import ISBN, LoanPeriod, UserName # UserNameを追加
from typing import Optional, List

# -----------------------------------------------------------------------------
# Book Repository Interface (Refactored)
# - CAの Application 層 (境界定義)
# -----------------------------------------------------------------------------
class BookRepositoryInterface(ABC):
    @abstractmethod
    def find_by_isbn(self, isbn: ISBN) -> Optional[Book]: # 👈 ISBN(VO) で検索
        raise NotImplementedError

    @abstractmethod
    def save(self, book: Book):
        raise NotImplementedError
    # (find_all などは変更なし想定)

# -----------------------------------------------------------------------------
# User Repository Interface (Refactored)
# - CAの Application 層 (境界定義)
# -----------------------------------------------------------------------------
class UserRepositoryInterface(ABC):
    @abstractmethod
    def find_by_id(self, user_id: str) -> Optional[User]:
        raise NotImplementedError

    @abstractmethod
    def save(self, user: User):
        raise NotImplementedError
    # (必要であれば find_by_name(UserName) なども追加)

# -----------------------------------------------------------------------------
# Loan Repository Interface (Refactored)
# - CAの Application 層 (境界定義)
# -----------------------------------------------------------------------------
class LoanRepositoryInterface(ABC):
    @abstractmethod
    def find_by_id(self, loan_id: str) -> Optional[Loan]:
        raise NotImplementedError

    @abstractmethod
    def save(self, loan: Loan):
        raise NotImplementedError

    @abstractmethod
    def find_active_by_book_id(self, book_id: str) -> Optional[Loan]:
        """指定された書籍IDの有効な貸出を検索 (通常1件のはず)"""
        raise NotImplementedError

    @abstractmethod
    def find_active_by_user_id(self, user_id: str) -> List[Loan]:
        """指定された利用者IDの有効な貸出リストを検索"""
        raise NotImplementedError

    # 貸出数チェック用にカウントメソッドを追加しても良い
    # @abstractmethod
    # def count_active_by_user_id(self, user_id: str) -> int:
    #     """指定された利用者IDの有効な貸出数をカウント"""
    #     raise NotImplementedError

```

**ファイル:** `adapters/repositories.py` (修正)

```python
# adapters/repositories.py
# (Imports: interfaces, aggregates, value objects, typing, copy...)
from application.boundaries import BookRepositoryInterface, UserRepositoryInterface, LoanRepositoryInterface
from domain.aggregates import Book, User, Loan
from domain.value_objects import ISBN, UserName, LoanStatus # LoanStatusを追加
from typing import Optional, List, Dict
import copy

# -----------------------------------------------------------------------------
# In-Memory Book Repository Implementation (Refactored)
# - CAの Adapters 層
# -----------------------------------------------------------------------------
class InMemoryBookRepository(BookRepositoryInterface):
    def __init__(self):
        self._books: Dict[ISBN, Book] = {} # 👈 キーを ISBN(VO) に変更

    def find_by_isbn(self, isbn: ISBN) -> Optional[Book]: # 👈 引数を ISBN(VO) に
        print(f"[Adapter] InMemoryRepo: Finding book by ISBN {isbn.value}")
        book = self._books.get(isbn) # 値オブジェクトをキーにできる
        return copy.deepcopy(book) if book else None

    def save(self, book: Book):
        print(f"[Adapter] InMemoryRepo: Saving book {book.isbn.value}")
        self._books[book.isbn] = copy.deepcopy(book) # キーも ISBN(VO)

# -----------------------------------------------------------------------------
# In-Memory User Repository Implementation (Refactored)
# - CAの Adapters 層
# -----------------------------------------------------------------------------
class InMemoryUserRepository(UserRepositoryInterface):
    def __init__(self):
        self._users: Dict[str, User] = {} # user_id をキー

    def find_by_id(self, user_id: str) -> Optional[User]:
        print(f"[Adapter] InMemoryRepo: Finding user {user_id}")
        user = self._users.get(user_id)
        return copy.deepcopy(user) if user else None

    def save(self, user: User):
        # UserName(VO) の値を使ってログ出力
        print(f"[Adapter] InMemoryRepo: Saving user {user.user_id} ({user.name.value})")
        self._users[user.user_id] = copy.deepcopy(user)

# -----------------------------------------------------------------------------
# In-Memory Loan Repository Implementation (Refactored)
# - CAの Adapters 層
# -----------------------------------------------------------------------------
class InMemoryLoanRepository(LoanRepositoryInterface):
    def __init__(self):
        self._loans: Dict[str, Loan] = {} # loan_id をキー

    def find_by_id(self, loan_id: str) -> Optional[Loan]:
        print(f"[Adapter] InMemoryRepo: Finding loan {loan_id}")
        loan = self._loans.get(loan_id)
        return copy.deepcopy(loan) if loan else None

    def save(self, loan: Loan):
        print(f"[Adapter] InMemoryRepo: Saving loan {loan.loan_id} for book {loan.book_id}")
        self._loans[loan.loan_id] = copy.deepcopy(loan)

    def find_active_by_book_id(self, book_id: str) -> Optional[Loan]:
        """有効な貸出を書籍IDで検索"""
        print(f"[Adapter] InMemoryRepo: Finding active loan for book {book_id}")
        for loan in self._loans.values():
            if loan.book_id == book_id and loan.status == LoanStatus.ACTIVE:
                return copy.deepcopy(loan)
        return None

    def find_active_by_user_id(self, user_id: str) -> List[Loan]:
        """有効な貸出を利用者IDで検索"""
        print(f"[Adapter] InMemoryRepo: Finding active loans for user {user_id}")
        active_loans = [
            copy.deepcopy(loan) for loan in self._loans.values()
            if loan.user_id == user_id and loan.status == LoanStatus.ACTIVE
        ]
        return active_loans

    # def count_active_by_user_id(self, user_id: str) -> int:
    #     """有効な貸出数をカウント"""
    #     print(f"[Adapter] InMemoryRepo: Counting active loans for user {user_id}")
    #     return len(self.find_active_by_user_id(user_id))

```

✅ **このステップのポイント**:

- リポジトリのメソッドシグネチャ（引数やキー）で**値オブジェクト** (`ISBN`) を使うように修正しました。
- `LoanRepository` に、UseCase が必要とする**新しい検索メソッド** (`find_active_by_user_id` など) を追加しました。
- 実装クラスもこれに合わせて修正しました。

---

## ⚙️ 2. UseCase の調整 - 集約の振る舞いを活用する

📝 **課題**: 以前の `BorrowBookUseCase` や `ReturnBookUseCase` は、集約の状態（`is_borrowed` など）を直接読み書きしていた可能性があります。また、最大貸出数のチェックロジックが UseCase 内にありました。

💡 **改善**:

1. UseCase は、集約の状態を直接変更する代わりに、集約に追加した**メソッド** (`book.borrow()`, `loan.complete()`) を呼び出すように修正します。これにより、状態変更のロジックと不変条件の維持は集約の責任になります。
2. UseCase は、入力された文字列 (`isbn_str` など) を、処理の早い段階で**値オブジェクト** (`ISBN` など) に変換します。
3. 最大貸出数のチェックは、UseCase が `LoanRepository.find_active_by_user_id()` を呼び出して行います（方針3-4）。

**ファイル:** `application/use_cases.py` (修正)

```python
# application/use_cases.py
# (Imports: boundaries, aggregates, value objects, datetime, typing...)
from application.boundaries import BookRepositoryInterface, UserRepositoryInterface, LoanRepositoryInterface
from domain.aggregates import Book, User, Loan
from domain.value_objects import ISBN, LoanPeriod # LoanPeriod をインポート
from datetime import date # date をインポート
from typing import Optional, List # List を追加

# (他の UseCase ...)

# -----------------------------------------------------------------------------
# Borrow Book Use Case (Refactored)
# - CAの Use Cases 層と同じ役割
# - 集約のメソッドを呼び出し、リポジトリを利用する
# -----------------------------------------------------------------------------
class BorrowBookUseCase:
    """書籍を貸し出すユースケース (リファクタリング後)"""
    MAX_LOANS_PER_USER = 5 # 例: 最大貸出数ルール

    def __init__(self,
                 book_repository: BookRepositoryInterface,
                 user_repository: UserRepositoryInterface,
                 loan_repository: LoanRepositoryInterface):
        self._book_repository = book_repository
        self._user_repository = user_repository
        self._loan_repository = loan_repository

    def handle(self, user_id: str, isbn_str: str, borrow_date: date):
        """
        ユースケースを実行する
        Args:
            user_id: 利用者ID
            isbn_str: 貸出希望書籍のISBN(文字列)
            borrow_date: 貸出日
        Raises:
            ValueError: 入力不正、ユーザー/書籍不存在、貸出不可、貸出上限超過など
        """
        print(f"[UseCase] Attempting to borrow book {isbn_str} for user {user_id} on {borrow_date}")

        # 1. 入力から値オブジェクトを生成 (ISBN検証)
        try:
            isbn = ISBN(isbn_str)
        except ValueError as e:
            print(f"[UseCase] Invalid ISBN format: {e}")
            raise

        # --- トランザクション管理の開始 (概念) ---
        print("[UseCase] --- Transaction Start (Conceptual) ---")
        try:
            # 2. 利用者と書籍の存在確認 (リポジトリ利用)
            user = self._user_repository.find_by_id(user_id)
            if not user: raise ValueError(f"User {user_id} not found.")

            book = self._book_repository.find_by_isbn(isbn)
            if not book: raise ValueError(f"Book with ISBN {isbn.value} not found.")

            # 3. 最大貸出数チェック (アプリケーション/UseCaseのルール)
            active_loans = self._loan_repository.find_active_by_user_id(user_id)
            if len(active_loans) >= self.MAX_LOANS_PER_USER:
                raise ValueError(f"User {user_id} has reached the maximum number of loans ({self.MAX_LOANS_PER_USER}).")

            # 4. 書籍集約のメソッドを呼び出して貸出手続き
            #    (内部で貸出可能かチェックし、状態を BORROWED に変更)
            #    ここで書籍が貸出不可なら ValueError が発生
            book.borrow()

            # 5. 新しい貸出(Loan)集約を生成 (ファクトリメソッド利用)
            new_loan = Loan.create_new(book_id=book.isbn.value, # ID参照は文字列で
                                      user_id=user.user_id,
                                      start_date=borrow_date)

            # 6. 変更された集約(Book)と新しい集約(Loan)を保存
            self._book_repository.save(book)
            self._loan_repository.save(new_loan)

            # --- トランザクションのコミット (概念) ---
            print(f"[UseCase] --- Transaction Commit (Conceptual) ---")
            print(f"[UseCase] Book {isbn.value} borrowed successfully by user {user_id}. Loan ID: {new_loan.loan_id}")

        except Exception as e:
            # --- トランザクションのロールバック (概念) ---
            print(f"[UseCase] Failed to borrow book: {e}")
            print("[UseCase] --- Transaction Rollback (Conceptual) ---")
            raise

# -----------------------------------------------------------------------------
# Return Book Use Case (Refactored)
# - CAの Use Cases 層と同じ役割
# -----------------------------------------------------------------------------
class ReturnBookUseCase:
    """書籍を返却するユースケース (リファクタリング後)"""
    def __init__(self,
                 book_repository: BookRepositoryInterface,
                 loan_repository: LoanRepositoryInterface):
        self._book_repository = book_repository
        self._loan_repository = loan_repository

    def handle(self, isbn_str: str, return_date: date):
        """
        ユースケースを実行する
        Args:
            isbn_str: 返却する書籍のISBN(文字列)
            return_date: 返却日
        Raises:
            ValueError: 入力不正、書籍不存在、貸出記録不存在など
        """
        print(f"[UseCase] Attempting to return book {isbn_str} on {return_date}")

        # 1. 入力から値オブジェクトを生成 (ISBN検証)
        try:
            isbn = ISBN(isbn_str)
        except ValueError as e:
            print(f"[UseCase] Invalid ISBN format: {e}")
            raise

        # --- トランザクション管理の開始 (概念) ---
        print("[UseCase] --- Transaction Start (Conceptual) ---")
        try:
            # 2. 書籍の存在確認
            book = self._book_repository.find_by_isbn(isbn)
            if not book: raise ValueError(f"Book with ISBN {isbn.value} not found.")

            # 3. 該当書籍の有効な貸出記録を取得
            #    (find_active_by_book_id は通常1件 or 0件を返す想定)
            active_loan = self._loan_repository.find_active_by_book_id(book.isbn.value) # ID参照は文字列
            if not active_loan:
                raise ValueError(f"No active loan found for book {isbn.value}.")

            # 4. 書籍集約のメソッドを呼び出して返却処理
            book.return_book() # 状態を AVAILABLE に戻す

            # 5. 貸出集約のメソッドを呼び出して完了処理
            active_loan.complete(return_date) # 状態を COMPLETED にする

            # 6. 変更された両方の集約を保存
            self._book_repository.save(book)
            self._loan_repository.save(active_loan)

            # --- トランザクションのコミット (概念) ---
            print(f"[UseCase] --- Transaction Commit (Conceptual) ---")
            print(f"[UseCase] Book {isbn.value} returned successfully. Loan ID: {active_loan.loan_id}")

        except Exception as e:
            # --- トランザクションのロールバック (概念) ---
            print(f"[UseCase] Failed to return book: {e}")
            print("[UseCase] --- Transaction Rollback (Conceptual) ---")
            raise

```

✅ **このステップのポイント**:

- UseCase は、集約の状態を直接変更する代わりに、集約の**メソッド** (`book.borrow()`, `loan.complete()`) を呼び出すようになりました。これにより、ドメインルール（状態遷移条件など）の実行責任が集約に移譲され、UseCase はより**ビジネスフローの調整役**に徹することができます。
- 入力された文字列は、早期に**値オブジェクト** (`ISBN`) に変換され、以降の処理で安全に利用されます。
- 集約をまたぐルール（最大貸出数）は、UseCase が**リポジトリ**に問い合わせてチェックするように実装しました。

---

## 🚀 3. 実行ファイル ([main.py](http://main.py/)) の作成 - リファクタリング後の動作確認

最後に、リファクタリングされた UseCase を呼び出して動作を確認する `main.py` を作成します。

**ファイル:** `main.py` (新規作成または修正)

```python
# main.py
# (Imports: repositories, use_cases, domain objects, datetime, date...)
from adapters.repositories import InMemoryBookRepository, InMemoryUserRepository, InMemoryLoanRepository
from application.use_cases import BorrowBookUseCase, ReturnBookUseCase
from domain.aggregates import Book, User, Loan
from domain.value_objects import ISBN, UserName, BookStatus, LoanStatus, LoanPeriod
from datetime import date, timedelta

if __name__ == "__main__":
    print("--- Library System Refactoring Example ---")

    # --- 依存関係の解決 (DI) ---
    print("\\n--- Wiring dependencies (DI) ---")
    book_repo = InMemoryBookRepository()
    user_repo = InMemoryUserRepository()
    loan_repo = InMemoryLoanRepository()
    borrow_book_use_case = BorrowBookUseCase(book_repo, user_repo, loan_repo)
    return_book_use_case = ReturnBookUseCase(book_repo, loan_repo)
    print("--- Dependencies wired successfully ---")

    # --- 初期データ投入 ---
    print("\\n--- Setting up initial data ---")
    try:
        user_name = UserName("Test User")
        user = User(name=user_name)
        user_repo.save(user)
        user_id = user.user_id
        print(f"User '{user_name.value}' created with ID: {user_id}")

        isbn1_str = "978-4-7981-5763-7"
        isbn1 = ISBN(isbn1_str)
        book1 = Book(isbn=isbn1, title="Clean Architecture", author="Robert C. Martin")
        book_repo.save(book1)
        print(f"Book '{book1.title}' ({isbn1.value}) created with Status: {book1.status.name}") # AVAILABLE
    except ValueError as e:
        print(f"Error setting up initial data: {e}")
        exit()

    today = date.today()

    # --- UseCase実行1: 書籍を借りる (成功) ---
    print("\\n--- Executing UseCase: Borrow Book (Success) ---")
    try:
        borrow_book_use_case.handle(user_id, isbn1_str, today)
    except Exception as e: print(f"Borrow failed: {e}")

    # --- 状態確認 1 ---
    print("\\n--- Verifying State 1 ---")
    book1_after_borrow = book_repo.find_by_isbn(isbn1)
    loans_after_borrow = loan_repo.find_active_by_user_id(user_id)
    if book1_after_borrow: print(f"Book 1 Status: {book1_after_borrow.status.name}") # -> BORROWED
    print(f"User Active Loans: {len(loans_after_borrow)}") # -> 1
    if loans_after_borrow: print(f" Loan Period: {loans_after_borrow[0].loan_period.start_date} to {loans_after_borrow[0].loan_period.end_date}")

    # --- UseCase実行2: 同じ本を借りる (失敗: 貸出中) ---
    print("\\n--- Executing UseCase: Borrow Book (Fail - Already Borrowed) ---")
    try:
        borrow_book_use_case.handle(user_id, isbn1_str, today)
    except Exception as e: print(f"Borrow failed as expected: {e}") # -> Book ... is not available...

    # --- UseCase実行3: 書籍を返す (成功) ---
    print("\\n--- Executing UseCase: Return Book (Success) ---")
    return_d = today + timedelta(days=7) # 7日後に返却
    try:
        return_book_use_case.handle(isbn1_str, return_d)
    except Exception as e: print(f"Return failed: {e}")

    # --- 最終状態確認 ---
    print("\\n--- Verifying Final State ---")
    book1_after_return = book_repo.find_by_isbn(isbn1)
    loans_after_return = loan_repo.find_active_by_user_id(user_id)
    # loan_history = loan_repo.find_all() # find_all があれば全履歴も見れる
    if book1_after_return: print(f"Book 1 Status: {book1_after_return.status.name}") # -> AVAILABLE
    print(f"User Active Loans: {len(loans_after_return)}") # -> 0
    # completed_loan = loan_repo.find_by_id(loans_after_borrow[0].loan_id) # IDを保持しておけば...
    # if completed_loan: print(f"Loan Status: {completed_loan.status.name}") # -> COMPLETED

```

✅ **このステップのポイント**:

- `main.py` が依存関係を組み立て、リファクタリングされた UseCase (`BorrowBookUseCase`, `ReturnBookUseCase`) を呼び出しました。
- UseCase が集約のメソッドを呼び出すことで、ドメインルール（貸出中の本は借りられないなど）が正しく機能し、状態が適切に更新されることを確認しました。

---

## 📝 この演習のまとめ

このリファクタリング演習を通じて、第2巡（想定）の図書館システムコードをDDDの戦術的パターンで改善しました。

1. **値オブジェクト**導入により、ISBN、貸出期間、利用者名といったドメイン概念が型安全に、ルールと共に表現されました。
2. **エンティティ/集約** (`Book`, `Loan`) が自身の状態とそれに関連する振る舞い（`borrow`, `return_book`, `complete`）を持つようになり、責務が明確化され、貧血ドメインモデルから脱却しました。
3. **リポジトリ**を調整し、値オブジェクトの利用や必要な検索機能を追加しました。
4. **UseCase** は、ドメインオブジェクト（集約メソッド、値オブジェクト）とリポジトリを利用する「調整役」に徹するようになり、よりシンプルで堅牢になりました。

リファクタリングの結果、コードはドメインの構造やルールをより正確に反映し、変更に強く、テストしやすいものへと改善されたはずです。

---

## ✅ DDD 実践編：既存コードのリファクタリング 完了！

これで、「既存コードのリファクタリング」演習は完了です。