# 04 リファクタリングの実装

# ステップ４：リファクタリングの実装：エンティティ/集約の責務明確化 🧱

Step 3 で値オブジェクト (`ISBN`, `LoanPeriod`, `UserName`) を導入しました。このステップでは、これらの値オブジェクトを利用して、**エンティティ (Entity)** / **集約 (Aggregate)** である `Book`, `Loan`, `User` の定義を修正し、それぞれの\*\*責務（振る舞いと状態管理）\*\*をより明確にカプセル化します。

---

## 🧱 1. `Book` 集約のリファクタリング

📝 **課題**: 以前の `Book` クラスは、貸出状態 (`is_borrowed`) を単なる `bool` で持ち、状態変更のロジック（貸出可能かチェックして状態を変える）が `UseCase` に漏れ出している可能性がありました。また、ISBNが `str` 型でした。

💡 **改善**:

1. `isbn` 属性の型を `ISBN` 値オブジェクトに変更します。
2. 貸出状態を表現する `BookStatus` Enum を定義し、`status` 属性として持ちます。
3. `borrow()` と `return_book()` メソッドを `Book` 集約自身に追加し、状態遷移ロジックをカプセル化します。

**ファイル:** `domain/value_objects.py` (Enum を追加)

```python
# domain/value_objects.py
# (ISBN, LoanPeriod, UserName definitions...)
from enum import Enum, auto # Enum をインポート

# -----------------------------------------------------------------------------
# BookStatus Enum (Value Objectに近い使い方)
# - DDD戦術的設計の Value Object (Enum表現)
# - CAの Entities 層 (Book集約の内部状態)
# -----------------------------------------------------------------------------
class BookStatus(Enum):
    """書籍の状態を表す列挙型"""
    AVAILABLE = auto() # 貸出可能
    BORROWED = auto()  # 貸出中
    # (将来的に: LOST, UNDER_REPAIR など)

```

**ファイル:** `domain/aggregates.py` (`Book` クラスを修正)

```python
# domain/aggregates.py
from dataclasses import dataclass, field
# 👈 値オブジェクトとEnumをインポート
from .value_objects import ISBN, Money, Title, Body, BookStatus
import uuid

# (他の Aggregate 定義 ...)

# -----------------------------------------------------------------------------
# Book Aggregate Root / Entity (Refactored)
# - DDD戦術的設計の Aggregate Root / Entity
# - CAの Entities 層
# -----------------------------------------------------------------------------
@dataclass
class Book:
    """
    書籍を表す集約ルート・エンティティ (リファクタリング後)。
    - isbn (VO) で識別される。
    - 貸出状態(status)とそれに関する振る舞い(borrow, return_book)を持つ。
    """
    # book_id: str = field(default_factory=lambda: str(uuid.uuid4())) # UUIDを使う場合
    isbn: ISBN # 👈 型を ISBN 値オブジェクトに変更
    title: str # 👈 Title VO に変更するのが望ましい (今回は省略)
    author: str # 👈 Author VO に変更するのが望ましい (今回は省略)
    status: BookStatus = BookStatus.AVAILABLE # 👈 BookStatus Enumを使用

    def borrow(self):
        """
        [集約の振る舞い] 書籍を貸し出す。
        - 貸出可能状態かチェックし、状態を BORROWED に変更する (不変条件維持)。
        """
        print(f"[Aggregate Logic] Attempting to borrow book {self.isbn.value}")
        # 不変条件: 貸出可能な状態でのみ貸出できる
        if self.status != BookStatus.AVAILABLE:
            raise ValueError(f"Book {self.isbn.value} is not available for borrowing (current status: {self.status.name}).")

        self.status = BookStatus.BORROWED
        print(f"[Aggregate Logic] Book {self.isbn.value} status changed to BORROWED.")
        # (BookBorrowed イベントを発行しても良い)

    def return_book(self):
        """
        [集約の振る舞い] 書籍を返却する。
        - 状態を AVAILABLE に戻す。
        """
        print(f"[Aggregate Logic] Returning book {self.isbn.value}")
        # (もし BORROWED 状態でのみ返却可能、というルールならチェックを追加)
        # if self.status != BookStatus.BORROWED:
        #     raise ValueError(...)

        self.status = BookStatus.AVAILABLE
        print(f"[Aggregate Logic] Book {self.isbn.value} status changed to AVAILABLE.")
        # (BookReturned イベントを発行しても良い)

```

✅ **効果**:

- `isbn` が `ISBN` 型になったことで、常に正しい形式であることが保証されます。
- `status` が `BookStatus` Enum になったことで、不正な状態（例: `"Borrowed"` のタイプミス）を防げます。
- `borrow()` / `return_book()` メソッドが `Book` 自身に追加されたことで、「貸出/返却」に関する**ビジネスルール**（状態チェックと遷移）が `Book` 集約内に**カプセル化**されました。`UseCase` はこれらのメソッドを呼び出すだけでよくなり、`UseCase` 内の `if book.is_borrowed:` のようなチェックが不要になります。

---

### 🧱 2. `Loan` 集約のリファクタリング

📝 **課題**: 以前の `Loan` クラスは、貸出期間を2つの `datetime` で持ち、完了状態の管理が外部（UseCase）に依存している可能性がありました。また、参照する `book_id` や `user_id` の型が曖昧でした。

💡 **改善**:

1. 貸出期間を `LoanPeriod` 値オブジェクトで保持するように変更します。
2. 貸出状態を表す `LoanStatus` Enum を定義し、`status` 属性として持ちます。
3. `complete()` メソッドを追加し、状態遷移ロジックをカプセル化します。
4. `book_id` や `user_id` の型を明確にします（今回は `str` のままですが、専用のID値オブジェクト `BookID`, `UserID` を定義するのがよりDDD的です）。

**ファイル:** `domain/value_objects.py` (Enum を追加)

```python
# domain/value_objects.py
# (ISBN, LoanPeriod, UserName, BookStatus definitions...)

# -----------------------------------------------------------------------------
# LoanStatus Enum (Value Objectに近い使い方)
# - DDD戦術的設計の Value Object (Enum表現)
# - CAの Entities 層 (Loan集約の内部状態)
# -----------------------------------------------------------------------------
class LoanStatus(Enum):
    """貸出の状態を表す列挙型"""
    ACTIVE = auto()    # 貸出中
    COMPLETED = auto() # 返却済み (完了)
    # (将来的に: OVERDUE 延滞中 など)

```

**ファイル:** `domain/aggregates.py` (`Loan` クラスを修正/追加)

```python
# domain/aggregates.py
# (Imports: dataclass, field, uuid, datetime, List, Dict...)
from .value_objects import LoanPeriod, LoanStatus # 👈 インポート

# (Book aggregate definition...)

# -----------------------------------------------------------------------------
# Loan Aggregate Root / Entity (Refactored)
# - DDD戦術的設計の Aggregate Root / Entity
# - CAの Entities 層
# -----------------------------------------------------------------------------
@dataclass
class Loan:
    """
    貸出を表す集約ルート・エンティティ (リファクタリング後)。
    - loan_id で識別される。
    - 貸出期間(loan_period)は LoanPeriod 値オブジェクトで保持。
    - 貸出状態(status)とそれに関する振る舞い(complete)を持つ。
    """
    loan_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    book_id: str # 👈 Book 集約への参照ID (BookID VOにするのが望ましい)
    user_id: str # 👈 User 集約への参照ID (UserID VOにするのが望ましい)
    loan_period: LoanPeriod # 👈 LoanPeriod 値オブジェクトを使用
    status: LoanStatus = LoanStatus.ACTIVE # 👈 LoanStatus Enumを使用 (デフォルトは貸出中)

    @classmethod
    def create_new(cls, book_id: str, user_id: str, start_date: date) -> 'Loan':
        """
        新しい貸出を生成するためのファクトリメソッド (例)。
        デフォルトの貸出期間で生成する。
        """
        print(f"[Factory Method] Creating new loan for book {book_id}, user {user_id}")
        # LoanPeriod値オブジェクトのファクトリメソッドを利用
        period = LoanPeriod.create_default(start_date)
        return cls(book_id=book_id, user_id=user_id, loan_period=period)

    def complete(self, return_date: date):
        """
        [集約の振る舞い] 貸出を完了（返却済み）にする。
        """
        print(f"[Aggregate Logic] Completing loan {self.loan_id} on {return_date}")
        if self.status == LoanStatus.COMPLETED:
            print("[Aggregate Logic] Loan already completed.")
            return

        # (例: 返却日が貸出期間内かどうかのチェックなどもここに追加可能)
        # if return_date < self.loan_period.start_date:
        #     raise ValueError("Return date cannot be before borrow date.")

        self.status = LoanStatus.COMPLETED
        print(f"[Aggregate Logic] Loan {self.loan_id} status changed to COMPLETED.")
        # (LoanCompleted イベントを発行しても良い)

    def is_overdue(self, current_date: date) -> bool:
        """指定日時点で延滞しているか (LoanPeriodへの委譲)"""
        # 貸出中(ACTIVE)で、かつ期日を過ぎているか
        return self.status == LoanStatus.ACTIVE and self.loan_period.is_overdue(current_date)

```

✅ **効果**:

- 貸出期間が `LoanPeriod` 値オブジェクトになったことで、期間の妥当性が保証され、関連ロジック（延滞チェックなど）がカプセル化されました。
- `status` が `LoanStatus` Enum になったことで、不正な状態を防げます。
- `complete()` メソッドが `Loan` 自身に追加されたことで、「貸出完了」に関する**ビジネスルール**（状態遷移）が `Loan` 集約内に**カプセル化**されました。`UseCase` はこのメソッドを呼び出すだけで済みます。
- 静的ファクトリメソッド `create_new` を追加し、新しい貸出オブジェクトの生成（特にデフォルト期間の設定）を単純化しました。

---

### 🧱 3. `User` 集約のリファクタリング（軽微）

📝 **課題**: 以前の `User` クラスは `name` が `str` で、空文字列などを許容する可能性がありました。

💡 **改善**: `name` 属性の型を `UserName` 値オブジェクトに変更します。

**ファイル:** `domain/aggregates.py` (`User` クラスを修正/追加)

```python
# domain/aggregates.py
# (Imports...)
from .value_objects import UserName # 👈 インポート

# (Book, Loan aggregate definitions...)

# -----------------------------------------------------------------------------
# User Aggregate Root / Entity (Refactored)
# - DDD戦術的設計の Aggregate Root / Entity
# - CAの Entities 層
# -----------------------------------------------------------------------------
@dataclass
class User:
    """
    利用者を表す集約ルート・エンティティ (リファクタリング後)。
    - user_id で識別される。
    - name は UserName 値オブジェクトで保持。
    """
    user_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    name: UserName # 👈 型を UserName 値オブジェクトに変更
    # ... 他の利用者属性 (例: email, address など) ...

    # (今回のスコープでは User に関する振る舞いは最小限)
    # def change_name(self, new_name: UserName): ...

```

✅ **効果**:

- `name` が `UserName` 値オブジェクトになったことで、`User` オブジェクトが常に空でない（かつ長すぎない）名前を持つことが保証されます。

---

## 📝 まとめ

このステップでは、Step 3 で作成した値オブジェクト (`ISBN`, `LoanPeriod`, `UserName`, `BookStatus`, `LoanStatus`) を活用して、主要なエンティティ/集約 (`Book`, `Loan`, `User`) をリファクタリングしました。

主な改善点は以下の通りです。

- **属性の型安全性の向上**: 基本型 (`str`, `bool`, `datetime`) をドメイン固有の値オブジェクトやEnumに置き換えました。
- **振る舞いのカプセル化**: 状態遷移に関するロジック（貸出/返却、貸出完了）を、それぞれのエンティティ/集約のメソッド (`borrow`, `return_book`, `complete`) として実装しました。

これにより、ドメインモデルはより**表現豊か**になり、**不変条件**が守られやすくなり、**貧血ドメインモデル**の状態から脱却しました。`UseCase` は、これらの洗練されたドメインオブジェクトを利用することで、よりシンプルかつ安全にビジネスフローを実装できるようになります。

---

## ➡️ 次へ

ドメインモデルのリファクタリングが完了しました。次は、この変更に合わせて「**(Step 5) リファクタリングの実装：リポジトリとUseCaseの調整**」に進み、永続化層とアプリケーション層を修正していきましょう。