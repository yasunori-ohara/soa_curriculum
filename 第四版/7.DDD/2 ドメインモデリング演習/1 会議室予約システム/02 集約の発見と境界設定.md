# 02 集約の発見と境界設定

# ステップ２：集約の発見と境界設定 🧱

Step 1 で洗い出したユビキタス言語（候補）をもとに、このドメインにおける**集約 (Aggregate)** を見つけ出します。集約は、データの一貫性を保つための「まとまり」であり、DDDの戦術的設計の中心です。

## 🤔 集約とは？（復習）

- 関連するエンティティと値オブジェクトの**まとまり**。
- データ変更における**一貫性**の単位。
- 外部からのアクセスは**集約ルート (Aggregate Root)** を通じてのみ行う。

**ポイント**: 「一緒に変更されるべきもの」「常に整合性が取れていないといけないもの」をグループ化し、そのグループの代表者（ルート）を決めます。

### 候補の検討

Step 1 で挙げた主な名詞候補を見てみましょう。

- **会議室 (MeetingRoom)**
- **予約 (Reservation)**
- **利用者 / 予約者 (User)**
- **予約時間帯 (TimeRange)**
- **予約可能時間帯 (BookableHours)**

これらのうち、どれが集約（特に集約ルート）になりそうでしょうか？ 集約は通常、IDを持ち、ライフサイクルを持つ**エンティティ**がルートになります。

1. **会議室 (MeetingRoom)**:
    - ID (`RoomID`) で識別される。
    - 属性（名前、収容人数、予約可能時間帯、備品リストなど）を持つ。
    - 状態（例：利用可能か、改装中か）が変わる可能性がある。
    - 他のオブジェクト（`BookableHours` や `Equipment`）を内部に含むかもしれない。
    - ➡️ **集約ルート**の有力候補です。
2. **予約 (Reservation)**:
    - ID (`ReservationID`) で識別される。
    - 属性（どの会議室を、誰が、いつ）を持つ。
    - 状態（確定、キャンセル済みなど）が変わる可能性がある。
    - ➡️ **集約ルート**の有力候補です。
3. **利用者 (User)**:
    - ID (`UserID`) で識別される。
    - 属性（名前、部署など）を持つ。
    - 会議室予約システムにおいては、予約をおこなう主体ですが、ユーザー自身の情報をこのシステムで変更することは主目的ではないかもしれません。
    - ➡️ **別のコンテキスト**（例：社員情報管理システム）の集約ルートである可能性が高いです。このシステムでは、主に **ID (`UserID`)** で参照するだけで十分かもしれません。
4. **予約時間帯 (TimeRange)**:
    - 開始日時と終了日時という「値」で定義されます。IDはありません。
    - ➡️ **値オブジェクト**の候補です。
5. **予約可能時間帯 (BookableHours)**:
    - 曜日と時間の組み合わせという「値」の集まりです。
    - ➡️ **値オブジェクト**（または `MeetingRoom` 集約内部のデータ構造）の候補です。

## 集約の決定（案）

以上の検討から、このシンプルな会議室予約システムでは、主要な集約として以下の2つが考えられます。

1. **`MeetingRoom` 集約**:
    - **ルート**: `MeetingRoom` (Entity)
    - **内部**: `BookableHours` (Value Object), `Equipment` (List of Value Objects?) などを含む可能性。
    - **責務**: 会議室自体の情報（名前、収容人数など）と、予約の可否に関する基本的なルール（予約可能時間帯）を管理する。
2. **`Reservation` 集約**:
    - **ルート**: `Reservation` (Entity)
    - **内部**: `UserID` (参照ID), `RoomID` (参照ID), `TimeRange` (Value Object) を含む。
    - **責務**: 特定の予約に関する情報（誰が、何を、いつ）と、その予約の状態（確定、キャンセルなど）、予約に関するルール（例：重複予約の禁止 *※後述*）を管理する。

```
+---------------------------+       +-------------------------------+
|   MeetingRoom Aggregate   |       |    Reservation Aggregate      |
| +-----------------------+ |       | +---------------------------+ |
| | MeetingRoom (Root)    | |       | | Reservation (Root)        | |
| | - roomId              | |       | | - reservationId           | |
| | - name                | |       | | - roomId (Ref to MR Agg)  | |
| | - capacity            | |       | | - userId (Ref to User Agg)| |
| | - bookableHours (VO)  | |       | | - timeRange (VO)          | |
| | - equipment (List<VO>)| |       | | - status                  | |
| |                       | |       | |                           | |
| | - isAvailableAt() ?   | |       | | - cancel()                | |
| +-----------------------+ |       | +---------------------------+ |
+---------------------------+       +-------------------------------+

```

## 境界と不変条件

- **`MeetingRoom` 集約**: 会議室の情報の一貫性を保ちます。例えば、「収容人数はマイナスにならない」といったルールは `MeetingRoom` が守ります。
- **`Reservation` 集約**: 予約情報の一貫性を保ちます。例えば、「予約時間帯の終了日時は開始日時より後でなければならない」というルールは `TimeRange` (VO) と `Reservation` が連携して守ります。

## 🤔 重複予約のチェックはどこ？

「ある会議室の特定の時間帯には、一つの予約しか存在できない」という重要なルール（不変条件）があります。これはどちらの集約が責任を持つべきでしょうか？

- `MeetingRoom` が全ての予約を知っている？ -\> 結合が強くなりすぎる。
- `Reservation` が他の全ての予約を知っている？ -\> 非現実的。

これは、**単一の集約だけでは保証するのが難しい不変条件**の典型例です。このような場合、以下のいずれかのアプローチを取ることが多いです。

1. **UseCase（またはDomain Service）が調整する**:
    - 予約を作成する `UseCase` が、まず `MeetingRoom` 集約（または専用の空き時間検索サービス）に「その時間帯は空いているか？」を問い合わせます。
    - 空いていれば、新しい `Reservation` 集約を作成し、リポジトリに保存します。
    - 保存時に、データベースの**一意性制約**などを利用して、最終的な重複を防ぎます。（楽観ロック/悲観ロックなども関連）
2. **より大きな集約を検討する**:
    - 例えば「会議室のスケジュール (`RoomSchedule`)」のような集約を考え、その中に予約 (`Reservation`) を含める設計も可能ですが、管理が複雑になる可能性があります。

今回は、より一般的な **アプローチ1** を想定して進めるのが良いでしょう。つまり、重複チェックは `UseCase` が関連する集約やリポジトリに問い合わせて行い、最終的な保証はデータベースレベルで行う、と考えます。

---

## 📝 まとめ

このステップでは、ユビキタス言語から主要な概念を抽出し、「**一貫性を保つべきまとまり**」として **`MeetingRoom`** と **`Reservation`** という2つの集約（とそのルートエンティティ）を特定しました。また、IDを持たない概念（`TimeRange`, `BookableHours`）は値オブジェクトの候補としました。

集約の境界を定義することで、各集約が守るべきルール（不変条件）が明確になり、モデル全体の複雑さを管理しやすくなります。

---

## ➡️ 次へ

次は、これらの集約の内部で使われる「**(Step 3) 値オブジェクトとエンティティの洗練**」に進み、`TimeRange` などを具体的に設計していきましょう。