# 03 値オブジェクトとエンティティの洗練

# ステップ３：値オブジェクトとエンティティの洗練 ✨

Step 2 で主要な集約 (`Article`, `Comment`) を特定しました。このステップでは、これらの集約内部で使われる**値オブジェクト (Value Object)** を具体的に設計し、エンティティの定義をより洗練させていきます。ドメインの概念（タイトル、本文、公開状態など）を豊かに表現することを目指します。

## 🤔 値オブジェクトとは？（復習）

- *属性（値）*だけで定義される（IDを持たない）。
- 通常は**不変 (Immutable)**。
- **自己検証**ロジックを持つことができる。

---

## 💎 1. 値オブジェクト (Value Object) の設計

Step 1 で洗い出した候補の中から、値オブジェクトとして定義するものを具体化します。

### a) `PublishStatus` (公開状態)

📝 **課題**: 記事の状態は「下書き」か「公開済み」のどちらかです。これを単なる文字列 (`"DRAFT"`, `"PUBLISHED"`) で管理すると、タイプミス（`"Draft"` や `"Publishd"`）が起きたり、想定外の状態（`"DELETED"` など）が紛れ込んだりする可能性があります。

💡 **解決策**: **Enum（列挙型）または専用の値オブジェクト**として定義します。Enum はシンプルで分かりやすく、値オブジェクトならより複雑なルール（例：状態遷移の可否）もカプセル化できます。今回はシンプルに Enum を使ってみましょう。

**ファイル:** `domain/value_objects.py` (または `domain/enums.py`)

```python
# domain/value_objects.py (または domain/enums.py)
from enum import Enum, auto

# -----------------------------------------------------------------------------
# PublishStatus Enum (Value Objectに近い使い方)
# - DDD戦術的設計の Value Object (Enum表現)
# - CAの Entities 層
# -----------------------------------------------------------------------------
class PublishStatus(Enum):
    """記事の公開状態を表す列挙型"""
    DRAFT = auto()      # 下書き状態
    PUBLISHED = auto()  # 公開済み状態

    def is_published(self) -> bool:
        """公開済みかどうかを判定するヘルパーメソッド"""
        return self == PublishStatus.PUBLISHED

```

### b) `Title` (記事タイトル)

📝 **課題**: タイトルには文字数制限（例：最大100文字）があるかもしれません。これを単なる `str` で扱うと、長すぎるタイトルが設定されてしまう可能性があります。

💡 **解決策**: `Title` 値オブジェクトを定義し、生成時に文字数制限をチェックします。

**ファイル:** `domain/value_objects.py` (追記)

```python
# domain/value_objects.py
from dataclasses import dataclass
# (Enum definition from above)

# -----------------------------------------------------------------------------
# Title Value Object
# - DDD戦術的設計の Value Object
# - CAの Entities 層
# -----------------------------------------------------------------------------
@dataclass(frozen=True)
class Title:
    """記事のタイトルを表す値オブジェクト"""
    value: str
    MAX_LENGTH = 100 # タイトルの最大文字数 (ドメインルール)

    def __post_init__(self):
        print(f"[VO Check] Validating Title: '{self.value}'")
        if not self.value:
            raise ValueError("Title cannot be empty.")
        if len(self.value) > self.MAX_LENGTH:
            raise ValueError(f"Title cannot exceed {self.MAX_LENGTH} characters.")
        print("[VO Check] Title is valid.")

```

### c) `Body` (記事本文)

📝 **課題**: 本文にも最小・最大の文字数制限があるかもしれません。

💡 **解決策**: `Body` 値オブジェクトを定義し、同様に検証ロジックを入れます。

**ファイル:** `domain/value_objects.py` (追記)

```python
# domain/value_objects.py
# (Other definitions...)

# -----------------------------------------------------------------------------
# Body Value Object
# - DDD戦術的設計の Value Object
# - CAの Entities 層
# -----------------------------------------------------------------------------
@dataclass(frozen=True)
class Body:
    """記事やコメントの本文を表す値オブジェクト"""
    value: str
    MIN_LENGTH = 1 # 本文の最小文字数 (例)

    def __post_init__(self):
        print(f"[VO Check] Validating Body (length: {len(self.value)})")
        if len(self.value) < self.MIN_LENGTH:
            raise ValueError(f"Body must be at least {self.MIN_LENGTH} character(s).")
        # (最大文字数チェックなども追加可能)
        print("[VO Check] Body is valid.")

```

### d) `CommenterName` (コメント投稿者名)

📝 **課題**: 投稿者名にも文字数制限や禁止文字などのルールがあるかもしれません。

💡 **解決策**: `CommenterName` 値オブジェクトを定義します。

**ファイル:** `domain/value_objects.py` (追記)

```python
# domain/value_objects.py
# (Other definitions...)

# -----------------------------------------------------------------------------
# CommenterName Value Object
# - DDD戦術的設計の Value Object
# - CAの Entities 層
# -----------------------------------------------------------------------------
@dataclass(frozen=True)
class CommenterName:
    """コメント投稿者名を表す値オブジェクト"""
    value: str
    MAX_LENGTH = 50

    def __post_init__(self):
        print(f"[VO Check] Validating CommenterName: '{self.value}'")
        if not self.value:
            raise ValueError("Commenter name cannot be empty.")
        if len(self.value) > self.MAX_LENGTH:
            raise ValueError(f"Commenter name cannot exceed {self.MAX_LENGTH} characters.")
        print("[VO Check] CommenterName is valid.")

```

### e) 日時 (`PublishedAt`, `PostedAt` など)

📝 **課題**: 公開日時や投稿日時もドメインの重要な概念です。

💡 **解決策**: Python 標準の `datetime` をそのまま使うことも、専用の `PublishedAt` 値オブジェクトなどを作成することも可能です。今回はシンプルに `datetime` を使いますが、特定のタイムゾーンルールなどを強制したい場合は値オブジェクト化が有効です。

---

## 🧱 2. エンティティ (`Article`, `Comment`) の洗練

作成した値オブジェクトを使って、`Article` と `Comment` 集約（エンティティ）の定義を更新します。

**ファイル:** `domain/aggregates.py` (修正)

```python
# domain/aggregates.py
from dataclasses import dataclass, field
from typing import List, Dict, Optional # List, Dict, Optional を追加
# 👈 作成した値オブジェクトとEnumをインポート
from .value_objects import Title, Body, PublishStatus, CommenterName
from datetime import datetime
import uuid
# from .events import DomainEvent # ドメインイベント用

# -----------------------------------------------------------------------------
# Article Aggregate Root / Entity
# - DDD戦術的設計の Aggregate Root / Entity
# - CAの Entities 層
# -----------------------------------------------------------------------------
@dataclass
class Article:
    """記事を表す集約ルート・エンティティ"""
    article_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    author_id: str # User集約への参照ID
    title: Title   # 👈 値オブジェクトを使用
    body: Body     # 👈 値オブジェクトを使用
    status: PublishStatus = PublishStatus.DRAFT # 👈 Enumを使用 (デフォルトは下書き)
    published_at: Optional[datetime] = None # 公開日時 (公開されるまでNone)
    created_at: datetime = field(default_factory=datetime.now)
    updated_at: datetime = field(default_factory=datetime.now)

    # _domain_events: List[DomainEvent] = field(default_factory=list, init=False, repr=False)

    def publish(self):
        """[集約の振る舞い] 記事を公開状態にする"""
        print(f"[Aggregate Logic] Attempting to publish article {self.article_id}")
        if self.status.is_published():
            print("[Aggregate Logic] Article already published.")
            return # 既に公開済みなら何もしない

        self.status = PublishStatus.PUBLISHED
        self.published_at = datetime.now() # 公開日時を設定
        self.updated_at = self.published_at
        print(f"[Aggregate Logic] Article {self.article_id} published at {self.published_at}.")
        # event = ArticlePublishedEvent(...)
        # self._domain_events.append(event)

    def change_body(self, new_body: Body):
        """[集約の振る舞い] 記事本文を変更する"""
        print(f"[Aggregate Logic] Changing body for article {self.article_id}")
        if self.status.is_published():
             # 例：公開済みの記事は本文変更時に更新日時も変更するルール
             self.updated_at = datetime.now()
        self.body = new_body # 新しいBody値オブジェクトで置き換え
        print(f"[Aggregate Logic] Body updated. New length: {len(new_body.value)}")

    def change_title(self, new_title: Title):
         """[集約の振る舞い] 記事タイトルを変更する"""
         print(f"[Aggregate Logic] Changing title for article {self.article_id}")
         # (本文と同様に更新日時を変更するルールなど)
         self.title = new_title
         print(f"[Aggregate Logic] Title updated to '{new_title.value}'")

    # --- ドメインイベント関連メソッド (参考) ---
    # def get_uncommitted_events(self) -> List[DomainEvent]: ...
    # def clear_uncommitted_events(self): ...

# -----------------------------------------------------------------------------
# Comment Aggregate Root / Entity
# - DDD戦術的設計の Aggregate Root / Entity
# - CAの Entities 層
# -----------------------------------------------------------------------------
@dataclass
class Comment:
    """コメントを表す集約ルート・エンティティ"""
    comment_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    article_id: str # Article集約への参照ID
    commenter_name: CommenterName # 👈 値オブジェクトを使用
    body: Body                  # 👈 値オブジェクトを使用
    posted_at: datetime = field(default_factory=datetime.now)
    # status: CommentStatus = CommentStatus.PENDING # 将来的な承認ステータスなど

    # _domain_events: List[DomainEvent] = field(default_factory=list, init=False, repr=False)

    # (コメントに関する振る舞い、例：編集、承認など)
    # def edit_body(self, new_body: Body): ...
    # def approve(self): ...

```

✅ **このステップのポイント**:

- `Article` と `Comment` エンティティが、`Title`, `Body`, `PublishStatus`, `CommenterName` という*意味のある型（値オブジェクト/Enum）*を持つようになりました。これにより、コードの可読性と型安全性が向上しました。
- 各エンティティは、自身の状態（例：`Article.status`）とそれに関連する振る舞い（例：`Article.publish()`）をカプセル化しています。`publish` メソッドは、ステータスを `PUBLISHED` に変更し、`published_at` を設定するというビジネスルールを実行します。

---

## 📝 まとめ

このステップでは、ドメイン内の単純に見えるデータ（タイトル、本文、状態、名前など）に対しても、**値オブジェクト**や**Enum**を導入することで、以下の利点が得られることを見ました。

- **表現力の向上**: コードがドメインの言葉を直接語るようになる。
- **不変性**: 意図しない変更を防ぎ、安全性を高める。
- **自己検証**: 不正なデータがドメインモデルに混入するのを防ぐ。
- **ロジックのカプセル化**: 関連するルールや振る舞いを一箇所に集める。

これにより、**エンティティ**はより自身の本質的な責務（同一性の管理、主要な状態遷移）に集中できるようになり、ドメインモデル全体がより堅牢で理解しやすくなります。

---

## ➡️ 次へ

次は、これらのドメインモデル（集約）を永続化するための「**(Step 4) リポジトリ、ドメインサービス等の検討**」に進みます。