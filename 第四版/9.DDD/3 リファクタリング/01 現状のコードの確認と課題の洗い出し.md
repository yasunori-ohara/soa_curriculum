# 01 現状のコードの確認と課題の洗い出し

# ステップ１：現状のコード（図書館システム）の確認と課題の洗い出し 🔍

このステップでは、第2巡で作成した（または想定した）図書館システムのコード（設計）を**DDDの視点**から見直し、改善できそうな点（課題）を洗い出します。

*(第2巡の正確なコードがないため、クリーンアーキテクチャ(CA)に基づいて一般的に考えられる構造を想定して進めます。もし具体的なコードがあれば、それに合わせて読み替えてください。)*

---

## 🤔 想定される現状の設計（CAベース）

第2巡では、おそらく以下のような要素が含まれていたと考えられます。

- **`domain/entities.py`**:
    - `Book`クラス: `book_id`, `title` (str), `author` (str), `isbn` (str), `is_borrowed` (bool) などの属性。
    - `User`クラス: `user_id`, `name` (str) などの属性。
    - `Loan`クラス（またはそれに類するもの）: `loan_id`, `book_id`, `user_id`, `borrow_date` (datetime), `due_date` (datetime) などの属性。
- **`application/boundaries.py`**:
    - `BookRepositoryInterface`: `find_by_id`, `save`, `find_all` など。
    - `UserRepositoryInterface`: `find_by_id`, `save` など。
    - `LoanRepositoryInterface`: `find_by_id`, `save`, `find_by_book_id`, `find_by_user_id` など。
- **`application/use_cases.py`**:
    - `BorrowBookUseCase`: 利用者IDと書籍IDを受け取り、書籍が貸出可能かチェックし、`Loan` を作成・保存し、`Book` の状態を更新する。
    - `ReturnBookUseCase`: 貸出ID（または書籍ID）を受け取り、`Loan` を完了状態にし、`Book` の状態を更新する。
- **`adapters/repositories.py`**:
    - `InMemory...Repository` や `Mongo...Repository` などの具体的なリポジトリ実装。

---

## 🧐 DDDの視点からの課題洗い出し

上記の想定される設計に対して、DDDの戦術的パターン（値オブジェクト、集約など）の観点から、以下のような課題や改善点が考えられます。

1. 💎**値オブジェクトの不在 (Primitive Obsession)** 💎:
    - **ISBN**: 単なる `str` として扱われている可能性が高いです。ISBNには特定の形式（桁数、チェックデジット）がありますが、その検証ロックがどこにあるか不明確（または存在しない）かもしれません。`ISBN` 値オブジェクトを導入すべきです。
    - **Title / Author**: これらも単なる `str` でしょうか？ 文字数制限やフォーマットルールがあれば、値オブジェクト化を検討できます。
    - **貸出期間 (Loan Period)**: `borrow_date` と `due_date` という2つの `datetime` で表現されていますが、「貸出期間」というドメイン概念（例：常に2週間）を表す `LoanPeriod` 値オブジェクトとしてカプセル化できるかもしれません。期間の計算や妥当性チェック（開始日 < 終了日）をそこに含めることができます。
    - **ユーザー名 (Name)**: 文字数制限などがあれば `UserName` 値オブジェクトにできます。
2. 🧱**エンティティの振る舞い不足 (Anemic Domain Model?)** 🧱:
    - `Book` エンティティは `is_borrowed` という状態を持っていますが、「貸し出す (`borrow`)」「返却する (`return_book`)」という振る舞い（メソッド）を自身で持っているでしょうか？ もし `UseCase` が `book.is_borrowed = True` のように直接状態を変更している場合、書籍の状態遷移に関するルールが `Book` エンティティの外に漏れ出しています。`Book` エンティティ自身が `borrow()` や `return_book()` メソッドを持ち、その中で状態変更を行うべきです。
    - `Loan` エンティティも同様に、自身の状態（例：`ACTIVE`, `COMPLETED`）とその遷移（例：`complete()` メソッド）を持つべきです。
3. 🧩**集約境界の曖昧さ** 🧩:
    - **貸出 (`Loan`) は誰のもの？**: `Loan` は `Book` の一部でしょうか？ `User` の一部でしょうか？ それとも独立した集約でしょうか？
        - `Book` に `List<Loan>` を持たせる？ → 特定の本の貸出履歴を見るのは良いが、本をロードするたびに全履歴を読むのは非効率。
        - `User` に `List<Loan>` を持たせる？ → 特定の利用者の貸出履歴を見るのは良いが、同様に非効率。
        - **`Loan` を独立した集約**とするのが最も自然に見えます。`Loan` は `BookID` と `UserID` を参照として持ち、自身のライフサイクル（作成、完了）を管理します。
    - **一貫性ルール**: 「貸出中の本は、再度貸し出せない」「利用者は最大N冊までしか借りられない」というルールは、どの集約が責任を持つべきでしょうか？
        - 前者は `Book` 集約が `borrow()` メソッド内で自身の状態 (`is_borrowed`) をチェックすることで保証できます。
        - 後者は `User` 集約が自身の貸出数（または貸出中の `LoanID` リスト）を管理し、`can_borrow()` のようなメソッドでチェックするのが自然かもしれません（ただし、`User` 集約を今回のスコープに入れるかどうかの判断が必要です）。あるいは、`BorrowBookUseCase` が `LoanRepository` に問い合わせて利用者の現在の貸出数をチェックし、`User` 集約に頼らない方法も考えられます（ドメインサービス的アプローチ）。
4. 💎**リポジトリの粒度**💎:
    - Step 3-3 で `Loan` を独立した集約と判断した場合、`BookRepository`, `UserRepository`, `LoanRepository` がそれぞれ対応する集約ルートを扱う形になり、これは適切です。
    - リポジトリのメソッド（例：`find_by_...`）が、永続化技術の詳細（例：MongoDBのクエリオブジェクト）を漏洩していないか確認が必要です。インターフェースは抽象的であるべきです。
5. 🧱**ユビキタス言語の確認**🧱:
    - コード内のクラス名やメソッド名（`is_borrowed`, `borrow`, `return_book`, `Loan`, `Reservation` など）が、図書館の業務で実際に使われる言葉と一致しているでしょうか？ もし齟齬があれば、リファクタリングの機会に修正します。

---

## 📝 まとめと次のステップ

現状（想定）のコードをDDDの視点で見直すと、特に**値オブジェクトの導入**と**集約（特に `Book` と `Loan`）の責務（振る舞い）の明確化**に改善の余地がありそうです。

これらの課題認識に基づき、次のステップ「**(Step 2) 改善方針の決定**」で、具体的なリファクタリング計画を立てていきましょう。