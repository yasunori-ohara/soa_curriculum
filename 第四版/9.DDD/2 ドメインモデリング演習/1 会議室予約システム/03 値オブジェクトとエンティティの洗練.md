# 03 値オブジェクトとエンティティの洗練

# ステップ３：値オブジェクトとエンティティの洗練 ✨

Step 2 で主要な集約 (`MeetingRoom`, `Reservation`) を特定しました。このステップでは、これらの集約内部で使われる**値オブジェクト (Value Object)** を具体的に設計し、エンティティの定義をより洗練させていきます。特に、「予約時間帯」のような概念を豊かに表現することを目指します。

## 🤔 値オブジェクトとは？（復習）

- *属性（値）*だけで定義される（IDを持たない）。
- 通常は**不変 (Immutable)**。
- **自己検証**ロジックを持つことができる。

---

## 💎 1. `TimeRange` 値オブジェクトの設計

📝 **課題**: 予約時間帯は「開始日時」と「終了日時」で構成されます。これらを単に2つの `datetime` オブジェクトとして `Reservation` エンティティに持たせることもできますが、「終了日時は開始日時より後でなければならない」というルールや、「時間帯の長さを計算する」「他の時間帯と重複しているかチェックする」といった関連ロジックが `Reservation` エンティティや `UseCase` に散らばる可能性があります。

💡 **解決策**: 「予約時間帯」という概念自体を `TimeRange` **値オブジェクト**として定義します。このクラスに、開始日時と終了日時の保持、ルールの検証、関連する振る舞いをカプセル化します。

**ファイル:** `domain/value_objects.py` (追記)

```python
# domain/value_objects.py
from dataclasses import dataclass
from datetime import datetime, timedelta # timedelta を追加

# (Money, AccountNumber from previous examples - remove if not needed)

# -----------------------------------------------------------------------------
# TimeRange Value Object
# - DDD戦術的設計の Value Object
# - CAの Entities 層 (ドメインの核となるルールの一部)
# -----------------------------------------------------------------------------
@dataclass(frozen=True) # 不変
class TimeRange:
    """
    予約時間帯（開始日時と終了日時）を表す値オブジェクト。
    - 不変であり、値（start_datetime, end_datetime）で定義される。
    - 生成時に時間的前後関係を検証する (自己検証)。
    - 時間帯に関するロジック（期間計算、重複チェックなど）をカプセル化する。
    """
    start_datetime: datetime
    end_datetime: datetime

    def __post_init__(self):
        """自己検証：終了は開始の後でなければならない"""
        print(f"[VO Check] Validating TimeRange: {self.start_datetime} - {self.end_datetime}")
        if self.start_datetime >= self.end_datetime:
            raise ValueError("End datetime must be after start datetime.")
        # (例: 最小予約時間、最大予約時間のチェックなどもここに追加可能)
        print("[VO Check] TimeRange is valid.")

    def get_duration(self) -> timedelta:
        """予約時間帯の長さを計算するメソッド"""
        return self.end_datetime - self.start_datetime

    def overlaps_with(self, other: 'TimeRange') -> bool:
        """
        別の時間帯と重複しているかチェックするメソッド。
        (境界値の扱い: 開始時刻は含み、終了時刻は含まないと定義する場合)
        """
        # 重複しない条件:
        # 1. 自分の終了が相手の開始以前
        # 2. 自分の開始が相手の終了以後
        # 上記以外は重複する
        return not (self.end_datetime <= other.start_datetime or \\
                    self.start_datetime >= other.end_datetime)

```

✅ **このステップのポイント**:

- `TimeRange` クラスにより、「時間帯」というドメイン概念が明確な型になりました。
- `__post_init__` で**自己検証**を行い、「終了 \> 開始」というルールを保証します。
- `get_duration` や `overlaps_with` といった、時間帯に関連する**ロジック**を値オブジェクト内にカプセル化できました。これにより、`Reservation` エンティティや `UseCase` のコードがシンプルになります。

---

## 🧱 2. エンティティ (`Reservation`) の洗練

`TimeRange` 値オブジェクトを使って、`Reservation` エンティティの定義を更新します。

**ファイル:** `domain/aggregates.py` (Reservation 部分を修正)

```python
# domain/aggregates.py
# (Imports: Money, datetime, List, Dict, uuid, field etc. are assumed)
from .value_objects import Money, TimeRange # 👈 TimeRange をインポート

# (OrderItem definition remains the same)
@dataclass
class OrderItem: # 実装省略
    pass

# (Order aggregate remains the same, if it exists in this context)
@dataclass
class Order: # 実装省略
    pass

# -----------------------------------------------------------------------------
# Reservation Aggregate Root / Entity
# - DDD戦術的設計の Aggregate Root / Entity
# - CAの Entities 層
# -----------------------------------------------------------------------------
@dataclass
class Reservation:
    """
    予約を表す集約ルート・エンティティ。
    - reservationIdで識別される。
    - 予約時間帯は TimeRange 値オブジェクトで保持する。
    """
    reservation_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    room_id: str # どの会議室か (MeetingRoom集約への参照ID)
    user_id: str # 誰が予約したか (User集約への参照ID)
    time_range: TimeRange # 👈 datetime 2つではなく、TimeRange値オブジェクトを使う
    status: str = "CONFIRMED" # 例: CONFIRMED, CANCELLED

    # _domain_events: List[DomainEvent] = field(default_factory=list, init=False, repr=False)

    def cancel(self):
        """[エンティティの振る舞い] 予約をキャンセルする"""
        print(f"[Aggregate Logic] Cancelling reservation {self.reservation_id}")
        if self.status == "CANCELLED":
            print("[Aggregate Logic] Already cancelled.")
            return
        # (例: キャンセル期限チェックなどのビジネスルールをここに追加)
        self.status = "CANCELLED"
        print("[Aggregate Logic] Reservation cancelled.")
        # event = ReservationCancelledEvent(...)
        # self._domain_events.append(event)

    def get_start_time(self) -> datetime:
        """予約開始時刻を取得する (TimeRangeへの委譲)"""
        return self.time_range.start_datetime

    def get_end_time(self) -> datetime:
        """予約終了時刻を取得する (TimeRangeへの委譲)"""
        return self.time_range.end_datetime

    # (もし予約時間変更のロジックが必要なら、新しいTimeRangeを生成して設定するメソッドを定義)
    # def reschedule(self, new_time_range: TimeRange): ...

    # --- ドメインイベント関連メソッド (参考) ---
    # def get_uncommitted_events(self) -> List[DomainEvent]: ...
    # def clear_uncommitted_events(self): ...

```

✅ **このステップのポイント**:

- `Reservation` エンティティが、`start_datetime` と `end_datetime` を直接持つ代わりに、`TimeRange` **値オブジェクト**を持つようになりました。
- これにより、`Reservation` クラス自体のコード量が減り、「予約」という概念の本質的な属性（誰が、何を、いつ）と状態（`status`）に焦点を当てられるようになりました。
- 時間帯に関するロジック（期間計算や重複チェック）が必要な場合は、`self.time_range` のメソッドを呼び出すだけで済みます（**関心の分離**）。

---

## 🧩 3. `MeetingRoom` エンティティと `BookableHours`

📝 **課題**: 会議室 (`MeetingRoom`) には、「予約可能な時間帯（例：平日9時〜18時）」という情報が必要です。これも時間帯に関するルールです。

💡 **解決策**: これも `BookableHours` という**値オブジェクト**としてモデル化することが考えられます。ただし、実装が複雑になる可能性もあるため、今回は単純化して `MeetingRoom` の属性として文字列などで保持するか、あるいはこの演習のスコープ外としても良いでしょう。ここでは、`TimeRange` を使って特定の時間帯が予約可能かをチェックするメソッドを `MeetingRoom` に持たせることを考えます。

**ファイル:** `domain/aggregates.py` (MeetingRoom 部分を追加・修正)

```python
# domain/aggregates.py
# (Other imports and classes...)
from .value_objects import TimeRange # TimeRange をインポート

# -----------------------------------------------------------------------------
# MeetingRoom Aggregate Root / Entity
# - DDD戦術的設計の Aggregate Root / Entity
# - CAの Entities 層
# -----------------------------------------------------------------------------
@dataclass
class MeetingRoom:
    """
    会議室を表す集約ルート・エンティティ。
    - roomIdで識別される。
    - 予約の可否に関する基本的なルールを持つ。
    """
    room_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    name: str
    capacity: int
    # bookable_hours: BookableHours # 👈 より洗練させるなら値オブジェクト化
    # equipment: List[EquipmentVO] # 👈 備品も値オブジェクトリストに

    def can_book(self, requested_range: TimeRange) -> bool:
        """
        指定された時間帯が、この会議室の予約可能ルールに合致するかを判断する。
        (注意: 他の予約との重複チェックはここで行わない)
        """
        print(f"[Aggregate Logic] Checking if {self.name}({self.room_id}) can be booked for {requested_range.start_datetime} - {requested_range.end_datetime}")

        # --- ここに予約可能ルールを実装 ---
        # 例1: 営業時間をチェック (bookable_hours を使う)
        # if not self.bookable_hours.includes(requested_range): return False

        # 例2: 簡単なルール（例：開始が9時以前、終了が18時以降は不可）
        if requested_range.start_datetime.hour < 9 or requested_range.end_datetime.hour > 18:
             print("[Aggregate Logic] Requested time is outside operating hours (9-18).")
             return False

        # 例3: 最小予約時間、最大予約時間のチェック
        if requested_range.get_duration() < timedelta(minutes=30):
             print("[Aggregate Logic] Booking duration is less than minimum (30 min).")
             return False

        print("[Aggregate Logic] Basic booking rules passed.")
        return True

    # ... 他の会議室に関するメソッド ...

```

✅ **このステップのポイント**:

- `MeetingRoom` エンティティが、自身の予約可能性に関するルール (`can_book`) を持つようになりました。
- このメソッドの引数として `TimeRange` 値オブジェクトを受け取ることで、`UseCase` は `datetime` 2つではなく、意味のある「時間帯」を渡すことができます。
- `BookableHours` や `Equipment` を値オブジェクトとしてさらに洗練させることで、`MeetingRoom` の責務をより明確にできます（今回は省略）。

---

## 📝 まとめ

このステップでは、ドメイン内の重要な概念である「時間帯 (`TimeRange`)」を**値オブジェクト**として抽出し、それを `Reservation` や `MeetingRoom` **エンティティ**で利用するようにモデルを洗練しました。

値オブジェクトを導入することで、

- コードの**表現力**が向上し（`TimeRange` 型）、
- **不変性**によって安全性が高まり、
- **自己検証**によって不正なデータが減り、
- 関連する**ロジック**（期間計算、重複チェック）をカプセル化して**関心を分離**することができました。

---

## ➡️ 次へ

次は、これらのドメインモデル（集約）を永続化し、利用するための「**(Step 4) リポジトリ、ドメインサービス等の検討**」に進みます。