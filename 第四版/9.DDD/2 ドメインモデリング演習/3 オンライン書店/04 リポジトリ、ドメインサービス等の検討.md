# 04 リポジトリ、ドメインサービス等の検討

# ステップ４：リポジトリ、ドメインサービス等の検討 💾⚙️

Step 3 で集約 (`Book`, `ShoppingCart`, `Order`) と値オブジェクトを洗練させました。このステップでは、これらのドメインモデルを**永続化**するための**リポジトリ (Repository)** を定義し、また、特定の集約に属さないドメインロジックを担う**ドメインサービス (Domain Service)** の必要性を検討します。

---

## 💾 1. リポジトリ (Repository) の定義と実装 - 永続化の抽象化

📝 **課題**: 作成・変更した `Book`, `ShoppingCart`, `Order` 集約を、永続化ストレージに保存したり、後で検索したりする必要があります。しかし、ドメインモデルや UseCase が、具体的な保存方法を知るべきではありません。

💡 **解決策**: 各集約ルートに対して**リポジトリ (`Repository`)** パターンを適用します。永続化操作の**インターフェース**を定義し、具体的な実装を **Adapters 層**に隠蔽します。

**ファイル:** `application/boundaries.py` (追記)

```python
# application/boundaries.py
from abc import ABC, abstractmethod
# 👈 永続化対象の集約 (各コンテキストからインポート想定)
from domain.aggregates import Book, ShoppingCart, Order
# 👈 検索で使う値オブジェクト (各コンテキストからインポート想定)
from domain.value_objects import ISBN
from typing import Optional, List # Listを追加

# (他のインターフェース定義 ...)

# -----------------------------------------------------------------------------
# Book Repository Interface (Catalog Context)
# - DDD戦術的設計の Repository Interface
# - CAの Application 層 (境界定義)
# -----------------------------------------------------------------------------
class BookRepositoryInterface(ABC):
    """Book集約(カタログ情報)の永続化を抽象化するインターフェース"""
    @abstractmethod
    def find_by_isbn(self, isbn: ISBN) -> Optional[Book]: # 👈 ISBN(VO)で検索
        """ISBNでBook集約を検索する"""
        raise NotImplementedError

    @abstractmethod
    def save(self, book: Book):
        """Book集約を保存する"""
        raise NotImplementedError

    # (必要であれば find_by_title なども追加)

# -----------------------------------------------------------------------------
# ShoppingCart Repository Interface (Cart Context)
# - DDD戦術的設計の Repository Interface
# - CAの Application 層 (境界定義)
# -----------------------------------------------------------------------------
class ShoppingCartRepositoryInterface(ABC):
    """ShoppingCart集約の永続化を抽象化するインターフェース"""
    @abstractmethod
    def find_by_customer_id(self, customer_id: str) -> Optional[ShoppingCart]:
        """顧客IDでShoppingCart集約を検索する"""
        raise NotImplementedError

    @abstractmethod
    def save(self, cart: ShoppingCart):
        """ShoppingCart集約を保存する"""
        raise NotImplementedError

    # (必要であれば delete なども追加)

# -----------------------------------------------------------------------------
# Order Repository Interface (Order Context - 演習1と同様)
# - DDD戦術的設計の Repository Interface
# - CAの Application 層 (境界定義)
# -----------------------------------------------------------------------------
class OrderRepositoryInterface(ABC):
    """Order集約の永続化を抽象化するインターフェース"""
    @abstractmethod
    def find_by_id(self, order_id: str) -> Optional[Order]:
        raise NotImplementedError

    @abstractmethod
    def save(self, order: Order):
        raise NotImplementedError

```

**ファイル:** `adapters/repositories.py` (新規作成または追記)

```python
# adapters/repositories.py
from application.boundaries import ( # 👈 インターフェースをインポート
    BookRepositoryInterface,
    ShoppingCartRepositoryInterface,
    OrderRepositoryInterface
)
from domain.aggregates import Book, ShoppingCart, Order # 👈 集約をインポート
from domain.value_objects import ISBN # 👈 値オブジェクトをインポート
from typing import Optional, List, Dict # Dictを追加
import copy

# (他のリポジトリ実装 ...)

# -----------------------------------------------------------------------------
# In-Memory Book Repository Implementation
# - DDD戦術的設計の Repository Implementation
# - CAの Adapters 層
# -----------------------------------------------------------------------------
class InMemoryBookRepository(BookRepositoryInterface):
    """Book集約をメモリ上の辞書で保持するリポジトリ実装"""
    def __init__(self):
        self._books: Dict[ISBN, Book] = {} # ISBN(VO) をキー

    def find_by_isbn(self, isbn: ISBN) -> Optional[Book]:
        print(f"[Adapter] InMemoryRepo: Finding book by ISBN {isbn.value}")
        book = self._books.get(isbn) # 値オブジェクトをキーにできる
        return copy.deepcopy(book) if book else None

    def save(self, book: Book):
        print(f"[Adapter] InMemoryRepo: Saving book {book.isbn.value} ('{book.title.value}')")
        self._books[book.isbn] = copy.deepcopy(book)

# -----------------------------------------------------------------------------
# In-Memory ShoppingCart Repository Implementation
# - DDD戦術的設計の Repository Implementation
# - CAの Adapters 層
# -----------------------------------------------------------------------------
class InMemoryCartRepository(ShoppingCartRepositoryInterface):
    """ShoppingCart集約をメモリ上の辞書で保持するリポジトリ実装"""
    def __init__(self):
        # customer_id をキーとする辞書 (カートは顧客ごとに1つと想定)
        self._carts: Dict[str, ShoppingCart] = {}

    def find_by_customer_id(self, customer_id: str) -> Optional[ShoppingCart]:
        print(f"[Adapter] InMemoryRepo: Finding cart for customer {customer_id}")
        cart = self._carts.get(customer_id)
        return copy.deepcopy(cart) if cart else None

    def save(self, cart: ShoppingCart):
        print(f"[Adapter] InMemoryRepo: Saving cart {cart.cart_id} for customer {cart.customer_id}")
        self._carts[cart.customer_id] = copy.deepcopy(cart)

# -----------------------------------------------------------------------------
# In-Memory Order Repository Implementation (演習1と同様)
# - DDD戦術的設計の Repository Implementation
# - CAの Adapters 層
# -----------------------------------------------------------------------------
class InMemoryOrderRepository(OrderRepositoryInterface):
    """Order集約をメモリ上の辞書で保持するリポジトリ実装"""
    def __init__(self):
        self._orders: Dict[str, Order] = {} # order_id をキー

    def find_by_id(self, order_id: str) -> Optional[Order]:
        print(f"[Adapter] InMemoryRepo: Finding order {order_id}")
        order = self._orders.get(order_id)
        return copy.deepcopy(order) if order else None

    def save(self, order: Order):
        print(f"[Adapter] InMemoryRepo: Saving order {order.order_id}")
        self._orders[order.order_id] = copy.deepcopy(order)

```

✅ **このステップのポイント**:

- 各集約ルート (`Book`, `ShoppingCart`, `Order`) に対して、永続化を抽象化する**リポジトリインターフェース**を定義しました。
- 具体的な実装（今回はインメモリ）を **Adapters 層**に隠蔽しました。
- リポジトリのキーや検索メソッドの引数として**値オブジェクト** (`ISBN`) を使用できることを示しました。

---

## ⚙️ 2. ドメインサービス (Domain Service) の必要性検討

📝 **課題**: このオンライン書店のコア機能（カタログ閲覧、カート追加、注文作成）において、特定の集約に属さない、ドメイン固有の重要な操作はあるでしょうか？

💡 **検討**:
現在のシンプルなシナリオでは、ドメインサービスが**必須となる場面は少ない**かもしれません。

- **カートへの商品追加**: `ShoppingCart` 集約の `add_item` メソッドで実現できます。
- **注文作成**: `OrderFactory` が `ShoppingCart` の情報（UseCase経由で渡される）と `Book` の情報（価格取得のためUseCaseが参照）を使って `Order` 集約を生成し、`Order` 集約が内部の一貫性を保ちます。

**将来的な可能性**:
もし、以下のような複雑な機能が必要になった場合、ドメインサービスの導入を検討します。

- **複雑な価格計算/割引適用**:
複数の商品、顧客ランク、キャンペーン情報などを組み合わせて最終的な価格を決定するロジックは、特定の集約に属さないかもしれません (`PricingService`)。
- **在庫引き当ての確認**:
注文作成時に、複数の `InventoryItem` 集約（在庫コンテキスト）に対して在庫引き当てが可能かを確認するプロセスは、`InventoryAllocationService` のようなドメインサービスが担うかもしれません（ただし、在庫確認は UseCase がリポジトリ経由で行うことも多いです）。
- **おすすめ商品の生成**:
顧客の購買履歴や閲覧履歴、商品の関連性などに基づいておすすめを計算するアルゴリズムは、`RecommendationService` として切り出すのが自然でしょう。

**今回の判断**:
現時点のコア機能（カート追加、注文作成）においては、`OrderFactory` を除き、明示的なドメインサービスは**不要**と判断します。ロジックは主に集約と UseCase でカバーできると考えられます。価格取得は `BookRepository` 経由で UseCase が行います。

✅ **このステップのポイント**:

- ドメインサービスは強力なパターンですが、**必要性**を慎重に検討する必要があります。
- 単純な CRUD 操作や、単一集約内で完結するロジックは、ドメインサービスではなく**リポジトリ**や**集約のメソッド**で実装すべきです。
- 複数の集約にまたがる複雑なドメインルールやプロセスが存在する場合に、ドメインサービスの導入を検討します。

---

## 📝 まとめ

このステップでは、オンライン書店の主要な集約 (`Book`, `ShoppingCart`, `Order`) に対する**リポジトリインターフェース**とその**インメモリ実装**を定義しました。これにより、UseCase は具体的な永続化方法を知ることなく、集約を保存・取得できるようになります。

また、**ドメインサービス**の必要性を検討し、現在のシンプルなスコープでは明示的なドメインサービスは不要であると判断しました。

---

## ➡️ 次へ

これでドメインモデルと永続化の準備が整いました。最後のステップ「**(Step 5) モデルの一部をコード化 (UseCaseとMain)**」に進み、これらの部品を組み合わせて「商品をカートに入れる」「カートから注文を作成する」という UseCase を実装してみましょう。