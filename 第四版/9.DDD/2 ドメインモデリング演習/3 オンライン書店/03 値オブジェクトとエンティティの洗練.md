# 03 値オブジェクトとエンティティの洗練

# ステップ３：値オブジェクトとエンティティの洗練 ✨

Step 2 で主要な集約 (`Book`, `ShoppingCart`, `Order`) を特定しました。このステップでは、これらの集約内部で使われる**値オブジェクト (Value Object)** を具体的に設計し、エンティティの定義をより洗練させていきます。ドメインの概念（価格、カート項目、注文明細など）を豊かに表現することを目指します。

## 🤔 値オブジェクトとは？（復習）

- *属性（値）*だけで定義される（IDを持たない）。
- 通常は**不変 (Immutable)**。
- **自己検証**ロジックを持つことができる。

---

## 💎 1. 値オブジェクト (Value Object) の設計

Step 1 で洗い出した候補の中から、値オブジェクトとして定義するものを具体化します。

### a) `Price` / `Money` (価格/金額)

📝 **課題**: 書籍の価格や注文の合計金額は、通貨と数値を持ちます。不正な値（マイナス）や異なる通貨間の計算を防ぐ必要があります。

💡 **解決策**: 金額を表す `Money` 値オブジェクトを定義します（演習1, 3と同様）。

**ファイル:** `domain/value_objects.py`

```python
# domain/value_objects.py
from dataclasses import dataclass

# -----------------------------------------------------------------------------
# Money Value Object
# - DDD戦術的設計の Value Object
# - CAの Entities 層
# -----------------------------------------------------------------------------
@dataclass(frozen=True)
class Money:
    """金額を表す値オブジェクト (演習1, 3 と同様)"""
    amount: int # (intにするかDecimalにするかは要件による)
    currency: str

    def __post_init__(self):
        # print(f"[VO Check] Validating Money: {self.amount} {self.currency}")
        if self.amount < 0: raise ValueError("Amount cannot be negative.")
        if len(self.currency) != 3: raise ValueError("Currency must be 3-letter code.")
        # print("[VO Check] Money is valid.")

    def add(self, other: 'Money') -> 'Money':
        if self.currency != other.currency: raise ValueError("Cannot add different currencies.")
        return Money(self.amount + other.amount, self.currency)

    # (必要であれば subtract, multiply なども実装)

```

### b) `ISBN` (書籍識別子)

📝 **課題**: ISBNは書籍を一意に識別する重要なコードですが、特定の形式（例：13桁の数字、チェックデジット）を持っています。単なる文字列(`str`)で扱うと、不正な形式のISBNが紛れ込む可能性があります。

💡 **解決策**: `ISBN` 値オブジェクトを定義し、形式検証を行います。

**ファイル:** `domain/value_objects.py` (追記)

```python
# domain/value_objects.py
# (Money definition ...)

# -----------------------------------------------------------------------------
# ISBN Value Object
# - DDD戦術的設計の Value Object
# - CAの Entities 層
# -----------------------------------------------------------------------------
@dataclass(frozen=True)
class ISBN:
    """ISBNコードを表す値オブジェクト"""
    value: str

    def __post_init__(self):
        """ISBN形式を検証 (簡易版)"""
        print(f"[VO Check] Validating ISBN: {self.value}")
        # ハイフンを除去して数字のみにする (例)
        cleaned_value = self.value.replace("-", "")
        # 長さチェック (ISBN-13を想定)
        if not (cleaned_value.isdigit() and len(cleaned_value) == 13):
            raise ValueError(f"Invalid ISBN format: {self.value}. Should be 13 digits (hyphens optional).")
        # (チェックデジットの検証もここに追加可能)
        print("[VO Check] ISBN is valid.")

    # (必要に応じてハイフン付き/なしのフォーマットメソッドなどを追加)

```

### c) `Quantity` (数量)

📝 **課題**: カートや注文の数量は、通常1以上の整数です。マイナスやゼロは通常ありえません。これを単なる `int` で扱うと、不正な値が設定される可能性があります。

💡 **解決策**: `Quantity` 値オブジェクトを定義し、1以上であることを保証します。

**ファイル:** `domain/value_objects.py` (追記)

```python
# domain/value_objects.py
# (Money, ISBN definitions ...)

# -----------------------------------------------------------------------------
# Quantity Value Object
# - DDD戦術的設計の Value Object
# - CAの Entities 層
# -----------------------------------------------------------------------------
@dataclass(frozen=True)
class Quantity:
    """数量を表す値オブジェクト"""
    value: int

    def __post_init__(self):
        print(f"[VO Check] Validating Quantity: {self.value}")
        if self.value <= 0:
            raise ValueError("Quantity must be positive.")
        print("[VO Check] Quantity is valid.")

    def add(self, other: 'Quantity') -> 'Quantity':
        """数量を加算する"""
        return Quantity(self.value + other.value)

    # (必要であれば subtract なども実装)

```

### d) `CartItem` (カート項目 - 値オブジェクトとして)

📝 **課題**: Step 2 で `CartItem` は値オブジェクトかもしれないと考えました。カート内では、同じ商品 (`ProductID`/`ISBN`) が複数回追加されるのではなく、数量が増えるのが一般的です。IDで区別する必要性は低そうです。

💡 **解決策**: `CartItem` を**値オブジェクト**として設計します。`ISBN` と `Quantity` という値オブジェクトで構成されます。

**ファイル:** `domain/value_objects.py` (追記)

```python
# domain/value_objects.py
# (Money, ISBN, Quantity definitions ...)

# -----------------------------------------------------------------------------
# CartItem Value Object
# - DDD戦術的設計の Value Object
# - CAの Entities 層 (ShoppingCart集約の内部要素)
# -----------------------------------------------------------------------------
@dataclass(frozen=True)
class CartItem:
    """カート内の項目を表す値オブジェクト"""
    isbn: ISBN # どの書籍か (ISBN値オブジェクト)
    quantity: Quantity # 何冊か (Quantity値オブジェクト)
    # (カート内での単価を持つ場合もあるが、今回はシンプルにしない)

    def change_quantity(self, new_quantity: Quantity) -> 'CartItem':
        """数量を変更した新しいCartItemを返す (不変性を維持)"""
        return CartItem(isbn=self.isbn, quantity=new_quantity)

```

---

## 🧱 2. エンティティ (`Book`, `ShoppingCart`, `Order`) の洗練

作成した値オブジェクトを使って、各集約（エンティティ）の定義を更新します。

### a) `Book` 集約 (カタログコンテキスト)

**ファイル:** `domain/aggregates.py` (または `catalog_context/domain/aggregates.py`)

```python
# domain/aggregates.py (or catalog_context/...)
from dataclasses import dataclass, field
# 👈 作成した値オブジェクトをインポート
from .value_objects import ISBN, Money, Title, Body # Title, BodyもVO化想定

# -----------------------------------------------------------------------------
# Book Aggregate Root / Entity
# - DDD戦術的設計の Aggregate Root / Entity
# - CAの Entities 層
# -----------------------------------------------------------------------------
@dataclass
class Book:
    """書籍カタログ情報を表す集約ルート・エンティティ"""
    isbn: ISBN # 👈 IDとしてISBN値オブジェクトを使用
    title: Title
    # author: AuthorVO # AuthorもVO化可能
    # publisher: PublisherVO # PublisherもVO化可能
    price: Money # 👈 金額はMoney値オブジェクト
    description: Body # 説明文もBody値オブジェクトを使う (例)
    # ... 他のカタログ情報 ...

    # カタログ情報の変更メソッドなど (例: 価格改定)
    def change_price(self, new_price: Money):
        print(f"[Aggregate Logic] Changing price for book {self.isbn.value} to {new_price.amount}")
        if new_price.currency != self.price.currency:
            raise ValueError("Cannot change currency.")
        self.price = new_price
        # (PriceChanged イベントを発行するなど)

```

### b) `ShoppingCart` 集約 (カートコンテキスト)

**ファイル:** `domain/aggregates.py` (または `cart_context/domain/aggregates.py`)

```python
# domain/aggregates.py (or cart_context/...)
# (Imports: dataclass, field, uuid, List, Dict...)
# 👈 作成した値オブジェクトをインポート
from .value_objects import ISBN, Quantity, CartItem, Money

# -----------------------------------------------------------------------------
# ShoppingCart Aggregate Root / Entity
# - DDD戦術的設計の Aggregate Root / Entity
# - CAの Entities 層
# -----------------------------------------------------------------------------
@dataclass
class ShoppingCart:
    """
    ショッピングカートを表す集約ルート・エンティティ。
    顧客IDで識別される想定 (カートは通常ユーザーに紐づく)。
    """
    cart_id: str = field(default_factory=lambda: str(uuid.uuid4())) # カート自体のIDを持つ場合
    customer_id: str
    # カート項目を ISBN をキーにした辞書で保持 (同じISBNはまとめる)
    items: Dict[ISBN, CartItem] = field(default_factory=dict) # 👈 CartItem(VO)を使用

    def add_item(self, isbn: ISBN, quantity: Quantity):
        """[集約の振る舞い] 商品をカートに追加、または数量を増やす"""
        print(f"[Aggregate Logic] Adding/Updating item {isbn.value} (qty: {quantity.value}) to cart {self.cart_id}")
        if isbn in self.items:
            # 既にカートにあれば数量を加算
            current_item = self.items[isbn]
            new_quantity = current_item.quantity.add(quantity)
            self.items[isbn] = current_item.change_quantity(new_quantity)
            print(f"[Aggregate Logic] Quantity updated for {isbn.value} to {new_quantity.value}")
        else:
            # なければ新しい項目として追加
            self.items[isbn] = CartItem(isbn=isbn, quantity=quantity)
            print(f"[Aggregate Logic] Item {isbn.value} added.")
        # (カートの合計金額を更新するロジックなどもここに追加可能)

    def remove_item(self, isbn: ISBN):
        """[集約の振る舞い] 商品をカートから削除する"""
        print(f"[Aggregate Logic] Removing item {isbn.value} from cart {self.cart_id}")
        if isbn in self.items:
            del self.items[isbn]
            print(f"[Aggregate Logic] Item {isbn.value} removed.")
        else:
            print(f"[Aggregate Logic] Item {isbn.value} not found in cart.")
            # raise ValueError("Item not found") # エラーにする場合

    def change_item_quantity(self, isbn: ISBN, new_quantity: Quantity):
        """[集約の振る舞い] カート内の商品の数量を変更する"""
        print(f"[Aggregate Logic] Changing quantity for item {isbn.value} to {new_quantity.value} in cart {self.cart_id}")
        if isbn not in self.items:
            raise ValueError(f"Item {isbn.value} not found in cart.")

        current_item = self.items[isbn]
        self.items[isbn] = current_item.change_quantity(new_quantity)
        print(f"[Aggregate Logic] Quantity changed successfully.")

```

### c) `Order` 集約 (注文コンテキスト)

**ファイル:** `domain/aggregates.py` (または `order_context/domain/aggregates.py`)

```python
# domain/aggregates.py (or order_context/...)
# (Imports: dataclass, field, uuid, List, Dict, Optional, datetime...)
# 👈 作成した値オブジェクトをインポート
from .value_objects import Money, ISBN, Quantity
# from .events import DomainEvent, OrderPlacedEvent # (OrderPlacedEventも定義想定)

@dataclass
class OrderItem: # 注文明細はエンティティ (Order内で識別)
    item_id: str # ローカルID
    isbn: ISBN     # 👈 ISBN値オブジェクトを使用
    quantity: Quantity # 👈 Quantity値オブジェクトを使用
    unit_price: Money  # 👈 Money値オブジェクトを使用 (注文確定時の価格)

    def calculate_item_total(self) -> Money:
        # 値オブジェクトの属性とメソッドを使って計算
        return Money(self.unit_price.amount * self.quantity.value, self.unit_price.currency)

# -----------------------------------------------------------------------------
# Order Aggregate Root / Entity
# - DDD戦術的設計の Aggregate Root / Entity
# - CAの Entities 層
# -----------------------------------------------------------------------------
@dataclass
class Order:
    """注文を表す集約ルート・エンティティ"""
    order_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    customer_id: str
    items: Dict[str, OrderItem] = field(default_factory=dict) # item_id -> OrderItem
    total_price: Money = field(init=False) # 👈 Money値オブジェクト
    status: str = "PENDING" # (OrderStatus Enum/VO 化も検討)
    order_date: datetime = field(default_factory=datetime.now)
    # shipping_address: AddressVO # 住所もVO化
    # payment_info: PaymentVO # 支払い情報もVO化

    # _domain_events: List[DomainEvent] = field(default_factory=list, init=False, repr=False)

    def __post_init__(self):
        self._recalculate_total() # 生成時に合計計算

    # (add_item は Factory で呼ばれる想定)
    def _add_internal_item(self, item: OrderItem): # 内部用追加メソッド
        if item.item_id in self.items:
             raise ValueError(f"Duplicate item ID: {item.item_id}")
        self.items[item.item_id] = item
        self._recalculate_total()

    def _recalculate_total(self):
        """合計金額を再計算"""
        if not self.items:
             # 通貨不明時は0円とする (最初のアイテムで決まる想定)
             self.total_price = Money(0, "JPY") # 仮通貨
             return

        currency = next(iter(self.items.values())).unit_price.currency
        total = Money(0, currency)
        for item in self.items.values():
            if item.unit_price.currency != currency:
                 raise ValueError("Cannot mix currencies in a single order.")
            total = total.add(item.calculate_item_total())
        self.total_price = total
        print(f"[Aggregate Logic] Order {self.order_id} total recalculated: {total.amount} {total.currency}")

    def confirm(self):
         """注文を確定する"""
         if self.status != "PENDING": raise ValueError("Order is not pending.")
         if not self.items: raise ValueError("Order cannot be empty.")
         self.status = "CONFIRMED"
         print(f"[Aggregate Logic] Order {self.order_id} confirmed.")
         # event = OrderPlacedEvent(...)
         # self._domain_events.append(event)

    # --- ドメインイベント関連メソッド (参考) ---
    # def get_uncommitted_events(self) -> List[DomainEvent]: ...
    # def clear_uncommitted_events(self): ...

```

✅ **このステップのポイント**:

- 各集約 (`Book`, `ShoppingCart`, `Order`) が、内部で適切な**値オブジェクト** (`ISBN`, `Money`, `Quantity`, `CartItem`) を利用するように修正しました。
- これにより、エンティティクラスは自身の主要な責務（同一性の管理、状態遷移）に集中しやすくなり、コードの可読性と安全性が向上しました。
- 例えば `ShoppingCart.add_item` は `ISBN` と `Quantity` を受け取り、`Order` は `Money` を `total_price` として持つことで、型レベルでドメインの概念が表現されています。

---

## 📝 まとめ

このステップでは、オンライン書店のドメインにおける様々な概念（価格、ISBN、数量、カート項目）を**値オブジェクト**として具体的に設計し、それらを使って\*\*エンティティ（集約）\*\*の定義を洗練させました。

値オブジェクトを積極的に導入することで、

- コードの**表現力**と**型安全性**を高め、
- **不変性**と**自己検証**によってバグを減らし、
- エンティティの責務をより明確にする
効果が得られます。

---

## ➡️ 次へ

次は、これらのドメインモデル（集約）を永続化するための「**(Step 4) リポジトリ、ドメインサービス等の検討**」に進みます。