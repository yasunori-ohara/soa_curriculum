# 02 集約の発見と境界設定

# ステップ２：集約の発見と境界設定 🧱

Step 1 でユビキタス言語（候補）を洗い出し、ドメインを「カタログ」「在庫」「注文」「カート」「顧客管理」といった**境界づけられたコンテキスト**に分割するヒントを得ました。

このステップでは、これらのコンテキスト（特に今回のコア機能である「カタログ閲覧」「カート管理」「注文作成」に関連するもの）の中で、中心となる**集約 (Aggregate)** とその**集約ルート (Aggregate Root)** を見つけ出します。

## 🤔 集約とは？（復習）

- 関連するエンティティと値オブジェクトの**まとまり**。
- データ変更における**一貫性**の単位。
- 外部からのアクセスは**集約ルート (Aggregate Root)** を通じてのみ行う。

**ポイント**: 各コンテキスト内で、「一緒に変更され、一貫性が保たれるべき」モノのグループを探します。

---

## コンテキストごとの候補検討

### 1. カタログコンテキスト 📚

- **主な関心事**: 書籍情報の提供（検索、詳細表示）。
- **ユビキタス言語**: 書籍 (Book), ISBN, タイトル, 著者, 出版社, 定価, 説明文など。
- **集約候補**:
    - **`Book` 集約**:
        - **ルート**: `Book` (Entity)。識別子は `ISBN` が自然でしょう。
        - **内部**: `Title` (VO), `Author` (VO or Entity?), `Publisher` (VO?), `Price` (VO), `Description` (VO) など。
        - **責務**: 特定の書籍に関するカタログ情報（不変に近い情報）の一貫性を保つ。
    - *在庫数 (`StockLevel`)* は、このコンテキストの `Book` に含めるべきでしょうか？ Step 1 で検討したように、「在庫」は別の関心事（在庫コンテキスト）である可能性が高いです。カタログは「どんな本があるか」を示し、在庫は「その本が今何冊あるか」を示す、という分離です。

### 2. カートコンテキスト 🛒

- **主な関心事**: 顧客が購入予定の商品を一時的に保持する。
- **ユビキタス言語**: カート (ShoppingCart), カート項目 (CartItem), 顧客ID (CustomerID), 書籍ID (ISBN/ProductID), 数量 (Quantity)。
- **集約候補**:
    - **`ShoppingCart` 集約**:
        - **ルート**: `ShoppingCart` (Entity)。識別子は `CustomerID` が自然かもしれません（通常、顧客一人につきカートは一つ）。
        - **内部**: `CartItem` (Entity or VO?) のリスト。`CartItem` は `ProductID` と `Quantity` (VO) を持つ。
        - **責務**: 特定の顧客のカート内の商品リストと数量の一貫性を保つ。カート内での合計金額計算などもここに含まれるかもしれません。
    - `CartItem` はエンティティでしょうか？ カート内で識別する必要はあまりなく、`ProductID` と `Quantity` という**属性**で定義されるため、**値オブジェクト**として扱う方がシンプルな場合が多いです。ただし、カート内で特定の項目に割引を適用するなど、項目ごとに状態を持つ場合はエンティティになる可能性もあります。今回は値オブジェクト（または単純なデータ構造）として考えましょう。

### 3. 注文コンテキスト 📦

- **主な関心事**: 顧客の購入要求を記録し、処理する。
- **ユビキタス言語**: 注文 (Order), 注文明細 (OrderItem), 注文ID, 顧客ID, 注文日時, 合計金額, ステータスなど。
- **集約候補**:
    - **`Order` 集約**:
        - **ルート**: `Order` (Entity)。識別子は `OrderID`。
        - **内部**: `OrderItem` (Entity), `CustomerID` (Ref), `ShippingAddress` (VO), `PaymentInfo` (VO?), `TotalPrice` (VO), `Status` (VO/Enum) など。
        - **責務**: 特定の注文に関する全ての情報（誰が、何を、いつ、どこへ、いくらで）と状態（`Status`）の一貫性を保つ。注文合計金額の計算、ステータス遷移のルールなどを管理する。
    - `OrderItem` は `Order` 内で識別する必要がある（例：「明細番号1の商品の数量を変更する」）ため、**内部エンティティ**として扱うのが適切です。

---

## 集約の決定（案）

以上の検討から、コア機能に必要な主要な集約として以下を定義します。

1. **`Book` 集約 (カタログコンテキスト)**:
    - **ルート**: `Book` (ISBN で識別)
    - **責務**: 書籍のカタログ情報管理。
2. **`ShoppingCart` 集約 (カートコンテキスト)**:
    - **ルート**: `ShoppingCart` (CustomerID で識別)
    - **責務**: 顧客のカート内情報管理。
3. **`Order` 集約 (注文コンテキスト)**:
    - **ルート**: `Order` (OrderID で識別)
    - **責務**: 注文情報とその状態管理。

| **コンテキスト** | **主要な集約 (ルート)** | **主な責務 / 内部要素** |
| --- | --- | --- |
| **📚 カタログ** | `Book` (ISBNで識別) | 書籍のカタログ情報（タイトル(VO?), 価格(VO)など）の管理 |
| **🛒 カート** | `ShoppingCart` (CustomerIDで識別) | 顧客のカート内情報（商品リスト(VO?), 数量(VO?)など）の管理、`addItem()` など |
| **📦 注文** | `Order` (OrderIDで識別) | 注文情報（明細(Entity), 合計金額(VO), Statusなど）とその状態管理、`confirm()` など |
| **👤 (顧客管理)** | `Customer` (CustomerIDで識別) | (今回のスコープ外だが) 顧客のマスター情報管理 |
| **🏭 (在庫管理)** | `InventoryItem` (ISBN/SKUで識別) | (今回のスコープ外だが) 商品の在庫数管理 |

---

### 境界と不変条件（例）

- **`Book` 集約**: ISBN は必須、定価はマイナス不可。
- **`ShoppingCart` 集約**: カート項目 (`CartItem`) の数量は1以上。
- **`Order` 集約**: 注文明細 (`OrderItem`) は最低1つ必要。注文合計金額は常に明細合計と一致。`Status` は定義された遷移ルールに従う。

---

## 📝 まとめ

このステップでは、オンライン書店のドメインを「カタログ」「カート」「注文」といった**境界づけられたコンテキスト**に（暗黙的に）分割し、それぞれのコンテキストの中心となる**集約** (`Book`, `ShoppingCart`, `Order`) を特定しました。

特に「書籍」のように、コンテキストによって関心事が異なる概念を、無理に一つのモデルに押し込めず、コンテキストごとに独立した集約として定義する、というDDDの重要な考え方を確認しました。

---

## ➡️ 次へ

次は、これらの集約の内部で使われる「**(Step 3) 値オブジェクトとエンティティの洗練**」に進み、`Price`, `CartItem`, `OrderItem` などを具体的に設計していきましょう。