# 8. ファクトリ

# 🏛️ 戦術的設計：ファクトリ

DDD（ドメイン駆動設計）の戦術的設計において、「**ファクトリ (Factory)**」は、**複雑なオブジェクト、特に集約 (Aggregate) の生成**に関する責務をカプセル化するためのパターンです。

---

## ❓ ファクトリとは？

> オブジェクト（特にエンティティや集約）の生成プロセスをカプセル化し、生成ロジックの複雑さをクライアント（利用側）から隠蔽するもの。
> 

### 💡 簡単に言うと

オブジェクトを作るための「**専門の工場**」や「**組み立て係**」のようなものです。特に、部品が多くて組み立てが複雑なモノ（集約）を作る場合に、その組み立て手順（生成ロジック）を全部知っている専門家にお任せするイメージです。クライアントは工場に「こういう注文票（パラメータ）で製品を作って」と依頼するだけです。

### 🤔 なぜ重要か？

オブジェクト、特に不変条件（Invariants）を持つ集約の生成が複雑になると、その生成ロジックがクライアントコード（例：UseCase）のあちこちに散らばる可能性があります。

1. **生成ロジックのカプセル化**:
オブジェクトを生成するために必要な知識（例：どの属性が必須か、デフォルト値は何か、関連オブジェクトをどうやって作成・設定するか、生成直後に満たすべき不変条件は何か）をファクトリに集約します。
2. **クライアントコードの単純化**:
`UseCase` などのクライアントは、複雑な生成手順を知る必要がなくなり、「ファクトリに必要な情報を渡して、完成品（オブジェクト）を受け取る」だけで済みます。コードがシンプルになり、本来のビジネスフローに集中できます。
3. **不変条件の保証**:
集約の生成時に満たすべき不変条件（例：「注文を作成する際は、必ず1つ以上の注文明細が必要」）を、ファクトリ内で確実にチェック・保証することができます。不正な状態のオブジェクトが生成されるのを防ぎます。
4. **インターフェースによる抽象化**:
（より高度な使い方として）ファクトリ自体をインターフェースとして定義し、その実装をDI（依存性の注入）で切り替えることで、オブジェクトの生成方法（例：テスト用のダミーオブジェクト生成、設定に基づく異なる種類のオブジェクト生成）を柔軟に変更することも可能になります（Abstract Factory パターン）。

---

## ✅ これまでの実践例（どこで使ったか）

私たちのプロジェクトでは、オブジェクト生成が比較的単純だったため、明示的なファクトリクラスを作成する場面はほとんどありませんでした。多くの場合、Pythonのクラスの**コンストラクタ (`__init__`)** が、暗黙的にシンプルなファクトリの役割を果たしていました。

### 📌 クラスのコンストラクタ (`__init__`) (第1巡〜第5巡)

- **具体例**: `WorldModel`, `ParkingPlan`, `ControlCommand`, `VehicleState` などのクラスを `WorldModel(...)` のように直接インスタンス化していました。
- **実践**: これらのクラスの生成は単純（主にデータクラス）だったので、コンストラクタがファクトリとして十分機能していました。コンストラクタ内でデフォルト値を設定したり、簡単な初期化処理を行ったりすることは、ファクトリの責務の一部（オブジェクトを正しく初期化する）を実行していると言えます。
もし、`ParkingPlan` を生成する際に、常に特定の初期コマンド（例：`steer=0.0`）を追加する必要がある、といったルールがあれば、そのロジックをコンストラクタや、後述する静的ファクトリメソッドにカプセル化するのが適切です。

### 📌 (参考) 値オブジェクトのコンストラクタ/ファクトリメソッド

- **具体例**: 値オブジェクトのアンチパターン改善例で、`EmailAddress` や `ZipCode` クラスの `__init__` (または `__post_init__`) に検証ロジックを入れました。
- **実践**: これは、不正な値を持つオブジェクトの「生成を防ぐ」という、ファクトリが担う重要な責務（不変条件の保証）をコンストラクタで実現した例です。より複雑な検証や、複数の方法でオブジェクトを生成したい場合は、コンストラクタの代わりに**静的ファクトリメソッド (Static Factory Method)** を使うこともあります。
    
    ```python
    @dataclass(frozen=True)
    class EmailAddress:
        value: str
    
        # コンストラクタはプライベートにするか、単純にする
        # def __init__(self, value): self.value = value
    
        # 静的ファクトリメソッドで生成と検証を行う
        @staticmethod
        def create(email_string: str) -> 'EmailAddress':
            if "@" not in email_string:
                raise ValueError("Invalid email format")
            return EmailAddress(email_string)
    
    # 利用側
    # email = EmailAddress("user@example.com") # 直接コンストラクタを呼ぶ代わりに
    email = EmailAddress.create("user@example.com") # ファクトリメソッドを呼ぶ
    
    ```
    

---

## ❌ 間違った適用例（アンチパターン）

ファクトリパターンを適用すべき場面で適用しない、あるいは誤用すると、コードの保守性や可読性が低下します。

- **例1：複雑な生成ロジックがクライアントに散らばる**
    
    ```python
    # アンチパターン：生成ロジックの漏洩
    
    # UseCase内
    class CreateOrderUseCase:
        def handle(self, customer_id, item_data_list):
            # 注文オブジェクトの生成ロジックがUseCase内に散らばっている
            order_id = generate_order_id()
            order = Order(order_id)
            order.customer_id = customer_id
            order.order_date = datetime.now()
            order.status = "PENDING" # 初期ステータス設定
    
            total_price = 0
            for item_data in item_data_list:
                # 注文明細の生成ロジックもここにある
                order_item = OrderItem(
                    item_id=generate_item_id(),
                    product_id=item_data['product_id'],
                    quantity=item_data['quantity'],
                    unit_price=get_product_price(item_data['product_id']) # 外部依存も
                )
                order.items.append(order_item)
                total_price += order_item.unit_price * order_item.quantity
    
            order.total_price = total_price # 合計金額設定
    
            # 不変条件のチェックもここ？ (例: アイテムが1つ以上あるか？)
            if not order.items:
                 raise ValueError("Order must have at least one item.")
    
            order_repository.save(order)
            # ...
    
    ```
    
    注文(`Order`)と注文明細(`OrderItem`)を生成するための一連の手順（ID生成、初期値設定、価格取得、合計計算、不変条件チェック）が、`UseCase` の中に直接書かれています。このロジックは他の `UseCase` でも必要になるかもしれず、重複の原因になります。また、`UseCase` が本来のビジネスフロー以外の「オブジェクト生成」という詳細に関心を持ちすぎています。
    
    **改善策**: `OrderFactory` を作成し、生成ロジックをそこにカプセル化する。
    
    ```python
    # 改善例：OrderFactoryの導入
    class OrderFactory:
        def create_new_order(self, customer_id, item_data_list) -> Order:
            # --- 生成ロジックをここに集約 ---
            order_id = generate_order_id()
            order = Order(order_id, customer_id) # コンストラクタは最小限に
    
            if not item_data_list: # 不変条件チェック
                raise ValueError("Order must have at least one item.")
    
            for item_data in item_data_list:
                price = get_product_price(item_data['product_id'])
                # OrderItemの生成も内部で行う (OrderItemFactoryを使うことも)
                order.add_item( # Orderのメソッド経由で追加 (集約のルール)
                    product_id=item_data['product_id'],
                    quantity=item_data['quantity'],
                    unit_price=price
                )
            # 合計金額計算などは Order Entity の責務かもしれない
            # order.recalculate_total_price()
    
            return order
    
    # UseCase内 (シンプルになる)
    class CreateOrderUseCase:
         def __init__(self, order_factory: OrderFactory, ...): # DIでFactoryを受け取る
             self._order_factory = order_factory
             ...
    
         def handle(self, customer_id, item_data_list):
             # 生成はFactoryに任せる
             new_order = self._order_factory.create_new_order(customer_id, item_data_list)
    
             order_repository.save(new_order)
             # ...
    
    ```
    
- **例2：単純なオブジェクト生成にまでファクトリを使いすぎる**
ファクトリは複雑さをカプセル化するためのパターンです。単に `MyClass()` とコンストラクタを呼ぶだけで済むような単純なオブジェクト生成に対してまで、わざわざ `MyClassFactory` を作るのは過剰設計 (Over-engineering) になる可能性があります。

---

## 📝 まとめ

ファクトリは、DDDの戦術的設計において、「**複雑なオブジェクト（特に集約）の生成ロジックをカプセル化し、クライアントコードを単純化し、オブジェクトが常に正当な状態（不変条件を満たす）で生成されることを保証する**」ためのパターンです。

- オブジェクトの**生成手順**が複雑な場合。
- オブジェクト生成時に**不変条件**を満たす必要がある場合。
- 生成するオブジェクトの**具体的な型**をクライアントから隠蔽したい場合（Abstract Factory）。

これらの場合にファクトリの導入を検討します。単純なオブジェクト生成は、コンストラクタや静的ファクトリメソッドで十分な場合が多いです。

---

## ➡️ 次へ

戦術的設計のビルディングブロックの解説はこれで一区切りです。
次は、これらの要素（Entity, Value Object, Aggregate, Repository, Domain Event, Domain Service, Factory）が、**一つの境界づけられたコンテキスト内でどのように連携してドメインモデルを形成するか**、全体像を整理してみましょう。