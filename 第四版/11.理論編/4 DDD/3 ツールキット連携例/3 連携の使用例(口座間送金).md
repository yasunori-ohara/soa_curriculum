# 3. 連携の使用例（口座間送金）

# 🏛️ ドメイン駆動設計：連携の使用例（口座間送金）

## 🎯 シナリオ

ある銀行口座から別の銀行口座へ、指定した金額を送金するシナリオを考えます。送金元口座の残高が不足している場合は、送金は失敗します。

---

## 🧱 ビルディングブロックの定義

### 1. 値オブジェクト (Value Object)

まず、金額を表す `Money` 値オブジェクトを定義します（前の例と同じ）。口座番号を表す `AccountNumber` も値オブジェクトとして定義します。

```python
# domain/value_objects.py
from dataclasses import dataclass

@dataclass(frozen=True)
class Money:
    amount: int
    currency: str

    def __post_init__(self):
        if self.amount < 0:
            raise ValueError("Amount cannot be negative.")
        if len(self.currency) != 3:
            raise ValueError("Currency must be 3-letter code.")

    def add(self, other: 'Money') -> 'Money':
        if self.currency != other.currency:
            raise ValueError("Cannot add different currencies.")
        return Money(self.amount + other.amount, self.currency)

    def subtract(self, other: 'Money') -> 'Money':
        if self.currency != other.currency:
            raise ValueError("Cannot subtract different currencies.")
        if self.amount < other.amount:
            raise ValueError("Insufficient funds for subtraction.")
        return Money(self.amount - other.amount, self.currency)

    # Comparison methods
    def __lt__(self, other: 'Money'):
        if self.currency != other.currency: raise TypeError("Cannot compare different currencies")
        return self.amount < other.amount
    # ... (add __le__, __gt__, __ge__ if needed)

@dataclass(frozen=True)
class AccountNumber:
    value: str
    # (Potentially add format validation in __post_init__)

```

### 2. エンティティ (Entity) / 集約 (Aggregate)

次に、「銀行口座」を表す集約を定義します。「口座 (`Account`)」が集約ルートです。

```python
# domain/aggregates.py
from dataclasses import dataclass, field
from .value_objects import Money, AccountNumber
import uuid

# -----------------------------------------------------------------------------
# Account Aggregate Root
# - クラス図の位置: Entities (Aggregate Root)
# - 同心円図の位置: Entities (最も内側)
# -----------------------------------------------------------------------------
@dataclass
class Account: # 集約ルート (グローバルIDで識別)
    account_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    account_number: AccountNumber # 口座番号 (VO)
    balance: Money # 残高 (VO)
    # ... other account attributes like owner_id, status etc.

    def withdraw(self, amount: Money):
        """[ビジネスルール] 口座から引き出す (残高チェック含む)"""
        if self.balance < amount:
            raise ValueError(f"Insufficient funds in account {self.account_number.value}.")

        self.balance = self.balance.subtract(amount)
        print(f"[Domain] Withdrew {amount.amount}{amount.currency} from {self.account_number.value}. New balance: {self.balance.amount}")
        # ここで FundsWithdrawn ドメインイベントを発行しても良い

    def deposit(self, amount: Money):
        """[ビジネスルール] 口座に入金する"""
        self.balance = self.balance.add(amount)
        print(f"[Domain] Deposited {amount.amount}{amount.currency} to {self.account_number.value}. New balance: {self.balance.amount}")
        # ここで FundsDeposited ドメインイベントを発行しても良い

```

- **集約ルート**: `Account` クラスが集約ルートです。`account_id` で識別されます。
- **値オブジェクトの利用**: 口座番号 (`AccountNumber`) と残高 (`Money`) は値オブジェクトとして保持されます。`Money` 値オブジェクトの `add` や `subtract` メソッド（不変条件チェック含む）を利用して残高操作を行います。
- **振る舞い**: 引き出し (`withdraw`) と入金 (`deposit`) は `Account` エンティティの責務です。残高不足チェックも `withdraw` メソッド内で行われます。

### 3\. リポジトリ (Repository)

口座集約を永続化するためのインターフェースと、インメモリ実装を定義します。口座番号でも検索できるようにします。

```python
# application/boundaries.py
from abc import ABC, abstractmethod
from domain.aggregates import Account
from domain.value_objects import AccountNumber # 検索で使う
from typing import Optional

class AccountRepositoryInterface(ABC):
    @abstractmethod
    def find_by_id(self, account_id: str) -> Optional[Account]:
        raise NotImplementedError

    @abstractmethod
    def find_by_number(self, account_number: AccountNumber) -> Optional[Account]:
        raise NotImplementedError

    @abstractmethod
    def save(self, account: Account):
        raise NotImplementedError

# adapters/repositories.py
class InMemoryAccountRepository(AccountRepositoryInterface):
    def __init__(self):
        self._accounts: Dict[str, Account] = {} # account_idをキーに

    def find_by_id(self, account_id: str) -> Optional[Account]:
        print(f"[Adapter] InMemoryRepo: Finding account by ID {account_id}")
        return self._accounts.get(account_id)

    def find_by_number(self, account_number: AccountNumber) -> Optional[Account]:
        print(f"[Adapter] InMemoryRepo: Finding account by Number {account_number.value}")
        for acc in self._accounts.values():
            if acc.account_number == account_number:
                return acc
        return None

    def save(self, account: Account):
        print(f"[Adapter] InMemoryRepo: Saving account {account.account_id} ({account.account_number.value})")
        self._accounts[account.account_id] = account

```

### 4. ドメインサービス (Domain Service)

口座間送金は、**2つの `Account` 集約**にまたがる操作です。送金元(`from_account`)から引き出し、送金先(`to_account`)に入金するという一連のプロセスは、どちらか一方の `Account` エンティティの責務とするのは不自然です。このような場合に**ドメインサービス**が役立ちます。

```python
# domain/services.py
from .aggregates import Account
from .value_objects import Money

class TransferService:
    """口座間送金プロセスを担当するドメインサービス (ステートレス)"""

    def transfer(self, from_account: Account, to_account: Account, amount: Money):
        """
        指定された金額を送金元口座から送金先口座へ移動する。
        (注意: このメソッド自体は永続化を行わない。永続化はUseCaseの責務)
        """
        print(f"[Domain Service] Attempting to transfer {amount.amount}{amount.currency} from {from_account.account_number.value} to {to_account.account_number.value}")

        # 1. 送金元から引き出し (残高チェックはwithdrawメソッド内)
        #    ここで失敗する可能性 (ValueError)
        from_account.withdraw(amount)

        # 2. 送金先に入金
        #    (通常、入金は失敗しない想定)
        to_account.deposit(amount)

        print(f"[Domain Service] Transfer logic completed successfully in memory.")
        # ここで FundsTransferred ドメインイベントを発行しても良い

```

- **ドメインサービス**: `TransferService` は状態を持たず（ステートレス）、送金というドメイン固有のプロセスを実行します。
- **集約との連携**: ドメインサービスは、操作対象となる集約（`from_account`, `to_account`）を受け取り、それらのメソッド（`withdraw`, `deposit`）を呼び出してドメインロジックを実行します。
- **永続化は責務外**: ドメインサービスは、**永続化（リポジトリの呼び出し）は行いません**。永続化は、トランザクション管理の責任を持つ `UseCase` が行います。

---

## ⚙️ 連携の例：UseCase

これらのビルディングブロックを使って、「口座間送金を行う」UseCase を実装します。

```python
# application/use_cases.py
from application.boundaries import AccountRepositoryInterface
from domain.services import TransferService
from domain.value_objects import AccountNumber, Money

class TransferFundsUseCase:
    def __init__(self,
                 account_repository: AccountRepositoryInterface,
                 transfer_service: TransferService): # ドメインサービスもDIで受け取る
        self._account_repository = account_repository
        self._transfer_service = transfer_service

    def handle(self, from_account_number_str: str, to_account_number_str: str, amount_int: int, currency_str: str):

        # 1. 入力から値オブジェクトを生成
        try:
            from_acc_num = AccountNumber(from_account_number_str)
            to_acc_num = AccountNumber(to_account_number_str)
            amount_to_transfer = Money(amount_int, currency_str)
        except ValueError as e:
            print(f"[UseCase] Invalid input: {e}")
            raise

        # --- トランザクション開始 (概念) ---
        # (実際のDBトランザクション管理はリポジトリ実装やUnit of Workパターンで行う)
        print("[UseCase] --- Transaction Start (Conceptual) ---")
        try:
            # 2. リポジトリを使って必要な集約を取得
            from_account = self._account_repository.find_by_number(from_acc_num)
            to_account = self._account_repository.find_by_number(to_acc_num)

            if not from_account: raise ValueError(f"Source account {from_acc_num.value} not found.")
            if not to_account: raise ValueError(f"Destination account {to_acc_num.value} not found.")
            if from_account.account_id == to_account.account_id:
                raise ValueError("Cannot transfer to the same account.")

            # 3. ドメインサービスに処理を委譲
            #    (ドメインサービス内で withdraw/deposit が実行される)
            self._transfer_service.transfer(from_account, to_account, amount_to_transfer)

            # 4. 変更された両方の集約をリポジトリを使って保存
            #    (これがアトミックに行われる必要がある)
            self._account_repository.save(from_account)
            self._account_repository.save(to_account)

            print("[UseCase] --- Transaction Commit (Conceptual) ---")

        except Exception as e:
            # --- トランザクションロールバック (概念) ---
            print(f"[UseCase] Error during transfer: {e}")
            print("[UseCase] --- Transaction Rollback (Conceptual) ---")
            raise # エラーを上位に伝える

```

- **UseCase**: リポジトリから必要な `Account` 集約を2つ取得し、`TransferService` ドメインサービスに送金処理を委譲し、最後に変更された両方の `Account` 集約をリポジトリに保存します。
- **トランザクション管理**: UseCase は、一連の処理（取得→ドメインサービス実行→保存）が**アトミック**に行われるように管理する責任を持ちます（今回は概念的なコメントのみ）。実際のトランザクション管理は、リポジトリの実装や、Unit of Work パターンなどで行われます。

---

## 🚀 実行のイメージ ([main.py](http://main.py/))

```python
# main.py (簡易版)
from adapters.repositories import InMemoryAccountRepository
from domain.services import TransferService
from application.use_cases import TransferFundsUseCase
from domain.aggregates import Account # 初期データ作成用
from domain.value_objects import AccountNumber, Money # 初期データ作成用

# --- DIコンテナ部分 ---
account_repository = InMemoryAccountRepository()
transfer_service = TransferService() # ステートレスなのでそのままインスタンス化
transfer_funds_use_case = TransferFundsUseCase(account_repository, transfer_service)

# --- 初期データ投入 ---
acc_num1 = AccountNumber("123-456")
acc_num2 = AccountNumber("789-012")
account1 = Account(account_number=acc_num1, balance=Money(10000, "JPY"))
account2 = Account(account_number=acc_num2, balance=Money(5000, "JPY"))
account_repository.save(account1)
account_repository.save(account2)
print("Initial balances:")
print(f"- {acc_num1.value}: {account1.balance.amount}")
print(f"- {acc_num2.value}: {account2.balance.amount}")

# --- UseCaseの実行 (成功例) ---
try:
    print("\\nTransferring 3000 JPY...")
    transfer_funds_use_case.handle(
        from_account_number_str="123-456",
        to_account_number_str="789-012",
        amount_int=3000,
        currency_str="JPY"
    )
except Exception as e: print(f"Transfer failed: {e}")

# --- UseCaseの実行 (失敗例: 残高不足) ---
try:
    print("\\nTransferring 10000 JPY (Insufficient funds)...")
    transfer_funds_use_case.handle(
        from_account_number_str="123-456", # 残高は7000のはず
        to_account_number_str="789-012",
        amount_int=10000,
        currency_str="JPY"
    )
except Exception as e: print(f"Transfer failed as expected: {e}")

# --- 結果の確認 ---
print("\\nFinal balances:")
final_acc1 = account_repository.find_by_number(acc_num1)
final_acc2 = account_repository.find_by_number(acc_num2)
if final_acc1: print(f"- {acc_num1.value}: {final_acc1.balance.amount}") # -> 7000
if final_acc2: print(f"- {acc_num2.value}: {final_acc2.balance.amount}") # -> 8000

```

---

## 📝 まとめ

この例では、

- **集約 (`Account`)**: 口座という単位で残高の一貫性を保ち、`withdraw`/`deposit` という振る舞いをカプセル化しました。
- **値オブジェクト (`Money`, `AccountNumber`)**: 金額や口座番号を明確な型として定義し、ルール（マイナス不可など）を保証しました。
- **ドメインサービス (`TransferService`)**: 2つの集約にまたがる「送金」というドメインプロセスを実装しました。
- **リポジトリ (`AccountRepository`)**: 口座集約の永続化を抽象化しました。
- **UseCase (`TransferFundsUseCase`)**: ドメインサービスとリポジトリを利用してビジネスフローを実現し、トランザクション（概念）を管理しました。

特に、複数の集約が関わる操作において、**ドメインサービス**がロジックをドメイン層に留めるための有効な手段であることがわかります。