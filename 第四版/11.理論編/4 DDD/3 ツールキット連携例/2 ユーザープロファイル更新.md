# 2. ユーザープロファイル更新

# 🏛️ 連携の使用例（ユーザープロファイル更新）

## 🎯 シナリオ

ユーザーが自身のメールアドレスを変更するシンプルなシナリオを考えます。メールアドレスには特定の形式（`@`が含まれるなど）が必要です。

---

## 🧱 ビルディングブロックの定義

### 1. 値オブジェクト (Value Object)

まず、メールアドレスを表す不変の `EmailAddress` 値オブジェクトを定義します。形式の検証もここで行います。

```python
# domain/value_objects.py
from dataclasses import dataclass
import re # Regular expression for basic email format check

@dataclass(frozen=True) # 不変にする
class EmailAddress:
    value: str

    def __post_init__(self):
        # Basic email format check (adjust regex as needed)
        if not re.match(r"[^@]+@[^@]+\\.[^@]+", self.value):
            raise ValueError("Invalid email format.")

```

- **値オブジェクト**: `EmailAddress` は属性(`value`)で定義され、不変です。
- **自己検証**: `__post_init__` で生成時に形式をチェックし、不正なメールアドレスのオブジェクトが作られるのを防ぎます。

### 2. エンティティ (Entity) / 集約 (Aggregate)

次に、「ユーザー」を表すエンティティを定義します。今回はシンプルにするため、「ユーザー」自体が集約ルートであると考えます。

```python
# domain/aggregates.py
from dataclasses import dataclass, field
from .value_objects import EmailAddress # 値オブジェクトをインポート
import uuid

# -----------------------------------------------------------------------------
# User Aggregate Root
# - クラス図の位置: Entities (Aggregate Root)
# - 同心円図の位置: Entities (最も内側)
# -----------------------------------------------------------------------------
@dataclass
class User: # 集約ルート (グローバルIDで識別)
    user_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    name: str
    email: EmailAddress # Emailは値オブジェクトとして保持
    # ... other user attributes

    def change_email(self, new_email: EmailAddress):
        """[ビジネスルール] メールアドレスを変更する"""
        # (例: 変更履歴の記録や、変更通知イベントの発行などもここに追加可能)
        if self.email == new_email:
            print("[Domain] New email is the same as the current one.")
            return # 同じ場合は何もしない

        self.email = new_email
        print(f"[Domain] User {self.user_id} email changed to {new_email.value}")
        # ここで UserEmailChanged ドメインイベントを発行しても良い

```

- **集約ルート**: `User` クラスが集約ルートです。`user_id` で識別されます。
- **値オブジェクトの利用**: メールアドレスは単なる文字列(`str`)ではなく、`EmailAddress` 値オブジェクトとして保持します。これにより、`User` オブジェクトが常に有効な形式のメールアドレスを持つことが保証されます。
- **振る舞い**: メールアドレスの変更は `change_email()` メソッドを通じて行われます。このメソッド内で、変更に関するビジネスルール（例: 同じアドレスへの変更は無視）をカプセル化できます。

### 3. リポジトリ (Repository)

ユーザー集約を永続化するためのインターフェースと、インメモリ実装を定義します。

```python
# application/boundaries.py
from abc import ABC, abstractmethod
from domain.aggregates import User
from typing import Optional

class UserRepositoryInterface(ABC):
    @abstractmethod
    def find_by_id(self, user_id: str) -> Optional[User]:
        raise NotImplementedError

    @abstractmethod
    def find_by_email(self, email: 'EmailAddress') -> Optional[User]: # EmailAddressで検索
        raise NotImplementedError

    @abstractmethod
    def save(self, user: User):
        raise NotImplementedError

# adapters/repositories.py
from domain.value_objects import EmailAddress # インポート

class InMemoryUserRepository(UserRepositoryInterface):
    def __init__(self):
        self._users: Dict[str, User] = {}

    def find_by_id(self, user_id: str) -> Optional[User]:
        print(f"[Adapter] InMemoryRepo: Finding user {user_id}")
        return self._users.get(user_id)

    def find_by_email(self, email: EmailAddress) -> Optional[User]:
        print(f"[Adapter] InMemoryRepo: Finding user by email {email.value}")
        for user in self._users.values():
            if user.email == email:
                return user
        return None

    def save(self, user: User):
        print(f"[Adapter] InMemoryRepo: Saving user {user.user_id}")
        self._users[user.user_id] = user

```

- **リポジトリ**: `UserRepositoryInterface` が永続化操作を抽象化し、`InMemoryUserRepository` が具体的な実装を提供します。`find_by_email` のように、値オブジェクトを使って検索するメソッドも定義できます。

---

## ⚙️ 連携の例：UseCase

これらのビルディングブロックを使って、「ユーザーのメールアドレスを変更する」UseCase を実装します。

```python
# application/use_cases.py
from application.boundaries import UserRepositoryInterface
from domain.value_objects import EmailAddress # UseCaseも値オブジェクトを使う

class ChangeUserEmailUseCase:
    def __init__(self, user_repository: UserRepositoryInterface):
        self._user_repository = user_repository

    def handle(self, user_id: str, new_email_str: str):
        # 1. 入力文字列から値オブジェクトを生成 (ここで不正な形式はエラーになる)
        try:
            new_email = EmailAddress(new_email_str)
        except ValueError as e:
            print(f"[UseCase] Invalid email format: {e}")
            raise # エラーを呼び出し元に伝える

        # 2. リポジトリを使って集約を取得
        user = self._user_repository.find_by_id(user_id)
        if not user:
            print(f"[UseCase] User {user_id} not found.")
            raise ValueError(f"User {user_id} not found.") # 例外を発生

        # (発展: 重複チェック - ドメインサービスに切り出すことも可能)
        existing_user = self._user_repository.find_by_email(new_email)
        if existing_user and existing_user.user_id != user_id:
            print(f"[UseCase] Email {new_email.value} is already in use.")
            raise ValueError(f"Email {new_email.value} is already in use.")

        # 3. 集約ルートのメソッドを呼び出してビジネスロジックを実行
        user.change_email(new_email)

        # 4. リポジトリを使って変更された集約を保存
        self._user_repository.save(user)

        print(f"[UseCase] User {user_id} email successfully changed.")

```

- **UseCase**: リポジトリから `User` 集約を取得し、`User` の `change_email()` メソッドを呼び出し、結果をリポジトリに保存します。
- **値オブジェクトの活用**: UseCase は入力として文字列を受け取りますが、それをまず `EmailAddress` 値オブジェクトに変換します。これにより、UseCase は常に有効な形式のメールアドレスを扱うことができます。また、メールアドレスの重複チェックも `EmailAddress` オブジェクトを使って行えます。

---

## 🚀 実行のイメージ ([main.py](http://main.py/))

```python
# main.py (簡易版)
from adapters.repositories import InMemoryUserRepository
from application.use_cases import ChangeUserEmailUseCase
from domain.aggregates import User # 初期データ作成用
from domain.value_objects import EmailAddress # 初期データ作成用

# --- DIコンテナ部分 ---
user_repository = InMemoryUserRepository()
change_email_use_case = ChangeUserEmailUseCase(user_repository)

# --- 初期データ投入 ---
initial_email = EmailAddress("initial@example.com")
user = User(name="Test User", email=initial_email)
user_repository.save(user)
user_id = user.user_id
print(f"Initial user created with ID: {user_id}, Email: {initial_email.value}")

# --- UseCaseの実行 ---
try:
    new_email_str = "new.email@example.com"
    change_email_use_case.handle(user_id, new_email_str)
except ValueError as e:
    print(f"Error: {e}")

# --- 結果の確認 ---
updated_user = user_repository.find_by_id(user_id)
if updated_user:
    print(f"Updated Email: {updated_user.email.value}")
    # -> Updated Email: new.email@example.com

# --- 不正なメールアドレスで試す ---
try:
    change_email_use_case.handle(user_id, "invalid-email")
except ValueError as e:
    print(f"Error caught: {e}")
    # -> Error caught: Invalid email format.

```

---

## 📝 まとめ

この例では、

- **値オブジェクト (`EmailAddress`)**: メールアドレスという概念を型として定義し、形式の検証をカプセル化しました。
- **エンティティ (`User`)**: ユーザーという同一性を持つオブジェクトを定義し、メールアドレス変更 (`change_email`) という振る舞いをカプセル化しました。`EmailAddress` 値オブジェクトを利用することで、常に有効なメールアドレスを持つことを保証しました。
- **リポジトリ (`UserRepository`)**: ユーザーエンティティの永続化を抽象化し、UseCase を具体的な保存方法から隔離しました。

単純なプロファイル更新のシナリオでも、これらのビルディングブロックを組み合わせることで、ドメインのルール（メールアドレス形式）がコード全体で一貫して守られ、変更に強くテストしやすい設計になることがわかります。