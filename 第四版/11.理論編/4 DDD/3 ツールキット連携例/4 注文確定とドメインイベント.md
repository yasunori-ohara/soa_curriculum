# 4. 注文確定とドメインイベント

# 🏛️ 連携の使用例（注文確定とドメインイベント）

## 🎯 シナリオ

顧客の注文（Order）を「確定（Confirm）」するシナリオを考えます。注文が確定されたら、副作用として「顧客への通知」と「在庫の引き当て」が行われる必要がありますが、注文集約自体はこれらの副作用について直接関知しないようにします。

---

## 🧱 ビルディングブロックの定義

### 1. 値オブジェクト (Value Object) と エンティティ (Entity) / 集約 (Aggregate)

前の「シンプルな注文」例の `Money`, `OrderItem`, `Order` を再利用しますが、`Order` にドメインイベントを発行する機能を追加します。

```python
# domain/value_objects.py
from dataclasses import dataclass
# (Money definition is the same as the previous example)
@dataclass(frozen=True)
class Money:
    amount: int
    currency: str
    # ... (methods like __post_init__, add, subtract)

# domain/events.py (New file for domain events)
from dataclasses import dataclass
from datetime import datetime

@dataclass(frozen=True) # イベントは不変
class DomainEvent:
    """ドメインイベントの基底クラス (マーカー)"""
    occurred_on: datetime = field(default_factory=datetime.now)

@dataclass(frozen=True)
class OrderConfirmedEvent(DomainEvent):
    """注文が確定されたことを示すドメインイベント"""
    order_id: str
    customer_id: str
    # (イベントに必要な最小限のデータを含める)

# domain/aggregates.py
from dataclasses import dataclass, field
from typing import List, Dict, Optional
from .value_objects import Money
from .events import DomainEvent, OrderConfirmedEvent # 👈 イベントをインポート
import uuid

@dataclass
class OrderItem: # (Same as previous example)
    item_id: str
    product_id: str
    quantity: int
    unit_price: Money
    # ...

@dataclass
class Order: # 集約ルート
    order_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    customer_id: str
    items: Dict[str, OrderItem] = field(default_factory=dict)
    total_price: Money = field(init=False)
    status: str = "PENDING"

    # 👈 ドメインイベントを一時的に保持するリスト
    _domain_events: List[DomainEvent] = field(default_factory=list, init=False, repr=False)

    def __post_init__(self):
        self._recalculate_total()

    # ... (add_item, change_item_quantity, _recalculate_total methods are same) ...
    def add_item(self, product_id: str, quantity: int, unit_price: Money): # (実装は省略)
        pass
    def _recalculate_total(self): # (実装は省略)
        pass

    def confirm_order(self):
        """[ビジネスルール] 注文を確定し、ドメインイベントを発行する"""
        if self.status != "PENDING":
            raise ValueError("Order is not pending.")
        if not self.items:
            raise ValueError("Order cannot be empty.")

        self.status = "CONFIRMED"
        print(f"[Domain] Order {self.order_id} confirmed.")

        # 👈 ドメインイベントを作成してリストに追加
        event = OrderConfirmedEvent(order_id=self.order_id, customer_id=self.customer_id)
        self._domain_events.append(event)

    def get_uncommitted_events(self) -> List[DomainEvent]:
        """発生したが未コミット（未ディスパッチ）のイベントを取得"""
        return self._domain_events[:] # コピーを返す

    def clear_uncommitted_events(self):
        """未コミットのイベントリストをクリア"""
        self._domain_events.clear()

```

- **ドメインイベント**: `OrderConfirmedEvent` を定義しました。これは注文が確定したという「事実」を表す不変のオブジェクトです。
- **イベントの発行**: `Order` 集約の `confirm_order` メソッド内で、ステータスを変更した後、`OrderConfirmedEvent` を生成し、内部の `_domain_events` リストに追加します。集約はイベントを「発生させる」だけで、それがどう使われるかは知りません。
- **イベントの取得/クリア**: UseCase（または後述のディスパッチャ）が、発生したイベントを取得 (`get_uncommitted_events`) し、処理後にクリア (`clear_uncommitted_events`) するためのメソッドを用意します。

### 2. リポジトリ (Repository)

`OrderRepositoryInterface` と `InMemoryOrderRepository` は前の例と同じです。

```python
# application/boundaries.py
# (OrderRepositoryInterface definition is the same)
from abc import ABC, abstractmethod
from domain.aggregates import Order
from typing import Optional

class OrderRepositoryInterface(ABC):
    @abstractmethod
    def find_by_id(self, order_id: str) -> Optional[Order]: raise NotImplementedError
    @abstractmethod
    def save(self, order: Order): raise NotImplementedError

# adapters/repositories.py
# (InMemoryOrderRepository definition is the same)
class InMemoryOrderRepository(OrderRepositoryInterface):
    # ... (implementation) ...
    def find_by_id(self, order_id: str) -> Optional[Order]: # 実装省略
        pass
    def save(self, order: Order): # 実装省略
        pass

```

### 3. イベントハンドラ（副作用の実行者）

ドメインイベント (`OrderConfirmedEvent`) を受け取って、具体的な副作用（通知、在庫引き当てなど）を実行するコンポーネントを定義します。これらは通常、ドメイン層ではなく、**アプリケーション層**や**インフラストラクチャ層**に属します。

```python
# application/event_handlers.py (または infrastructure/)

from domain.events import OrderConfirmedEvent

class NotificationEventHandler:
    """注文確定通知を送るイベントハンドラ"""
    def handle(self, event: OrderConfirmedEvent):
        # (実際にはメール送信サービスなどを呼び出す)
        print(f"[EventHandler] Sending confirmation email for order {event.order_id} to customer {event.customer_id}")

class InventoryEventHandler:
    """在庫を引き当てるイベントハンドラ"""
    def handle(self, event: OrderConfirmedEvent):
        # (実際には在庫サービスやリポジトリを呼び出す)
        print(f"[EventHandler] Allocating inventory for order {event.order_id}")

# --- イベントディスパッチャ (簡易版) ---
# (実際にはもっと洗練された仕組みを使うことが多い)
class SimpleEventDispatcher:
    def __init__(self):
        self._handlers = {
            OrderConfirmedEvent: [NotificationEventHandler(), InventoryEventHandler()]
        }

    def dispatch(self, events: List[DomainEvent]):
        print(f"[Dispatcher] Dispatching {len(events)} event(s)...")
        for event in events:
            event_type = type(event)
            if event_type in self._handlers:
                for handler in self._handlers[event_type]:
                    try:
                        # ここでハンドラを実行 (同期的に)
                        handler.handle(event)
                    except Exception as e:
                        print(f"[Dispatcher] Error handling {event_type.__name__}: {e}")

```

- **イベントハンドラ**: `NotificationEventHandler` と `InventoryEventHandler` は、`OrderConfirmedEvent` を受け取り、それぞれの関心事（通知、在庫）に関する処理を実行します。これらは `Order` 集約について直接知る必要はありません。
- **イベントディスパッチャ**: 集約から取得したイベントを受け取り、適切なハンドラに渡す役割を担います（今回はシンプルな実装）。

---

## ⚙️ 連携の例：UseCase

これらのビルディングブロックを使って、「注文を確定する」UseCase を実装します。

```python
# application/use_cases.py
from application.boundaries import OrderRepositoryInterface
from application.event_handlers import SimpleEventDispatcher # ディスパッチャをインポート

class ConfirmOrderUseCase:
    def __init__(self,
                 order_repository: OrderRepositoryInterface,
                 event_dispatcher: SimpleEventDispatcher): # 👈 DIで受け取る
        self._order_repository = order_repository
        self._event_dispatcher = event_dispatcher

    def handle(self, order_id: str):
        # --- トランザクション開始 (概念) ---
        print("[UseCase] --- Transaction Start (Conceptual) ---")
        try:
            # 1. リポジトリを使って集約を取得
            order = self._order_repository.find_by_id(order_id)
            if not order:
                raise ValueError(f"Order {order_id} not found.")

            # 2. 集約ルートのメソッドを呼び出してビジネスロジックを実行
            #    (この中でドメインイベントが _domain_events に追加される)
            order.confirm_order()

            # 3. 発生したドメインイベントを集約から取得
            events = order.get_uncommitted_events()

            # 4. 変更された集約をリポジトリを使って保存
            #    (DBへの保存が成功したらイベントをディスパッチする流れが一般的)
            self._order_repository.save(order)

            # 5. 集約内のイベントリストをクリア (永続化後)
            order.clear_uncommitted_events()

            print("[UseCase] --- Transaction Commit (Conceptual) ---")

            # --- トランザクション外 (または別トランザクション) ---
            # 6. 取得したイベントをディスパッチャに渡して副作用を実行
            self._event_dispatcher.dispatch(events)

        except Exception as e:
            # --- トランザクションロールバック (概念) ---
            print(f"[UseCase] Error confirming order: {e}")
            print("[UseCase] --- Transaction Rollback (Conceptual) ---")
            # (ロールバックした場合、イベントはディスパッチされない)
            raise

```

- **UseCase**: リポジトリから `Order` 集約を取得し、`confirm_order()` メソッドを呼び出します。その後、集約から発生したイベントを取得し、集約を保存します。保存が成功した後（＝トランザクションコミット後）、取得したイベントを**イベントディスパッチャ**に渡して副作用（通知、在庫引き当て）の実行を依頼します。
- **疎結合**: `ConfirmOrderUseCase` や `Order` 集約は、通知や在庫引き当ての具体的な処理について一切関知しません。`SimpleEventDispatcher` と `EventHandler` がその責務を担います。

---

## 🚀 実行のイメージ ([main.py](http://main.py/))

```python
# main.py (簡易版)
# (前の例の import に加えて以下を追加)
from application.use_cases import ConfirmOrderUseCase
from application.event_handlers import SimpleEventDispatcher
from domain.factories import OrderFactory # 初期データ作成用

# --- DIコンテナ部分 (前の例に追加) ---
order_factory = OrderFactory() # from previous example
order_repository = InMemoryOrderRepository() # from previous example
event_dispatcher = SimpleEventDispatcher() # ディスパッチャを生成
confirm_order_use_case = ConfirmOrderUseCase(order_repository, event_dispatcher) # UseCase生成

# --- 初期データ投入 (前の例と同様に注文を作成) ---
items = [{'product_id': 'prod-001', 'quantity': 1, 'unit_price': 1500, 'currency': 'JPY'}]
customer_id = "cust-456"
# (※ CreateOrderUseCase を使って注文を作成する方がより実践的)
initial_order = order_factory.create_new_order(customer_id, items)
order_repository.save(initial_order)
order_id = initial_order.order_id
print(f"Order {order_id} created with status: {initial_order.status}") # -> PENDING

# --- UseCaseの実行 ---
try:
    print(f"\\nConfirming order {order_id}...")
    confirm_order_use_case.handle(order_id)
except Exception as e:
    print(f"Confirmation failed: {e}")

# --- 結果の確認 ---
confirmed_order = order_repository.find_by_id(order_id)
if confirmed_order:
    print(f"Order Status after confirm: {confirmed_order.status}") # -> CONFIRMED

```

- **実行ログ**: `main.py` を実行すると、UseCase のログに加えて、イベントディスパッチャとイベントハンドラのログが出力されるはずです。
    
    ```
    ...
    [Domain] Order <order_id> confirmed.
    [Adapter] InMemoryRepo: Saving order <order_id>
    [UseCase] --- Transaction Commit (Conceptual) ---
    [Dispatcher] Dispatching 1 event(s)...
    [EventHandler] Sending confirmation email for order <order_id> to customer cust-456
    [EventHandler] Allocating inventory for order <order_id>
    Order Status after confirm: CONFIRMED
    
    ```
    

---

## 📝 まとめ

この例では、

- **ドメインイベント (`OrderConfirmedEvent`)**: 注文確定というドメイン内の出来事をモデル化しました。
- **集約 (`Order`)**: 状態変更時にドメインイベントを発行しました。
- **イベントハンドラ (`NotificationEventHandler` etc.)**: ドメインイベントを購読し、副作用（通知、在庫引き当て）を実行しました。
- **UseCase (`ConfirmOrderUseCase`)**: 集約のメソッドを呼び出し、発生したイベントを（永続化後に）ディスパッチャに渡す役割を担いました。

ドメインイベントを使うことで、**集約 (`Order`) が副作用（通知、在庫）について知る必要がなくなり**、関心が明確に分離され、**疎結合**な設計が実現できました。これにより、通知方法の変更や、新しい副作用（例：ポイント付与）の追加が、`Order` 集約や `ConfirmOrderUseCase` に影響を与えることなく行えるようになります。