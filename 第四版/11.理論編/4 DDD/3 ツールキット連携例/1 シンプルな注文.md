# 1. シンプルな注文

# 🏛️ 連携の使用例１（シンプルな注文）

## 🎯 シナリオ

顧客が商品をカートに入れ、注文を作成するシンプルなシナリオを考えます。

---

## 🧱 ビルディングブロックの定義

### 1. 値オブジェクト (Value Object)

まず、金額を表す不変の `Money` 値オブジェクトを定義します。

```python
# domain/value_objects.py
from dataclasses import dataclass

@dataclass(frozen=True) # 不変にする
class Money:
    amount: int
    currency: str

    def __post_init__(self):
        if self.amount < 0:
            raise ValueError("Amount cannot be negative.")
        if len(self.currency) != 3:
            raise ValueError("Currency must be 3-letter code.")

    def add(self, other: 'Money') -> 'Money':
        if self.currency != other.currency:
            raise ValueError("Cannot add different currencies.")
        return Money(self.amount + other.amount, self.currency)

```

### 2. エンティティ (Entity) と 集約 (Aggregate)

次に、「注文」集約を定義します。「注文 (`Order`)」が集約ルートとなり、「注文明細 (`OrderItem`)」を内部エンティティとして含みます。

```python
# domain/aggregates.py
from dataclasses import dataclass, field
from typing import List, Dict
from .value_objects import Money # 値オブジェクトをインポート
import uuid

@dataclass
class OrderItem: # 集約内部のエンティティ (ローカルIDで識別)
    item_id: str # (ここでは単純な文字列ID)
    product_id: str
    quantity: int
    unit_price: Money

    def calculate_item_total(self) -> Money:
        return Money(self.unit_price.amount * self.quantity, self.unit_price.currency)

# -----------------------------------------------------------------------------
# Order Aggregate Root
# - クラス図の位置: Entities (Aggregate Root)
# - 同心円図の位置: Entities (最も内側)
# -----------------------------------------------------------------------------
@dataclass
class Order: # 集約ルート (グローバルIDで識別)
    order_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    customer_id: str
    items: Dict[str, OrderItem] = field(default_factory=dict) # item_idをキーに
    total_price: Money = field(init=False) # 計算結果を保持
    status: str = "PENDING"

    def __post_init__(self):
        self._recalculate_total() # 生成時に合計を計算

    def add_item(self, product_id: str, quantity: int, unit_price: Money):
        """[ビジネスルール] 注文明細を追加し、合計を更新する"""
        if quantity <= 0:
            raise ValueError("Quantity must be positive.")
        # (在庫チェックなどはDomain ServiceやUseCaseで行う想定)

        item_id = f"item_{len(self.items) + 1}" # 簡易的なローカルID生成
        new_item = OrderItem(item_id, product_id, quantity, unit_price)
        self.items[item_id] = new_item
        self._recalculate_total() # 不変条件（合計金額）を維持

    def change_item_quantity(self, item_id: str, new_quantity: int):
        """[ビジネスルール] 数量を変更し、合計を更新する"""
        if new_quantity <= 0:
            raise ValueError("Quantity must be positive.")
        if item_id not in self.items:
            raise ValueError("Item not found in order.")

        self.items[item_id].quantity = new_quantity
        self._recalculate_total()

    def _recalculate_total(self):
        """[内部ロジック] 合計金額を再計算する"""
        if not self.items:
             # 通貨が不明な場合は0円とする (最初のアイテム追加時に決まる)
            self.total_price = Money(0, "JPY") # 仮のデフォルト通貨
            return

        # 最初のアイテムの通貨を基準とする
        currency = next(iter(self.items.values())).unit_price.currency
        total = Money(0, currency)
        for item in self.items.values():
            total = total.add(item.calculate_item_total())
        self.total_price = total

    def confirm_order(self):
        """[ビジネスルール] 注文を確定する"""
        if self.status != "PENDING":
            raise ValueError("Order is not pending.")
        if not self.items:
            raise ValueError("Order cannot be empty.")
        self.status = "CONFIRMED"
        # ここで OrderConfirmed ドメインイベントを発行しても良い

```

- **集約ルート**: `Order` クラスが集約ルートです。`order_id` で識別されます。
- **内部エンティティ**: `OrderItem` クラスが集約内部のエンティティです。`item_id`（ローカルID）で識別されます。
- **値オブジェクト**: `Money` が使われています。`OrderItem` の `quantity` も値オブジェクトと見なせます。
- **不変条件**: `total_price` は常に `items` の合計と一致するという不変条件が、`add_item`, `change_item_quantity`, `_recalculate_total` によって維持されます。
- **カプセル化**: 注文明細 (`items`) への変更は、`add_item`, `change_item_quantity` という集約ルートのメソッドを通じてのみ行われます。

### 3. ファクトリ (Factory)

注文の生成が少し複雑（顧客IDと最初のアイテムリストが必要）なので、ファクトリを作成します。

```python
# domain/factories.py
from .aggregates import Order, OrderItem
from .value_objects import Money
from typing import List, Dict

class OrderFactory:
    def create_new_order(self, customer_id: str, item_data_list: List[Dict]) -> Order:
        """新しい注文集約を生成する"""
        if not item_data_list:
            raise ValueError("Order must have at least one item.")

        # 集約ルートの生成 (IDはコンストラクタ内で生成される)
        order = Order(customer_id=customer_id)

        # 最初のアイテムリストを集約に追加
        for item_data in item_data_list:
            # Money値オブジェクトの生成もここで行う
            unit_price = Money(amount=item_data['unit_price'], currency=item_data['currency'])
            # Orderのメソッド経由でItemを追加 (不変条件を維持)
            order.add_item(
                product_id=item_data['product_id'],
                quantity=item_data['quantity'],
                unit_price=unit_price
            )

        # ファクトリが生成時に満たすべき状態を保証する
        # (例: Orderの__post_init__で合計計算済み)
        return order

```

### 4. リポジトリ (Repository)

注文集約を永続化するためのインターフェースと、インメモリ実装を定義します。

```python
# application/boundaries.py
from abc import ABC, abstractmethod
from domain.aggregates import Order
from typing import Optional

class OrderRepositoryInterface(ABC):
    @abstractmethod
    def find_by_id(self, order_id: str) -> Optional[Order]:
        raise NotImplementedError

    @abstractmethod
    def save(self, order: Order):
        raise NotImplementedError

# adapters/repositories.py
class InMemoryOrderRepository(OrderRepositoryInterface):
    def __init__(self):
        self._orders: Dict[str, Order] = {}

    def find_by_id(self, order_id: str) -> Optional[Order]:
        print(f"[Adapter] InMemoryRepo: Finding order {order_id}")
        return self._orders.get(order_id)

    def save(self, order: Order):
        print(f"[Adapter] InMemoryRepo: Saving order {order.order_id}")
        self._orders[order.order_id] = order # 辞書に保存/上書き

```

---

## ⚙️ 連携の例：UseCase

これらのビルディングブロックを使って、「注文を作成する」UseCase を実装します。

```python
# application/use_cases.py
from application.boundaries import OrderRepositoryInterface
from domain.factories import OrderFactory
from typing import List, Dict

class CreateOrderUseCase:
    def __init__(self,
                 order_factory: OrderFactory,
                 order_repository: OrderRepositoryInterface):
        self._order_factory = order_factory
        self._order_repository = order_repository

    def handle(self, customer_id: str, item_data_list: List[Dict]) -> str:
        # 1. ファクトリを使って集約を生成
        #    (複雑な生成ロジックと不変条件チェックはFactory内)
        new_order = self._order_factory.create_new_order(customer_id, item_data_list)

        # (ここで new_order に対する追加の操作やドメインイベント発行も可能)
        # new_order.confirm_order()

        # 2. リポジトリを使って集約を保存
        self._order_repository.save(new_order)

        print(f"[UseCase] New order created: {new_order.order_id}")
        return new_order.order_id # 生成された注文IDを返す

```

---

## 🚀 実行のイメージ ([main.py](http://main.py/))

```python
# main.py (簡易版)
from domain.factories import OrderFactory
from adapters.repositories import InMemoryOrderRepository
from application.use_cases import CreateOrderUseCase

# --- DIコンテナ部分 ---
order_factory = OrderFactory()
order_repository = InMemoryOrderRepository()
create_order_use_case = CreateOrderUseCase(order_factory, order_repository)

# --- UseCaseの実行 ---
items = [
    {'product_id': 'prod-001', 'quantity': 2, 'unit_price': 1000, 'currency': 'JPY'},
    {'product_id': 'prod-002', 'quantity': 1, 'unit_price': 2500, 'currency': 'JPY'},
]
customer_id = "cust-123"

order_id = create_order_use_case.handle(customer_id, items)

# --- 結果の確認 (リポジトリから取得) ---
created_order = order_repository.find_by_id(order_id)
if created_order:
    print(f"Order Status: {created_order.status}")
    print(f"Total Price: {created_order.total_price.amount} {created_order.total_price.currency}")
    # -> Total Price: 4500 JPY

```

---

## 📝 まとめ

この例では、DDDの戦術的設計のビルディングブロックが以下のように連携しました。

- **値オブジェクト (`Money`)**: 金額という概念を明確にし、不変性と検証ルールを提供。
- **エンティティ (`Order`, `OrderItem`)**: 注文と明細という、IDで識別され状態が変化するモノをモデル化。
- **集約 (`Order` がルート)**: 注文と明細を一つの単位としてまとめ、`total_price` の一貫性を保証。変更は `Order` のメソッド経由で行う。
- **ファクトリ (`OrderFactory`)**: 複雑な注文集約の生成ロジックをカプセル化し、`UseCase` をシンプルに保つ。
- **リポジトリ (`OrderRepositoryInterface`, `InMemoryOrderRepository`)**: 注文集約の永続化を抽象化し、`UseCase` をDBの詳細から隔離。

これらのパターンを組み合わせることで、ドメインのルールをコードに明確に反映し、関心を分離し、テストしやすく保守しやすいドメインモデルを構築することができました。