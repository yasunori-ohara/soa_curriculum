# 05  テスト容易性

# 🏛️ テスト容易性

クリーンアーキテクチャ(CA)を採用する大きな動機の一つが、**テスト容易性 (Testability)** の向上です。テストがしやすいコードは、品質が高く、保守しやすいコードであると言えます。

---

## ❓ テスト容易性とは？

ソフトウェアの部品（モジュール、クラス、関数）が、どれだけ簡単に、独立してテストできるかを示す度合いです。テスト容易性が高いコードは、以下のような特徴を持ちます。

- **分離可能**: テスト対象の部品を、依存する他の部品（特に外部システム like DB, API）から切り離してテストできる。
- **制御可能**: テストに必要な入力（データ、状態）を簡単に与え、テスト対象の振る舞いを制御できる。
- **観察可能**: テスト対象の実行結果（出力、状態変化）を簡単に確認できる。

### 💡 簡単に言うと

「部品ごとに、おもちゃのブロックみたいに簡単に組み立てたり、バラしたりして、ちゃんと動くか確かめられるようにしよう」ということです。

### 🤔 なぜ重要か？

テスト容易性が低いコードは、開発プロセス全体に悪影響を及ぼします。

1. **バグ発見の遅れ**:
テストが難しいと、テスト自体が書かれなくなったり、実行されなくなったりしがちです。これにより、バグが開発の後工程や、最悪の場合リリース後に発見され、修正コストが増大します。
2. **リファクタリングの阻害**:
コードを改善（リファクタリング）したくても、その変更が既存の機能を壊していないかを確認するテストがない（または実行が難しい）ため、怖くて手を出せなくなります。結果として、コードの品質が徐々に低下していきます。
3. **開発スピードの低下**:
手動でのテストや、複雑な環境構築が必要なテストは時間がかかります。自動化された単体テスト（ユニットテスト）が容易であれば、開発者は迅速にフィードバックを得られ、自信を持って開発を進められます。
4. **仕様の不明確化**:
テストコードは、その部品が「どのように使われるべきか」「どのような振る舞いを期待されているか」を示す「実行可能な仕様書」としての役割も果たします。テストが書けない・読みにくいコードは、仕様が不明確になりがちです。

---

## ✅ これまでの実践例（どこで使ったか）

クリーンアーキテクチャは、その構造自体がテスト容易性を高めるように設計されています。

### 📌 UseCaseのユニットテスト (第1巡〜第5巡)

- **具体例**: 各サービスの `tests/application/use_cases/` フォルダ内に、UseCaseのテストコードを作成しました（例: `test_update_world_model.py`）。
- **実践**:
    1. **分離**: UseCaseはインターフェース（`SensorInterface`, `RepositoryInterface`など）にのみ依存していたため、テスト時にはこれらのインターフェースを満たす「偽物」（**モック**や**スタブ**）を簡単に作成し、DI（依存性の注入）で差し替えました。これにより、実際のDBやセンサー、ネットワーク通信がなくても、UseCaseのロジックだけを独立してテストできました。
    2. **制御**: モックオブジェクトを使うことで、「センサーからはこのデータを返す」「リポジトリの`save`メソッドが呼ばれたか」といった、テストに必要な入力や期待される振る舞いを細かく制御できました。
    3. **観察**: モックオブジェクトのメソッドが期待通りに呼び出されたか（`assert mock_repo.save_called is True`）、UseCaseが返した値や、モックに渡されたデータが期待通りかを `assert` 文で簡単に確認できました。
    
    <!-- end list -->
    
    ```python
    # tests/.../test_update_world_model.py より抜粋
    async def test_UseCaseはセンサーデータを取得しWorldModelを公開する():
        # 1. Arrange (偽物の依存先を用意)
        mock_sensor = MockSensorInterface()
        mock_repo = MockWorldModelRepository()
        mock_planner_adapter = MockPlanningServiceAdapter()
        # ... 偽物の振る舞いを設定 ...
    
        # 2. Act (テスト対象に偽物を注入して実行)
        use_case = UpdateWorldModelUseCase(mock_sensor, mock_repo, mock_planner_adapter)
        await use_case.handle()
    
        # 3. Assert (偽物が期待通り使われたか観察)
        assert mock_sensor.get_camera_image_called is True
        assert mock_repo.save_called is True
        assert mock_planner_adapter.publish_world_model_called is True
        # ...
    
    ```
    

### 📌 Entityのユニットテスト (第1巡〜第5巡)

- **具体例**: `domain/entities.py` に定義したクラス（`WorldModel`, `ParkingPlan`など）のメソッド（ビジネスルール）も、同様に簡単にテストできました。
- **実践**: Entityは最も内側の層であり、外部への依存をほとんど（または全く）持たないため、インスタンスを作成し、メソッドを呼び出し、結果を確認するだけで簡単にテストできました。

---

## ❌ 間違った適用例（アンチパターン）

テスト容易性が低いコードは、依存関係が密結合している場合によく見られます。

- **例1：UseCaseが外部サービスAPIを直接呼び出す**
    
    ```python
    # アンチパターン：テスト困難なUseCase
    import requests # 外部ライブラリ
    
    class GetWeatherUseCase:
        def handle(self, city_name):
            # 外部の天気APIを直接呼び出している！
            api_key = "..."
            url = f"<https://api.weather.com/?city={city_name}&appid={api_key}>"
            try:
                response = requests.get(url, timeout=5) # ネットワーク通信が発生！
                response.raise_for_status() # エラーチェック
                data = response.json()
                # ... データ加工ロジック ...
                return formatted_weather_data
            except requests.exceptions.RequestException as e:
                # ... エラー処理 ...
                return None
    
    ```
    
    この `UseCase` をテストするには、以下の問題があります。
    
    - 実際に `api.weather.com` へのネットワーク通信が発生してしまう（テストが遅い、不安定、API制限に引っかかる）。
    - APIがダウンしているとテストが失敗する。
    - 特定のエラーケース（タイムアウトなど）をテストするのが難しい。
    - データ加工ロジックだけを独立してテストできない。
    
    **改善策**: 外部API呼び出しを `Adapter` 層に分離し、`UseCase` はインターフェースに依存するようにします。テスト時には、そのインターフェースのモックを使います。
    
- **例2：UIのイベントハンドラ内に複雑なロジックがある**
    
    ```jsx
    // アンチパターン：テスト困難なUIイベントハンドラ
    // function onSaveButtonClick() {
    //   // 1. UIから値を取得 (UI依存)
    //   const userName = document.getElementById('user-name').value;
    //   const email = document.getElementById('email').value;
    
    //   // 2. バリデーション (ビジネスロジック)
    //   if (!userName || !email.includes('@')) {
    //     showError("Invalid input!"); // UI依存
    //     return;
    //   }
    
    //   // 3. API呼び出し (Adapter依存)
    //   fetch('/api/users', { method: 'POST', body: JSON.stringify({ name: userName, email }) })
    //     .then(response => {
    //       if (!response.ok) throw new Error('Save failed');
    //       // 4. UI更新 (UI依存)
    //       showSuccess("User saved!"); // UI依存
    //     })
    //     .catch(error => {
    //       showError(error.message); // UI依存
    //     });
    // }
    
    ```
    
    この関数をテストするには、実際のDOM（HTML要素）や `fetch` API（またはそのモック）が必要です。バリデーションロジックだけを簡単にテストすることができません。関心が分離されておらず、テスト容易性が低いです。
    
    **改善策**: UIイベントハンドラは入力を受け取って `UseCase` (またはそれに類するコントローラ/プレゼンタ) を呼び出すだけにします。バリデーションやAPI呼び出しは `UseCase` や `Adapter` に分離します。
    

---

## 📝 まとめ

テスト容易性は、ソフトウェアの品質と保守性を支える重要な柱です。

クリーンアーキテクチャは、**関心の分離**、**依存性のルール**、そして**境界インターフェース**という仕組みを通じて、各部品を独立してテスト可能にすることで、高いテスト容易性を実現します。

「テストが書きにくいな」と感じたら、それは多くの場合、依存関係が密結合していたり、関心が分離できていなかったりするサインかもしれません。

---

## ➡️ 次へ

次は、テスト容易性とも関連が深い、「**(6/10) フレームワーク独立性**」について復習しましょう。