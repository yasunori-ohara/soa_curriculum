# OOP-09 : SOLID原則とCA/DDDの旅（まとめ）

### 🏛️ CA（クリーンアーキテクチャ）による「配置」の分離
（`OOP-01`の「神クラス」`Store`を解体し、SOLID原則違反をアーキテクチャレベルで解消するフェーズ）

* **OOP-03: CAの設計（境界の定義）**
    * `OOP-01`の`Store`（神クラス）を解体。
    * ドメイン層（エンティティ）とアプリケーション層（境界/インターフェース）を定義。
    * **SRP** / **DIP** 違反を「設計レベル」で解消する道筋を立てた。
* **OOP-04: CAの実装（ユースケース / インフラ）**
    * `OOP-03`の設計に基づき、ユースケース（アプリ層）とリポジトリ（インフラ層）の「具象クラス」を実装。
* **OOP-05: CAの実装（アダプター / DI）**
    * アダプター層（Controller / Presenter）を実装。
    * `main.py`で、全レイヤーの依存関係を「DI（依存性の注入）」によって組み立て、システムを完成させた。

---

### 🧠 DDD（ドメイン駆動設計）による「質」の向上
（CAの骨格は維持しつつ、ドメイン層とアプリケーション層の「内部」を洗練させるフェーズ）

* **OOP-06: DDDの適用（VO / 集約）**
    * `int`型を「**値オブジェクト**」に置き換え、ドメインの不変条件（ルール）を強化。
    * 「太ったユースケース」のロジックを「**集約**（`Store`エンティティ）」に移動させ、ドメイン層を強化（SRPの徹底）。
* **OOP-07: DDD適用による追従**
    * `OOP-06`のドメイン変更（`IStoreRepository`導入）に伴い、インフラ層とDI層（`main.py`）を修正し、システムを再稼働させた。

---

### 🎨 SOLID原則の仕上げ
（ドメイン層内部に残っていた違反を解消するフェーズ）

* **OOP-08: OCP/LSPの達成（ポリモーフィズム）**
    * `Store`集約が具象`Product`に依存していた（ドメイン層内部のDIP違反）のを修正。
    * ドメイン層に`IProduct`インターフェースを導入し、**ポリモーフィズム**（多態性）を適用。
    * `DigitalProduct`を「追加」可能にし、**OCP** / **LSP** 違反を完全に解消した。

---

## 🎨 補足：なぜOCP/LSPの達成を最後にしたのか？

OCP/LSPの達成を最後に回したのは、それが**最も「内側」で、かつ最も「高度な」設計問題**だったからです。

`OOP-01`のコードは、それ以前に解決すべき、より大きな構造的問題を抱えていました。

1.  **最初に解くべき問題 (SRP/DIP)**: `Store`クラスが「神クラス（God Class）」であり、アーキテクチャ全体が**SRP（単一責任）**と**DIP（依存性逆転）**に違反していました。
2.  **CA/DDDによる解決 (OOP-03〜07)**: まずはこの「骨格」の問題を解決する必要がありました。CA（クリーンアーキテクチャ）でレイヤーを分離し（SRP/DIP）、DDD（ドメイン駆動設計）でドメイン層のロジック（集約）を強化しました。
3.  **最後に残った問題 (OCP/LSP)**: `OOP-07`の時点で、アーキテクチャは健全になりました。しかし、その**ドメイン層の「内部」**（`Store`集約が具象の`Product`に依存）に、OCP/LSP違反がまだ潜んでいました。

大きな問題（アーキテクチャ）から小さな問題（ドメイン内部の設計）へと順を追ってリファクタリングした結果、OCP/LSPというドメインモデリングの最終仕上げが最後に来た、ということです。

---



`OOP-01`の素朴なOOPコードから始まり、CA（クリーンアーキテクチャ）とDDD（ドメイン駆動設計）のパターンを適用しながら、`OOP-08`の堅牢な設計に至るまでのリファクタリングの旅を終えました。

この最終章では、私たちが`OOP-01`からどれだけ遠くまで来たのかを振り返り、SOLID原則がどのように達成されたのかを総括します。

## 🎯 この章のゴール

* `OOP-01`（ビフォー）と`OOP-08`（アフター）の設計を比較し、その「変更耐性」の違いを実感する。
* CA/DDDが、SOLID原則を達成するための強力な「実践的パターン」であることを理解する。
* SOLID原則が、アーキテクチャ全体からドメイン内部まで、階層的に適用されることを学ぶ。

---

## 🎨 ビフォー(`OOP-01`) vs アフター(`OOP-08`)

### `OOP-01`（ビフォー）: 密結合な「神クラス」

`logic.py`という一つのファイルに、すべてのロジックが詰め込まれていました。

* **`Store`クラス**: ユースケース（`process_order`）、インフラ（`_products`辞書）、ドメイン（`Product`への具象依存）がすべて混在。
* **脆弱なドメイン**: `Product`クラスは`int`型に依存し、`quantity = -5`のような不正なデータから自身を守れませんでした。
* **変更への耐性**: 「DB保存への変更」も「ダウンロード商品の追加」も、`logic.py`の**全面的な修正**を必要としました。

### `OOP-08`（アフター）: 関心が分離された疎結合アーキテクチャ

ロジックは、その「責任」に応じて明確なファイル（レイヤー）に分離されました。

* **`domain.py` / `domain_vo.py`**:
    * ビジネスの「不変条件（ルール）」をカプセル化（`Quantity > 0`など）。
    * ビジネスの「振る舞い」を集約（`Store.process_order`）に集約。
* **`application.py`（ユースケース）**:
    * ドメインをオーケストレーション（調整）する薄い層。
* **`infrastructure.py`（インフラ）**:
    * 「どう保存するか」という実装の詳細をカプセル化。
* **`main.py`（DI層）**:
    * これらの「部品」を組み立てる責任だけを持つ。

---

## ✨ SOLID原則はどのように達成されたか？

クリーンアーキテクチャとDDDは、単なる流行語ではなく、SOLID原則を**実践（プラクティス）**するための洗練された戦略です。

### 🥇 S: 単一責任の原則 (SRP)
* **CAによる達成**:
    * `OOP-01`の`Store`（神クラス）を、**レイヤー（UseCase, Repository, Controller）**に分離しました。
    * 「変更される理由」が異なるロジック（アプリの手順、保存方法、画面表示）が、異なるファイル（クラス）に配置されました。
* **DDDによる達成**:
    * `UseCase`が持っていた「値の検証」という責任を`Value Object`に分離しました。
    * `UseCase`が持っていた「在庫管理と注文生成の一貫性」という責任を`Store`集約に分離しました。

### 🥈 O: オープン・クローズドの原則 (OCP)
* **DIPとポリモーフィズムによる達成**:
    * `OOP-08`で、`Store`集約が`IProduct`（抽象）に依存するようにしました。
    * これにより、`DigitalProduct`という新機能を、`Store`集約の**修正**なしに「**追加**」できました。
    * 同様に、`UseCase`が`IRepository`（抽象）に依存しているため、「DB保存」機能も「**追加**」で対応可能です。

### 🥉 L: リスコフの置換原則 (LSP)
* **ポリモーフィズムによる達成**:
    * `DigitalProduct`（子）は、`IProduct`（親）の「契約」（`check_stock`, `reduce_stock`）を、**振る舞いが違えど（何もしない等）**、シグネチャ（入出力）としては遵守しました。
    * これにより、`Store`（利用者側）は`if isinstance(...)`のような型チェックを必要とせず、`PhysicalProduct`と`DigitalProduct`を区別なく（＝**置換**して）扱えました。

### 🏅 D: 依存性逆転の原則 (DIP)
* **このリファクタリングの「礎」**でした。
* **CAレベル (OOP-03)**:
    * `UseCase` → `IRepository` ← `Infrastructure`
    * CAの「依存性のルール」そのものがDIPの実践です。
* **ドメインレベル (OOP-08)**:
    * `Store`（集約） → `IProduct` ← `PhysicalProduct` / `DigitalProduct`
    * 高レベルなドメインロジック（`Store`）を、低レベルな実装（`PhysicalProduct`）から切り離しました。


## 🚀 まとめ：私たちが手に入れたもの（真の変更耐性）

`OOP-08`で完成したアーキテクチャは、`OOP-01`では不可能だった「柔軟な変更」が可能です。

* **要求1: 「注文をDBに保存したい」**
    * **対応**: `infrastructure.py`に`DatabaseStoreRepository`を「追加」し、`main.py`で注入するクラスを差し替える。
    * **影響範囲**: `Domain`, `Application`, `Adapters` は**修正ゼロ**。

* **要求2: 「新しい商品（例：セット商品）を追加したい」**
    * **対応**: `domain.py`に`SetProduct(IProduct)`を「追加」し、`main.py`でインスタンス化する。
    * **影響範囲**: `Store`集約, `UseCase` は**修正ゼロ**。

* **要求3: 「注文時のルール（例：会員は5%割引）を追加したい」**
    * **対応**: `Store.process_order`（ドメイン層）と、`Money`（VO）のロジックを「修正」する。
    * **影響範囲**: `UseCase`, `Infrastructure`, `Adapters` は**修正ゼロ**。

`OOP-01`のコードでは、これらの変更が`logic.py`全体に影響を及ぼしていました。
SOLID原則、CA、DDDを適用した結果、**「変更が、その責任を持つレイヤー（ファイル）の内部に閉じ込められる」**という、真に保守性の高いシステムが完成しました。