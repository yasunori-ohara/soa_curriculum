# 03 経路計算サービス

# 🧠 経路計算サービス (Planning Service)

自動駐車システムの第二ステップ、「頭脳」を担当する「経路計算サービス」について解説します。このサービスは、認識サービスが作成した「世界モデル（状況）」を理解し、「どう動くべきか」という具体的な計画を立てる責任を持ちます。

---

## 🗺️ このサービスの全体像（ファイル構成と依存関係）

この「経路計算サービス」も、クリーンアーキテクチャのルールに従って設計されます。
UseCase（ビジネスロジック）を中心（内側）に置き、具体的な実装（ファイル入出力など）を**Adapters層**（外側）に配置します。

![クリーンアーキテクチャ](../クリーンアーキテクチャ.png)

### ファイル構成

```
planning_service/
├── domain/
│   └── entities.py         # [Entity] ParkingPlan や WorldModel(契約) など
├── application/
│   ├── boundaries.py       # [境界] Subscriber/Publisher などのインターフェース
│   └── use_cases.py        # [UseCase] CalculateParkingPlanUseCase ロジック
├── adapters/
│   ├── file_subscriber.py  # [Adapters層] FileWorldModelSubscriber (入力実装)
│   ├── file_publisher.py   # [Adapters層] FilePlanPublisher (出力実装)
│   └── repositories.py     # [Adapters層] InMemoryPlanRepository (状態実装)
├── tests/
│   └── ...                 # (テストコード)
└── main.py                 # [起動] DIコンテナ、実行ファイル

```

---

## 🎯 責務：状況を理解し、計画を立てる

経路計算サービスの唯一の責務は、「認識サービスが作成した\*世界モデル\*（現状）を読み込み、ゴール（駐車）までの最適な\*動作コマンド\*（計画）を作成すること」です。

```
[ 世界モデル (ファイル) ] -------> [ 経路計算サービス ] --------> [ 動作コマンド (ファイル) ]
(駐車スペース位置など)              (Planning)                   (ハンドル角度、速度など)
                                 - 状況解釈
                                  - 経路アルゴリズム

```

このサービスは、「世界モデル」に記載された障害物や駐車スペースの位置に基づき、衝突を回避しながら駐車を達成するための、時系列のコマンド（例：「ハンドルを右に30度」「時速5kmで後退」）を計算します。

---

## 🧩 主要コンポーネント

このサービスも、独立したクリーンアーキテクチャで構成されます。

### 主要なEntities

ビジネスの核となる概念とルールを定義します。

- **WorldModel (契約)**: 認識サービスから受け取るデータ（インターフェース）です。このサービスは `WorldModel` を「Entity」として扱いますが、その定義は認識サービス（生産者）と合意された「契約」に基づきます。（※説明のため、認識サービスの `WorldModel` 定義をここにも記載します）
- **ControlCommand**: 車両を制御するための最小単位の命令（例：「ハンドルを右に30度」「1.5秒間後退」）を表すValue Objectです。
- **ParkingPlan**: このサービスの中心となるEntity。`ControlCommand` のリスト（時系列）を保持し、「駐車計画全体」を表現します。`add_command()` や `get_total_duration()` などのビジネスルールを持ちます。

```python
# domain/entities.py (経路計算サービス内)
from dataclasses import dataclass, field
from datetime import datetime
from typing import List

# --- 認識サービスとの「契約」として定義されるEntity ---
# (※本来的には共通ライブラリやスキーマで定義・共有される)

@dataclass
class DetectedObject:
    # (認識サービスと同じ定義)
    ...

@dataclass
class ParkingSpace:
    # (認識サービスと同じ定義)
    ...

# -----------------------------------------------------------------------------
# WorldModel Entity (入力データ)
# - クラス図の位置: Entities
# - 同心円図の位置: Entities (最も内側)
# -----------------------------------------------------------------------------
@dataclass
class WorldModel:
    """認識サービスから受け取る「世界モデル」を表すEntity"""
    timestamp: datetime
    objects: List[DetectedObject] = field(default_factory=list)
    parking_spaces: List[ParkingSpace] = field(default_factory=list)

# --- このサービス（経路計算）が定義するEntity ---

@dataclass
class ControlCommand:
    """車両への個別の制御命令（Value Object）"""
    action: str  # (例: 'steer', 'throttle')
    value: float # (例: 30.0 [度], -0.5 [m/s^2])
    duration: float # (例: 1.5 [秒])

# -----------------------------------------------------------------------------
# ParkingPlan Entity (出力データ)
# - クラス図の位置: Entities
# - 同心円図の位置: Entities (最も内側)
# -----------------------------------------------------------------------------
@dataclass
class ParkingPlan:
    """計算された駐車計画全体を表すEntity"""
    timestamp: datetime
    commands: List[ControlCommand] = field(default_factory=list)

    def add_command(self, command: ControlCommand):
        """[ビジネスルール] 計画に制御コマンドを追加する"""
        self.commands.append(command)
        self.timestamp = datetime.now()

    def get_total_duration(self) -> float:
        """[ビジネスルール] 計画の総実行時間を計算する"""
        return sum(cmd.duration for cmd in self.commands)

```

### 主要なUseCase

特定のシナリオを実行するためのビジネスフローを定義します。

- **CalculateParkingPlanUseCase**: `WorldModel` を読み込み、経路計算アルゴリズムを実行し、その結果（`ParkingPlan`）を保存・公開する一連の流れを担当します。

```python
# application/use_cases/calculate_parking_plan.py (経路計算サービス内)
from application.boundaries import (
    WorldModelSubscriberInterface,
    PlanRepositoryInterface,
    PlanPublisherInterface,
    CalculateParkingPlanInputBoundary # InputBoundaryもboundaries.pyで定義想定
)
from domain.entities import ParkingPlan # このUseCaseが作成するEntity
from datetime import datetime

# -----------------------------------------------------------------------------
# Use Case
# - クラス図の位置: UseCase
# - 同心円図の位置: Use Cases
# -----------------------------------------------------------------------------
class CalculateParkingPlanUseCase(CalculateParkingPlanInputBoundary):
    def __init__(self,
                 world_model_sub: WorldModelSubscriberInterface,
                 plan_repo: PlanRepositoryInterface,
                 plan_pub: PlanPublisherInterface):
        # DIにより、インターフェース(抽象)のみを受け取る
        self._world_model_sub = world_model_sub
        self._plan_repo = plan_repo
        self._plan_pub = plan_pub

    async def handle(self):
        # 1. 世界モデルを取得 (非同期I/O)
        #    (具体的なファイル読み込みの実装は知らない)
        world_model = await self._world_model_sub.get_world_model()
        if not world_model:
            print("[UseCase] World Model not found. Skipping plan calculation.")
            return

        # 2. 経路計算アルゴリズムを実行 (今回の主題)
        #    (WorldModelからParkingPlanを生成する処理)
        print("[UseCase] Calculating parking plan...")
        new_plan = self._run_planning_algorithm(world_model)

        # 3. 計画 Entityを取得し、更新
        #    (ここでは単純に上書きするが、古い計画(get)と比較も可能)
        # current_plan = self._plan_repo.get()

        # 4. 計算された計画を永続化（内部状態の保存）
        self._plan_repo.save(new_plan)

        # 5. 結果を次のサービスに公開 (非同期I/O)
        #    (具体的なファイル書き出しや通信の実装は知らない)
        await self._plan_pub.publish_plan(new_plan)

    def _run_planning_algorithm(self, world_model: WorldModel) -> ParkingPlan:
        # (ここはダミーのアルゴリズム)
        # (本来はここでA*やRRT*などの複雑な計算が実行される)
        plan = ParkingPlan(timestamp=datetime.now())

        # 駐車スペースが見つかったら、単純なバック操作を計画する
        if world_model.parking_spaces:
            target_space = world_model.parking_spaces[0]
            plan.add_command(ControlCommand(action='steer', value=-30.0, duration=2.0))
            plan.add_command(ControlCommand(action='throttle', value=-0.5, duration=5.0))
            plan.add_command(ControlCommand(action='steer', value=0.0, duration=1.0))

        return plan

```

---

## 🔌 重要な境界 (Boundaries)

このサービスのUseCaseが外部とやり取りするための「契約書（インターフェース）」です。

```python
# application/boundaries.py (経路計算サービス内)
from abc import ABC, abstractmethod
from domain.entities import WorldModel, ParkingPlan # このサービスが扱うEntity
from typing import Optional # WorldModelが未作成の場合があるため

# --- 1. 入力境界：WorldModelSubscriberInterface ---
# --------------------------------------------------------------------
# - クラス図の位置: <I>ServiceAdapterInterface (DataAccessInterfaceの一種)
# - 同心円図の位置: 円と円の境界線そのもの
# --------------------------------------------------------------------
class WorldModelSubscriberInterface(ABC):
    @abstractmethod
    async def get_world_model(self) -> Optional[WorldModel]:
        """認識サービスが公開した世界モデルを取得する (非同期)"""
        raise NotImplementedError

# --- 2. 出力境界：PlanPublisherInterface ---
# --------------------------------------------------------------------
# - クラス図の位置: <I>ServiceAdapterInterface (DataAccessInterfaceの一種)
# - 同心円図の位置: 円と円の境界線そのもの
# --------------------------------------------------------------------
class PlanPublisherInterface(ABC):
    @abstractmethod
    async def publish_plan(self, plan: ParkingPlan):
        """計算された駐車計画を次の車両制御サービスに渡す (非同期)"""
        raise NotImplementedError

# --- 3. 内部状態境界：PlanRepositoryInterface ---
# --------------------------------------------------------------------
# - クラス図の位置: <I>DataAccessInterface
# - 同心円図の位置: 円と円の境界線そのもの
# --------------------------------------------------------------------
class PlanRepositoryInterface(ABC):
    @abstractmethod
    def get(self) -> Optional[ParkingPlan]:
        """現在の(最後に計算した)駐車計画を取得する"""
        raise NotImplementedError

    @abstractmethod
    def save(self, plan: ParkingPlan):
        """駐車計画を保存する"""
        raise NotImplementedError

# --- 4. UseCase自体の入力境界 (参考) ---
class CalculateParkingPlanInputBoundary(ABC):
    @abstractmethod
    async def handle(self):
        raise NotImplementedError

```

---

## ⚙️ Adapters層：具体的な実装（アダプタ）

`application/boundaries.py`で定義されたインターフェース（契約書）を、ここで**具体的に実装**します。`adapters/` フォルダにすべての実装を集約します。

### 1. 入力アダプタの実装 (サービス間入力)

`WorldModelSubscriberInterface`を実装します。SOAシミュレーションとして、認識サービスが書き出した `world_model.json` を読み込む（購読する）クラスを作成します。

```python
# adapters/file_subscriber.py (経路計算サービス内)
import json
import asyncio
from domain.entities import WorldModel, DetectedObject, ParkingSpace # Entity定義が必要
from application.boundaries import WorldModelSubscriberInterface
from typing import Optional
from datetime import datetime

# -----------------------------------------------------------------------------
# Service Adapter Implementation (File Subscriber)
# - クラス図の位置: ServiceAdapter
# - 同心円図の位置: Adapters (外側の円)
# -----------------------------------------------------------------------------
class FileWorldModelSubscriber(WorldModelSubscriberInterface):
    """
    UseCaseの要求(I/F)に基づき、ファイル（JSON）から
    WorldModelを読み込む（購読する）アダプタ。
    """
    def __init__(self, filepath="world_model.json"):
        # (※ 本来は認識サービスとパスを共有する設定ファイルなどから取得)
        self._filepath = filepath

    async def get_world_model(self) -> Optional[WorldModel]:
        print(f"[Adapter] FileSubscriber: Reading World Model from {self._filepath}...")
        try:
            # (※ 本来は非同期ファイルI/Oライブラリを使うべきだが簡潔化)
            await asyncio.sleep(0.01) # 非同期I/Oのシミュレーション
            with open(self._filepath, "r") as f:
                data = json.load(f)

            # JSON辞書からWorldModel Entityに変換する
            # (実際にはデシリアライズ処理をEntity側で行うのが望ましい)
            world_model = WorldModel(
                timestamp=datetime.fromisoformat(data["timestamp"]),
                # objects=[DetectedObject(**obj) for obj in data["objects"]],
                # parking_spaces=[ParkingSpace(**ps) for ps in data["parking_spaces"]],
                # (※上記は仮実装。ネストしたオブジェクトの変換は別途必要)
            )
            return world_model
        except FileNotFoundError:
            print("[Adapter] FileSubscriber: World Model file not found.")
            return None
        except Exception as e:
            print(f"[Adapter] FileSubscriber: Error reading World Model: {e}")
            return None

```

### 2. 出力アダプタの実装 (サービス間出力)

`PlanPublisherInterface`を実装します。計算結果の `ParkingPlan` を、次の車両制御サービスのためにファイル（`plan.json`）に書き出します。

```python
# adapters/file_publisher.py (経路計算サービス内)
import json
import asyncio
from domain.entities import ParkingPlan # 出力するEntity
from application.boundaries import PlanPublisherInterface

# -----------------------------------------------------------------------------
# Service Adapter Implementation (File Publisher)
# - クラス図の位置: ServiceAdapter
# - 同心円図の位置: Adapters (外側の円)
# -----------------------------------------------------------------------------
class FilePlanPublisher(PlanPublisherInterface):
    """
    UseCaseの要求(I/F)に基づき、ParkingPlanを
    ファイル（JSON）として書き出す（公開する）アダプタ。
    """
    def __init__(self, filepath="plan.json"):
        self._filepath = filepath

    async def publish_plan(self, plan: ParkingPlan):
        # ParkingPlanを辞書形式に変換する処理 (仮)
        plan_dict = {
             "timestamp": plan.timestamp.isoformat(),
             "commands": [cmd.__dict__ for cmd in plan.commands]
        }
        try:
            await asyncio.sleep(0.01) # 非同期I/Oのシミュレーション
            with open(self._filepath, "w") as f:
                json.dump(plan_dict, f, indent=2)
            print(f"[Adapter] FilePublisher: Parking Plan saved to {self._filepath}")
        except IOError as e:
            print(f"[Adapter] FilePublisher: Error saving Parking Plan: {e}")

```

### 3. リポジトリアダプタの実装 (内部状態)

`PlanRepositoryInterface`を実装します。最後に計算した `ParkingPlan` をメモリ上に保持します。

```python
# adapters/repositories.py (経路計算サービス内)
from domain.entities import ParkingPlan
from application.boundaries import PlanRepositoryInterface
from typing import Optional

# -----------------------------------------------------------------------------
# Data Access Implementation (In-Memory)
# - クラス図の位置: DataAccess
# - 同心円図の位置: Adapters (外側の円)
# -----------------------------------------------------------------------------
class InMemoryPlanRepository(PlanRepositoryInterface):
    """
    最後に計算したParkingPlanをメモリ上に保持するリポジトリ。
    """
    def __init__(self):
        self._plan: Optional[ParkingPlan] = None
        print("[Adapter] InMemoryRepo: Initialized.")

    def get(self) -> Optional[ParkingPlan]:
        print("[Adapter] InMemoryRepo: Getting ParkingPlan from memory.")
        return self._plan

    def save(self, plan: ParkingPlan):
        print("[Adapter] InMemoryRepo: Saving ParkingPlan to memory.")
        self._plan = plan

```

---

## 🚀 起動ファイル ([main.py](http://main.py/))：すべてを結合する

このサービスの起動ファイルです。
`Adapters`層の具体的な実装（`FileSubscriber`, `FilePublisher`など）をインスタンス化し、`UseCase`に「注入（DI）」して実行します。

```python
# main.py (経路計算サービス内)
import asyncio
from application.use_cases import CalculateParkingPlanUseCase
from adapters.file_subscriber import FileWorldModelSubscriber
from adapters.repositories import InMemoryPlanRepository
from adapters.file_publisher import FilePlanPublisher

# -----------------------------------------------------------------------------
# Entry Point (Main Application)
# - クラス図の位置: Main (DIコンテナの役割)
# - 同心円図の位置: 最も外側の層 (Frameworks & Drivers)
# -----------------------------------------------------------------------------
async def main():
    """
    アプリケーションを起動し、依存関係を注入 (DI) する。
    """
    print("--- [Planning Service] Starting Up ---")

    # 1. Adapters層（具体的な実装）をインスタンス化
    world_model_subscriber = FileWorldModelSubscriber(filepath="world_model.json")
    plan_publisher = FilePlanPublisher(filepath="plan.json")
    plan_repository = InMemoryPlanRepository()

    # 2. UseCase層に、具体的な実装を「依存性の注入 (DI)」
    use_case = CalculateParkingPlanUseCase(
        world_model_sub=world_model_subscriber,
        plan_repo=plan_repository,
        plan_pub=plan_publisher
    )

    # 3. アプリケーション（UseCase）の実行
    print("\\n--- [Planning Service] Running UseCase ---")
    try:
        # UseCaseのhandleメソッドを呼び出す
        await use_case.handle()
        print("--- [Planning Service] UseCase Finished ---")
    except Exception as e:
        print(f"--- [Planning Service] Error: {e} ---")

if __name__ == "__main__":
    # このサービス（経路計算サービス）を実行
    asyncio.run(main())

```

---

## 💡 ユニットテストでサービス境界を検証する

UseCaseのテストでは、`Adapters`層のすべてを偽物（モック）に差し替えて、ロジックが正しくインターフェースを呼び出したかを検証します。

```python
# tests/application/use_cases/test_calculate_parking_plan.py (経路計算サービス内)
import pytest
from unittest.mock import MagicMock
# (MockWorldModelSubscriber, MockPlanRepository, MockPlanPublisher を
#  テスト用に別途定義する想定)
# (WorldModel, ParkingPlan などのEntityもインポートが必要)

@pytest.mark.asyncio
async def test_UseCaseはWorldModelを取得しPlanを公開する():
    # 1. Arrange (準備): 全ての依存先を偽物(モック)にする
    mock_subscriber = MockWorldModelSubscriber()
    mock_repo = MockPlanRepository()
    mock_publisher = MockPlanPublisher()

    # 偽の入力(WorldModel)を設定
    mock_subscriber.set_world_model(WorldModel(...))

    # 2. Act (実行)
    use_case = CalculateParkingPlanUseCase(mock_subscriber, mock_repo, mock_publisher)
    await use_case.handle()

    # 3. Assert (検証)
    # 意図: 「Subscriberからデータを読み取り(1)、Planを保存し(4)、
    #       最後にPublisherに公開したか(5)？」をテスト
    assert mock_subscriber.get_world_model_called is True
    assert mock_repo.save_called is True
    assert mock_publisher.publish_plan_called is True

    # 公開されたParkingPlanの内容が期待通りかも検証できる
    assert mock_publisher.published_plan.timestamp is not None
    assert len(mock_publisher.published_plan.commands) > 0 # 何らかの計画が作られた

```

---

## 🐍 PythonとC言語の比較（初心者の方へ）

（※このセクションは認識サービスと同じ一般論です）
Python (オブジェクト指向): `WorldModelSubscriberInterface`のような抽象インターフェースを定義し、UseCaseはそれに依存します。アダプター（`FileWorldModelSubscriber`）がそのインターフェースを実装することで、具体的なファイル読み込みコードがUseCaseから隠蔽されます。

C言語 (手続き型): UseCase相当のロジックが、`read_world_model_file()`のような関数を直接呼び出す形になりがちです。これだと、ファイルI/Oに密結合してしまい、テストで偽物に差し替えたり、将来ファイルではなく通信（gRPC）に変更したりするのが困難になります。

---

## 🛡️ このサービスの鉄則

**計画を立てよ。ただし車は動かすな。** (Plan the path, but don't drive the car.)

経路計算サービスの責務は、あくまで「理想的な計画」を時系列のコマンド（`ParkingPlan`）として作成することに限定されます。
「そのコマンドをいつ、どのように実行するか」「実行した結果どうなったか」は、完全に次の車両制御サービスの責務です。

---

## 🔄 経路計算サービスの構成（復習）

最後にもう一度、このサービスの全体像を振り返りましょう。

### ファイル構成

```
planning_service/
├── domain/
│   └── entities.py         # [Entity] ParkingPlan や WorldModel(契約) など
├── application/
│   ├── boundaries.py       # [境界] Subscriber/Publisher などのインターフェース
│   └── use_cases.py        # [UseCase] CalculateParkingPlanUseCase ロジック
├── adapters/
│   ├── file_subscriber.py  # [Adapters層] FileWorldModelSubscriber (入力実装)
│   ├── file_publisher.py   # [Adapters層] FilePlanPublisher (出力実装)
│   └── repositories.py     # [Adapters層] InMemoryPlanRepository (状態実装)
├── tests/
│   └── ...                 # (テストコード)
└── main.py                 # [起動] DIコンテナ、実行ファイル

```

このサービスも、クリーンアーキテクチャの原則に厳密に従いました。

1. **中心 (Entity, UseCase)**:
    - `ParkingPlan` というルール（**Entity**）を定義しました。
    - `CalculateParkingPlanUseCase` というビジネスロジック（**UseCase**）を定義しました。
2. **境界 (Interfaces)**:
    - UseCaseは、具体的なファイルI/Oを知る代わりに、3つの抽象的な「窓口」（**Interfaces**）を定義しました。
3. **外側 (Adapters)**:
    - 3つの窓口に対応する、具体的な「道具」（**Adapters**）を実装しました（`FileWorldModelSubscriber`, `FilePlanPublisher`など）。
4. **組立 ([main.py](http://main.py/))**:
    - 最後に、`main.py`が「UseCase」と「Adapters」を\*\*注入（DI）\*\*によって結合しました。

この設計により、入力がファイル（`File...Subscriber`）から通信（`gRPC...Subscriber`）に変わっても、UseCaseのコードを一切変更する必要がありません。

---

次は、「車両制御サービス」について見ていきましょう。