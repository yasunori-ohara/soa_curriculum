# 04 車両制御サービス

# 🦾 車両制御サービス (Control Service)

自動駐車システムの最終ステップ、「手足」を担当する「車両制御サービス」について解説します。このサービスは、経路計算サービスが作成した「動作コマンド（計画）」を忠実に実行し、ハードウェア（モーターやステアリング）を制御する責任を持ちます。

---

## 🗺️ このサービスの全体像（ファイル構成と依存関係）

この「車両制御サービス」も、クリーンアーキテクチャのルールに従って設計されます。
UseCase（ビジネスロジック）を中心（内側）に置き、具体的な実装（ファイル入出力、ハードウェア制御）を**Adapters層**（外側）に配置します。

![クリーンアーキテクチャ](../クリーンアーキテクチャ.png)

### ファイル構成

```
control_service/
├── domain/
│   └── entities.py         # [Entity] ParkingPlan(契約), VehicleState など
├── application/
│   ├── boundaries.py       # [境界] Subscriber/Actuator などのインターフェース
│   └── use_cases.py        # [UseCase] ExecutePlanUseCase ロジック
├── adapters/
│   ├── file_subscriber.py  # [Adapters層] FilePlanSubscriber (入力実装)
│   ├── stub_actuator.py    # [Adapters層] StubActuatorAdapter (出力実装)
│   └── repositories.py     # [Adapters層] InMemoryVehicleStateRepository (状態実装)
├── tests/
│   └── ...                 # (テストコード)
└── main.py                 # [起動] DIコンテナ、実行ファイル

```

---

## 🎯 責務：計画を忠実に実行する

車両制御サービスの唯一の責務は、「経路計算サービスが作成した\*動作コマンド\*（計画）を読み込み、それを解釈して、ハードウェア（ステアリング、モーター）に具体的な指示を出すこと」です。

```
[ 動作コマンド (ファイル) ] -------> [ 車両制御サービス ] --------> [ ハードウェア (出力) ]
(ハンドル角度、速度など)              (Control)                   (ステアリング、モーター)
                                   - コマンド解釈
                                   - ハードウェア制御

```

このサービスは、`plan.json` に記載された時系列のコマンド（例：「ハンドルを右に30度」「1.5秒間後退」）を順番に読み込み、対応するハードウェアアダプタを呼び出します。

---

## 🧩 主要コンポーネント

このサービスも、独立したクリーンアーキテクチャで構成されます。

### 主要なEntities

ビジネスの核となる概念とルールを定義します。

- **ParkingPlan / ControlCommand (契約)**: 経路計算サービスから受け取るデータ（インターフェース）です。このサービスはこれらを「Entity」として扱います。
- **VehicleState**: このサービスの中心となるEntity（またはリポジトリの管理対象）。現在の車両の状態（例：現在のハンドル角度、速度、位置）を保持します。`update_state()` などのビジネスルールを持ちます。

```python
# domain/entities.py (車両制御サービス内)
from dataclasses import dataclass, field
from datetime import datetime
from typing import List

# --- 経路計算サービスとの「契約」として定義されるEntity ---
# (※本来的には共通ライブラリやスキーマで定義・共有される)

@dataclass
class ControlCommand:
    """経路計算サービスから受け取る個別の制御命令"""
    action: str  # (例: 'steer', 'throttle')
    value: float # (例: 30.0 [度], -0.5 [m/s^2])
    duration: float # (例: 1.5 [秒])

# -----------------------------------------------------------------------------
# ParkingPlan Entity (入力データ)
# - クラス図の位置: Entities
# - 同心円図の位置: Entities (最も内側)
# -----------------------------------------------------------------------------
@dataclass
class ParkingPlan:
    """経路計算サービスから受け取る「駐車計画」を表すEntity"""
    timestamp: datetime
    commands: List[ControlCommand] = field(default_factory=list)

# --- このサービス（車両制御）が定義するEntity ---

# -----------------------------------------------------------------------------
# VehicleState Entity (内部状態)
# - クラス図の位置: Entities
# - 同心円図の位置: Entities (最も内側)
# -----------------------------------------------------------------------------
@dataclass
class VehicleState:
    """現在の車両の状態を保持するEntity"""
    current_steer_angle: float = 0.0
    current_speed: float = 0.0
    last_updated: datetime = field(default_factory=datetime.now)

    def update_state(self, command: ControlCommand):
        """[ビジネスルール] 実行されたコマンドに基づき状態を更新する"""
        if command.action == 'steer':
            self.current_steer_angle = command.value
        elif command.action == 'throttle':
            # (※ 本来は物理演算に基づき速度を更新するが、ここでは単純化)
            self.current_speed = command.value
        self.last_updated = datetime.now()

```

### 主要なUseCase

特定のシナリオを実行するためのビジネスフローを定義します。

- **ExecutePlanUseCase**: `ParkingPlan` を読み込み、計画に含まれる `ControlCommand` を一つずつ順番に実行（ハードウェアアダプタを呼び出し）、内部状態（`VehicleState`）を更新する、という一連の流れを担当します。

```python
# application/use_cases/execute_plan.py (車両制御サービス内)
from application.boundaries import (
    PlanSubscriberInterface,
    VehicleStateRepositoryInterface,
    ActuatorInterface,
    ExecutePlanInputBoundary # InputBoundaryもboundaries.pyで定義想定
)
import asyncio # (コマンド実行のシミュレーションで時間待ちするため)

# -----------------------------------------------------------------------------
# Use Case
# - クラス図の位置: UseCase
# - 同心円図の位置: Use Cases
# -----------------------------------------------------------------------------
class ExecutePlanUseCase(ExecutePlanInputBoundary):
    def __init__(self,
                 plan_sub: PlanSubscriberInterface,
                 state_repo: VehicleStateRepositoryInterface,
                 actuator: ActuatorInterface):
        # DIにより、インターフェース(抽象)のみを受け取る
        self._plan_sub = plan_sub
        self._state_repo = state_repo
        self._actuator = actuator

    async def handle(self):
        # 1. 駐車計画を取得 (非同期I/O)
        #    (具体的なファイル読み込みの実装は知らない)
        plan = await self._plan_sub.get_plan()
        if not plan:
            print("[UseCase] Parking Plan not found. Skipping execution.")
            return

        print(f"[UseCase] Executing plan with {len(plan.commands)} commands...")

        # 2. 計画のコマンドを順番に実行
        for command in plan.commands:

            # 3. 現在の車両状態を取得 (内部状態)
            current_state = self._state_repo.get()

            # (※ ここで state と command に基づく事前チェックロジックが入る)
            print(f"[UseCase] Executing command: {command.action}={command.value} for {command.duration}s")

            # 4. ハードウェア（アクチュエータ）に指示 (非同期I/O)
            #    (具体的なハードウェア制御の実装は知らない)
            await self._actuator.execute_command(command)

            # (コマンドの実行時間をシミュレート)
            await asyncio.sleep(command.duration)

            # 5. 実行後の車両状態を更新・保存 (内部状態)
            current_state.update_state(command)
            self._state_repo.save(current_state)

        print("[UseCase] Plan execution finished.")

```

---

## 🔌 重要な境界 (Boundaries)

このサービスのUseCaseが外部とやり取りするための「契約書（インターフェース）」です。

```python
# application/boundaries.py (車両制御サービス内)
from abc import ABC, abstractmethod
from domain.entities import ParkingPlan, VehicleState, ControlCommand # このサービスが扱うEntity
from typing import Optional

# --- 1. 入力境界：PlanSubscriberInterface ---
# --------------------------------------------------------------------
# - クラス図の位置: <I>ServiceAdapterInterface (DataAccessInterfaceの一種)
# - 同心円図の位置: 円と円の境界線そのもの
# --------------------------------------------------------------------
class PlanSubscriberInterface(ABC):
    @abstractmethod
    async def get_plan(self) -> Optional[ParkingPlan]:
        """経路計算サービスが公開した駐車計画を取得する (非同期)"""
        raise NotImplementedError

# --- 2. 出力境界：ActuatorInterface ---
# --------------------------------------------------------------------
# - クラス図の位置: <I>HardwareInterface (DataAccessInterfaceの一種)
# - 同心円図の位置: 円と円の境界線そのもの
# --------------------------------------------------------------------
class ActuatorInterface(ABC):
    @abstractmethod
    async def execute_command(self, command: ControlCommand):
        """計算された制御コマンドをハードウェア（アクチュエータ）に送信する (非同期)"""
        raise NotImplementedError

# --- 3. 内部状態境界：VehicleStateRepositoryInterface ---
# --------------------------------------------------------------------
# - クラス図の位置: <I>DataAccessInterface
# - 同心円図の位置: 円と円の境界線そのもの
# --------------------------------------------------------------------
class VehicleStateRepositoryInterface(ABC):
    @abstractmethod
    def get(self) -> VehicleState:
        """現在の車両状態を取得する"""
        raise NotImplementedError

    @abstractmethod
    def save(self, state: VehicleState):
        """車両状態を保存する"""
        raise NotImplementedError

# --- 4. UseCase自体の入力境界 (参考) ---
class ExecutePlanInputBoundary(ABC):
    @abstractmethod
    async def handle(self):
        raise NotImplementedError

```

---

## ⚙️ Adapters層：具体的な実装（アダプタ）

`application/boundaries.py`で定義されたインターフェース（契約書）を、ここで**具体的に実装**します。`adapters/` フォルダにすべての実装を集約します。

### 1. 入力アダプタの実装 (サービス間入力)

`PlanSubscriberInterface`を実装します。SOAシミュレーションとして、経路計算サービスが書き出した `plan.json` を読み込む（購読する）クラスを作成します。

```python
# adapters/file_subscriber.py (車両制御サービス内)
import json
import asyncio
from domain.entities import ParkingPlan, ControlCommand # Entity定義が必要
from application.boundaries import PlanSubscriberInterface
from typing import Optional
from datetime import datetime

# -----------------------------------------------------------------------------
# Service Adapter Implementation (File Subscriber)
# - クラス図の位置: ServiceAdapter
# - 同心円図の位置: Adapters (外側の円)
# -----------------------------------------------------------------------------
class FilePlanSubscriber(PlanSubscriberInterface):
    """
    UseCaseの要求(I/F)に基づき、ファイル（JSON）から
    ParkingPlanを読み込む（購読する）アダプタ。
    """
    def __init__(self, filepath="plan.json"):
        self._filepath = filepath

    async def get_plan(self) -> Optional[ParkingPlan]:
        print(f"[Adapter] FileSubscriber: Reading Parking Plan from {self._filepath}...")
        try:
            await asyncio.sleep(0.01) # 非同期I/Oのシミュレーション
            with open(self._filepath, "r") as f:
                data = json.load(f)

            # JSON辞書からParkingPlan Entityに変換する
            plan = ParkingPlan(
                timestamp=datetime.fromisoformat(data["timestamp"]),
                commands=[ControlCommand(**cmd) for cmd in data["commands"]]
            )
            return plan
        except FileNotFoundError:
            print("[Adapter] FileSubscriber: Parking Plan file not found.")
            return None
        except Exception as e:
            print(f"[Adapter] FileSubscriber: Error reading Parking Plan: {e}")
            return None

```

### 2. 出力アダプタの実装 (ハードウェア出力)

`ActuatorInterface`を実装します。実際のハードウェア（ステアリング、モーター）と通信する代わりに、今回はコンソールに実行内容を「表示」するスタブ（ダミー）を作成します。

```python
# adapters/stub_actuator.py (車両制御サービス内)
import asyncio
from domain.entities import ControlCommand
from application.boundaries import ActuatorInterface

# -----------------------------------------------------------------------------
# Hardware Adapter Implementation (Stub)
# - クラス図の位置: HardwareAdapter
# - 同心円図の位置: Adapters (外側の円)
# -----------------------------------------------------------------------------
class StubActuatorAdapter(ActuatorInterface):
    """
    ハードウェア（アクチュエータ）のダミー（スタブ）。
    UseCaseの要求(I/F)に基づき、制御コマンドをコンソールに出力する。
    """
    async def execute_command(self, command: ControlCommand):
        """制御コマンドをハードウェアに送信する（シミュレーション）"""

        # 非同期I/O（例: CANバス通信）をシミュレート
        await asyncio.sleep(0.05)

        if command.action == 'steer':
            print(f"[Adapter] StubActuator: STEER set to {command.value} degrees")
        elif command.action == 'throttle':
            print(f"[Adapter] StubActuator: THROTTLE set to {command.value} m/s^2")
        else:
            print(f"[Adapter] StubActuator: Unknown command {command.action}")

```

### 3. リポジトリアダプタの実装 (内部状態)

`VehicleStateRepositoryInterface`を実装します。現在の車両状態（`VehicleState`）をメモリ上に保持します。

```python
# adapters/repositories.py (車両制御サービス内)
from domain.entities import VehicleState
from application.boundaries import VehicleStateRepositoryInterface
from datetime import datetime

# -----------------------------------------------------------------------------
# Data Access Implementation (In-Memory)
# - クラス図の位置: DataAccess
# - 同心円図の位置: Adapters (外側の円)
# -----------------------------------------------------------------------------
class InMemoryVehicleStateRepository(VehicleStateRepositoryInterface):
    """
    現在の車両状態(VehicleState)をメモリ上に保持するリポジトリ。
    """
    def __init__(self):
        self._state = VehicleState(last_updated=datetime.now())
        print("[Adapter] InMemoryRepo: Initialized.")

    def get(self) -> VehicleState:
        print("[Adapter] InMemoryRepo: Getting VehicleState from memory.")
        return self._state

    def save(self, state: VehicleState):
        print("[Adapter] InMemoryRepo: Saving VehicleState to memory.")
        self._state = state

```

---

## 🚀 起動ファイル ([main.py](http://main.py/))：すべてを結合する

このサービスの起動ファイルです。
`Adapters`層の具体的な実装（`FilePlanSubscriber`, `StubActuatorAdapter`など）をインスタンス化し、`UseCase`に「注入（DI）」して実行します。

```python
# main.py (車両制御サービス内)
import asyncio
from application.use_cases import ExecutePlanUseCase
from adapters.file_subscriber import FilePlanSubscriber
from adapters.repositories import InMemoryVehicleStateRepository
from adapters.stub_actuator import StubActuatorAdapter

# -----------------------------------------------------------------------------
# Entry Point (Main Application)
# - クラス図の位置: Main (DIコンテナの役割)
# - 同心円図の位置: 最も外側の層 (Frameworks & Drivers)
# -----------------------------------------------------------------------------
async def main():
    """
    アプリケーションを起動し、依存関係を注入 (DI) する。
    """
    print("--- [Control Service] Starting Up ---")

    # 1. Adapters層（具体的な実装）をインスタンス化
    plan_subscriber = FilePlanSubscriber(filepath="plan.json")
    state_repository = InMemoryVehicleStateRepository()
    actuator_adapter = StubActuatorAdapter()

    # 2. UseCase層に、具体的な実装を「依存性の注入 (DI)」
    use_case = ExecutePlanUseCase(
        plan_sub=plan_subscriber,
        state_repo=state_repository,
        actuator=actuator_adapter
    )

    # 3. アプリケーション（UseCase）の実行
    print("\\n--- [Control Service] Running UseCase ---")
    try:
        # UseCaseのhandleメソッドを呼び出す
        await use_case.handle()
        print("--- [Control Service] UseCase Finished ---")
    except Exception as e:
        print(f"--- [Control Service] Error: {e} ---")

if __name__ == "__main__":
    # このサービス（車両制御サービス）を実行
    asyncio.run(main())

```

---

## 💡 ユニットテストでサービス境界を検証する

UseCaseのテストでは、`Adapters`層のすべてを偽物（モック）に差し替えて、ロジックが計画通りにコマンドを実行しようとしたかを検証します。

```python
# tests/application/use_cases/test_execute_plan.py (車両制御サービス内)
import pytest
from unittest.mock import MagicMock, call
# (MockPlanSubscriber, MockVehicleStateRepository, MockActuatorInterface を
#  テスト用に別途定義する想定)
# (ParkingPlan, ControlCommand などのEntityもインポートが必要)

@pytest.mark.asyncio
async def test_UseCaseはPlanを取得しコマンドを順番に実行する():
    # 1. Arrange (準備): 全ての依存先を偽物(モック)にする
    mock_subscriber = MockPlanSubscriber()
    mock_repo = MockVehicleStateRepository()
    mock_actuator = MockActuatorInterface()

    # 偽の入力(ParkingPlan)を設定
    cmd1 = ControlCommand(action='steer', value=30.0, duration=1.0)
    cmd2 = ControlCommand(action='throttle', value=-0.5, duration=2.0)
    mock_subscriber.set_plan(ParkingPlan(timestamp=datetime.now(), commands=[cmd1, cmd2]))

    # 偽の内部状態(VehicleState)を設定
    mock_repo.set_state(VehicleState())

    # 2. Act (実行)
    use_case = ExecutePlanUseCase(mock_subscriber, mock_repo, mock_actuator)
    await use_case.handle()

    # 3. Assert (検証)
    # 意図: 「SubscriberからPlanを読み(1)、Actuatorにコマンドを2回(cmd1, cmd2)
    #       正しい順序で実行指示したか(4)？」をテスト
    assert mock_subscriber.get_plan_called is True
    assert mock_actuator.execute_command.call_count == 2
    assert mock_actuator.execute_command.call_args_list == [
        call(cmd1),
        call(cmd2)
    ]
    # 状態が2回保存されたかも検証できる
    assert mock_repo.save_called_count == 2

```

---

## 🐍 PythonとC言語の比較（初心者の方へ）

（※このセクションは認識サービスと同じ一般論です）
Python (オブジェクト指向): `ActuatorInterface`のような抽象インターフェースを定義し、UseCaseはそれに依存します。アダプター（`StubActuatorAdapter`）がそのインターフェースを実装することで、具体的なハードウェア制御コード（CANバス通信など）がUseCaseから隠蔽されます。

C言語 (手続き型): UseCase相当のロジックが、`set_steering_angle(30.0)`のような関数を直接呼び出す形になりがちです。これだと、特定のハードウェアドライバに密結合してしまい、テストで偽物に差し替えたり、将来ステアリングのメーカーを変更したりするのが困難になります。

---

## 🛡️ このサービスの鉄則

**車を動かせ。ただし計画は立てるな。** (Drive the car, but don't plan the path.)

車両制御サービスの責務は、あくまで「渡された計画」を忠実に実行することに限定されます。
「この障害物を避けるために、計画を変更しよう」といった判断は、完全に経路計算サービスの責務です。この明確な分離が、システムの信頼性とテストの容易性を高めます。

---

## 🔄 車両制御サービスの構成（復習）

最後にもう一度、このサービスの全体像を振り返りましょう。

### ファイル構成

```
control_service/
├── domain/
│   └── entities.py         # [Entity] ParkingPlan(契約), VehicleState など
├── application/
│   ├── boundaries.py       # [境界] Subscriber/Actuator などのインターフェース
│   └── use_cases.py        # [UseCase] ExecutePlanUseCase ロジック
├── adapters/
│   ├── file_subscriber.py  # [Adapters層] FilePlanSubscriber (入力実装)
│   ├── stub_actuator.py    # [Adapters層] StubActuatorAdapter (出力実装)
│   └── repositories.py     # [Adapters層] InMemoryVehicleStateRepository (状態実装)
├── tests/
│   └── ...                 # (テストコード)
└── main.py                 # [起動] DIコンテナ、実行ファイル

```

このサービスも、クリーンアーキテクチャの原則に厳密に従いました。

1. **中心 (Entity, UseCase)**:
    - `VehicleState` や `ParkingPlan`（契約） というルール（**Entity**）を定義しました。
    - `ExecutePlanUseCase` というビジネスロジック（**UseCase**）を定義しました。
2. **境界 (Interfaces)**:
    - UseCaseは、具体的なファイルI/Oやハードウェアを知る代わりに、3つの抽象的な「窓口」（**Interfaces**）を定義しました。
3. **外側 (Adapters)**:
    - 3つの窓口に対応する、具体的な「道具」（**Adapters**）を実装しました（`FilePlanSubscriber`, `StubActuatorAdapter`など）。
4. **組立 ([main.py](http://main.py/))**:
    - 最後に、`main.py`が「UseCase」と「Adapters」を\*\*注入（DI）\*\*によって結合しました。

この設計により、入力がファイル（`File...Subscriber`）から通信に変わったり、出力先がダミー（`Stub`）から本物のCANバス制御（`CANDriverAdapter`）に変わったりしても、UseCaseのコードを一切変更する必要がありません。

---

次は、「最終統合：3サービスを連携させる」について見ていきましょう。