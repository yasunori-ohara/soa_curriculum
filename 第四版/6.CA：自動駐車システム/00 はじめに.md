# 00 はじめに

# 🚗 はじめに：自動駐車システムと「大きな設計図」への挑戦

これまでの三巡（ToDoアプリ、図書館システム、自動販売機）で、私たちは「クリーンアーキテクチャ」という設計の考え方を学びましたね。`Entity`（ルールブック）、`UseCase`（仕事の手順）、`Adapters`（翻訳家や道具係）といった役割分担を決めて、変更に強くテストしやすい部品を作る練習をしてきました。

第四巡では、その学んだ知識を使って、もう少し大きなシステム、**自動駐車システム**を作ってみましょう。ここでの目標は、単に部品を作るだけでなく、**部品同士をどう組み合わせて「システム全体」を設計するか**、という少し高い視点を学ぶことです。これは、あなたの最終目標であるSDV開発（SOA）に繋がる、大切なステップになります。

## 🎯 なぜ自動駐車システム？ なぜ「分割」？

自動駐車は、これまでの題材より少し複雑です。車には周りを見る「目」（センサー）、どう動くか考える「頭脳」（計算）、そして実際に車を動かす「手足」（モーターなど）が必要です。

一つの大きなプログラムで全部やろうとすると、ごちゃごちゃして大変ですよね。そこで、現実の車の開発でもよく行われるように、この仕事を\*\*専門家チーム（＝サービス）\*\*に分けてみましょう。

- **認識チーム (Perception Service)**: センサーからの情報（カメラ映像など）を見て、「駐車スペースはあそこだ」「あそこに壁があるぞ」と状況を把握する専門家。
- **経路計算チーム (Planning Service)**: 認識チームからの報告を受けて、「じゃあ、このルートでバックしよう」と具体的な運転計画を立てる専門家。
- **車両制御チーム (Control Service)**: 経路計算チームの計画通りに、「ハンドルを右にこれだけ回して、アクセルをこれくらい踏んで…」と車を実際に動かす専門家。

このように仕事を分けることで、各チームは自分の専門分野に集中でき、全体の開発がしやすくなります。これが**サービス分割**の考え方で、SOA（サービス指向アーキテクチャ）の基本となります。

## 📖 この第四巡のアプローチ：3つの小さな「クリーンアーキテクチャ」

ここでは、上記の3つのチーム（サービス）を、それぞれ**独立した小さなクリーンアーキテクチャのアプリケーション**として作ります。

そうです、これまで学んだ`Entity`, `UseCase`, `Adapters`の考え方を、それぞれのサービスの中で再び使うのです。

## 🧩 サービス間の「情報の受け渡し」はどうする？

チーム（サービス）同士は、お互いに情報を伝え合う必要があります。認識チームは状況報告書を、経路計算チームは運転計画書を、それぞれ必要とするチームが利用できるようにしなければなりません。

本来のSOAでは、この情報の受け渡しにgRPCやMQTTといったネットワーク通信技術を使います。しかし、今回はその通信技術の詳細ではなく、\*\*「サービス同士の境界線をどう設計するか」\*\*に集中したいので、もっと簡単な方法を使います。

- **「アダプター」でシミュレーション**:
    - **情報の「出力側」**: 例えば認識サービスは、完成した「状況報告書（世界モデル）」を**ファイルに書き出す**アダプターを持ちます。
    - **情報の「入力側」**: 経路計算サービスは、その**ファイルを読み込む**アダプターを持ち、そこから状況報告書を受け取ります。
    
    このように、各サービスは他のサービスの内部を知ることなく、決められた形式のファイル（＝情報の置き場所）を介して情報を交換します。
    
- **ここがポイント！** 💡
これは、**いままでの三巡でやってきたことと同じ**です。
    - 第一巡、第二巡では、UIをコンソールからWebフレームワーク(Flask, FastAPI, Django)に置き換えました。これはUIという**アダプター**の差し替えでした。
    - 第二巡では、データ保存をインメモリDBからMongoDBに置き換えました。これもデータアクセスという**アダプター**の差し替えでした。
    - 今回も同様に、サービス間の情報交換の方法として、今は**ファイル入出力アダプター**を使いますが、これは将来、**通信アダプター（gRPCなど）に差し替えることができます。** そしてその際も、変更が必要なのは`UseCase`の外側、つまり**アダプター層だけ**なのです。

この第四巡は、アダプター層の差し替え可能性というクリーンアーキテクチャの強力な利点を、サービス間連携という新しい文脈で再確認する絶好の機会です。

## 💡 「世界モデル」って難しそう…？

認識サービスが作る「状況報告書」のことを、専門用語で「世界モデル（World Model）」と呼ぶことがあります。なんだかすごそうな名前ですが、心配いりません。

これは単に、「駐車スペースの位置は(x:10, y:5)で、大きさは…」「障害物の位置は(x:3, y:8)で…」といった、\*\*認識結果を整理して入れたデータ（箱）\*\*のことです。今回は、この箱（データ構造）を`WorldModel` Entityとして定義します。難しく考えず、「認識結果を入れるための専用のデータ形式」くらいに捉えておけば大丈夫です。

## 🛡️ この第四巡で得られる学び

このステップを通じて、あなたは以下の重要な視点を獲得します。

1. *システムレベルでの関心の分離*: `UseCase`よりも大きな単位（サービス）で、システムの機能をどう分割・整理するか。
2. *インターフェース設計の重要性*: サービス間で受け渡す情報（世界モデル、動作コマンド）の形式をきちんと決めること（API設計）が、いかに大切か。
3. *アダプター層による技術詳細の隔離*: サービス間の連携方法（ファイルか通信か）もまた、交換可能な「詳細」であること。

## 🚀 SOAへの最終ステップ

この第四巡が終われば、本当のSOAはもう目の前です。今回ファイル入出力でシミュレートしたアダプターを、実際の通信アダプター（gRPCなど）に差し替えるだけで、あなたの設計はそのまま本格的なサービス指向アーキテクチャへと進化します。

さあ、部品作りから一歩進んで、システム全体の設計図を描くアーキテクトとしての第一歩を踏み出しましょう！