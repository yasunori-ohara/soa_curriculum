# 06 フレームワーク独立性

# 🏛️ フレームワーク独立性

クリーンアーキテクチャ(CA)が目指す重要な特性の一つに、「**フレームワーク独立性 (Framework Independence)**」があります。これは、ソフトウェアの核心部分（ビジネスロジック）を、特定の技術フレームワークから切り離すという考え方です。

---

## ❓ 原則の定義

> アーキテクチャは、ライブラリやフレームワークの存在に依存すべきではない。フレームワークは使うためのツールであり、アーキテクチャの中心に据えるものではない。
> 
> 
> \--- (Clean Architecture より意訳)
> 

### 💡 簡単に言うと

「Webフレームワーク（例：Flask, Django, FastAPI）やORM（例：SQLAlchemy）は便利な『道具』だけど、それに『頼りすぎず』、いつでも他の道具に取り替えられるように、ビジネスロジック（中心）は道具のことを知らないようにしよう」ということです。

### 🤔 なぜ重要か？

フレームワークに強く依存したアーキテクチャは、以下のようなリスクを抱えます。

1. **技術的負債化**:
フレームワークは進化が速く、数年で古くなったり、サポートが終了したりすることがあります。フレームワークに依存しすぎていると、そのフレームワークが古くなったときに、システム全体を作り直す必要に迫られる可能性があります。
2. **ベンダーロックイン**:
特定のフレームワーク（特に商用製品）に深く依存すると、そのベンダーの意向（ライセンス変更、機能廃止など）に振り回されやすくなります。
3. **ビジネスロジックの汚染**:
フレームワーク固有の書き方（例：特定のアノテーション、基底クラスの継承）がビジネスロジック（UseCaseやEntity）に混入し、本来のルールが読み取りにくくなったり、フレームワークなしでは理解・テストできなくなったりします。
4. **テストの複雑化**:
ビジネスロジックをテストするために、フレームワーク全体を起動する必要が出てきてしまい、テストが遅く、不安定になる可能性があります。

フレームワークから独立することで、ビジネスロジックという**最も価値があり、長期的に安定すべき**部分を、移り変わりやすい**技術的な詳細**から守ることができます。

---

## ✅ これまでの実践例（どこで使ったか）

クリーンアーキテクチャの構造と依存性のルールが、この原則を支えています。

### 📌 フレームワークを「詳細」として扱う (第1巡〜第5巡)

- **具体例**: Webフレームワーク（Flaskなど）、データベースライブラリ（`pymongo`）、通信ライブラリ（`paho-mqtt`）などは、すべて**Adapters層**（または最も外側のFrameworks & Drivers層）に配置されました。
- **実践**: `UseCase` や `Entity` のコードには、これらのフレームワークやライブラリの名前（`import Flask`, `import paho.mqtt.client` など）は**一切登場しませんでした**。これらの具体的な技術は、`Adapters` 層がインターフェース（境界）の裏側で利用する「詳細」として扱われました。

### 📌 依存性のルールによる隔離 (第1巡〜第5巡)

- **具体例**: 「依存性は常に外側から内側へ」というルールを徹底しました。
- **実践**: `UseCase`（内側）はフレームワーク（外側）を知らないため、フレームワークがFlaskからFastAPIに変わろうが、MQTTライブラリが `paho-mqtt` から別のものに変わろうが、`UseCase` のコードは影響を受けません。

### 📌 [main.py](http://main.py/) による接着 (第1巡〜第5巡)

- **具体例**: 各サービスの `main.py` が、フレームワーク（`asyncio` など）の初期化や、アダプタのインスタンス化、UseCaseへのDIを行いました。
- **実践**: `main.py` は、クリーンアーキテクチャの同心円の外側に位置し、フレームワークとアプリケーション（UseCase, Adapters）を結びつける「接着剤」の役割を果たします。フレームワークへの依存は、この `main.py` と `Adapters` 層に限定され、内側の層には波及しませんでした。

---

## ❌ 間違った適用例（アンチパターン）

フレームワーク独立性が低いコードは、特定の技術に縛られ、将来の変更が困難になります。

- **例1：UseCaseがWebフレームワークのRequest/Responseオブジェクトを直接扱う**
    
    ```python
    # アンチパターン：UseCaseがWebフレームワークに依存
    # from flask import request, jsonify # 👈 フレームワーク固有のクラスをインポート！
    
    class ProcessOrderUseCase:
        def handle(self):
            # UseCaseがFlaskのrequestオブジェクトを直接参照！
            # user_id = request.headers.get("X-User-ID")
            # order_data = request.get_json()
    
            # ... ビジネスロジック ...
    
            # UseCaseがFlaskのjsonify関数を直接使用！
            # return jsonify({"status": "success", "order_id": new_order.id}), 201
            pass
    
    ```
    
    この `UseCase` は、Flaskという特定のWebフレームワークに強く依存しています。もし将来、FastAPIやgRPCに移行しようとした場合、`request` や `jsonify` を使っている箇所をすべて修正する必要があります。また、この `UseCase` をテストするためには、Flaskのテスト用クライアントなど、フレームワークの知識が必要になります。
    
    **改善策**: `Controller`（Adapters層の一部）がフレームワークのRequestを受け取り、`UseCase` に必要なデータ（DTOなど）に変換して渡します。`UseCase` は処理結果（EntityやDTO）を返し、`Presenter`（Adapters層の一部）がそれをフレームワークのResponse形式に変換します。（詳細は後の Presenter/Controller の回で解説）
    
- **例2：EntityがORMの基底クラスを継承したり、アノテーションに依存する**
    
    ```python
    # アンチパターン：EntityがORMに依存
    # from sqlalchemy.ext.declarative import declarative_base # 👈 ORM固有の機能
    # from sqlalchemy import Column, Integer, String
    
    # Base = declarative_base()
    
    # class User(Base): # 👈 ORMの基底クラスを継承！
    #     __tablename__ = 'users'
    #     id = Column(Integer, primary_key=True) # 👈 ORM固有の定義
    #     name = Column(String)
    
    #     # ... 本来のビジネスルール ...
    #     def is_valid_name(self):
    #         return len(self.name) > 0
    
    ```
    
    この `User` Entityは、SQLAlchemyという特定のORMフレームワークに強く依存しています。もし将来、別のORM（例：Django ORM）や、ORMを使わない方法（例：単純な辞書）に切り替えようとした場合、Entityクラス自体を大幅に書き直す必要があります。ビジネスルール（`is_valid_name`）と永続化の仕組み（ORM）という、異なる関心事が混在してしまっています。
    
    **改善策**: Entityは純粋なPythonクラス（Plain Old Python Object - POPO）として定義します。ORMのマッピングは、`Repository` の実装（Adapters層）内で行うか、マッピング用の別ファイル（`infrastructure/orm_mappings.py` など）で行います。
    

---

## 📝 まとめ

フレームワーク独立性は、「**ビジネスロジック（あなたの財産）を、移り変わりやすい技術（道具）から守る**」ための重要な原則です。

フレームワークは便利なツールですが、アーキテクチャの中心に据えるべきではありません。クリーンアーキテクチャのレイヤー構造と依存性のルールに従い、フレームワークへの依存を**Adapters層**と[**main.py**](http://main.py/)（最外層）に閉じ込めることで、将来の技術変更に柔軟に対応できる、息の長いシステムを構築することができます。

---

## ➡️ 次へ

次は、フレームワーク独立性と密接に関連する「**(7/10) UI独立性**」について復習しましょう。