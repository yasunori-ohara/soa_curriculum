# 00 はじめに

# TODOアプリの構築を始めよう

🚀 **いよいよ、最初の題材であるシンプルな「TODOアプリ」を作っていきます。**

なぜTODOアプリなのか？

それは、**入力・表示・ビジネスロジック**というアプリの基本要素をすべて含み、クリーンアーキテクチャの考え方を学ぶのに最適だからです。

このアプリを構築する過程で、私たちはクリーンアーキテクチャの設計思想を、理論ではなく**実践を通して体感**していきます。

---

### 🗺 私たちが使う「設計図」

このカリキュラムでは、道に迷わないように、「フローのクラス図」と呼ばれる設計図を使います。これが、私たちが作る部品とその役割を示した地図になります。

![クリーンアーキテクチャ](../クリーンアーキテクチャ.png)

今はまだ、この図の全ての箱や矢印の意味が分からなくても全く問題ありません。

重要なのは、この設計図が「ユーザーの操作が、どのように処理され、結果として画面に表示されるか」**という**処理の流れを示している、ということです。

これから私たちは、この設計図の左側にある **`View` や `Controller`** から順番に、一つ一つの部品を「これは何をする場所か？」を確認しながら、まるで地図をなぞるように実装していきます。

---

### 📂 プロジェクトの構成

まず、これから作るTODOアプリのフォルダ構成を準備しましょう。

この構成は、設計図の役割分担をそのまま反映した、**クリーンアーキテクチャ準拠構成**です。

```
clean_architecture_todo/
├─ core/
│   ├─ domain/
│   │   ├─ todo.py                 # <E> Entity（ビジネスルールの本体）
│   │   ├─ repository.py           # <I> Repository 抽象（データアクセス契約）
│   │   └─ errors.py               # ドメイン固有エラー（必要に応じて）
│   │
│   └─ usecase/
│       ├─ interactor/
│       │   └─ create_todo.py      # UseCase本体（Interactor: TodoUseCase）
│       └─ boundary/
│           ├─ input_boundary.py   # <I> InputBoundary（Controllerが呼ぶ）
│           ├─ output_boundary.py  # <I> OutputBoundary（Presenterが実装）
│           └─ dto.py              # <DS> DataStructure（Input/Output/ViewModel）
│
├─ interface_adapters/
│   ├─ presenters/
│   │   └─ todo_presenter.py        # Presenter（OutputBoundary実装）
│   ├─ controllers/
│   │   └─ todo_controller.py       # Controller（Viewが呼ぶ）
│   └─ views/
│       ├─ view_console.py          # View本体（ConsoleView）
│       └─ view_gui.py              # View本体（GUI版）
│
├─ infrastructure/
│   └─ repositories/
│       └─ in_memory_todo_repository.py   # Repositoryの具体実装
│       └─ postgres_todo_repository.py    # DB版
│
├─ tests/
│   └─ unit/
│       ├─ test_todo_usecase.py
│       ├─ test_presenter.py
│       ├─ test_controller.py
│       ├─ test_view_console.py
│       ├─ test_in_memory_todo_repository.py
│       └─ test_view_gui.py
│
└─ main.py

```

---

### 🧩 各フォルダの役割

| フォルダ                                 | 役割                                      | クラス図対応                                          |
| ------------------------------------ | --------------------------------------- | ----------------------------------------------- |
| **`core/domain`**                    | アプリの心臓部。TODOのビジネスルールやEntityを定義。         | `<E>` Entity, `<I>Repository`                   |
| **`core/usecase/interactor`**        | ユースケース（アプリの目的ごとの処理）を実装。                 | Interactor                                      |
| **`core/usecase/boundary`**          | UIとの会話の契約（Input/OutputBoundary・DTO）を定義。 | `<I>InputBoundary`, `<I>OutputBoundary`, `<DS>` |
| **`interface_adapters/controllers`** | ユーザー入力を受け取り、InputBoundaryを呼ぶ。           | Controller                                      |
| **`interface_adapters/presenters`**  | UseCase出力を受け取り、View表示形式に整える。            | Presenter                                       |
| **`interface_adapters/gateways`**    | Repositoryインターフェースを実装してDBなどに橋渡し。        | Gateway                                         |
| **`interface_adapters/views`**       | 実際の出力（CLI・GUI・Webなど）。                   | View                                            |
| **`infrastructure`**                 | DBや外部API、ファイルI/Oなどの現実層。                 | Frameworks & Drivers                            |
| **`app/`**                           | 依存関係注入と起動スクリプトをまとめる。                    | Composition Root                                |


### ✅ この構成の効果

1. **設計図（クラス図）との対応が完全一致**
   　→ `<DS>`, `<I>InputBoundary`, `<I>OutputBoundary`, `<I>Repository` などがすべて明示。

2. **用語の直感性が向上**
   　→ “boundary” は「境界」を意味し、UIとUseCaseの線引きを理解しやすい。

3. **教材の発展性を確保**
   　→ 後の第2巡で「Port/Adapter」命名に変更し、ヘキサゴナルアーキテクチャへ自然に発展できる。

---

### ✅ 次のステップ

準備は整いました。
ここからは、アプリの**心臓部**である `core/domain/todo.py` を作り、ビジネスルールをコードに落とし込んでいきましょう。


