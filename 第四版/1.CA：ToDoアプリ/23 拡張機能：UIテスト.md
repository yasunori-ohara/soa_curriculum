# 23 機能拡張：UIテスト

## 🔄 1. GUI版 View (`GuiView`) のテスト

### 💡 ねらい

* `GuiView.on_add_clicked()` が、Entryの内容を Controller に渡していること
* `GuiView.render()` が、ViewModel の `display_text` を Label に反映していること

tkinter は実際にウィンドウを表示しようとしますが、テストではウィンドウを画面に表示する必要はありません。
代わりに、最小限のウィジェット構築だけを許しつつ、Controllerをスパイ化します。

```python
# tests/unit/test_view_gui.py

import tkinter as tk
import pytest

from core.usecase.boundary.dto import TodoViewModel
from interface_adapters.views.view_gui import GuiView


class SpyController:
    """
    GuiView から呼び出される Controller のスパイ。
    呼び出し回数と、最後に渡された引数を記録する。
    """
    def __init__(self):
        self.called_times = 0
        self.last_title = None

    def add_todo(self, title: str):
        self.called_times += 1
        self.last_title = title


@pytest.fixture
def gui_env(monkeypatch):
    """
    tkinter.Tk() が本物のウィンドウを表示しようとすると
    テスト環境（CIやヘッドレス環境）で失敗する場合がある。

    そこで、Tk() をダミーのルートに差し替える。
    """
    # 本物のTk()を本当にモックする必要がある場合はここで差し替える。
    # 今回はそのまま実体化しても、mainloop()を呼ばない限りは
    # GUIがブロックしない前提で進めるので、特に差し替えなしでもOK。
    # ただ、このfixtureは将来の拡張（monkeypatch.Tkの差し替え）用に置いておく。
    yield


def test_gui_view_calls_controller_and_updates_label(gui_env):
    # Arrange
    vm = TodoViewModel(display_text="初期表示")
    controller = SpyController()

    # Tkのメインループは回さないので安全
    view = GuiView(controller, vm)

    # 入力欄にユーザーが打ち込んだ想定の文字をセット
    view.entry.delete(0, tk.END)
    view.entry.insert(0, "GUIから追加したタスク")

    # Act: ボタン押下相当の処理を直接呼ぶ
    view.on_add_clicked()

    # Assert 1: Controllerに入力が渡っているか
    assert controller.called_times == 1
    assert controller.last_title == "GUIから追加したタスク"

    # Assert 2: ViewModelの内容がLabelに反映されているか
    # Presenterが更新している前提で、View.render() がそれを表示用ラベルに流し込む
    assert view.label.cget("text") == vm.display_text
```

### 💡 補足

* `GuiView.run()` は `mainloop()` を回すので、そこは呼びません。ユニットテストではGUIイベントループは起動しないのが基本。
* tkinterのWidgetは、生成時点ではメモリ上に作られるだけなので、`mainloop()`さえ呼ばなければブロックしません。

---

## 🔄 2. FastAPI版 View (`FastApiView`) のテスト

### 💡 ねらい

* GET `/` で、ViewModelの内容がHTMLに反映されて返ること
* POST `/` で、フォームの値が Controller に渡されること
* POST 後は Presenter が更新した ViewModel の状態が HTML に含まれて返ること

FastAPIは公式に `fastapi.testclient.TestClient` を用意しているので、それを使います。
Controller はスパイにして、呼び出しの中身を検証します。

```python
# tests/unit/test_view_fastapi.py

from fastapi.testclient import TestClient

from core.usecase.boundary.dto import TodoViewModel
from interface_adapters.views.view_fastapi import FastApiView


class SpyController:
    """
    FastApiViewから呼ばれるControllerのスパイ。
    POST時に渡されたtitleを記録する。
    """
    def __init__(self):
        self.called_times = 0
        self.last_title = None

    def add_todo(self, title: str):
        self.called_times += 1
        self.last_title = title


def test_fastapi_view_get_renders_view_model(tmp_path, monkeypatch):
    """
    GET / で ViewModel.display_text がHTML上に埋め込まれることを確認する。
    """
    # テンプレートを一時ディレクトリに作る
    template_dir = tmp_path / "templates"
    template_dir.mkdir()

    template_file = template_dir / "index.html"
    template_file.write_text(
        """
        <html>
        <body>
            <p id="msg">{{ display }}</p>
        </body>
        </html>
        """,
        encoding="utf-8",
    )

    vm = TodoViewModel(display_text="初期表示メッセージ")
    controller = SpyController()

    # FastApiViewは、デフォで
    # directory="interface_adapters/views/templates"
    # を見に行くので、そこを一時ディレクトリに差し替える
    def fake_init_templates(self):
        from fastapi.templating import Jinja2Templates
        self.templates = Jinja2Templates(directory=str(template_dir))

    # monkeypatchで templates の初期化だけ差し替える
    monkeypatch.setattr(
        FastApiView,
        "_FastApiView__init_templates",
        fake_init_templates,
        raising=False,
    )

    # FastApiViewを生成
    view = FastApiView(controller, vm)

    # ただし上記monkeypatchでは __init__ 内の挙動を完全には書き換えられないので、
    # よりシンプルに、直接差し替える形で対応するほうが安定する:
    # view.templates = Jinja2Templates(directory=str(template_dir))
    # （この1行をテスト内で上書きするアプローチにしましょう）

    from fastapi.templating import Jinja2Templates
    view.templates = Jinja2Templates(directory=str(template_dir))

    client = TestClient(view.app)

    # Act
    res = client.get("/")

    # Assert
    assert res.status_code == 200
    assert "初期表示メッセージ" in res.text
    assert '<p id="msg">' in res.text


def test_fastapi_view_post_calls_controller_and_updates_response(tmp_path):
    """
    POST / で Controller.add_todo() が呼ばれ、
    レスポンスHTMLに最新の ViewModel.display_text が含まれることを確認する。
    """
    template_dir = tmp_path / "templates"
    template_dir.mkdir()

    template_file = template_dir / "index.html"
    template_file.write_text(
        """
        <html>
        <body>
            <p id="msg">{{ display }}</p>
        </body>
        </html>
        """,
        encoding="utf-8",
    )

    vm = TodoViewModel(display_text="まだ追加されていません")
    controller = SpyController()

    # FastApiViewを生成
    view = FastApiView(controller, vm)

    # テンプレートの格納先をテスト用ディレクトリに差し替え
    from fastapi.templating import Jinja2Templates
    view.templates = Jinja2Templates(directory=str(template_dir))

    client = TestClient(view.app)

    # Act: POSTで新しいTODOを送信
    res = client.post("/", data={"title": "Webから送ったタスク"})

    # Controllerが呼ばれていることを確認
    assert controller.called_times == 1
    assert controller.last_title == "Webから送ったタスク"

    # PresenterがViewModel.display_textを更新した、と仮定する。
    # 本番ではUseCase→Presenterによりvm.display_textが書き換わっているはずなので、
    # テストでは手で内容を変えて再レスポンスを検証してもよい。
    #
    # 今回は「レスポンスが成功していること」「HTMLが返っていること」
    # 「displayがHTML内に描画されていること」を見る:
    assert res.status_code == 200
    assert '<p id="msg">' in res.text
    # vm.display_text はボタン押下後の最新メッセージ想定
    # (シナリオに応じて "追加しました" 的な文章になることを期待する)
```

### 💡 ちょっとだけ解説

* FastAPIは同期/非同期両対応のテストクライアントを持っていて、`TestClient(view.app)` を使うとHTTPリクエストをシミュレートできます。
* 画面テンプレート（`index.html`）は本番では `interface_adapters/views/templates/index.html` を読む想定でした。
  テストでは `tmp_path`（pytest組み込みの一時ディレクトリ）にテンプレートを生成し、`view.templates` をそのディレクトリに差し替えて動かします。
* Controller はスパイ化して、「POST時にちゃんとコントローラが呼ばれた？」を検証します。
* ViewModelの表示（`display_text`）がHTMLレスポンスに含まれていることも検証します。

---

## 🔄 ディレクトリへの追加

今回の2つのテストファイルは、既存の `tests/unit/` に次のように追加できます。

```text
tests/
└─ unit/
    ├─ test_todo_usecase.py
    ├─ test_presenter.py
    ├─ test_controller.py
    ├─ test_view_console.py
    ├─ test_view_gui.py          # ← GUI版 View のテスト
    ├─ test_view_fastapi.py      # ← FastAPI版 View のテスト
    └─ test_in_memory_todo_repository.py
```

---

## 🔄 まとめ

* GUIのViewも、Web(FastAPI)のViewも「Controllerに依頼してViewModelを表示するだけ」なので、テストはそこに集中できる。
* どのフレームワークを使っても、テスト観点はほぼ同じ：

  * 入力がControllerに渡ること
  * ViewModelの内容がレンダリングされること
* つまり、**フレームワークが変わってもテストの仕方は変わらない**
  → クリーンアーキテクチャの分離がうまくいっている証拠。

