# 00 はじめに

# 第６巡：はじめに

👋 第6巡へようこそ。
本巡では、第5巡で扱ったMQTTによる非同期通信とは対照的なアプローチを採用します。

🎯 本巡の目的は、Webの標準技術である OpenAPI (REST) を用い、「同期型」のサービス指向アーキテクチャ（SOA）の実装を体験することです。

## 🔧 なぜREST/OpenAPIか？

REST (Representational State Transfer) は、Web APIの設計原則として広く普及しており、HTTPプロトコルを基盤とするため、多くの開発ツールやライブラリが対応しています。

また、OpenAPI Specification は、REST APIの「契約書」を記述する標準フォーマットです。OpenAPIを利用することで、API仕様の明確化、ドキュメントやコードの自動生成、契約ベースの開発が可能となり、開発効率と堅牢性を高めることができます。

## 🔄 第5巡（MQTT）との違い

本巡のREST（同期）を理解する上で、第5巡のMQTT（非同期）との比較が重要です。

- **第5巡 (MQTT)**: 非同期 Pub/Sub モデル。メッセージの送信側は、受信側の応答を待たずに処理を進めます（送りっぱなし）。
- **第6巡 (REST)**: 主に 同期 Request/Response モデル。クライアントがサーバーにリクエストを送信し、サーバーからの応答（結果）が返ってくるまで待機します。

この「同期」と「非同期」の根本的な違いが、システム設計にどう影響するかを学びます。

## 🗺️ 本巡の進め方（ページ構成案）

この第6巡は、以下の構成案に沿って、理論から実践的なコード変更、考察までをステップ・バイ・ステップで進めていきます。

- **🎯 はじめに**
    - 第6巡の目的：同期SOAの実装体験
    - なぜREST/OpenAPIか？ (Web API標準、開発ツールの豊富さなど)
    - 第5巡(MQTT)との大まかな違い (非同期Pub/Sub vs 同期Req/Res)
    - この巡でやることの概要
- **🎯 理論：同期 vs 非同期通信**
    - 同期通信 (Synchronous) とは？ (電話の例：相手の応答を待つ)
    - 非同期通信 (Asynchronous) とは？ (メール/郵便の例：送りっぱなし、応答は後で)
    - それぞれのメリット・デメリット（即時性 vs 応答性/耐障害性、結合度）
    - REST (主に同期) と MQTT (非同期) の位置づけ
- **🎯 理論：REST API と OpenAPI**
    - REST (Representational State Transfer) の基本原則（ステートレス、リソース指向、HTTPメソッド活用など）
    - HTTPメソッド (GET, POST, PUT, DELETEなど) の役割
    - OpenAPI Specification とは？ (APIの「契約書」を記述する標準フォーマット)
    - なぜOpenAPIを使うのか？ (ドキュメント自動生成、コード自動生成、契約ベース開発)
- **🎯 ステップ1：OpenAPI 仕様の定義**
    - サービス間の「契約」をOpenAPI形式 (YAMLまたはJSON) で記述する。
    - 例：経路計算サービスが認識サービスに WorldModel を要求するAPI (GET /world_model)
    - 例：車両制御サービスが経路計算サービスに ParkingPlan を要求するAPI (GET /parking_plan)
    - リクエスト/レスポンスのデータ形式（スキーマ）も定義する。
- **🎯 ステップ2：認識サービスの変更 (サーバー側)**
    - 課題: MQTT Publisherを削除し、REST APIサーバーとして WorldModel を提供する必要がある。
    - 実装: Webフレームワーク (例: FastAPI) を導入する。
    - WorldModel を返すAPIエンドポイント (GET /world_model) を持つController (Adapter層) を実装する。
    - Controllerが UseCase を呼び出してデータを取得し、レスポンス形式 (JSON) に変換する (FastAPIが支援)。
    - [main.py](http://main.py/) を修正し、FastAPIサーバーを起動するように変更する。
    - ポイント: UseCase自体は（ほぼ）変更不要なはず。
- **🎯 ステップ3：経路計算サービスの変更 (クライアント & サーバー側)**
    - 課題: MQTT Subscriber/Publisherを削除し、認識サービスへのRESTクライアントと、車両制御サービスへのRESTサーバーの両方を実装する必要がある。
    - 実装 (クライアント側): HTTPクライアント (例: requests) を導入。認識サービスの GET /world_model APIを呼び出すAdapter (REST Client) を実装。
    - UseCase内で、MQTTデータ取得部をREST Client呼び出しに置き換える（同期呼び出し）。
    - 実装 (サーバー側): FastAPIを導入。ParkingPlan を返すAPIエンドポイント (GET /parking_plan) を持つController (Adapter層) を実装。
    - [main.py](http://main.py/) を修正し、FastAPIサーバーを起動するように変更する。
    - ポイント: UseCaseが他のサービスを同期的に呼び出す形になる。
- **🎯 ステップ4：車両制御サービスの変更 (クライアント側)**
    - 課題: MQTT Subscriberを削除し、経路計算サービスへのRESTクライアントを実装する必要がある。
    - 実装: HTTPクライアントを導入。経路計算サービスの GET /parking_plan APIを呼び出すAdapter (REST Client) を実装。
    - UseCase内で、計画取得部分をREST Client Adapter呼び出しに置き換える。
    - [main.py](http://main.py/) を修正する（サーバー機能は不要）。
    - ポイント: 計画取得が同期的になる。
- **🎯 ステップ5：統合実行と考察**
    - 3つのサービス（FastAPIサーバー x2, クライアント x1）を同時に起動する方法。
    - システム全体の動作確認。
    - 同期呼び出しの影響の考察（例：認識サービスが遅いと、経路計算サービスも待たされる）。
    - MQTT版との比較（開発体験、エラーハンドリング、パフォーマンス特性など）。
- **🎯 補足 (Q&A)**
    - REST APIのエラーハンドリング
    - 同期呼び出しのタイムアウト管理
    - REST vs gRPC の比較など。