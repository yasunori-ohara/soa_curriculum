# 07 統合実行と考察

# ステップ5：統合実行と考察

これまでのステップで、3つのサービスすべてをMQTT（非同期）からREST API（同期）ベースのアーキテクチャに改修しました。
最後は、これらすべてを連携させて実行し、同期モデルの影響について考察します。

## 🏃 統合実行

3つのサービスは、それぞれが独立したWebサーバー（またはクライアント）として動作します。これらを同時に起動する必要があります。

### 💡 1. 起動方法

最も簡単な方法は、3つの異なるターミナル（コマンドプロンプト）を起動し、それぞれで各サービスを実行することです。

**ターミナル 1: 認識サービス (サーバー)**

```bash
# recognition_service/ ディレクトリに移動
cd recognition_service/
# ポート8001でサーバーを起動
python main.py
# (出力例) Uvicorn running on <http://0.0.0.0:8001> (Press CTRL+C to quit)

```

**ターミナル 2: 経路計算サービス (サーバー & クライアント)**

```bash
# planning_service/ ディレクトリに移動
cd planning_service/
# ポート8002でサーバーを起動
python main.py
# (出力例) Uvicorn running on <http://0.0.0.0:8002> (Press CTRL+C to quit)

```

**ターミナル 3: 車両制御サービス (クライアント)**

```bash
# control_service/ ディレクトリに移動
cd control_service/
# クライアントの実行ループを開始
python main.py
# (出力例) Starting Control Service (REST Client)...

```

### 💡 2. 動作確認

ターミナル3（車両制御サービス）を起動すると、`EXECUTION_INTERVAL_SECONDS`（例：5秒）ごとに処理が開始されます。
ターミナル3のログに以下のような出力が流れ始めれば成功です。

**(ターミナル 3: 車両制御サービス のログ)**

```
Starting Control Service (REST Client)...
Fetching ParkingPlan from Planning Service...
Executing ParkingPlan (ID: a1b2c3d4-...)....
  Moving to step 1: (x=..., y=..., theta=...)
  ...
ParkingPlan (ID: a1b2c3d4-...) execution complete.
Waiting for 5 seconds before next cycle...
Fetching ParkingPlan from Planning Service...

```

この時、他のターミナルのログも連動して動くはずです。

**(ターミナル 2: 経路計算サービス のログ)**

```
...
Fetching WorldModel from Recognition Service...
Calculating plan based on WorldModel (timestamp: ...)
Parking plan calculated: a1b2c3d4-...
INFO:     127.0.0.1:xxxxx - "GET /parking_plan HTTP/1.1" 200 OK
...

```

**(ターミナル 1: 認識サービス のログ)**

```
...
INFO:     127.0.0.1:xxxxx - "GET /world_model HTTP/1.1" 200 OK
...

```

## 🤔 同期呼び出しの影響と考察

このRESTベースの同期アーキテクチャを動作させることで、第5巡のMQTT（非同期）モデルとの間にいくつかの明確な違いが見えてきます。

### 💡 1. 遅延の伝播（レイテンシー）

最も顕著な違いは「遅延」です。

- 車両制御サービスは `GET /parking_plan` を呼び出します。
- 経路計算サービスは、そのリクエストを処理するために `GET /world_model` を呼び出します。
- 認識サービスが `world_model` を返すまで、経路計算サービスは待機します。
- 経路計算サービスが計算を終えて `parking_plan` を返すまで、車両制御サービスは待機します。

もし認識サービスの処理（`GET /world_model`）に3秒かかった場合、車両制御サービスは、経路計算サービスの処理時間（例：0.5秒）＋認識サービスの処理時間（3秒）＝ 合計3.5秒以上、必ず待たされることになります。
このように、**同期呼び出しは、呼び出し先の遅延が呼び出し元の遅延に直接加算される**特性を持ちます。

### 💡 2. 障害の伝播

遅延と同様に「障害」も伝播します。

- もし認識サービス ( `port:8001` ) が停止したらどうなるでしょうか？
- 経路計算サービスは `GET /world_model` に失敗（タイムアウトや接続拒否）します。
- 結果、経路計算サービスは車両制御サービスに `HTTP 503 Service Unavailable`（ステップ3で実装したエラー）を返します。
- 車両制御サービスは計画を取得できず、アイドル状態になります。

このように、**あるサービスの障害が、そのサービスを同期的に呼び出している別のサービスに即座に伝播**し、システム全体の機能不全（または機能低下）を引き起こします。

### 💡 3. MQTT版（非同期）との比較

| 観点 | 第5巡：MQTT (非同期) | 第6巡：REST (同期) |
| --- | --- | --- |
| **データフロー** | プッシュ型 (Push) <br>データが発生したらPublish | プル型 (Pull) <br>データが必要になったらGET |
| **サービス結合度** | 疎結合 (Decoupled) <br>お互いの稼働を知らない | 密結合 (Tightly Coupled) <br>相手が稼働している前提 |
| **障害耐性** | 高い <br>認識サービスが停止しても、計画サービスは（古いデータで）動き続ける | 低い <br>認識サービスが停止すると、計画サービスも機能停止する |
| **遅延 (レイテンシー)** | 低い（ように見える） <br>各サービスは待機しない | 高い（蓄積される） <br>呼び出しの連鎖で待機時間が増える |
| **開発体験** | 複雑 <br>状態管理やエラー検知が難しい | シンプル <br>処理の流れが直線的で追跡しやすい |

## 💡 まとめ

第6巡では、RESTとOpenAPIを使った同期SOAを構築しました。
このアーキテクチャは、処理の流れが直線的で理解しやすいという大きなメリットがあります。
一方で、サービスの遅延や障害がシステム全体に伝播しやすいというトレードオフも明らかになりました。

現実のシステムでは、即時性が必要な処理（例：今回の計画取得）には「同期」を、時間がかかっても良い処理や耐障害性が重要な処理（例：ログ収集）には「非同期」を、といった形で、両者を適切に使い分ける設計が求められます。