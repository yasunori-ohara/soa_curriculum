# 21 拡張：非同期（実践編）

# ⚡️ 非同期プログラミングへのリファクタリング（実践編）

ここでは、既存のアプリを「同期」→「非同期」にリファクタリングしてみます。

キモはこれです👇

> ビジネスルール（中心）はそのまま。
> 実行の仕方（外側）だけを入れ替える。

これは「UIを差し替える」「DBの実装を変える」と同じノリです。ハードウェアアクセスのやり方も「技術的な詳細」にすぎない、というのを体で感じてもらうステップです。

フォルダ構成はこれまでと同じです：

```text
vending_machine/
├─ domain/
│   ├─ entities.py                # Item / PaymentManager（ビジネスルールの中心）
│   └─ errors.py                  # ドメインルール違反例外（必要なら）
│
├─ usecase/
│   ├─ dto.py                     # InputData / OutputData / ViewModel
│   ├─ boundaries.py              # UseCaseが外部とやり取りする契約（インターフェース群）
│   ├─ insert_coin_usecase.py     # コイン投入ユースケース
│   └─ select_item_usecase.py     # 商品購入ユースケース（←これを非同期化する）
│
├─ interface_adapters/
│   ├─ controller.py              # ユーザー操作をUseCaseに橋渡し
│   ├─ presenter.py               # UseCase結果→ViewModelに整形
│   ├─ view_console.py            # CLIループ（ユーザーとのやり取り）
│   ├─ data_access.py             # InMemory在庫リポジトリ / PaymentManagerリポジトリ
│   └─ hardware_adapter.py        # ハードウェア制御（コンソールで模擬）
│
└─ main.py                        # 依存性を組み立ててアプリを起動する
```

この構成はそのまま維持したまま、非同期対応します。

---

## 🪨 ステップ1：まず「変わらないもの」を確認する

最初に一番大事なことを言います。

> `domain/entities.py` は一行も変えません。

例えば `Item` や `PaymentManager` は、在庫を減らしたり、お釣りを計算したりするだけです。そこには「待ち時間(IO待ち)」がありません。CPUだけで終わる純粋なビジネスロジック（純粋なルール）です。

* `Item.is_in_stock()`
* `Item.dispense()`
* `PaymentManager.process_purchase(item)`
* `PaymentManager.return_change()`

これらは同期/非同期という“実行モデル”とは無関係です。
だから、非同期化の影響は**ドメイン（中心）には波及しません**。

これはクリーンアーキテクチャの美味しいところです。
「ビジネスの核心」は、アプリの実行スタイルに影響されない。

---

## 🔌 ステップ2：境界（usecase/boundaries.py）を非同期対応にする

どこから変えるべきか？
外側です。特にハードウェア制御は「実機に命令を出す」「モーターが回るまで待つ」など、待ち時間が発生します。ここを `async` にします。

`HardwareInterface` をこう変えます：

```python
# vending_machine/usecase/boundaries.py
from abc import ABC, abstractmethod
from vending_machine.domain.entities import Item

class HardwareInterface(ABC):
    @abstractmethod
    async def dispense_item(self, item: Item):
        """
        指定された商品を物理的に排出する。
        非同期I/O（モーター制御やシリアル通信など）を想定。
        """
        raise NotImplementedError

    @abstractmethod
    async def return_change(self, amount: int):
        """
        指定された金額のお釣りを物理的に排出する。
        こちらもハードウェアI/Oになるのでasync。
        """
        raise NotImplementedError
```

変更点はここだけではありません。
`SelectItemInputBoundary`（＝UseCaseの「入口」）も非同期にします。

```python
from abc import ABC, abstractmethod
from vending_machine.usecase.dto import SelectItemInputData

class SelectItemInputBoundary(ABC):
    @abstractmethod
    async def handle(self, input_data: SelectItemInputData):
        """
        商品購入ユースケースのエントリポイント。
        非同期になったハードウェアを呼び出す可能性があるのでasync。
        """
        raise NotImplementedError
```

👍 こうして `UseCase` と `Hardware` のあいだの契約が「非同期の世界」を表現できるようになります。

他のインターフェース（`ItemDataAccessInterface`, `PaymentManagerAccessInterface`, `SelectItemOutputBoundary`）は同期のままでもOKです。
理由：メモリアクセスやPresenter更新は即時で終わるから（I/O待ちではない）。

---

## 🧠 ステップ3：UseCase（select_item_usecase.py）を async 化する

`SelectItemUseCase` はハードウェアを呼ぶ責任者なので、`await`が必要になります。

```python
# vending_machine/usecase/select_item_usecase.py

from vending_machine.usecase.boundaries import (
    SelectItemInputBoundary,
    SelectItemOutputBoundary,
    ItemDataAccessInterface,
    PaymentManagerAccessInterface,
    HardwareInterface,
)
from vending_machine.usecase.dto import SelectItemInputData, SelectItemOutputData

class SelectItemUseCase(SelectItemInputBoundary):
    """
    商品購入（ボタンが押されたとき）のユースケース。
    - 商品があるか確認
    - お金が足りるか確認
    - モーターを回して商品を出す
    - お釣りを返す
    - Presenterに結果を伝える
    """

    def __init__(
        self,
        presenter: SelectItemOutputBoundary,
        item_repository: ItemDataAccessInterface,
        payment_manager_repo: PaymentManagerAccessInterface,
        hardware: HardwareInterface,
    ):
        self._presenter = presenter
        self._item_repository = item_repository
        self._payment_manager_repo = payment_manager_repo
        self._hardware = hardware

    async def handle(self, input_data: SelectItemInputData):
        """
        非同期メソッドになったのは、ハードウェア操作がawaitになるから。
        ビジネスロジック自体は同期処理のまま。
        """

        # 1. 必要なエンティティを集める
        item = self._item_repository.find_by_slot_id(input_data.slot_id)
        if item is None:
            self._presenter.present_failure("指定されたスロットに商品がありません。")
            return

        pm = self._payment_manager_repo.get()

        try:
            # 2. ドメインルールの実行（同期のまま）
            if not item.is_in_stock():
                raise ValueError(f"「{item.name}」は売り切れです。")

            change = pm.process_purchase(item)  # お釣り計算＋残高リセット

            # 3. ハードウェア制御（ここが await）
            await self._hardware.dispense_item(item)
            if change > 0:
                await self._hardware.return_change(change)

            # 4. 在庫減らす・保存（同期でOK）
            item.dispense()
            self._item_repository.save(item)
            self._payment_manager_repo.save(pm)

            # 5. Presenterに成功を伝える（同期のまま）
            output = SelectItemOutputData(
                item_name=item.name,
                change=change,
            )
            self._presenter.present_success(output)

        except ValueError as e:
            # お金不足や売り切れなど
            self._presenter.present_failure(str(e))
```

🥤 大事な観察ポイント：

* `process_purchase()` は同期のまま
* `item.dispense()` も同期のまま
* `await` が必要なのは `hardware` 呼び出しだけ
* `UseCase` の中で async/await が必要になっても、**ビジネスルールそのものは変わらない**

これが「実行モデルは詳細（Detail）である」ということ。

---

## 🤖 ステップ4：Hardware Adapter（interface_adapters/hardware_adapter.py）を async 化する

ここが I/O（外界との対話）なので、`async` 対応させます。
「モーターを回す時間」「コインを払い出す時間」を `asyncio.sleep()` で疑似的に再現します。

```python
# vending_machine/interface_adapters/hardware_adapter.py

import asyncio
from vending_machine.usecase.boundaries import HardwareInterface
from vending_machine.domain.entities import Item

class ConsoleHardwareAdapter(HardwareInterface):
    """
    ハードウェア制御のコンソール版実装。
    実機のかわりにprintでシミュレーションする。
    今回は疑似的なI/O待ちをasyncio.sleepで再現する。
    """

    async def dispense_item(self, item: Item):
        """
        [インターフェースの実装]
        商品を排出するモーターを回す…という想定の処理。
        今回は print と sleep で“それっぽく”待つ。
        """
        print("（商品を排出しています...）")
        await asyncio.sleep(1.0)  # モーターが動作している1秒間
        print(f"（ガコンッ！『{item.name}』を排出しました）")

    async def return_change(self, amount: int):
        """
        [インターフェースの実装]
        お釣りを払い出す…という想定の処理。
        同様に待ち時間を入れる。
        """
        if amount <= 0:
            return
        print("（お釣りを準備しています...）")
        await asyncio.sleep(0.5)  # コイン払い出し0.5秒想定
        print(f"（チャリン！お釣り {amount} 円を返却しました）")
```

ここで行っていることは、こうです：

* `UseCase` は `HardwareInterface` の抽象だけを知っている
* `ConsoleHardwareAdapter` はその抽象を満たす具体実装
* 今回、その具体実装がたまたま「非同期I/O」です
* でも `UseCase` のロジックは壊れない
* もちろん `domain` には一切波及していない

これはつまり、**技術的な詳細はいつでも安全に差し替えられる**ということの実演です。

---

## 🎮 ステップ5：Controller と View も async に合わせる

`View` はユーザー入力を受けて `Controller` を呼び出します。
`Controller` は `UseCase` を呼び出します。

この呼び出しチェーンに `await` を伝播させます。

### controller.py（抜粋・非同期版イメージ）

```python
# vending_machine/interface_adapters/controller.py

from vending_machine.usecase.boundaries import SelectItemInputBoundary
from vending_machine.usecase.dto import SelectItemInputData
from vending_machine.usecase.boundaries import PaymentManagerAccessInterface

class VendingMachineController:
    """
    View から呼ばれる入り口。
    ユーザー操作をUseCaseのInputDataに翻訳し、UseCaseを呼ぶ役。
    """

    def __init__(
        self,
        select_item_use_case: SelectItemInputBoundary,
        payment_manager_repo: PaymentManagerAccessInterface,
    ):
        self._select_item_use_case = select_item_use_case
        self._pm_repo = payment_manager_repo

    async def select_item(self, slot_id: str):
        """
        商品購入ボタンが押された、というイベントをハンドルする。
        非同期UseCaseをawaitする。
        """
        input_data = SelectItemInputData(slot_id=slot_id)
        await self._select_item_use_case.handle(input_data)

    def insert_coin(self, coin: int):
        """
        コイン投入はハードウェアを叩かず、PaymentManagerだけを更新するので同期のままでもOK。
        """
        pm = self._pm_repo.get()
        pm.insert_coin(coin)
        self._pm_repo.save(pm)

    def return_change(self):
        """
        お釣り返却要求も、今回は同期のPaymentManagerロジックで完結させてしまう実装例。
        （もしここでハードウェアを物理的に動かすならasyncにする）
        """
        pm = self._pm_repo.get()
        change = pm.return_change()
        self._pm_repo.save(pm)
        return change
```

ポイントは「ハードウェアに触る可能性がある処理だけ async に寄せる」こと。
（ここでは `select_item` がそれに該当します）

他の操作もハードウェアを巻き込むようにしたいなら、同じように `async def` / `await` にしていけます。

---

### view_console.py（抜粋・非同期版イメージ）

```python
# vending_machine/interface_adapters/view_console.py

class ConsoleView:
    """
    ユーザーとの直接のやり取り担当。
    - 入力を受ける
    - Controllerを呼ぶ（awaitする場合もある）
    - Presenterが更新したViewModelを表示する
    """

    def __init__(self, controller, view_model, payment_manager_repo):
        self._controller = controller
        self._view_model = view_model
        self._pm_repo = payment_manager_repo

    async def run(self):
        """
        メインループ（非同期版）
        """
        while True:
            pm = self._pm_repo.get()
            print("\n--------------------")
            print(f"現在の投入金額: {pm.current_amount}円")
            print("操作を選んでください: [c: コイン投入, s: 商品選択, r: お釣り返却, q: 終了]")
            action = input("> ").lower()

            try:
                if action == "c":
                    coin_str = input("投入する硬貨（10, 50, 100, 500）: ")
                    self._controller.insert_coin(int(coin_str))

                elif action == "s":
                    slot_id = input("購入する商品のスロットID: ")
                    # ← 商品購入はハードウェアを動かすのでawait
                    await self._controller.select_item(slot_id)

                elif action == "r":
                    change = self._controller.return_change()
                    if change > 0:
                        self._view_model.display_text = f"{change}円お返ししました。"
                    else:
                        self._view_model.display_text = "返却する硬貨はありません。"

                elif action == "q":
                    print("ご利用ありがとうございました。")
                    break

                else:
                    self._view_model.display_text = "無効な操作です。"

            except ValueError:
                self._view_model.display_text = "エラー: 不正な入力です。"
            except Exception as e:
                self._view_model.display_text = f"予期せぬエラー: {e}"

            # ループ最後にPresenter/ViewModelが持つ最新メッセージを表示
            self.render()

    def render(self):
        """
        Presenterが整形済みのメッセージをそのまま表示する。
        """
        print(f"ディスプレイ: {self._view_model.display_text}")
```

ここも同じ考え方です。

* ViewはUI担当なので「どの操作はawaitが必要か」を判断してControllerを呼ぶ
* ビジネスルールは一切ここに書かない（それはUseCase側の仕事）

---

## 🚀 ステップ6：main.py（起動部分）を非同期エントリにする

同期版の `main()` はそのまま `async def main()` になります。
そして、エントリポイントで `asyncio.run(main())` を呼びます。

```python
# main.py
import asyncio

from vending_machine.interface_adapters.presenter import VendingMachinePresenter
from vending_machine.interface_adapters.data_access import (
    InMemoryItemRepository,
    InMemoryPaymentManagerRepository,
)
from vending_machine.interface_adapters.hardware_adapter import ConsoleHardwareAdapter
from vending_machine.interface_adapters.controller import VendingMachineController
from vending_machine.interface_adapters.view_console import ConsoleView
from vending_machine.usecase.select_item_usecase import SelectItemUseCase
from vending_machine.usecase.dto import VendingMachineViewModel

async def main():
    # 1. 共有状態（ViewModelやリポジトリ）を準備
    view_model = VendingMachineViewModel()
    item_repo = InMemoryItemRepository()
    pm_repo = InMemoryPaymentManagerRepository()
    hardware = ConsoleHardwareAdapter()

    # 2. Presenter
    presenter = VendingMachinePresenter(view_model)

    # 3. UseCase（非同期用のインスタンス）
    select_item_uc = SelectItemUseCase(
        presenter=presenter,
        item_repository=item_repo,
        payment_manager_repo=pm_repo,
        hardware=hardware,
    )

    # 4. Controller
    controller = VendingMachineController(
        select_item_use_case=select_item_uc,
        payment_manager_repo=pm_repo,
    )

    # 5. View（非同期ループ）
    view = ConsoleView(
        controller=controller,
        view_model=view_model,
        payment_manager_repo=pm_repo,
    )

    # 6. 実行開始
    await view.run()


if __name__ == "__main__":
    asyncio.run(main())
```

ここでのメッセージは、とても大事です：

* `main.py` の責務は「全部品を配線すること」だけ
* どの層がどの層を知っていいのか、という依存関係のルール自体は、同期版と変わっていません
* ただ「一部がasyncだからawaitで呼ぶ」ようにしただけ

---

## 🐛 非同期アプリのデバッグのコツ

async/awaitになると「順番どうなってるの？」って不安になります。
でも基本は同じです。

* `print()` デバッグは普通に有効

  * 「dispense_item入った」「await待ち中」「終わった」を順番に出すだけで状況が追えます
* `logging` モジュールを使うとタイムスタンプ付きで追跡できる
* `asyncio.sleep()` を短くすればテスト高速化ができる
* VSCodeなどのIDEは `async def` にブレークポイントを置けます（ステップ実行可能）

さらに、`asyncio.run()` の前にデバッグ用の環境変数や `asyncio.get_running_loop().set_debug(True)` を使うと、「どのタスクが長く止まってる？」みたいな情報も拾えます。

---

## 🔚 まとめ：実行モデルも詳細である

この章でやったことを振り返ります。

1. `domain/entities.py` は変更なし
   ビジネスルールは何も壊れない
2. `HardwareInterface` を `async` にした
   → これは「外の世界との接点」の話
3. `SelectItemUseCase` を `async def handle` にした
   → ハードウェアを `await` するため
4. View / Controller / main まで `await` を伝播させた
   → UIの呼び出し側も非同期対応に

ここで伝えたいことは一つだけです。

> 実行方法は詳細である。
> (The execution model is a detail.)

自販機が「同期的にガコン」と動くか、「非同期にガコン」と動くかは、あくまで外側の都合です。
在庫チェックのルールや、お釣り計算のルールは、永遠に同じです。

この分離こそが、クリーンアーキテクチャの約束してくれる“変更に強い設計”です。
UIが変わっても、DBが変わっても、ハードウェアが進化しても、同期→非同期に切り替わっても──ビジネスの芯だけは守られる。これで、このカリキュラムの旅はきれいに閉じます。お疲れさまでした。👏
