# 00 はじめに

# 🥤 第５巡：自動販売機で“本質だけ”のクリーンアーキテクチャを構築する

これまで私たちは次の題材でクリーンアーキテクチャを段階的に体得してきました。

* ✅ **第１巡（ToDoアプリ）**
  層構造と依存方向という**基礎原則**を体感。
* ✅ **第２巡・第３巡（図書館システム）**
  現実的なWebアプリ規模でも**同じ原則が通用**することを確認。
  さらに第３巡では、**別設計者の構成**でも「依存は内へ」が保たれる柔軟性を学習。
* ✅ **第４巡（会議室予約アプリ）**
  **整合性・排他・冪等性**など、実務で必須の制約を**層分離のまま扱う**練習を実施。

そして本章では、これまでとは異なる領域である **ハードウェア制御（組込み寄り）**の **「自動販売機」** を題材にします。
目的は、クリーンアーキテクチャが **Webや業務アプリに限らず“どのドメインでも通用する普遍原則”** であることを実感することです。

![クリーンアーキテクチャ](../クリーンアーキテクチャ.png)

---

## 🧭 本章の目的と設計方針

**狙い：原則そのものをクリアに体得。**
そのため、次の方針で進めます。

1. **構造は“最小限”に保つ（しかし原則は不変）**
   　③・④でフォルダ構成のバリエーションを経験済みなので、ここでは**最短の学習導線**に寄せます。
   　層を減らしても、**依存方向（内→外）**と**抽象による分離**は絶対に崩しません。

2. **組込みI/Oをアダプタに集約**
   　ハードウェア（排出モーター、返却ソレノイド等）は**常に外側の詳細（Detail）**。
   　**内側（Entity/UseCase）は装置やプロトコルを知らない**設計を徹底します。

---

## 🗂 フォルダ構成（第５巡）

> ③・④で使った `domain / usecase / interface / infrastructure` の流儀を踏襲しつつ、
> **教育目的で “infrastructure を無くして interface に集約”** します（外部詳細を一望できるようにするための“教材最適化”）。

```text
vending_machine/
├─ domain/
│   ├─ entities.py              # 🍾 Item, 💰 PaymentManager（ビジネスルール）
│   └─ errors.py                # ドメイン固有の例外
│
├─ usecase/
│   ├─ dto.py                   # 📦 InputData / OutputData / ViewModel
│   ├─ boundaries.py            # 🔌 UseCaseが外部に要求する契約（Repository, Hardware, OutputBoundary）
│   ├─ select_item_usecase.py   # 🛒 商品購入
│   └─ insert_coin_usecase.py   # 🪙 コイン投入
│
├─ interface/                   # ← “外の詳細”をここに集約（UI/データ/ハード）
│   ├─ controller.py            # 🎛 入力受付 → UseCase呼び出し
│   ├─ presenter.py             # 🎨 出力整形 → ViewModel
│   ├─ view_console.py          # 📺 コンソールUI（CLI）
│   ├─ data_access.py           # 💾 InMemoryリポジトリ実装
│   └─ hardware_adapter.py      # 🤖 ハード制御のモック（排出・返却）
│
└─ main.py                      # 🧠 依存注入（Composition Root）
```

* **domain**：不変のビジネスルールのみ（外部を一切知らない）
* **usecase**：手続きの司令塔。**必要な外部機能は契約（interface）で要求**する
* **interface**：契約の**具象実装**（UI/データ/ハードを横並びで可視化）
* **main**：どの具象を使うか**最後に組み立てる**

> ※ 用語上の「interface_adapters」と「interface」は同義扱いです。本巡では**短く“interface”**に統一。

---

## 🔄 Repository定義の位置づけ（②→③/④→本巡の踏襲）

②では `domain/repository.py`（抽象）＋`infrastructure/...`（具象）でした。
③・④で **抽象を `usecase/contracts`（本巡では `usecase/boundaries.py` に統合）** へ移し、具象をアダプタ層へ寄せる流儀を導入済み。
**本巡もそれを踏襲**します。

| 役割                 | 置き場所                    | 例                                                                      |
| ------------------ | ----------------------- | ---------------------------------------------------------------------- |
| 抽象（契約 / interface） | `usecase/boundaries.py` | `ItemRepository`, `HardwareInterface`, `SelectItemOutputBoundary`      |
| 具象（実装）             | `interface/*.py`        | `InMemoryItemRepository`, `ConsoleHardwareAdapter`, `ConsolePresenter` |

**意図**：

* Domainは純化（外部を一切知らない）
* UseCaseが**欲しい機能を宣言**し、差し替え可能性を内側から確保
* 具象は常に外側で差し替え

---

## 🧠 層の役割（概観）

* **domain/**
  在庫が0なら販売不可、金額が不足なら販売不可、など**純粋な制約**のみ。
* **usecase/**
  「コイン投入→選択→在庫更新→ハード駆動→お釣り表示」等の**手続き**を組み立てる。
  直接ハードを触らず **`HardwareInterface` に依頼**。
* **interface/**
  UI/データ/ハードの**現実詳細**をまとめて実装。
  テストではモックで差し替え可能。
* **main.py**
  依存を**内→外の順に接続**して起動（ビジネスロジックは書かない）。

---

## 🛡 本巡で守る５原則

1. **Domainは他層に依存しない**（純粋ロジックのみ）
2. **UseCaseは司令塔**（自分で処理せず、契約で依頼）
3. **契約は内側が定義し外側が従う**（DIPをコードで表す）
4. **UI/データ/ハードは常に“詳細”**（いつでも差し替え可能）
5. **実機がなくてもテスト可能**（ハードはインターフェース越しにモック）

---

## 🚀 次のステップ

この後の章では、次の順に組み立てます。

1. `01 Entities` — **Item / PaymentManager**（ドメイン制約の定義）
2. `02 UseCase` — 購入・投入の**手続き**設計
3. `03 Boundaries` — **契約の明文化**（依頼の入口を固定）
4. `04 Interface` — **具象**（UI/データ/ハード）を横並び実装
5. `05 Main` — **依存注入と起動**

> **最終目標**
> 外部装置や保存先を“詳細”として扱い、**ビジネスロジックを完全に独立**させる。

