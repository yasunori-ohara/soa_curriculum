# 01 通信基盤の準備

# 🚀 ステップ1：通信基盤（MQTTブローカー）の準備

第5巡（実通信）へようこそ。
最初のステップとして、3つのサービスがメッセージを交換するための中継局、**MQTTブローカー (Broker)** を起動します。

---

## 🎯 このステップのゴール

- 第4巡の「共有ファイル（`world_model.json` など）」の代わりとなる、「通信の中継局」をローカル環境で起動する。

---

## 🛠️ 使用するツール：Docker と Mosquitto

サービス間の通信を中継するソフトウェア（ブローカー）は色々ありますが、今回は **Mosquitto** （モスキート）という、世界中で広く使われている軽量なMQTTブローカーを使用します。

これを自分のPCに直接インストールすると環境が複雑になるため、これまでの学習（DBなど）と同様に、**Docker** を使って簡単に起動・破棄できるようにします。

---

## 🧩 手順1：設定ファイルの作成

まず、DockerでMosquittoを起動するための設定ファイル2つを、プロジェクトのルートフォルダ（`run_all_services.py` がある場所）に作成します。

### 1. ブローカーの設定ファイル (`mosquitto/config/mosquitto.conf`)

Mosquittoに「誰でも（認証なしで）接続を許可する」という設定ファイルを作成します。

まず、プロジェクトルートに `mosquitto` フォルダを作り、その中に `config` フォルダを作成します。

```bash
mkdir -p mosquitto/config

```

次に、以下の内容で `mosquitto/config/mosquitto.conf` ファイルを新規作成します。

```
# mosquitto/config/mosquitto.conf

# -----------------------------------------------------------------------------
# Mosquitto MQTT Broker Configuration
# -----------------------------------------------------------------------------

# --- 接続設定 ---
# 1883番ポートで、すべてのIPアドレス(0.0.0.0)からの接続を待ち受ける
listener 1883 0.0.0.0

# --- 認証設定 ---
# (学習用) 匿名ユーザー(認証なし)の接続を許可する
allow_anonymous true

# --- 永続化設定 ---
# (学習用) データを永続化しない (ブローカー再起動でメッセージは消える)
persistence false

```

- **listener 1883**: `1883`はMQTT通信の標準ポート番号です。
- **allow\_anonymous true**: 学習用として、IDやパスワードなしで接続できるようにします。（本番環境では `false` にして認証が必須です）

### 2. Docker Compose の設定ファイル (`docker-compose.yml`)

次に、この設定ファイル（`mosquitto.conf`）を使ってMosquittoのDockerコンテナを起動するための指示書、`docker-compose.yml` をプロジェクトルートに作成します。

（※もしプロジェクトルートに既に `docker-compose.yml` がある場合は、`services:` の下に `mqtt-broker:` のブロックを追記してください。）

```yaml
# docker-compose.yml (プロジェクトルートに作成)

version: '3.8'

services:
  # ---------------------------------------------------------------------------
  # MQTT Broker (Mosquitto)
  # - クラス図の位置: - (システム外部の基盤)
  # - 同心円図の位置: 最も外側 (Frameworks & Drivers のさらに外)
  # ---------------------------------------------------------------------------
  mqtt-broker:
    # eclipse-mosquitto という公式Dockerイメージを使用する
    image: eclipse-mosquitto:2.0

    # コンテナの名前
    container_name: mqtt_broker

    # ポートフォワーディング設定
    ports:
      # PC(ホスト)の1883番ポートを、コンテナの1883番ポートにつなぐ
      - "1883:1883"

    # ボリューム（設定ファイルのマウント）
    volumes:
      # 先ほど作成したmosquitto.confを、コンテナ内の正しい位置に配置する
      - ./mosquitto/config/mosquitto.conf:/mosquitto/config/mosquitto.conf

    # 常に再起動する設定
    restart: always

```

---

## 🚀 手順2：MQTTブローカーの起動

設定ファイルが2つ準備できたら、ターミナルでプロジェクトルートに移動し、以下のコマンドを実行します。

```bash
docker-compose up -d

```

- `d` は「デタッチモード」を意味し、ターミナルを占有せず、バックグラウンドで起動し続けてくれます。

### 動作確認

起動したら、`docker ps` コマンドでコンテナが動いているか確認します。

```bash
$ docker ps
CONTAINER ID   IMAGE                     COMMAND                  CREATED          STATUS          PORTS                    NAMES
a1b2c3d4e5f6   eclipse-mosquitto:2.0     "/docker-entrypoint.…"   10 seconds ago   Up 9 seconds    0.0.0.0:1883->1883/tcp   mqtt_broker

```

`STATUS` が `Up` になっていれば、MQTTブローカーの起動は成功です。
これで、3つのサービスがデータを交換するための中継局（`localhost:1883`）が準備できました。

---

## 🛡️ このステップの鉄則

**通信を始める前に、まず中継局を確保せよ。**

サービス同士が直接通信（1対1）すると、相手の「住所（IPアドレス）」や「生死」を互いに管理する必要があり、システムが複雑になります。

ブローカー（中継局）を中央に置くことで、各サービスは「ブローカーの住所」だけを知っていればよくなり、お互いを意識する必要がなくなります。これがPub/Sub（疎結合）の基本です。

---

次は、「ステップ2：認識サービスのアダプタ差し替え」に進み、`FileWorldModelPublisher` を `MqttWorldModelPublisher` に置き換えていきましょう。