# 00 はじめに

# 🚀 第5巡：実通信（MQTT）への進化

第4巡では、「認識」「経路計算」「制御」という3つの独立したサービスを構築し、それらを「ファイルI/O（JSON）」というアダプタで連携させる、SOA（サービス指向アーキテクチャ）のシミュレーションを完成させました。

この第5巡では、いよいよ「シミュレーション」から「実践」へとステップアップします。第4巡で学んだクリーンアーキテクチャの最大の利点である「アダプタの差し替え可能性」を実証するため、サービス間の連携をファイルI/Oから**実ネットワーク通信**に置き換えます。

---

## 🎯 なぜPub/Sub（MQTT）なのか？

サービス間通信には、REST（同期）やgRPC（同期）、MQTT（非同期）など、様々な方式があります。このカリキュラムでは、その中から **MQTT** を使った **Pub/Sub（Publish/Subscribe）** パターンを採用します。

その理由は、第4巡で構築した私たちの設計思想（ファイル連携）と、MQTTの非同期モデルが**完全に一致**しているからです。

| 比較 | 第4巡（ファイル連携） | 第5巡（MQTT連携） |
| --- | --- | --- |
| **役割** | 認識サービスが `world_model.json` に書き込む。 | 認識サービスが `world_model` トピックに **Publish**（公開）する。 |
| **役割** | 経路計算サービスが `world_model.json` を読む。 | 経路計算サービスが `world_model` トピックを **Subscribe**（購読）する。 |
| **方式** | **非同期**（お互いのタイミングを気にしない） | **非同期**（お互いのタイミングを気にしない） |
| **結合** | 疎結合（ファイルという「媒体」を介する） | 疎結合（ブローカーという「中継局」を介する） |

もし、ここでREST（HTTPリクエスト）のような「同期」方式を採用してしまうと、経路計算サービスが認識サービスを「呼び出す」形になり、第4巡で構築したUseCaseのロジック（`handle()` を実行するだけ）を根本的に変更する必要が出てきてしまいます。

MQTTを採用することで、私たちは **UseCaseのロジック（`application/`）を1行も変更することなく**、`adapters/` フォルダ内の実装を差し替えるだけで、システムをネットワーク対応に進化させることができます。

これは、クリーンアーキテクチャが目指した「ビジネスロジックを技術的詳細から守る」という目的の、完璧な実証となります。

---

## 🛰️ MQTT（Pub/Sub）の仕組み：中継局（ブローカー）

MQTT (Message Queuing Telemetry Transport) は、IoTや自動運転の分野で広く使われている、非常に軽量なPub/Subプロトコルです。

Pub/Subモデルは、「新聞社」と「購読者」の関係に似ています。

1. **ブローカー (Broker)**:
「新聞の配送センター（中継局）」です。すべての通信はここを経由します。
2. **トピック (Topic)**:
「新聞の銘柄（例：`/world_model` や `/plan`）」です。
3. **Publisher（公開者）**:
新聞記者（例：認識サービス）が、記事（データ）を特定のトピック（`/world_model`）宛にブローカーへ送ります。
4. **Subscriber（購読者）**:
読者（例：経路計算サービス）が、読みたいトピック（`/world_model`）をブローカーに「購読予約」しておきます。

ブローカーは、`/world_model` トピックに新しい記事が届くと、それを購読予約していたすべての読者（経路計算サービス）に一斉に配送します。

ポイントは、**新聞記者（認識サービス）は、読者（経路計算サービス）が誰なのか、何人いるのかを一切知らない**ことです。ただ中継局（ブローカー）に送るだけです。これが「疎結合」な設計です。

---

## 📖 この第五巡のアプローチ：アダプタの差し替え

この第5巡では、以下のステップで進めます。

1. **MQTTブローカーのセットアップ**:
通信の中継局となる「Mosquitto」というMQTTブローカーを、Dockerを使って簡単に起動します。
2. **認識サービスのアダプタ変更**:
`adapters/file_publisher.py` を、`adapters/mqtt_publisher.py` に差し替えます。
3. **経路計算サービスのアダプタ変更**:
`adapters/file_subscriber.py` を `adapters/mqtt_subscriber.py` に、
`adapters/file_publisher.py` を `adapters/mqtt_publisher.py` に差し替えます。
4. **車両制御サービスのアダプタ変更**:
`adapters/file_subscriber.py` を `adapters/mqtt_subscriber.py` に差し替えます。
5. **統合実行**:
3つのサービスを（`run_all_services.py` を使って）同時に起動し、ファイルではなくネットワーク経由で連携することを確認します。

---

## 🛡️ この第五巡で得られる学び

第4巡の最後で触れた「現実の課題」に、私たちは本格的に取り組むことになります。

1. **ネットワークの不安定さとの戦い**:
ファイルI/Oと違い、MQTTブローカーへの接続は失敗する可能性があります（ブローカーがダウンしている、ネットワークが切断された、など）。
アダプタ層に「自動再接続」や「エラーハンドリング」のロジックを組み込むことで、UseCaseを守りながら「回復性（Resilience）」の高いシステムを構築する方法を学びます。
2. **厳格な契約（シリアライズ）**:
ファイル連携ではJSON（テキスト）を使いました。MQTTでは、より高速な通信のためにデータをバイナリ形式（バイト列）に変換（**シリアライズ**）する必要があります。
（※今回は学習の容易さのため、JSONをそのままテキストとして送受信しますが、これが将来 Protobuf などに置き換わる「シリアライズ層」であることを意識します）
3. **サービスディスカバリ（住所録）**:
「ブローカーのIPアドレス（住所）はどこか？」という問題（サービスディスカバリ）も発生します。今回は、この「住所」を環境変数（設定）としてアダプタに渡す方法を学びます。

さあ、ファイルという「シミュレーション」の世界から、ネットワークという「現実」の世界へ、システムを進化させましょう！