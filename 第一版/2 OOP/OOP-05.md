# OOP-05 : インターフェースと継承の役割

`OOP-03` と `OOP-04` では、「インターフェース（抽象クラス）」と「継承」というOOPの重要な概念を同時に、そして密接に連携させて使用しました。

なぜ `Store` は `PhysicalProduct` と `DigitalProduct` を区別せずに扱えた（＝ポリモーフィズム）のでしょうか？
それは、「インターフェース」と「継承」が、車の両輪のような関係で機能しているからです。

この関係を、**契約書**に例えてみましょう。

## 🎯 この章のゴール

  * 「インターフェース」の役割が「契約の定義」であることを理解する。
  * 「継承」の役割が「契約の履行（署名）」であることを理解する。
  * ポリモーフィズムが、この2つの仕組みの上になりたっていることを学ぶ。

-----

## 📜 1. インターフェースの役割：「契約書」を定義する

`Product(ABC)` という抽象基底クラスは、**インターフェース**として機能しています。

これは、「これから『商品』として扱われるクラスは、以下の項目（メソッド）を必ず持たなければならない」という**契約書**を定義しているのと同じです。

#### logic.py (Product 抽象クラスの契約)
```python
class Product(ABC):
    # ...
    @abstractmethod
    def check_stock(self, quantity: int) -> bool:
        """【契約】在庫を確認する能力"""
        pass

    @abstractmethod
    def reduce_stock(self, quantity: int):
        """【契約】在庫を減らす能力"""
        pass
    
    @abstractmethod
    def is_stock_managed(self) -> bool:
        """【契約】在庫管理対象か報告する能力"""
        pass
    
    @abstractmethod
    def get_stock(self) -> int:
        """【契約】在庫数を数値で報告する能力"""
        pass
```

*（※`OOP-06` でLSP修正後の、より厳密な契約書を掲載しています）*

この契約書があるおかげで、`Store` クラスは「この `product` 変数の中身が何であれ、『商品』の契約を守っているはずだ。だから、安心して `check_stock()` を呼び出そう」と信頼して仕事を任せることができます。

-----

## ✍️ 2. 継承の役割：契約書に「署名」し「実装」する

`PhysicalProduct` や `DigitalProduct` が `Product` を**継承**する (`class PhysicalProduct(Product):`) というコードは、この契約書に**署名する行為**に相当します。

署名したクラスは、契約書で定められた全ての抽象メソッド（`@abstractmethod`）を、具体的に実装する**義務**を負います。

  * **`PhysicalProduct` の署名と実装:**
    「私は『商品』契約に署名します。契約書通り、`check_stock` は物理在庫（`_stock`）と比較し、`get_stock` はその数値を返します」
  * **`DigitalProduct` の署名と実装:**
    「私も『商品』契約に署名します。契約書通り、`check_stock` は常に `True` を返し、`get_stock` は `0` を返します」

**継承**は、この契約（インターフェース）を守ることを宣言し、その具体的な内容を実装するための\*\*メカニズム（手段）\*\*なのです。

-----

## ✨ まとめ

| 概念 | 役割 | コード上の表現 |
| --- | --- | --- |
| **インターフェース** | **ルール・契約**を定義する | `Product(ABC)` |
| **継承** | その契約を**守ることを宣言**し、実装する | `class PhysicalProduct(Product):` |

結論として、`OOP-04` の変更は\*\*「インターフェースとして定義された契約を、継承というメカニズムを使って、それぞれのクラスが独自に実装した」\*\*と言うことができます。

`Store` は「契約書（インターフェース）」だけを見て仕事をするため、相手の「実装（`Physical` か `Digital` か）」を気にする必要がないのです。これこそが、ポリモーフィズムが実現される仕組みの核心です。