# OOP-10 : OOPのまとめとクリーンアーキテクチャへの橋渡し

これまでのリファクタリング（`OOP-01` 〜 `OOP-09`）を通して、私たちのコードは劇的に改善されました。この章の最後に、私たちが実践してきたことの本質的な意味と、それが次のステップ（クリーンアーキテクチャ）にどう繋がるのかを整理します。

## 🎯 この章のゴール
* これまでのリファクタリングが「依存関係の制御」であったことを理解する。
* 「制御の流れ」と「依存の方向」が逆転するOOPの強力なメカニズムを、「コンセント」のアナロジーで理解する。
* 「`main.py` の変更を減らす」ことの本質的な意味を知り、クリーンアーキテクチャへの準備を完了する。

---

## 🤔 質問： `main.py` の変更を減らすのが目的だった？

> 「ここまでの改良は『`main.py` の変更が少なくなるようにしている』ように思うのですが、これは次のクリーンアーキテクチャの考えにも通じるものですか？」

はい、その通りです。その気づきは、**クリーンアーキテクチャの魂そのもの**と言っても過言ではないほど、本質を捉えています。

これまでのリファクタリング（DIP、リポジトリ、Factory）は、一見すると「`main.py` の変更を減らす」という目的のように見えます。しかし、その根底にある思想は、まさしくクリーンアーキテクチャへと直接つながるものです。

### 共通する思想：「誰が、誰に依存するべきか？」

私たちの目的は、「**上位の安定した方針（Policy）は、下位の不安定な詳細（Detail）に依存してはならない**」という、一貫した原則を守るためでした。

クリーンアーキテクチャの世界では、何が「方針」で、何が「詳細」かを明確に定義します。

* **方針 (Policy / ビジネスルール):**
    `Store` や `Product` が持つ「在庫がなければ売れない」といったビジネスの本質。これらは頻繁には変わりません。
* **詳細 (Detail / インフラ):**
    `main.py`、`InMemoryOrderRepository`、`print`文、フレームワーク、データベース。これらはビジネスの本質ではなく、目的を達成するための「道具」であり、交換される可能性があります。



クリーンアーキテクチャの図が示す通り、**`main.py` はアプリケーションの「詳細」の最も外側に位置する存在**なのです。

私たちが「`main.py` の変更が少なくなるように」してきたのは、`main.py` が特別だからではありません。それは、`main.py` が「詳細」であり、**「方針」であるビジネスロジック（`Store` など）を、「詳細」の変更から守ってきた**結果なのです。

---

## 🔌 「依存の逆転」という魔法： コンセントのアナロジー

では、なぜ「方針（`Store`）」が「詳細（`InMemoryOrderRepository`）」を利用しているのに、`Store` は `InMemoryOrderRepository` を知らなくて済むのでしょうか？

それは、「**制御の流れ**」と「**依存の方向**」を分離・逆転させる「インターフェース」という魔法を使ったからです。

### 1. ➡️ 制御の流れ (Control Flow)
これは、プログラムが**実行される時**の、実際の処理の順番です。
1.  `Store` が `_order_repository.save()` を呼び出す。
2.  その実体である `InMemoryOrderRepository` の `save()` が実行される。
処理の流れは、`Store` → `InMemoryOrderRepository` と、上位から下位へと流れています。

### 2. ⬅️ 依存の方向 (Dependency Direction)
これは、ソースコード上での**「どちらが、どちらの存在を知っているか」**という静的な関係です。

* `Store` クラスは、`IOrderRepository` という**抽象的なインターフェース**しか知りません。
* `InMemoryOrderRepository` クラスは、`IOrderRepository` という**抽象的なインターフェース**を実装する（知っている）責任を負っています。

ソースコード上の依存関係は、 `Store` → `IOrderRepository` ← `InMemoryOrderRepository` となっており、両者とも**抽象**に依存しているのです。



### 壁のコンセントと家電製品
この関係は、**壁のコンセントと家電製品**に例えることができます。

* **コンセントの穴の形 = インターフェース (`IOrderRepository`)**
    これは「電力を供給する」という、標準化された**約束事（抽象）**です。
* **家電製品のプラグ = 実装クラス (`InMemoryOrderRepository`)**
    家電メーカーは、この標準的なコンセントの形に合わせてプラグを実装します。
* **電気の流れ = 制御の流れ**
    電気は、壁のコンセントから家電製品へと流れます。
* **依存の方向**
    家電製品（`InMemoryOrderRepository`）は、壁のコンセントの形（`IOrderRepository`）に依存しています。壁（`Store`）は、特定の家電（`InMemoryOrderRepository`）の存在を一切知りません。

このインターフェースという「標準化されたコンセント」があるおかげで、私たちは壁を工事することなく、様々な家電製品（メモリ保存、DB保存）を自由に差し替えることができるのです。

---

## 🚀 次のステージへ
私たちは、この強力な「依存関係の逆転」を、クラスという小さなスケールで実践してきました。

* `Store`（方針）は `PhysicalProduct`（詳細）に依存しない
* `Store`（方針）は `InMemoryOrderRepository`（詳細）に依存しない
* `main.py`（詳細）は `PhysicalProduct`（詳細）に依存しない

この「**ビジネスの核心（方針）を、技術的詳細から守る**」というルールを、アプリケーションの**すべての境界（ビジネスロジック vs データベース、ビジネスロジック vs UIなど）**で徹底的に適用したものが、次の章で学ぶ**クリーンアーキテクチャ**の全体像なのです。