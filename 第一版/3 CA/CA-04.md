# CA-04

```markdown
## `use_cases/process_order.py` (ユースケース)

ここがアプリケーション固有のロジックを司る、非常に重要なレイヤーです。

---
### 1. このファイルの役割：ビジネスフローの指揮者 (Use Cases レイヤー)

この`use_cases/process_order.py`ファイルは、クリーンアーキテクチャの同心円の中で2番目に位置するUse Cases（ユースケース）レイヤーです。

その役割は、ユーザーがこのシステムで「何ができるか」を定義し、その目的を達成するための**具体的な手順（ビジネスフロー）**を指揮することです。

このレイヤーは、内側の**Entities（エンティティ）と、先ほど定義したInterfaces（インターフェース）を使って仕事を進めます。重要なのは、この指揮者が「どうやって」データベースに保存するか、「どうやって」**ユーザーに結果を表示するかといった、外側の世界の具体的な方法を一切知らない、という点です。

### 2. ソースコードの詳細解説

#### `ProcessOrderUseCase` クラス: 「注文を処理する」という一つの仕事
このクラスは、「注文を処理する」という、ただ一つのアプリケーションのユースケース（仕事）に責任を持ちます。

#### `__init__(self, product_repo: ProductRepository)`: 依存性の注入 (DI)
このクラスは、自身でリポジトリ（InMemoryProductRepositoryなど）を生成しません。代わりに、外部から抽象的なProductRepositoryインターフェースを受け取ります。これを**依存性の注入（Dependency Injection）**と呼びます。  
これにより、このユースケースは「具体的なDBの実装」から完全に切り離され、テストが非常に容易になります。

#### `execute(self, product_id: str, quantity: int) -> dict`: ユースケースの実行
これが、この指揮者の具体的な仕事の手順です。

1. リポジトリを使ってエンティティを取得: 抽象的な`product_repo`に依頼して、`Product`エンティティ（ビジネスの核心）を見つけます。

2. エンティティに仕事をさせる: 見つけてきた`Product`エンティティ自身に、「在庫を確認しろ(`check_stock`)」「在庫を減らせ(`reduce_stock`)」と命令します。ユースケース自身が在庫計算のロジックを持つのではなく、エンティティに仕事を委譲するのがポイントです。

3. リポジトリを使ってエンティティを保存: 状態が変化した`Product`エンティティを、再び抽象的な`product_repo`に渡して「これを保存しておけ」と命令します。

4. 結果を返す: 処理結果を、特定のフレームワークに依存しない、単純なデータ構造（辞書）で返します。

### 3. このレイヤーの鉄則

内側にのみ依存: `domain`や同じ`use_cases`レイヤーのファイルには依存しますが、外側の`interface_adapters`や`main.py`には決して依存しません。

エンティティを指揮する: コアなビジネスルール（例：在庫が足りるかの計算）はエンティティに任せ、自身はその実行順序などを管理する指揮者に徹します。

抽象と対話する: 外部の世界とは、`interfaces.py`で定義された抽象的なインターフェースを通じてのみ対話します。

### `use_cases/process_order.py`
``` Python
# 依存性のルール:
# このファイルはUse Casesレイヤーに属します。
# したがって、自分より内側のレイヤー（domain）と、同じレイヤーのファイル
# （interfaces.py）にのみ依存することが許されます。

from domain.product import Product
from .interfaces import ProductRepository

class ProcessOrderUseCase:
    """
    【Use Casesレイヤー】
    「注文を処理する」という単一のユースケース（アプリケーションの目的）
    に責任を持つクラス。
    
    このクラスは、アプリケーション固有のビジネスルールを指揮します。
    ただし、どのようにデータを永続化するか（DBの種類など）や、
    どのようにユーザーに結果を表示するか（Webか、CLIか）は知りません。
    """
    
    def __init__(self, product_repo: ProductRepository):
        """
        コンストラクタで、外部の世界との窓口となるリポジトリの「抽象」を受け取ります。
        これを「依存性の注入（Dependency Injection）」と呼びます。
        
        具体的な実装（例：InMemoryProductRepository）ではなく、
        抽象（ProductRepository）に依存することが、このアーキテクチャの鍵です。
        """
        self.product_repo = product_repo

    def execute(self, product_id: str, quantity: int) -> dict:
        """
        ユースケースを実行するためのメインメソッド。
        
        引数と返り値は、特定のフレームワークに依存しない、
        単純なデータ型（プリミティブ型や辞書など）であるべきです。
        """
        # 1. 永続化層（リポジトリ）を使って、ドメインオブジェクトを見つける
        product = self.product_repo.find_by_id(product_id)
        if not product:
            raise ValueError("指定された商品が見つかりません。")

        # 2. ドメインオブジェクト（エンティティ）にビジネスルールを実行させる
        if not product.check_stock(quantity):
            raise ValueError(f"{product.name}の在庫が不足しています。")
            
        product.reduce_stock(quantity)

        # 3. 状態が変化したドメインオブジェクトを、再びリポジトリに渡して永続化する
        self.product_repo.save(product)
        
        # 4. 処理結果を、特定の技術に依存しない単純な辞書として返す
        return {
            "product_name": product.name,
            "quantity": quantity,
            "total_price": product.price * quantity,
            "message": "注文が正常に処理されました。"
        }
```

```