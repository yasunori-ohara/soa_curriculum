# CA-04: 🟢 Use Cases レイヤー (2/2)
### ロジック (use\_cases/process\_order\_use\_case.py)

`CA-03` で、`Use Cases` レイヤーが必要とする「契約書（インターフェース）」を定義しました。
いよいよ、この `Use Cases` レイヤーの核心である「ビジネスフロー（ロジック）」を実装します。

## 🎯 この章のゴール

  * `Use Cases` レイヤーが、アプリケーションの「目的（例：注文処理）」を担うことを理解する。
  * **依存性の注入 (DI)** を使って、`__init__` で「抽象（インターフェース）」を受け取る方法を学ぶ。
  * `execute` メソッドが、`domain`（エンティティ）と `interfaces`（リポジトリ）だけを使って、純粋なビジネスフローを指揮する様子を実装する。
  * ユースケースが、`print` などの「技術的詳細」から完全に分離されていることを体感する。

-----

## 🎼 このファイルの役割：ビジネスフローの指揮者

この `process_order_use_case.py` ファイルは、クリーンアーキテクチャの同心円の中で2番目に位置する `Use Cases` レイヤーの本体です。

その役割は、ユーザーがこのシステムで「何ができるか（＝注文を処理する）」を定義し、その目的を達成するための\*\*具体的な手順（ビジネスフロー）\*\*を指揮することです。

`OOP` での `Store.process_order` メソッドの責任を、この `ProcessOrderUseCase` クラスが引き継ぎます。
重要なのは、この指揮者（ユースケース）が「どうやって」データベースに保存するか（`InMemory`? `MySQL`?）、また「どうやって」ユーザーに結果を表示するか（`print`? `JSON`?）といった、外側の世界の具体的な方法を一切知らない、という点です。

-----

## 💻 ソースコードの詳細解説

### `ProcessOrderUseCase` クラス

「注文を処理する」という、ただ一つのアプリケーションのユースケース（仕事）に責任を持ちます。

### `__init__(self, product_repo: IProductRepository, order_repo: IOrderRepository)`

このクラスは、`OOP-09` の「コンセントのアナロジー」で学んだように、必要な「鍵穴（インターフェース）」をコンストラクタで受け取ります。

  * 自分で `InMemoryProductRepository` などの「具象クラス」を生成しません。
  * 外部から `IProductRepository` と `IOrderRepository` という「抽象」を受け取ります。
  * これを\*\*依存性の注入（Dependency Injection: DI）\*\*と呼びます。

これにより、このユースケースは「具体的なDBの実装」から完全に切り離され、テストが非常に容易になります。

### `execute(self, product_id: str, quantity: int) -> dict`

これが、この指揮者の具体的な仕事の手順です。

1.  **リポジトリを使ってエンティティを取得:** `product_repo` に依頼して、`Product` エンティティ（宝物）を見つけます。
2.  **エンティティに仕事をさせる:** `Product` エンティティ自身に、「在庫を確認しろ (`check_stock`)」「在庫を減らせ (`reduce_stock`)」と命令します。ユースケース自身が在庫計算のロジックを持つのではなく、`domain`（エンティティ）に仕事を委譲するのがポイントです。
3.  **状態変更を保存:** 状態が変化した `Product` エンティティを、`product_repo` に渡して「これを保存しておけ」と命令します。
4.  **新しいエンティティを作成:** `domain` の `Order` エンティティを作成します。
5.  **新しいエンティティを保存:** `order_repo` に依頼して、新しい `Order` エンティティを保存します。
6.  **結果を返す:** 処理結果を、特定のフレームワークに依存しない、単純なデータ構造（辞書）で返します。`print` や `JSON` 化は、このクラスの責任ではありません。

-----

## 🏛️ このレイヤーの鉄則

1.  **内側にのみ依存:** `domain` や同じ `use_cases` レイヤーのファイル（`interfaces.py`）には依存しますが、外側の `interface_adapters` や `infrastructure` には決して依存しません。
2.  **エンティティを指揮する:** コアなビジネスルール（例：在庫が足りるかの計算）はエンティティに任せ、自身はその実行順序などを管理する指揮者に徹します。
3.  **抽象と対話する:** 外部の世界とは、`interfaces.py` で定義された抽象的なインターフェース（リポジトリ）を通じてのみ対話します。

-----

## 📄 `use_cases/process_order_use_case.py` の実装

```python:use_cases/process_order_use_case.py
# 依存性のルール:
# このファイルは Use Cases レイヤーに属します。
# したがって、自分より内側のレイヤー（domain）と、
# 同じレイヤーのファイル（interfaces.py）にのみ依存することが許されます。

from domain.product import Product
from domain.order import Order
from .interfaces import IProductRepository, IOrderRepository

class ProcessOrderUseCase:
    """
    【Use Casesレイヤー】
    「注文を処理する」という単一のユースケース（アプリケーションの目的）
    に責任を持つクラス。
    
    このクラスは、アプリケーション固有のビジネスルールを指揮します。
    ただし、どのようにデータを永続化するか（DBの種類など）や、
    どのようにユーザーに結果を表示するか（Webか、CLIか）は知りません。
    """
    
    def __init__(self, 
                 product_repo: IProductRepository, 
                 order_repo: IOrderRepository):
        """
        コンストラクタで、外部の世界との窓口となるリポジトリの「抽象」を受け取ります。
        これを「依存性の注入（Dependency Injection）」と呼びます。
        
        具体的な実装（例：InMemoryProductRepository）ではなく、
        抽象（IProductRepository）に依存することが、このアーキテクチャの鍵です。
        """
        self.product_repo = product_repo
        self.order_repo = order_repo

    def execute(self, product_id: str, quantity: int) -> dict:
        """
        ユースケースを実行するためのメインメソッド。
        
        引数と返り値は、特定のフレームワークに依存しない、
        単純なデータ型（プリミティブ型や辞書など）であるべきです。
        """
        try:
            # 1. 永続化層（リポジトリ）を使って、ドメインオブジェクトを見つける
            product = self.product_repo.find_by_id(product_id)
            if not product:
                # このレイヤーは print() をしない。例外を発生させるか、
                # 失敗を示す戻り値を返す（今回は例外を選択）
                raise ValueError("指定された商品が見つかりません。")

            # 2. ドメインオブジェクト（エンティティ）にビジネスルールを実行させる
            if not product.check_stock(quantity):
                raise ValueError(f"{product.name}の在庫が不足しています。")
                
            product.reduce_stock(quantity)

            # 3. 状態が変化したドメインオブジェクトを、再びリポジトリに渡して永続化
            self.product_repo.save(product)
            
            # 4. 新しいドメインオブジェクト（Order）を作成する
            order = Order(
                product_name=product.name,
                quantity=quantity,
                total_price=product.price * quantity
            )
            
            # 5. 新しいドメインオブジェクトを、別のリポジトリに渡して永続化
            self.order_repo.save(order)
            
            # 6. 処理結果を、特定の技術に依存しない単純な辞書として返す
            return {
                "success": True,
                "product_name": product.name,
                "quantity": quantity,
                "total_price": product.price * quantity
            }
        
        except ValueError as e:
            # 失敗した場合も、技術に依存しない辞書として返す
            return {
                "success": False,
                "error": str(e)
            }

```

-----

## 📖 (補足) 質問と回答


### ❓ 質問

「リポジトリを使ってエンティティを取得する」というのは、割と重要な考え方ですね。

### 🅰️ 回答

はい、まさしくその通りです。
「**リポジトリを使ってエンティティを取得する**」という考え方は、クリーンアーキテクチャやドメイン駆動設計（DDD）における、最も重要で強力な概念の一つです。

この一点を理解することが、**ビジネスロジック**と**永続化の技術**を分離する鍵となります。

#### 📚 図書館のアナロジー

この関係は、図書館のシステムに例えると非常によく分かります。

  * **あなた（利用者）**
    \= **`ProcessOrderUseCase`（ユースケース）**
    あなたの目的は、「特定のビジネス書を読んで、知識を得る」ことです。
  * **本そのもの**
    \= **`Product`（エンティティ）**
    あなたが本当に欲しいのは、情報が詰まった「本」そのものです。これがビジネスの核心です。
  * **図書館の司書さん（あるいは検索システム）**
    \= **`IProductRepository`（リポジトリのインターフェース）**
    あなたは、本の探し方のプロである司書さんに「このISBNコードの本を探してください」と**依頼**します。あなたは、司書さんがその本を書庫から持ってくるのか、コンピュータで検索するのか、その**具体的な方法を知る必要はありません**。
  * **司書さんの具体的な探し方**
    \= **`InMemoryProductRepository`（リポジトリの実装）**
    この司書さんは記憶力が抜群で、全ての本の場所を覚えていて、すぐに棚から持ってきてくれます（インメモリでの実装）。もし別の司書さんなら、コンピュータのデータベースを検索して探すかもしれません（MySQLでの実装）。

#### ✨ なぜ、この考え方が重要なのか？

この「司書さん（リポジトリ）」という仲介役を挟むことで、絶大なメリットが生まれます。

1.  **ビジネスロジックの純粋性**
    あなた（ユースケース）は、「本を探す」という**ビジネス上の目的**にのみ集中できます。図書館の棚の配置や、データベースの仕組みといった**技術的詳細**について考える必要が一切なくなります。
2.  **永続化技術の交換可能性**
    もし図書館が、紙の索引カードから最新のコンピュータシステムに蔵書管理の方法を変えたとしても、あなた（ユースケース）が司書さんに本を依頼するという**インターフェース（やり取りの方法）は一切変わりません**。これと同じで、`InMemory` を `MySQL` に切り替えても、`ProcessOrderUseCase` のコードには一切変更が必要ないのです。
3.  **テストの容易性**
    あなたの「本を読む」という行動をテストしたいとき、**わざわざ巨大な図書館（本物のDB）に行く必要はありません**。友達（テスト用のリポジトリ）に頼んで、目の前に用意してもらった本を読めば良いのです。
    これと同じで、ユースケースのテストは、本物のデータベースを使わず、テスト用の簡単な `FakeProductRepository` を使うことで、高速かつ安定して実行できます。

この「リポジトリ」という抽象的な壁一枚を挟むだけで、アプリケーションの保守性、柔軟性、テストの容易性が劇的に向上します。