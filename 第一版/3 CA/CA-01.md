# CA-01: クリーンアーキテクチャの適用と設計図

`OOP` の章で、私たちはSOLID原則とデザインパターンを駆使し、非常に堅牢で保守性の高いオブジェクト指向設計を完成させました。

しかし、`OOP-09` の最後で触れたように、まだ最大の課題が残っています。
`Store` クラスの `process_order` メソッドには、

  * **ビジネスロジック**（`product.check_stock()`）
  * **技術的詳細**（`print("エラー: ...")` というUI層の処理）

これらが混在しています。このままでは、「`print`」を「Web APIの `JSON` レスポンス」に変えたい場合、ビジネスロジックの核心である `Store` クラスを修正しなくてはなりません。

この「**ビジネスの核心**」と「**技術的詳細**」を完全に分離し、ビジネスルールを「金庫室」に隔離する——それこそが、クリーンアーキテクチャの目的です。

## 🎯 この章のゴール

  * クリーンアーキテクチャの目的（＝関心事の分離）を理解する。
  * 「エンティティ」「ユースケース」「アダプタ」「インフラ」というレイヤー構造を学ぶ。
  * 依存関係のルール（＝内側（抽象）へ依存する）を理解する。
  * なぜ「内側から」実装するのが良いのかを学ぶ。

-----

## 🏛️ クリーンアーキテクチャとは？

クリーンアーキテクチャは、アプリケーションを同心円のレイヤー（層）に分割し、依存関係の矢印が常に**外側から内側へ**向かうという絶対的なルールを設けます。

  * **内側のレイヤー（方針）:**
    より抽象的で、ビジネスの本質的なルール。変更頻度が低い。（例：`Product` エンティティ）
  * **外側のレイヤー（詳細）:**
    より具体的で、技術的な実装。変更頻度が高い。（例：データベース、Webフレームワーク、`main.py`）

`OOP-09` で学んだ「コンセントのアナロジー」を、アプリケーション全体に適用する壮大な設計図だと考えてください。

-----

## 📁 新しいファイル構造

この「関心事の分離」を物理的に実現するため、プロジェクトのディレクトリ構造を以下のように変更します。

```bash
clean_architecture_project/
├── domain/                  # 🔵 円の中心：エンティティ
│   ├── product.py
│   └── order.py
│
├── use_cases/               # 🟢 2番目の円：ユースケース
│   ├── process_order_use_case.py
│   └── interfaces.py          # 外部との「契約書」(リポジトリI/F)
│
├── interface_adapters/      # 🟡 3番目の円：アダプター/プレゼンター
│   ├── repositories.py        # (リポジトリの「実装」)
│   └── controllers.py       # (Webフレームワークなどからの入力を処理)
│
└── infrastructure/          # 🔴 最も外側の円：インフラ
    ├── db/                    # (DB接続など ※今回は InMemory)
    └── main.py              # (アプリケーションの起動と「依存性の注入」)
```

このアーキテクチャの思想を最も効果的に理解するため、**「内側から外側へ」**、つまり同心円の中心から外に向かって実装と説明を進めていきます。

1.  **`domain` (エンティティ):**
    アプリケーションの**魂**。フレームワークから独立した純粋なビジネスルール（`Product` や `Order` クラス）を定義します。「守るべき宝物」です。
2.  **`use_cases/interfaces.py` (抽象インターフェース):**
    ユースケースが外部の世界（DBなど）と結ぶ「**契約書**」を定義します。「宝物庫の扉には、こういう形の鍵穴（`IProductRepository`）が付いています」と宣言する部分です。
3.  **`use_cases/process_order_use_case.py` (ユースケース):**
    具体的なアプリケーションの目的（「注文を処理する」）を達成する手順を記述します。外側の世界を一切知らず、ただ「鍵穴（インターフェース）」に合う「鍵（実装）」が渡されることだけを期待しています。
4.  **`interface_adapters` (アダプター):**
    ここで初めて、ユースケースが要求した「鍵（インターフェースの実装）」を具体的に作ります。`InMemoryOrderRepository` のような、具体的な技術が登場するレイヤーです。
5.  **`infrastructure` (インフラ / `main.py`):**
    すべての\*\*具体的な部品を組み立てる「組立工場」\*\*です。どのユースケースに、どのリポジトリ実装（鍵）を渡すのかを決定し（＝依存性の注入）、アプリケーション全体を起動します。最も具体的で、最も変更されやすい部分です。

-----

## 🛠️ なぜ「内側から」実装するのか？

プログラミングも、この説明の順番と同じ\*\*「内側から外側へ」\*\*進めるのが、クリーンアーキテクチャの思想を実践する上で最も効果的です。

この開発スタイルは「**テスト駆動開発（TDD）**」とも非常に相性が良いです。

### 1\. 🎯 ビジネスの核心に集中できる

最初に `domain` と `use_cases` を実装することで、開発者はUIやDBといった**技術的詳細に惑わされることなく、解決すべきビジネス問題そのものに集中できます**。

### 2\. 🧪 圧倒的なテストの容易性

内側のレイヤーは、外部のフレームワークやDBに一切依存しません。そのため、**UIを起動したり、本物のDBに接続したりすることなく**、ビジネスロジックの単体テストを高速かつ安定して実行できます。

### 3\. ⏳ 技術選定を後回しにできる

Webフレームワークを何にするか、DBをMySQLにするかといった**技術的な意思決定を、プロジェクトの後半まで遅らせることが可能**です。

-----

### 🏠 家づくりのアナロジー

この開発プロセスは、家づくりに例えることができます。

  * **悪い進め方（外側から）:**
    まず外壁や屋根（フレームワーク）を決めてしまい、その制約の中で、後から間取り（ビジネスロジック）を無理やり詰め込んでいく。
  * **良い進め方（内側から）:**
    まず、その家でどんな生活を送りたいか（ビジネスロジック）を考え、最適な間取り（エンティティとユースケース）を設計します。そして、その設計が正しいことを模型（テスト）で確認します。最後に、その理想の間取りを実現するために最適な壁材や屋根（フレームワークやDB）を選んで取り付けるのです。

