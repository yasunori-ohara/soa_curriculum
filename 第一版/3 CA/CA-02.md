# CA-02

```markdown
## `domain/product.py` (エンティティ)

ここはアプリケーションの魂であり、他のすべてが依存する最も中心的で安定した部分です。ここには、フレームワークやデータベースから独立した、純粋なビジネスルールが記述されています。「守るべき宝物」が何であるかを最初に定義します。

### 1. このファイルの役割：アプリケーションの魂 (Entities レイヤー)

この`domain/product.py`ファイルは、クリーンアーキテクチャの同心円の中で最も内側に位置するEntities（エンティティ）レイヤーです。

ここには、このアプリケーションの魂とも言える、最も重要で、最も変更されることの少ない、純粋なビジネスルールだけを記述します。

このレイヤーは、いわばシステムの「宝物」が保管された「金庫室」の中心です。そのため、データベース、Webフレームワーク、UIなど、外の世界のことは一切知りません。

### 2. ソースコードの詳細解説

#### `Product(ABC)`: 「商品」という概念の契約書

この抽象基底クラスは、「商品」として扱われるオブジェクトが**必ず守らなければならない契約（インターフェース）**を定義しています。

- `check_stock()`: 在庫を確認する能力
- `reduce_stock()`: 在庫を減らす能力
- `get_stock()`: 在庫数を報告する能力

`Store`や`ProcessOrderUseCase`といった、このクラスを利用する側は、相手がどんな種類の商品であっても、この3つの能力を持っていることを信頼して仕事を任せることができます。

#### `PhysicalProduct` と `DigitalProduct`: 契約書への具体的な署名

これらは、`Product`という契約書に**署名（継承）**し、その内容を具体的に実装したクラスです。

- `PhysicalProduct`は、契約通りに物理的な在庫数を操作します。

- `DigitalProduct`も同じ契約書に署名しますが、その振る舞いは異なります。在庫は常に「あり」とみなし、在庫を減らす処理は何も行いません。

### 3. このレイヤーの鉄則

1. 外部への依存は許されない: このファイルの中には、`import fastapi`や`import mysql.connector`のような、外側のレイヤーに属するライブラリの`import`文は絶対に現れません。

2. 純粋なビジネスロジックに徹する: `print()`でエラーメッセージを表示したり、画面表示用にデータを整形したりといった、ビジネスの本質と関係ない処理はここには書きません。

3. 安定しているべき: このレイヤーは、ビジネスのルールそのものを表現しているため、技術の流行り廃りの影響を受けません。最も安定した、変更頻度の低いレイヤーであるべきです。

### `domain/product.py`
``` Python
# 依存性のルール:
# このファイルは、クリーンアーキテクチャの最も中心に位置するEntitiesレイヤーです。
# そのため、外部のライブラリや他のレイヤー（use_cases, infrastructureなど）に
# 一切依存してはいけません。Pythonの標準ライブラリのみが利用可能です。

from abc import ABC, abstractmethod

class Product(ABC):
    """
    【Entitiesレイヤー】
    商品というビジネスオブジェクトの「概念」を定義する抽象基底クラス。
    これはアプリケーションのユースケース（どう使われるか）には依存しない、
    最も中心的で普遍的なビジネスルールを表現します。
    """
    def __init__(self, product_id: str, name: str, price: int):
        self.product_id = product_id
        self.name = name
        self.price = price

    @abstractmethod
    def check_stock(self, quantity: int) -> bool:
        """
        商品が購入可能かを判断するための「契約」。
        具体的な判断方法はサブクラスに委ねる。
        """
        pass

    @abstractmethod
    def reduce_stock(self, quantity: int):
        """
        購入を確定させる処理の「契約」。
        具体的な処理内容はサブクラスに委ねる。
        """
        pass

    @abstractmethod
    def get_stock(self) -> int | str:
        """
        現在の在庫数を取得するための「契約」。
        具体的な表現方法はサブクラスに委ねる。
        """
        pass

class PhysicalProduct(Product):
    """
    物理的な在庫を持つ商品。Productという「契約」を具体的に実装します。
    """
    def __init__(self, product_id: str, name: str, price: int, stock: int):
        super().__init__(product_id, name, price)
        self._stock = stock

    def check_stock(self, quantity: int) -> bool:
        """物理的な在庫数と注文数を比較して、購入可能か判断します。"""
        return self._stock >= quantity

    def reduce_stock(self, quantity: int):
        """在庫が十分にあれば、物理的な在庫数を減らします。"""
        if self.check_stock(quantity):
            self._stock -= quantity

    def get_stock(self) -> int:
        """現在の物理的な在庫数を数値として返します。"""
        return self._stock

class DigitalProduct(Product):
    """
    在庫の概念がないダウンロード商品。同じくProductという「契約」を実装します。
    """
    def __init__(self, product_id: str, name: str, price: int):
        super().__init__(product_id, name, price)
        
    def check_stock(self, quantity: int) -> bool:
        """ダウンロード商品は常に在庫があるので、Trueを返します。"""
        return True

    def reduce_stock(self, quantity: int):
        """在庫を減らすという概念がないため、何も処理を行いません。"""
        pass

    def get_stock(self) -> str:
        """物理的な在庫数はないため、その旨を文字列で返します。"""
        return "N/A (Downloadable)"

``` 

```