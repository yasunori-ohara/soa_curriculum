# CA-05: 🟡 Interface Adapters レイヤー
### 実装 (interface\_adapters/repositories.py)

`CA-04` までで、システムの「核心（`domain`）」と「ビジネスフロー（`use_cases`）」を、外部の技術から完全に隔離された状態で実装しました。

`CA-03` では、`use_cases` が「こういう機能（＝鍵穴）が欲しい」と `IProductRepository` や `IOrderRepository` という形で「契約書（インターフェース）」を定義しました。

この `CA-05` では、その契約書（インターフェース）を**具体的に実装**する `Interface Adapters` レイヤーを作成します。`OOP-09` のアナロジーで言えば、\*\*「鍵穴」に合う「具体的な鍵」\*\*を作る作業です。

## 🎯 この章のゴール

  * `Interface Adapters` レイヤーの役割（＝「内側」と「外側」の通訳）を理解する。
  * `use_cases` で定義した「抽象（インターフェース）」を、「具象（クラス）」として実装する方法を学ぶ。
  * `OOP` の章で作った `InMemory...Repository` が、このレイヤーに対応することを再確認する。
  * **依存関係のルール**（「外側」が「内側」に依存する）が守られていることを `import` 文で確認する。

-----

## 🔌 このファイルの役割：内側と外側をつなぐ「アダプター」

このレイヤーは「アダプター（通訳者）」と呼ばれます。
`CA-03` で定義した「コンセントの鍵穴（インターフェース）」に対し、このレイヤーは「**具体的なプラグ（実装クラス）**」を提供します。

  * **内側（`use_cases`）に対して:**
    「`IProductRepository` の契約（`find_by_id` など）を守ります」と約束し、「鍵」として機能します。
  * **外側（`infrastructure`）に対して:**
    「メモリ（辞書）」や「本物のDB（`SQL`）」といった具体的な技術と会話し、データを `domain` のエンティティ（`Product` オブジェクト）の形に\*\*変換（アダプト）\*\*します。

今回は、最も単純な「インメモリ（Pythonの辞書やリスト）」をデータベースの代わりとして使う「鍵」を作成します。

-----

## 🏛️ このレイヤーの鉄則

1.  **契約書を必ず履行する:**
    `Use Cases` レイヤーで定義されたインターフェース（`IProductRepository`など）を必ず継承し、そのすべてのメソッドを実装しなければなりません。
2.  **依存の矢印は必ず内側を向く:**
    `import`文を見てください。このファイル（`interface_adapters`）は、自分より内側の `domain` や `use_cases` に依存していますが、外側の `infrastructure`（`main.py`）のことは一切知りません。
3.  **翻訳者であれ:**
    外側の世界のデータ形式（DBの行データ、APIのJSONなど）を、内側の世界のドメインオブジェクト（エンティティ）に変換する責任を持ちます。（今回はメモリなので翻訳処理は単純です）

-----

## 📄 `interface_adapters/repositories.py` の実装

`OOP` の章で `Store` クラスや `InMemoryOrderRepository` が持っていた「データ保存機能（辞書やリスト）」を、このファイルの具象クラスが引き受けます。

```python:interface_adapters/repositories.py
# 依存性のルール:
# このファイルは Interface Adapters レイヤーに属します。
# したがって、自分より内側のレイヤー（use_cases, domain）にのみ
# 依存することが許されます。

from typing import List

# 「内側」の domain レイヤーからエンティティをインポート
from domain.product import Product
from domain.order import Order

# 「内側」の use_cases レイヤーからインターフェース（契約書）をインポート
from use_cases.interfaces import IProductRepository, IOrderRepository


class InMemoryProductRepository(IProductRepository):
    """
    【Interface Adaptersレイヤー / Adapter】
    IProductRepository（鍵穴）に対する「具体的な鍵」の実装クラス。
    
    データを永続化する方法として「インメモリ（プログラムのメモリ上）」
    の辞書を使用します。
    """
    
    def __init__(self):
        """
        簡易的なデータベースとして空の辞書を初期化します。
        OOP の Store が持っていた _products 辞書がここに移動しました。
        """
        self._products: dict[str, Product] = {}

    def find_by_id(self, product_id: str) -> Product | None:
        """
        【実装】IProductRepositoryの契約に従い、find_by_id を実装します。
        インメモリDB（辞書）から商品IDをキーにしてデータを検索します。
        """
        print(f"リポジトリ: インメモリDBから商品ID'{product_id}'を検索します。")
        return self._products.get(product_id)

    def save(self, product: Product):
        """
        【実装】IProductRepositoryの契約に従い、save を実装します。
        引数の Product エンティティを、インメモリDB（辞書）に保存（更新）します。
        """
        print(f"リポジトリ: {product.name} をインメモリDBに保存します。")
        self._products[product.product_id] = product


class InMemoryOrderRepository(IOrderRepository):
    """
    【Interface Adaptersレイヤー / Adapter】
    IOrderRepository（鍵穴）に対する「具体的な鍵」の実装クラス。
    (OOP-05 で作成したものとほぼ同じ)
    """
    def __init__(self):
        self._orders: List[Order] = []

    def save(self, order: Order):
        """【実装】リストに Order オブジェクトを追加する"""
        print(f"リポジトリ: 注文 {order.product_name} をインメモリDBに保存します。")
        self._orders.append(order)

    def get_all(self) -> List[Order]:
        """【実装】保持しているリストを返す"""
        print(f"リポジトリ: 全注文履歴をインメモリDBから取得します。")
        return self._orders
```

-----

## 📖 (補足) 質問と回答

`CA-05` の作業を終えた今、`CA-03` から始まった「インターフェース」の役割について、ある重要な結論が導き出されます。ご提示いただいたQ\&A（`CA-05-2`）をここにまとめます。

### ❓ 質問

「使う側（ユースケース）が、自分にとって都合の良いIF（インターフェース）を定義し、使われる側（リポジトリ実装）にそのIFに従ってもらう」ということですね。

### 🅰️ 回答

はい、その通りです！ その気づきは、ソフトウェア設計における**パラダイムシフト**と言ってもいいほど、極めて重要なポイントです。

「使われる側（DBなど）がIFを決める」のではなく、
「**使う側（ユースケース）が、自分にとって都合の良いIFを定義し、使われる側にそのIFに従ってもらう**」

この考え方の転換こそが、SOLID原則の**D: 依存性逆転の原則 (DIP)** そのものです。

  * **上位モジュール（使う側）**: `ProcessOrderUseCase`
  * **下位モジュール（使われる側）**: `InMemoryProductRepository`
  * **抽象**: `IProductRepository` （`ProcessOrderUseCase`が定義した、自分にとって都合の良いIF）

`ProcessOrderUseCase` と `InMemoryProductRepository` は、直接お互いを知りません。両者とも、間に挟まれた `IProductRepository` という**抽象的な契約書**だけを見て仕事をします。

そして、ご指摘の通り、**クリーンアーキテクチャは、この依存性逆転の原則 (DIP) を、アーキテクチャ全体の絶対的な掟（おきて）として体系化したもの**です。

| | SOLID原則 | クリーンアーキテクチャ |
| :--- | :--- | :--- |
| **DIPの扱い** | 5つの重要な原則の**一つ** | アーキテクチャ全体を貫く**絶対的な掟** |

クリーンアーキテクチャは、DIPという強力なアイデアを、アプリケーション全体の設計思想へと昇華させたもの、と理解すると非常に分かりやすいです。