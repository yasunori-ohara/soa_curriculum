# CA-05

```markdown
## `interface_adapters/repositories.py` (リポジトリ実装)

いよいよ、内側の世界と外側の世界をつなぐ「アダプター」の登場です。

---

### 1. このファイルの役割：契約書を「実装」するアダプター (Interface Adapters レイヤー)

この`interface_adapters/repositories.py`ファイルは、クリーンアーキテクチャの同心円の中で3番目に位置するInterface Adapters（インターフェースアダプター）レイヤーです。

その役割は、Use Casesレイヤーで定義された抽象的な「契約書（インターフェース）」を、具体的に実装することです。

Use Casesレイヤーが「こういう形のポート（接続口）が必要です」と宣言したのに対し、このレイヤーは「はい、そのポートにぴったり合う、この技術（インメモリDB）を使ったアダプター（プラグ）です」と、具体的な部品を提供します。

---
### 2. ソースコードの詳細解説

#### `InMemoryProductRepository(ProductRepository)`: 契約の履行
このクラス定義の (`ProductRepository`) の部分が極めて重要です。これは、「`InMemoryProductRepository`クラスは、`use_cases/interfaces.py`で定義されたProductRepositoryという契約書に書かれた内容を、すべて守り、実装することを約束します」という宣言です。

#### `__init__(self)`: データベース本体
このクラスの`__init__`で定義されている`self._products`という辞書が、今回のアプリケーションにおける簡易的なインメモリデータベースそのものです。もしこれがMySQLを使うリポジトリであれば、ここにはデータベースへの接続情報などが保持されることになります。

#### `find_by_id(...)` と `save(...)`: 具体的な実装
ここで初めて、`ProductRepository`という契約書に書かれていた抽象的なメソッドが、具体的に実装されます。

- `find_by_id`: 辞書（`_products`）からIDをキーにして商品データを探し、それを`Product`エンティティオブジェクトに変換して返します。

- `save`: `Product`エンティティオブジェクトを受け取り、その情報を再び辞書に保存します。

このように、このレイヤーは内側の世界（ドメインオブジェクト）と外側の世界（ここでは辞書、本来はDBなど）の間のデータ形式の翻訳者の役割も担っています。

---
### 3. このレイヤーの鉄則

1. 契約書を必ず履行する: Use Casesレイヤーで定義されたインターフェースを必ず継承し、そのすべてのメソッドを実装しなければなりません。これは絶対的なルールです。

2. 依存の矢印は必ず内側を向く: `import`文を見てください。このファイルは、自分より内側の`domain`や`use_cases`に依存していますが、外側の`main.py`のことは一切知りません。

3. 翻訳者であれ: 外側の世界のデータ形式（DBの行データ、APIのJSONなど）を、内側の世界のドメインオブジェクト（エンティティ）に変換する責任を持ちます。

---

### interface_adapters/repositories.py
``` Python
# 依存性のルール:
# このファイルはInterface Adaptersレイヤーに属します。
# したがって、自分より内側のレイヤー（domain, use_cases）にのみ依存することが許されます。
# 依存の方向が必ず「内側へ」向かうことが、このアーキテクチャの核心です。

from domain.product import Product, PhysicalProduct, DigitalProduct
from use_cases.interfaces import ProductRepository

class InMemoryProductRepository(ProductRepository):
    """
    【Interface Adaptersレイヤー / Adapter】
    ProductRepositoryインターフェースの「具体的な実装」クラス。
    
    このクラスは、データを永続化する方法として「インメモリ（プログラムのメモリ上）」
    を選択しています。もしデータベースを使いたければ、同じインターフェースを実装した
    MySqlProductRepositoryクラスを別途作成することになります。
    """
    
    def __init__(self):
        """
        このクラスのインスタンスが生成されたときに、
        簡易的なデータベースとして空の辞書を初期化します。
        """
        self._products = {}

    def find_by_id(self, product_id: str) -> Product | None:
        """
        ProductRepositoryの契約に従い、find_by_idメソッドを具体的に実装します。
        インメモリDB（辞書）から商品IDをキーにしてデータを検索します。
        """
        print(f"リポジトリ: インメモリDBから商品ID'{product_id}'を検索します。")
        return self._products.get(product_id)

    def save(self, product: Product):
        """
        ProductRepositoryの契約に従い、saveメソッドを具体的に実装します。
        引数で受け取ったProductエンティティを、インメモリDB（辞書）に保存（更新）します。
        """
        print(f"リポジトリ: {product.name}をインメモリDBに保存します。")
        self._products[product.product_id] = product
``` 

```