# CA-08

```markdown
## 質問：SOLID原則のD: 依存性逆転の原則について、クリーンアーキテクチャでは「掟」になっている、ということでしたが、他にも似たようなものはありますか？

## 回答：依存性逆転の原則（DIP）がクリーンアーキテクチャの最も目立つ「掟（おきて）」であることは間違いありませんが、実は**SOLIDの他の原則も、単なる「良い習慣」から、アーキテクチャそのものに組み込まれた「構造的な必然」へと格上げされています**。

クリーンアーキテクチャは、いわば**「SOLID原則を実践しやすくするための、具体的な設計図」**なのです。

---

### アーキテクチャの屋台骨となっている原則

#### S: 単一責任の原則 (SRP)

* **SOLIDでの意味**: クラスを変更する理由は一つであるべき。
* **クリーンアーキテクチャでの強化**:
    この原則は、**アーキテクチャの各レイヤー、各コンポーネントの存在理由そのもの**になっています。
    * **Use Caseクラス**: `ProcessOrderUseCase`は「注文を処理する」という**単一のユースケース**にのみ責任を持ちます。「ユーザーを登録する」といった別の責任は、別のUse Caseクラスが担当します。
    * **Entity**: `Product`は「商品に関するビジネスルール」という**単一の責任**を持ちます。
    * **Repository**: `ProductRepository`は「商品の永続化」という**単一の責任**を持ちます。

**結論**: クリーンアーキテクチャは、単一責任の原則を**アーキテクチャレベルで強制する構造**と言えます。

#### O: オープン・クローズドの原則 (OCP)

* **SOLIDでの意味**: 拡張に対して開き、修正に対して閉じるべき。
* **クリーンアーキテクチャでの強化**:
    依存性逆転の原則は、このオープン・クローズドの原則を**アーキテクチャ全体で実現するための強力なメカニズム**です。
    * **DBの変更**: データベースをインメモリからMySQLに変更したい場合、既存のUse CaseやEntityを**修正**する必要は一切ありません。新しい`MySqlProductRepository`を**拡張（追加）**するだけで対応できます。
    * **UIの変更**: Web APIをコマンドラインツールに変更したい場合でも、中心にあるUse CaseやEntityを**修正**する必要はありません。

**結論**: クリーンアーキテクチャの「依存性のルール」は、まさにオープン・クローズドの原則を**システム全体で保証するための掟**なのです。

---

### アーキテクチャを支える必須の潤滑油

#### L: リスコフの置換原則 (LSP)

* **SOLIDでの意味**: 親クラスを子クラスで置き換えても問題なく動作すべき。
* **クリーンアーキテクチャでの強化**:
    この原則は、**レイヤー境界のインターフェースが正しく機能するための大前提**となります。
    `ProcessOrderUseCase`は、`ProductRepository`という「抽象」に依存しています。ここに`InMemoryProductRepository`を渡しても、`MySqlProductRepository`を渡しても、Use Caseの振る舞いが変わってしまってはアーキテクチャが崩壊します。
    つまり、すべての具象リポジトリは、リスコフの置換原則に従い、親であるインターフェースの「契約」を完全に守らなければなりません。

**結論**: DIPによって作られた「抽象の壁」が、**正しく機能するための品質保証**となる原則です。

#### I: インターフェース分離の原則 (ISP)

* **SOLIDでの意味**: 不要なメソッドを持つインターフェースに依存を強制すべきではない。
* **クリーンアーキテクチャでの強化**:
    この原則は、**Use Caseごとに、本当に必要なインターフェース（ポート）だけを定義する**ことを推奨します。
    例えば、`ProcessOrderUseCase`は商品の保存も必要なので`ProductRepository`（`find`と`save`を持つ）に依存しますが、もし「商品一覧を表示する」という別のユースケースがあれば、それは`save`メソッドを必要としません。その場合、`find`メソッドだけを持つ`ProductFinder`のような、より小さなインターフェースを定義すべきです。
    これにより、各ユースケースは本当に必要な機能だけに依存し、より疎結合になります。

**結論**: レイヤー境界を越えるインターフェースを、**より精密で目的に特化したものにする**ための指針です。

---

### まとめ

| 原則 | クリーンアーキテクチャにおける役割 | アナロジー |
| :--- | :--- | :--- |
| **S (SRP)** | **構造そのもの**。各コンポーネントの存在理由。 | 会社の各部署（営業部、経理部） |
| **O (OCP)** | **システム全体の目標**。変更を安全に行うための設計。 | コンセント（壁を壊さずに家電を追加できる） |
| **D (DIP)** | OCPを実現するための**絶対的な掟**。依存の方向を制御する。 | 上司は部下を知らない（部下が上司の指示に従う） |
| **L (LSP)** | DIPが正しく機能するための**品質保証**。 | どのメーカーの電球でもソケットに合えば光る |
| **I (ISP)** | DIPのインターフェースを精密にする**指針**。 | テレビのリモコン（再生ボタンしかないシンプルなもの） |

このように、SOLID原則はバラバラに存在するのではなく、クリーンアーキテクチャという一つの大きな設計思想の中で、互いに深く関連し合ってシステム全体を支えているのです。SOLIDが「クラス設計の良い習慣」であるのに対し、クリーンアーキテクチャは「**その習慣を強制・促進するシステム構造**」と考えると、その関係性がよく分かります。
```