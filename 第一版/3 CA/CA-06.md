# CA-06

```markdown
## main.py

### 1. このファイルの役割：すべてを組み立てる「組立工場」 (Frameworks & Drivers レイヤー)

この`main.py`ファイルは、クリーンアーキテクチャの同心円の中で最も外側に位置するFrameworks & Drivers（フレームワーク＆ドライバ）レイヤーです。

その役割は、これまで各レイヤーで作ってきたすべての抽象的な部品と具体的な部品を、ここで初めて結合し、アプリケーション全体を組み立てて、命を吹き込むことです。この場所を特別に「Composition Root（コンポジションルート）」と呼びます。

このファイルは、いわば**アプリケーションの「組立工場」**です。どのエンジン（ユースケース）に、どのタイヤ（リポジトリの実装）を取り付けるかを決定し、完成した車（アプリケーション）を工場の外に出します。

---
### 2. ソースコードの詳細解説

`import`文: 唯一、すべてを知る場所
import文に注目してください。この`main.py`は、`domain`, `use_cases`, `interface_adapters`というすべての内側レイヤーから具体的なクラスをインポートしています。これは、この組立工場だけが持つ特権です。他のどのファイルも、自分より外側のレイヤーから何かをインポートすることは許されませんでした。

#### `1. 依存性の注入 (Dependency Injection)`: 部品の組み立て

ここがこのファイルの心臓部です。

1. まず、`InMemoryProductRepository()`という具体的な実装クラスのインスタンスを作成します。ここで初めて、このアプリケーションが「インメモリDBを使う」という技術的な決定が下されます。

2. 次に、その具体的なインスタンスを、`ProcessOrderUseCase`のコンストラクタに**注入（引数として渡す）**します。

`ProcessOrderUseCase`は、自分が受け取った`repo`が`InMemoryProductRepository`であるという事実を一切知りません。ただ、それが`ProductRepository`という契約書を守っていることだけを信頼して動作します。

#### `2. 初期データの設定`: アプリケーションの準備

組立工場では、車を組み立てるだけでなく、出荷前にガソリンを入れたり、タイヤの空気圧をチェックしたりします。  
この部分も同様に、アプリケーションが動作するための具体的な準備を行っています。ここでは、インメモリDBに初期商品データを投入しています。

#### `3. アプリケーションの実行`: ユーザーからのリクエストを模倣

`use_case.execute(...)`を呼び出している部分が、実際にアプリケーションの機能を実行している箇所です。
これは、Webアプリケーションであれば「ユーザーが注文ボタンをクリックした」、コマンドラインツールであれば「ユーザーがコマンドを実行した」という、外部からのトリガーを模倣しています。

---
### 3. このレイヤーの鉄則

1. ビジネスロジックを書かない: このファイルは部品を組み立てることに専念します。if文などを使ったビジネス上の判断は、ここには一切書きません。

2. すべての具体的な実装を知っている: どのインターフェースにどの実装クラスを割り当てるか、そのすべての組み合わせを知っている唯一の場所です。

3. 最も変更されやすい: データベースをMySQLに変える、Webフレームワークを導入する、といった技術的な変更があった場合、主に修正されるのはこのファイルです。しかし、このファイルが変更されても、内側のレイヤーは一切影響を受けません。

---
### main.py
``` Python
# 依存性のルール:
# このファイルは最も外側のレイヤーに属します。
# アプリケーション全体を組み立てるため、すべての内側のレイヤーから
# 具体的なクラスをインポートすることが許される、唯一の場所です。

from domain.product import PhysicalProduct, DigitalProduct
from use_cases.process_order import ProcessOrderUseCase
from interface_adapters.repositories import InMemoryProductRepository

def main():
    """
    【Frameworks & Driversレイヤー / Composition Root】
    アプリケーションのすべての部品を組み立て、起動するためのメイン関数。
    """
    print("--- アプリケーション組立開始 ---")
    
    # --- 1. 依存性の注入 (Dependency Injection) ---
    # ここで初めて、どの「インターフェース」にどの「具体的な実装」を使うかを決定します。
    # Use Caseは「ProductRepositoryという契約書を守る誰か」を必要としています。
    # ここで「はい、その役目はInMemoryProductRepositoryです」と、具体的な担当者を任命します。
    product_repo = InMemoryProductRepository()
    
    # Use Caseのインスタンスを生成し、具体的なリポジトリを注入（コンストラクタ経由で渡す）します。
    use_case = ProcessOrderUseCase(product_repo=product_repo)
    
    print("--- 組立完了 ---")

    # --- 2. 初期データの設定 ---
    # アプリケーションの動作に必要な初期データを準備します。
    # これも、具体的な実装であるリポジトリに対して行います。
    print("\n--- 初期在庫データ投入 ---")
    mouse = PhysicalProduct("p-001", "高機能マウス", 4000, 10)
    ebook = DigitalProduct("d-001", "Python入門 eBook", 3000)
    product_repo.save(mouse)
    product_repo.save(ebook)
    
    # --- 3. アプリケーションの実行 ---
    # 実際にユースケースを実行します。
    # これは、Webフレームワークのエンドポイントが呼び出されたり、
    # ユーザーがボタンをクリックしたりするのを模倣しています。
    print("\n--- ユースケース実行 ---")
    
    # シナリオ1: 正常な注文
    try:
        result = use_case.execute(product_id="p-001", quantity=3)
        print(f"成功: {result['message']}")
    except ValueError as e:
        print(f"失敗: {e}")

    # シナリオ2: 在庫不足
    try:
        result = use_case.execute(product_id="p-001", quantity=10)
        print(f"成功: {result['message']}")
    except ValueError as e:
        print(f"失敗: {e}")
        
    # シナリオ3: ダウンロード商品の注文
    try:
        result = use_case.execute(product_id="d-001", quantity=1)
        print(f"成功: {result['message']}")
    except ValueError as e:
        print(f"失敗: {e}")

    # --- 4. 結果の確認 ---
    print("\n--- 最終在庫確認 ---")
    final_mouse = product_repo.find_by_id("p-001")
    if final_mouse:
        print(f"{final_mouse.name}の最終在庫: {final_mouse.get_stock()}")

if __name__ == "__main__":
    main()
```

```