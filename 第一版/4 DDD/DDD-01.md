# DDD-01

## DDD

クリーンアーキテクチャという、ビジネスロジックを守るための堅牢な「金庫室」を構築した今、いよいよその金庫室の中に保管する**「宝物（ビジネスロジック）」そのものを、いかにして磨き上げ、価値を高めるか**というステージ、**ドメイン駆動設計（DDD: Domain-Driven Design）**に進みましょう。

## なぜクリーンアーキテクチャの次にDDDが必要なのか？

クリーンアーキテクチャは、技術的な関心事とビジネスの関心事を分離するための、非常に強力な構造的な設計図です。

しかし、その「ビジネスの関心事」の中身が、もし複雑で、分かりにくく、ビジネスの専門家が話す言葉とコードが食い違っていたとしたらどうでしょう？ 金庫室の構造は完璧でも、中に入っている宝物がごちゃごちゃでは、その価値を最大限に引き出すことはできません。

ドメイン駆動設計（DDD）は、この「ビジネスの複雑さ」そのものに立ち向かうための、設計思想であり、一連のパターンです。DDDは、ソフトウェアの最も重要な部分であるドメインモデル（ビジネスロジックの塊）を、ビジネスの専門家と開発者が協力して、現実のビジネスを忠実に反映した、豊かで分かりやすいものにするための方法論を提供します。

## DDDの重要な概念

DDDには多くの概念がありますが、今回のリファクタリングで特に重要となるのは以下の2つです。

### 1. ユビキタス言語 (Ubiquitous Language)

ビジネスの専門家（ドメインエキスパート）と開発者が、プロジェクトの会話からコードに至るまで、常に同じ言葉（共通言語）を使うという原則です。

- 例: 「注文処理」ではなく、専門家が「受注伝票を起票する」と言うなら、クラス名も`CreateSalesSlipUseCase`のように、ビジネスで使われる言葉に合わせます。

### 2. 戦術的設計パターン (Tactical Design Patterns)

ユビキタス言語で語られるビジネスの概念を、コードに落とし込むための具体的な設計パターンです。今回は特に以下のパターンを導入します。

- 豊かなドメインモデル (Rich Domain Model): エンティティが単なるデータの入れ物ではなく、それ自身がビジネスルールを持つようにします。
- 約 (Aggregate): 一貫性を保つべきオブジェクトのまとまりを「集約」として定義し、その整合性を守る責任者を決めます（集約ルート）。今回の例では、「注文」が集約の中心となります。

## ECサイト注文処理（DDD適用版）

これから、クリーンアーキテクチャの構造は維持しつつ、その内側にある`domain`と`use_cases`をDDDの戦術的設計パターンを使ってリファクタリングします。

### リファクタリングのポイント

`ProcessOrderUseCase`が持っていたビジネスロジックの一部を、新しく作る`Order`集約（アグリゲート）に移譲します。これにより、Use Caseはより薄くなり、ドメインモデルがより豊か（リッチ）になります。

### 新しいファイル構造

`domain`レイヤーに、注文という関心事を専門に扱うファイルを追加します。

```
clean_architecture_project/
├── domain/
│   ├── product.py
│   └── order.py # 🆕 注文集約をここに定義
├── use_cases/
│   ├── process_order.py
│   └── interfaces.py
├── interface_adapters/
│   └── repositories.py
└── main.py

```

## DDDによる改善点

このリファクタリングにより、私たちのコードは単に技術的にクリーンなだけでなく、ビジネスの現実をより忠実に、そして雄弁に語るようになりました。

1. ビジネス知識のコードへの反映:
「注文は、注文商品明細を持つ」「注文の合計金額は、明細の合計である」といったビジネスルールが、`Order`や`LineItem`というクラスとして直接的にコードに表現されました。
2. 一貫性の保証:
`Order`クラスが集約のルートとして、自身の整合性（例：合計金額が常に正しいこと）を自ら守ります。`ProcessOrderUseCase`のような外部のクラスが、誤って注文の状態を壊してしまう心配がありません。
3. Use Caseの責務の明確化:
`ProcessOrderUseCase`は、複雑なビジネスルールを計算する場所ではなく、リポジトリから必要な集約（`Product`）を見つけ出し、新しい集約（`Order`）を生成・実行し、結果をリポジオリに保存するという、**コーディネーター（調整役）**としての責務に集中できるようになりました。

## 次への課題 - DDDの限界とSOAへの道

DDDは、一つの明確に境界づけられたビジネス領域（コンテキスト）の中を、非常にうまくモデル化する手段を提供してくれます。

しかし、現実のビジネスは、複数の異なるビジネス領域が連携しあって動いています。

- 文管理システム（今回作ったもの）
- 在庫管理システム
- 顧客管理システム
- 配送管理システム

これらのシステムは、それぞれが独自の言語とルールを持つ、**異なるドメイン（境界づけられたコンテキスト）**です。

現在の`ProcessOrderUseCase`は、`ProductRepository`を通じて、暗黙的に在庫管理の領域にまで責任を持ってしまっています。もし在庫管理のルールが複雑化したら、このユースケースは再び肥大化してしまうでしょう。

この、異なるドメイン（コンテキスト）間をどうやって疎結合に連携させるかという課題を解決するため、次のステップである**サービス指向アーキテクチャ（SOA）**が必要となるのです。