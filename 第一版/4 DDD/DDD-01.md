# DDD-01 : ドメイン駆動設計 (DDD) への招待

`CA`（クリーンアーキテクチャ）の章で、私たちはビジネスロジックを守るための堅牢な「金庫室」を構築しました。
いよいよこの章では、その金庫室の中に保管する\*\*「宝物（ビジネスロジック）」そのものを、いかにして磨き上げ、価値を高めるか\*\*というステージ、\*\*ドメイン駆動設計（DDD: Domain-Driven Design）\*\*に進みましょう。

## 🎯 この章のゴール

  * クリーンアーキテクチャの「次」に、なぜDDDが必要なのかを理解する。
  * DDDの核心的な概念（ユビキタス言語、集約、リッチなドメインモデル）の概要を知る。
  * `UseCases` に偏りがちなビジネスロジックを `Domain`（エンティティ）に移譲する、というリファクタリングの方針を学ぶ。

-----

## 🤔 なぜクリーンアーキテクチャの次にDDDが必要なのか？

クリーンアーキテクチャは、技術的な関心事（DB, UI）とビジネスの関心事（`domain`, `use_cases`）を分離するための、非常に強力な構造的な設計図です。

しかし、その「ビジネスの関心事」の中身が、もし複雑で、分かりにくく、ビジネスの専門家が話す言葉とコードが食い違っていたとしたらどうでしょう？

金庫室の構造（`CA`）は完璧でも、中に入っている宝物（ビジネスロジック）がごちゃごちゃでは、その価値を最大限に引き出すことはできません。

\*\*ドメイン駆動設計（DDD）\*\*は、この「**ビジネスの複雑さ**」そのものに立ち向かうための、設計思想であり、一連のパターンです。DDDは、ソフトウェアの最も重要な部分であるドメインモデル（ビジネスロジックの塊）を、ビジネスの専門家と開発者が協力し、現実のビジネスを忠実に反映した、豊かで分かりやすいものにするための方法論を提供します。

-----

## 💡 DDDの重要な概念

DDDには多くの概念がありますが、今回のリファクタリングで特に重要となるのは以下の2つです。

### 1\. ユビキタス言語 (Ubiquitous Language)

ビジネスの専門家（ドメインエキスパート）と開発者が、プロジェクトの会話からコードに至るまで、常に同じ言葉（共通言語）を使うという原則です。

  * 例: 「注文処理」ではなく、専門家が「受注伝票を起票する」と言うなら、クラス名も `CreateSalesSlipUseCase` のように、ビジネスで使われる言葉に合わせます。

### 2\. 戦術的設計パターン (Tactical Design Patterns)

ユビキタス言語で語られるビジネスの概念を、コードに落とし込むための具体的な設計パターンです。今回は特に以下のパターンを導入します。

  * **リッチなドメインモデル (Rich Domain Model):**
    `CA` での `Order` クラスは、まだデータの入れ物（貧血なドメインモデル）に近いです。これを、`Order` 自身が「合計金額の計算」や「明細の追加」といったビジネスルールを持つ「リッチな」モデルに進化させます。
  * **集約 (Aggregate):**
    一貫性を保つべきオブジェクトのまとまりを「集約」として定義し、その整合性を守る責任者を決めます（集約ルート）。今回の例では、「注文 (`Order`)」が集約の中心（ルート）となります。

-----

## 📁 ECサイト注文処理（DDD適用版）

これから、クリーンアーキテクチャの構造は維持しつつ、その内側にある `domain` と `use_cases` をDDDの戦術的設計パターンを使ってリファクタリングします。

### リファクタリングのポイント

`ProcessOrderUseCase` が持っていたビジネスロジックの一部（注文の生成、合計金額の計算など）を、`domain/order.py` の `Order` 集約（アグリゲート）に移譲します。

これにより、`UseCase` はより薄くなり、`Domain` がより豊か（リッチ）になります。

### 新しいファイル構造

`CA` で作成したファイル構造は維持しつつ、`domain` レイヤーのクラスをリファクタリングしていきます。

```bash
clean_architecture_project/
├── domain/
│   ├── product.py         # (Productエンティティ)
│   └── order.py           # 👈 CA-02で作成したOrderエンティティを「集約」としてリファクタリング
│
├── use_cases/
│   ├── process_order.py   # 👈 Orderにロジックを移譲し、このクラスはスリムになる
│   └── interfaces.py
│
├── interface_adapters/
│   └── repositories.py
│
└── infrastructure/
    └── main.py
```

-----

## ✨ DDDによる改善点（目指す姿）

このリファクタリングにより、私たちのコードは単に技術的にクリーンなだけでなく、ビジネスの現実をより忠実に、そして雄弁に語るようになります。

1.  **ビジネス知識のコードへの反映:**
    「注文は、注文商品明細を持つ」「注文の合計金額は、明細の合計である」といったビジネスルールが、`Order` や `LineItem` というクラスとして `domain` レイヤーに直接的に表現されます。
2.  **一貫性の保証:**
    `Order` クラス（集約ルート）が、自身の整合性（例：合計金額が常に正しいこと）を自ら守ります。`ProcessOrderUseCase` のような外部のクラスが、誤って注文の状態を壊してしまう心配がなくなります。
3.  **Use Case の責務の明確化:**
    `ProcessOrderUseCase` は、複雑なビジネスルールを計算する場所ではなく、リポジトリから必要な集約を見つけ出し、新しい集約（`Order`）を生成・実行し、結果をリポジトリに保存するという、\*\*コーディネーター（調整役）\*\*としての責務に集中できるようになります。

-----

## 🚀 次への課題 - DDDの限界とSOAへの道

DDDは、一つの明確に境界づけられたビジネス領域（コンテキスト）の中を、非常にうまくモデル化する手段を提供してくれます。

しかし、現実のビジネスは、複数の異なるビジネス領域が連携しあって動いています。

  * **注文管理システム**（今回作っているもの）
  * **在庫管理システム**
  * **顧客管理システム**
  * **配送管理システム**

これらのシステムは、それぞれが独自の言語とルールを持つ、\*\*異なるドメイン（境界づけられたコンテキスト）\*\*です。

現在の `ProcessOrderUseCase` は、`IProductRepository` を通じて、暗黙的に**在庫管理**の領域にまで責任を持ってしまっています。もし在庫管理のルール（「予約在庫」「引当可能在庫」など）が複雑化したら、このユースケースは再び肥大化してしまうでしょう。

この、異なるドメイン（コンテキスト）間をどうやって疎結合に連携させるかという課題を解決するため、次のステップである\*\*サービス指向アーキテクチャ（SOA）\*\*が必要となるのです。