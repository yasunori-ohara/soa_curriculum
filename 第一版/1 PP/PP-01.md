# PP-01

このプログラムは、商品の在庫管理と注文の受付という基本的な機能を持っています。

```bash
import datetime

# --- 1. データベースの代わりとなるデータ構造 ---
# 商品データを格納する辞書 (キーは商品ID)
# このデータ構造がプログラムの「状態(state)」となる
PRODUCTS_DB = {
    "p-001": {"name": "高機能マウス", "price": 4000, "stock": 10},
    "p-002": {"name": "静音キーボード", "price": 6000, "stock": 5},
    "p-003": {"name": "24インチモニター", "price": 25000, "stock": 3},
}

# 注文記録を格納するリスト
ORDERS_LOG = []

# --- 2. 処理を分割した関数群 ---

def find_product(product_id: str, products_data: dict) -> dict | None:
    """商品IDを元に商品データを検索する"""
    return products_data.get(product_id)

def check_stock(product_data: dict, quantity: int) -> bool:
    """商品の在庫が十分か確認する"""
    return product_data["stock"] >= quantity

def reduce_stock(product_data: dict, quantity: int):
    """商品の在庫を減らす（副作用：引数の辞書を直接変更する）"""
    product_data["stock"] -= quantity
    print(f"在庫更新: {product_data['name']}の在庫が{product_data['stock']}になりました。")

def create_order_record(product_data: dict, quantity: int) -> dict:
    """注文記録を作成する"""
    return {
        "product_name": product_data["name"],
        "quantity": quantity,
        "total_price": product_data["price"] * quantity,
        "order_date": datetime.datetime.now().isoformat()
    }

def process_order(product_id: str, quantity: int, products_data: dict, orders_data: list):
    """
    注文処理のメインフローを管理する関数
    """
    print(f"\\n--- 注文処理開始: 商品ID={product_id}, 数量={quantity} ---")

    # 1. 商品存在チェック
    product = find_product(product_id, products_data)
    if not product:
        print("エラー: 指定された商品が見つかりません。")
        return

    # 2. 在庫チェック
    if not check_stock(product, quantity):
        print(f"エラー: {product['name']}の在庫が不足しています。（在庫: {product['stock']}）")
        return

    # 3. 在庫を減らす
    reduce_stock(product, quantity)

    # 4. 注文を記録する
    order_record = create_order_record(product, quantity)
    orders_data.append(order_record)

    print(f"注文成功: {product['name']}を{quantity}個受け付けました。")

# --- 3. メイン処理 (アプリケーションの実行) ---

if __name__ == "__main__":
    print("--- 初期在庫 ---")
    for pid, pdata in PRODUCTS_DB.items():
        print(f"{pdata['name']}: {pdata['stock']}個")

    # シナリオ1: 正常な注文
    process_order("p-001", 2, PRODUCTS_DB, ORDERS_LOG)

    # シナリオ2: 在庫不足による注文失敗
    process_order("p-002", 10, PRODUCTS_DB, ORDERS_LOG)

    # シナリオ3: 存在しない商品による注文失敗
    process_order("p-999", 1, PRODUCTS_DB, ORDERS_LOG)

    # シナリオ4: 別の正常な注文
    process_order("p-003", 3, PRODUCTS_DB, ORDERS_LOG)

    print("\\n--- 最終在庫 ---")
    for pid, pdata in PRODUCTS_DB.items():
        print(f"{pdata['name']}: {pdata['stock']}個")

    print("\\n--- 注文記録 ---")
    for order in ORDERS_LOG:
        print(order)

```

このコードは適切に関数が分割されており、問題なく動作します。しかし、ビジネスが成長し、仕様が複雑になるにつれて、以下のような限界が露呈します。

1. **データとロジックが分離されている**:
商品データ（`PRODUCTS_DB`辞書）と、それを操作するロジック（`check_stock`や`reduce_stock`関数）は、物理的に全く別の場所に存在します。**`PRODUCTS_DB`を、本来想定されていない別の関数が誤って書き換えてしまうことを、プログラムの構造として防ぐことができません。これが、オブジェクト指向のカプセル化**が解決しようとする中心的な課題です。
2. **状態管理の複雑さ**:
`PRODUCTS_DB`や`ORDERS_LOG`は、アプリケーション全体で共有される「状態」です。プログラムが大規模化すると、多くの関数がこの共有データを参照・変更するため、「いつ、どこで、誰が」データを変更したのかを追跡するのが非常に困難になります。
3. **拡張性の低さ**:
もし「**ダウンロード商品**」のような在庫の概念がない新しい商品種別を追加したい場合、どうなるでしょうか？ `check_stock`や`reduce_stock`関数の中に、「もし商品がダウンロード商品なら、在庫チェックをしない」といった`if`文を追加していく必要があります。機能を追加するたびに、既存の多くの関数を修正する必要があり、コードはどんどん複雑で脆くなっていきます。