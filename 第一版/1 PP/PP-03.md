# PP-03: 手続き型プログラミングの限界点 - 複数店舗への拡張

`PP-02`では、データをモジュール（`logic.py`）に隠蔽しようと試みましたが、「紳士協定」には強制力がなく、データの安全性は保証されませんでした。

この章では、`PP-01` `PP-02`で触れたもう一つの大きな問題、\*\*「拡張性の低さ」\*\*に焦点を当てます。ビジネスが成長し、「**複数店舗（東京店と大阪店）**」で在庫を管理したい、というごく自然な要求が追加されたケースを考えてみましょう。

## 🎯 この章のゴール

  * 「複数店舗」という要件変更に、手続き型アプローチで対応しようと試みる。
  * 全ての関数が「どの店舗か(`store_id`)」を意識する必要が出てくる問題（引数バケツリレー）を体験する。
  * データ構造が複雑化し、手続き型での管理が破綻することを理解する。

-----

## 📦 複雑化するファイル

「複数店舗」に対応するため、`logic.py` のデータ構造（`_PRODUCTS_DB`）を、全店舗のデータ（`_STORES_DATA`）を保持する巨大な辞書に変更します。

1.  **`logic.py`**: 全店舗の在庫と注文を一つの巨大な辞書で管理します。
2.  **`main.py`**: 東京店と大阪店の両方に対して注文処理を実行します。

-----

## 💻 `logic.py` : 巨大化するデータとロジック

`PP-02` の `_PRODUCTS_DB` が、`_STORES_DATA` という「辞書の辞書」の構造に変化します。それに伴い、**ほぼ全ての関数が「どの店舗のデータか」を指定する `store_id` を必要とする**ようになります。

```python:logic.py
import datetime

# --- 1. データベースの代わりとなるデータ構造 ---
# 複数店舗のデータを、一つの巨大な辞書で管理する。
# これがアプリケーション全体の「単一の巨大な状態」となり、非常に複雑化する。
_STORES_DATA = {
    "tokyo": {
        "name": "東京店",
        "products": {
            "p-001": {"name": "高機能マウス", "price": 4000, "stock": 10},
            "p-002": {"name": "静音キーボード", "price": 6000, "stock": 5},
            "p-003": {"name": "24インチモニター", "price": 25000, "stock": 3},
        },
        "orders": [] # 東京店の注文履歴
    },
    "osaka": {
        "name": "大阪店",
        "products": {
            # 店舗ごとに価格や在庫が異なる
            "p-001": {"name": "高機能マウス", "price": 4100, "stock": 8},
            "p-002": {"name": "静音キーボード", "price": 6000, "stock": 12},
            "p-003": {"name": "24インチモニター", "price": 25500, "stock": 5},
        },
        "orders": [] # 大阪店の注文履歴
    }
}

# --- 2. 処理を分割した関数群 ---
# ほぼ全ての関数が、第一引数に `store_id` を必要とするようになる。

def _find_store_data(store_id: str) -> dict | None:
    """（内部用）店舗IDをキーに、巨大な辞書から店舗データを探す"""
    return _STORES_DATA.get(store_id)

def _find_product(store_data: dict, product_id: str) -> dict | None:
    """（内部用）店舗データの中から、商品IDで商品を検索する"""
    # store_data['products'] の中を探す
    return store_data["products"].get(product_id)

def _check_stock(product_data: dict, quantity: int) -> bool:
    """（内部用）商品の在庫が十分か確認する"""
    return product_data["stock"] >= quantity

def _reduce_stock(product_data: dict, quantity: int):
    """（内部用）商品の在庫を減らす（副作用あり）"""
    product_data["stock"] -= quantity

def _create_order_record(product_data: dict, quantity: int) -> dict:
    """（内部用）注文記録を作成する"""
    return {
        "product_name": product_data["name"],
        "quantity": quantity,
        "total_price": product_data["price"] * quantity,
        "order_date": datetime.datetime.now().isoformat()
    }

# --- 3. 外部に公開するインターフェース（API） ---

def process_order(store_id: str, product_id: str, quantity: int):
    """
    注文処理のメインフロー。
    どの店舗(`store_id`)に対する処理なのかを、呼び出し元が常に指定する必要がある。
    """
    
    # 1. どの店舗のデータかをまず探す
    store_data = _find_store_data(store_id)
    if not store_data:
        print(f"エラー: 店舗ID '{store_id}' が見つかりません。")
        return

    store_name = store_data["name"]
    print(f"\n--- [{store_name}] 注文処理開始: 商品ID={product_id}, 数量={quantity} ---")

    # 2. その店舗の商品を探す
    product = _find_product(store_data, product_id)
    if not product:
        print(f"エラー: [{store_name}] 指定された商品が見つかりません。")
        return

    # 3. その商品の在庫をチェックする
    if not _check_stock(product, quantity):
        print(f"エラー: [{store_name}] {product['name']}の在庫が不足しています。")
        return

    # 4. 在庫を減らす（_STORES_DATA の深い階層にある辞書が直接変更される）
    _reduce_stock(product, quantity)
    
    # 5. 注文記録を作成する
    order_record = _create_order_record(product, quantity)
    
    # 6. その店舗の注文履歴（ordersリスト）に追加する
    store_data["orders"].append(order_record)

    print(f"注文成功: [{store_name}] {product['name']}を{quantity}個受け付けました。")

def get_current_stock_info(store_id: str) -> dict | None:
    """
    指定された店舗の現在の在庫情報を取得する（公開関数）
    """
    store_data = _find_store_data(store_id)
    if not store_data:
        return None
    
    # 店舗データの中の "products" 辞書を元に、分かりやすい形式の辞書を新しく作って返す
    return {
        pdata["name"]: pdata["stock"] 
        for pid, pdata in store_data["products"].items()
    }
```

-----

## 🏛️ `main.py` : 複数店舗への注文

`main.py` からは、`logic.py` を呼び出す際に `store_id` ("tokyo" や "osaka") を渡すだけです。

```python:main.py
import logic

if __name__ == "__main__":
    print("--- 初期在庫 ---")
    # "tokyo" を指定して東京店の在庫を取得
    print("東京店:", logic.get_current_stock_info("tokyo"))
    # "osaka" を指定して大阪店の在庫を取得
    print("大阪店:", logic.get_current_stock_info("osaka"))

    # シナリオ1: 東京店で注文
    logic.process_order("tokyo", "p-001", 3)

    # シナリオ2: 大阪店で注文
    logic.process_order("osaka", "p-002", 5)

    # シナリオ3: 東京店で在庫不足エラー
    # 東京店のキーボード在庫(5個)に対して10個注文
    logic.process_order("tokyo", "p-002", 10)

    # シナリオ4: 大阪店では同じ注文が成功
    # 大阪店のキーボード在庫(12個)に対して10個注文
    logic.process_order("osaka", "p-002", 10)

    print("\n--- 最終在庫 ---")
    print("東京店:", logic.get_current_stock_info("tokyo"))
    print("大阪店:", logic.get_current_stock_info("osaka"))
```

-----

## 🚧 限界の再確認 - なぜこのアプローチは破綻するのか？

このコードは一見動作しますが、`PP-01` `PP-02` で指摘した問題が、さらに深刻化しています。

### 1\. 🤯 状態管理のさらなる複雑化

データ構造が `_STORES_DATA` という「辞書の辞書の辞書のリスト…」という、非常に深く複雑な一つの「怪物」になってしまいました。
`logic.py` 内の関数群が、この巨大なデータ構造のどの部分を、どの順番で書き換えるのかを、プログラム全体で把握し続けるのは極めて困難です。

### 2\. 📉 拡張性のさらなる低下

ほぼ全ての関数が `store_id` というパラメータを必要とするようになりました。これは「引数バケツリレー」と呼ばれる悪しき兆候です。
もし次に「**顧客ごと**にポイントを管理したい」という要件が来たらどうなるでしょうか？ `process_order` やその他の多くの関数に、さらに `customer_id` を追加で渡す必要が出てくるでしょう。機能を追加するたびに、`logic.py` のほぼ全ての関数に修正が及んでしまいます。

### 3\. 👻 「店舗」という概念がコードに存在しない

最も本質的な問題はこれです。
現実世界には「東京店」「大阪店」という明確な「モノ（実体）」がありますが、私たちのコードの中には **`Store`（店舗）という概念は存在しません**。

それは `_STORES_DATA` という巨大な辞書の、\*\*単なるキー（文字列 "tokyo"）\*\*でしかありません。

その結果、`tokyo.process_order(...)` のような、現実に即した直感的なコード（＝東京店**に**注文を処理**させる**）が書けず、常に `process_order("tokyo", ...)` のように、\*\*データ（"tokyo"）**と**ロジック（`process_order`）\*\*を、外部からバラバラに指定し続ける必要があります。

-----

これらの問題は、「店舗」というビジネス上の関心事を、\*\*「店舗データ」**と**「店舗データを操作するロジック」\*\*が一体化した「モノ」として扱っていない、という手続き型パラダイムの本質的な限界から来ています。

この\*\*「関連するデータとロジックを一つにまとめ、独立した『モノ』として扱いたい」**という強い動機こそが、次のステップである**オブジェクト指向プログラミング\*\*が解決しようとする中心的な課題なのです。