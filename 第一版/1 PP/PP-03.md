# PP-03

手続き型パラダイムの限界を明確に示すため、「複数店舗」という要件に対応するプログラムを作成します。

これから、以下の2つのファイルを作成します。

1. [logic.py](http://logic.py/): 複数店舗のデータを一つの巨大な辞書で管理し、それらを操作する関数群。
2. [main.py](http://main.py/): 東京店と大阪店の注文を処理し、このアプローチの限界を解説します。

### [logic.py](http://logic.py/)

```python
import datetime

# --- データベースの代わりとなるデータ構造 ---
# 複数店舗のデータを、一つの巨大な辞書で管理する。
# これがアプリケーション全体の「状態」となり、非常に複雑化する。
_STORES_DATA = {
    "tokyo": {
        "name": "東京店",
        "products": {
            "p-001": {"name": "高機能マウス", "price": 4000, "stock": 10},
            "p-002": {"name": "静音キーボード", "price": 6000, "stock": 5},
            "p-003": {"name": "24インチモニター", "price": 25000, "stock": 3},
        },
        "orders": []
    },
    "osaka": {
        "name": "大阪店",
        "products": {
            "p-001": {"name": "高機能マウス", "price": 4100, "stock": 8},
            "p-002": {"name": "静音キーボード", "price": 6000, "stock": 12},
            "p-003": {"name": "24インチモニター", "price": 25500, "stock": 5},
        },
        "orders": []
    }
}

# --- 処理を分割した関数群 ---
# ほぼ全ての関数に「どの店舗のデータか」を示す store_id が必要になる。

def find_product(store_id: str, product_id: str) -> dict | None:
    """指定された店舗の商品データを検索する"""
    store_data = _STORES_DATA.get(store_id)
    if not store_data:
        return None
    return store_data["products"].get(product_id)

def check_stock(product_data: dict, quantity: int) -> bool:
    """商品の在庫が十分か確認する"""
    return product_data["stock"] >= quantity

def _reduce_stock(product_data: dict, quantity: int):
    """商品の在庫を減らす"""
    product_data["stock"] -= quantity

def _create_order_record(product_data: dict, quantity: int) -> dict:
    """注文記録を作成する"""
    return {
        "product_name": product_data["name"],
        "quantity": quantity,
        "total_price": product_data["price"] * quantity,
        "order_date": datetime.datetime.now().isoformat()
    }

def process_order(store_id: str, product_id: str, quantity: int):
    """
    注文処理のメインフロー。
    どの店舗に対する処理なのかを常に意識する必要がある。
    """
    store_data = _STORES_DATA.get(store_id)
    if not store_data:
        print(f"エラー: 店舗ID '{store_id}' が見つかりません。")
        return

    store_name = store_data["name"]
    print(f"\\n--- [{store_name}] 注文処理開始: 商品ID={product_id}, 数量={quantity} ---")

    product = find_product(store_id, product_id)
    if not product:
        print(f"エラー: [{store_name}] 指定された商品が見つかりません。")
        return

    if not check_stock(product, quantity):
        print(f"エラー: [{store_name}] {product['name']}の在庫が不足しています。")
        return

    _reduce_stock(product, quantity)
    order_record = _create_order_record(product, quantity)
    store_data["orders"].append(order_record)

    print(f"注文成功: [{store_name}] {product['name']}を{quantity}個受け付けました。")

def get_current_stock_info(store_id: str) -> dict | None:
    """指定された店舗の現在の在庫情報を取得する"""
    store_data = _STORES_DATA.get(store_id)
    if not store_data:
        return None
    return {pdata["name"]: pdata["stock"] for pid, pdata in store_data["products"].items()}

```

### [main.py](http://main.py/)

```bash
import logic

if __name__ == "__main__":
    print("--- 初期在庫 ---")
    print("東京店:", logic.get_current_stock_info("tokyo"))
    print("大阪店:", logic.get_current_stock_info("osaka"))

    # シナリオ1: 東京店で注文
    logic.process_order("tokyo", "p-001", 3)

    # シナリオ2: 大阪店で注文
    logic.process_order("osaka", "p-002", 5)

    # シナリオ3: 東京店で在庫不足
    logic.process_order("tokyo", "p-002", 10)

    # シナリオ4: 大阪店では在庫があるので同じ注文が成功
    logic.process_order("osaka", "p-002", 10)

    print("\\n--- 最終在庫 ---")
    print("東京店:", logic.get_current_stock_info("tokyo"))
    print("大阪店:", logic.get_current_stock_info("osaka"))

```

---

### 限界の再確認 - なぜこのアプローチは破綻するのか？

このコードは一見動作しますが、手続き型パラダイムの限界を明確に示しています。

1. 「店舗」という概念がコードに存在しない:
現実世界には「東京店」「大阪店」という明確な実体がありますが、コードの中にはStoreという概念は存在しません。それは_STORES_DATAという巨大な辞書の**ただのキー（文字列）**です。
そのため、tokyo.process_order(...)のような、現実に即した直感的なコードを書けず、常にprocess_order("tokyo", ...)のように、データとロジックを別々に指定する必要があります。
2. 状態管理のさらなる複雑化:
データ構造が「辞書の辞書の辞書のリスト…」というように、非常に深く、複雑になってしまいました。どの関数がこの巨大なデータ構造のどこを書き換えるのか、追跡するのは極めて困難です。
3. 拡張性のさらなる低下:
ほぼ全ての関数がstore_idというパラメータを必要とするようになりました。もし次に「顧客」という概念を追加したくなったら、多くの関数にcustomer_idを追加で渡す必要が出てくるでしょう。機能を追加するたびに、影響範囲がモジュール全体に及びます。

これらの問題は、「店舗」というビジネス上の関心事を、データとロジックが一体化した「オブジェクト」として扱っていないという、手続き型パラダイムの本質的な限界から来ています。

この「複数インスタンスを自然に扱えない」という課題こそが、オブジェクト指向プログラミングが解決する、最も強力な動機の一つなのです。