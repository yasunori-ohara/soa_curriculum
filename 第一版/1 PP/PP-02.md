# PP-02

手続き型の注文処理プログラムをlogic.pyとmain.pyに分割します。

logic.pyでは、データをモジュール内部変数として隠蔽する「紳士協定」としてのアンダースコアを使用します。<br>
main.pyでは、その紳士協定が強制力を持たないことを示すコードと、C言語との比較に関する補足説明を追加します。

これから、以下の2つのファイルを作成します。

1. [logic.py](http://logic.py/): 注文処理のロジックと、隠蔽されるべきデータを格納します。
2. [main.py](http://main.py/): logic.pyの機能を利用し、紳士協定の限界を実演します。

### [logic.py](http://logic.py/)

```bash
import datetime

# --- データベースの代わりとなるデータ構造 ---
# アンダースコアを付けて、モジュール内部でのみ使用されるべき変数であることを示す
_PRODUCTS_DB = {
    "p-001": {"name": "高機能マウス", "price": 4000, "stock": 10},
    "p-002": {"name": "静音キーボード", "price": 6000, "stock": 5},
    "p-003": {"name": "24インチモニター", "price": 25000, "stock": 3},
}

# 注文記録を格納するリスト
_ORDERS_LOG = []

# --- 処理を分割した関数群 ---
# これらの関数は、このモジュールが外部に提供する「公開用インターフェース」となる

def find_product(product_id: str) -> dict | None:
    """商品IDを元に商品データを検索する"""
    return _PRODUCTS_DB.get(product_id)

def check_stock(product_data: dict, quantity: int) -> bool:
    """商品の在庫が十分か確認する"""
    return product_data["stock"] >= quantity

def _reduce_stock(product_data: dict, quantity: int):
    """
    商品の在庫を減らす（内部処理用の関数）。
    アンダースコアを付けて、外部から直接呼び出すべきでないことを示す。
    """
    product_data["stock"] -= quantity
    print(f"在庫更新: {product_data['name']}の在庫が{product_data['stock']}になりました。")

def _create_order_record(product_data: dict, quantity: int) -> dict:
    """注文記録を作成する（内部処理用の関数）"""
    return {
        "product_name": product_data["name"],
        "quantity": quantity,
        "total_price": product_data["price"] * quantity,
        "order_date": datetime.datetime.now().isoformat()
    }

def process_order(product_id: str, quantity: int):
    """
    注文処理のメインフローを管理する唯一の公開関数
    """
    print(f"\\n--- 注文処理開始: 商品ID={product_id}, 数量={quantity} ---")

    product = find_product(product_id)
    if not product:
        print("エラー: 指定された商品が見つかりません。")
        return

    if not check_stock(product, quantity):
        print(f"エラー: {product['name']}の在庫が不足しています。（在庫: {product['stock']}）")
        return

    _reduce_stock(product, quantity)
    order_record = _create_order_record(product, quantity)
    _ORDERS_LOG.append(order_record)

    print(f"注文成功: {product['name']}を{quantity}個受け付けました。")

def get_current_stock_info() -> dict:
    """現在の在庫情報を取得するための公開関数"""
    return {pid: pdata["stock"] for pid, pdata in _PRODUCTS_DB.items()}

```

### [main.py](http://main.py/)

```bash
import logic

if __name__ == "__main__":
    print("--- 初期在庫 ---")
    print(logic.get_current_stock_info())

    # --- 紳士協定の限界を実演 ---
    # logicモジュールの開発者は、_PRODUCTS_DBがprocess_orderを通じてのみ変更されることを意図している。
    # しかし、Pythonのアンダースコアは単なる「規約」であり、強制力はない。
    # そのため、別の開発者がルールを無視してデータを直接書き換えることができてしまう。
    print("\\n--- ルール違反の直接アクセス ---")
    print(f"変更前のマウスの在庫: {logic._PRODUCTS_DB['p-001']['stock']}")
    logic._PRODUCTS_DB["p-001"]["stock"] = 9999 # 在庫チェックを無視して不正に書き換え
    print(f"変更後のマウスの在庫: {logic._PRODUCTS_DB['p-001']['stock']} ※不正な値")
    # --------------------------------

    # シナリオ1: 正常な注文
    logic.process_order("p-002", 2)

    # シナリオ2: 在庫不足のはずが、直接書き換えられたため注文が通ってしまう
    logic.process_order("p-001", 100)

    print("\\n--- 最終在庫 ---")
    print(logic.get_current_stock_info())

    # --- 補足: C言語との比較 ---
    # C言語の熟練者は、ファイルスコープ(static)等を駆使してモジュール内の情報を隠蔽し、
    # これに近い状態を擬似的に実現します。しかし、それはプログラマーの高度な技術と規律に
    # 依存する応用テクニックです。オブジェクト指向は、この「情報の隠蔽（カプセル化）」を
    # 言語の基本的な仕組みとして、より自然かつ安全に実現するために生まれました。

```

### 今回のコードで言うと…

- **「状態管理の複雑さ」は紳士協定に依存している**:
ファイル内に閉じ込めることで、誰でもアクセスできるグローバル変数よりは安全になりました。しかし、その安全性は`main.py`の開発者が`_PRODUCTS_DB`を直接触らない、という**紳士協定（規律）**に完全に依存しています。
プロジェクトが大規模になり、10個の別のファイルが`logic.py`をインポートし始めたらどうでしょう？誰かが協定を破ったときに、その犯人を見つけ出すのは非常に困難です。これが「状態管理の複雑さ」です。