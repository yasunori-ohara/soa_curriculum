# SOA-01

## SOA

DDDによってビジネスの核心を洗練されたモデルとして構築した今、いよいよこのカリキュラムの最終目的である**サービス指向アーキテクチャ（SOA: Service-Oriented Architecture）**へと進みます。

---

### なぜDDDの次にSOAが必要なのか？

DDDは、一つの明確なビジネス領域（境界づけられたコンテキスト）の内部をモデル化するのに非常に強力です。私たちは「注文管理」というコンテキストを見事にモデル化しました。

しかし、現実の企業活動は、複数の異なるビジネス領域が連携して成り立っています。

- 注文管理 (私たちが作ったもの)
- 在庫管理 (倉庫チームが管轄)
- 顧客管理 (営業チームが管轄)
- 配送管理 (物流チームが管轄)

現在の私たちのアプリケーションは、`ProductRepository`を通じて暗黙的に在庫管理の責任まで負ってしまっています。これでは、在庫管理のルールが複雑になった場合（例：倉庫ごとに在庫を持つ）、注文管理システムまで修正が必要になり、せっかく分離した関心事が再び癒着してしまいます。

- *サービス指向アーキテクチャ（SOA）は、このように異なるビジネス領域（コンテキスト）を、それぞれが独立した「サービス」として捉え、明確に定義された「契約（API）」**を通じて疎結合に連携させるための、システム全体の設計思想です。

---

### SOAの重要な概念

サービス (Service): 特定のビジネス機能を提供する、自己完結したコンポーネント。「在庫管理サービス」「顧客情報サービス」など。

契約 (Contract / API): サービスが外部に提供する機能の仕様書。この契約さえ守られていれば、サービスの内部実装は自由に変更できます。

疎結合 (Loose Coupling): 各サービスは互いの内部実装を知りません。契約を通じてのみ連携するため、片方のサービスが停止したり、更新されたりしても、他方のサービスへの影響を最小限に抑えられます。

---

### ECサイト注文処理（SOA適用版）

これから、私たちのアプリケーションを「注文受付サービス」として再定義し、これまで内包していた在庫管理のロジックを、外部の独立した「在庫管理サービス」に問い合わせる形にリファクタリングします。

リファクタリングのポイント

- 模擬的な「在庫管理サービス」を独立したコンポーネントとして作成します。
- 「注文受付サービス」の中に、在庫管理サービスと通信するための新しいアダプターを作成します。
- `ProcessOrderUseCase`は、在庫に関する処理を、この新しいアダプターを通じて外部サービスに委譲するようになります。

新しいファイル構造
`interface_adapters`に、外部サービスと通信するためのアダプターを追加します。また、模擬的な外部サービスを`external_services`ディレクトリに作成します。

```
soa_project/
├── domain/
│   ├── product.py
│   └── order.py
├── use_cases/
│   ├── process_order.py
│   └── interfaces.py
├── interface_adapters/
│   ├── repositories.py
│   └── inventory_service_adapter.py  # ⬅️ 外部サービスと通信するアダプター
├── external_services/                # ⬅️ 模擬的な外部サービス
│   └── inventory_service.py
└── main.py

```

---

### 実装コード

SOAへのリファクタリングは、これまでのステップで最も大きな変更となります。各ファイルがどのように変化し、連携するかにご注目ください。

---

SOA（サービス指向アーキテクチャ）へリファクタリングする際の、推奨される開発の順番とその理由を解説します。

この順番で進めることで、依存関係をクリーンに保ち、各コンポーネントを独立してテストしながら、システム全体を段階的に構築できます。

---

### 推奨される開発の順番

1. **`external_services/inventory_service.py`** （外部サービスの定義）
2. **`use_cases/interfaces.py`** （内部の接続口（ポート）の定義）
3. **`interface_adapters/inventory_service_adapter.py`** （アダプターの実装）
4. **`use_cases/process_order.py`** （ユースケースの修正）
5. **`main.py`** （全体の組み立て）

---

### 各ステップの理由

### 1. `external_services/inventory_service.py` （外部サービスの定義）

- **なぜ最初か？**: まずは**連携先となる相手の仕様を確定させる**必要があります。これから接続しようとする「在庫管理サービス」が、どのような機能（API）を提供してくれるのかが分からなければ、何も始めることができません。これは、家を建てる前に、接続する水道管や電線がどこに来ているかを確認するのと同じです。

### 2. `use_cases/interfaces.py` （内部の接続口（ポート）の定義）

- **なぜ2番目か？**: 外部サービスの仕様が分かったら、次に私たちのアプリケーション（Use Case）側で、**「自分たちは、在庫管理という機能に対して、どのような形でアクセスしたいか」という理想のインターフェース（ポート）を定義**します。これは依存性逆転の原則の核心であり、「外部の都合」ではなく「自分たちの都合」でインターフェースを決めます。

### 3. `interface_adapters/inventory_service_adapter.py` （アダプターの実装）

- **なぜ3番目か？**: 「外部サービスの仕様」と「自分たちが望むインターフェース」という2つのものが揃ったので、ここで初めて両者を**つなぐための「変換プラグ（アダプター）」**を実装できます。このアダプターは、ステップ2で定義したインターフェースを実装し、その内部でステップ1の外部サービスを呼び出すという、明確な役割を持ちます。

### 4. `use_cases/process_order.py` （ユースケースの修正）

- **なぜ4番目か？**: 外部サービスに接続するための**理想のインターフェース（ポート）が定義されたので、いよいよユースケース本体を修正します。重要なのは、このユースケースはステップ3で実装した具体的なアダプターではなく、ステップ2で定義した抽象的なインターフェースにのみ依存する**ように修正することです。これにより、ユースケースは外部サービスとの具体的な接続方法から完全に隔離されます。

### 5. `main.py` （全体の組み立て）

- **なぜ最後か？**: すべての部品（ユースケース、具体的なアダプター、外部サービスの実体）が完成したので、最後に**組立工場である`main.py`*で、これらの具体的な部品をすべて結合（依存性の注入）し、アプリケーション全体を起動します。

この順番で開発を進めることで、「依存性のルール」を常に守りながら、各部品の役割を明確にし、テスト容易性の高い、疎結合なシステムを構築することができるのです。