# 02 認識サービスのアダプター差し替え

# 🚀 ステップ2：認識サービスのアダプタ差し替え (Publisher)

第5巡の2番目のステップです。
「認識サービス」の「出口」であるアダプタを、ファイル書き出し（`File...Publisher`）から、MQTT（`Mqtt...Publisher`）に差し替えます。

---

## 🎯 このステップのゴール

- 認識サービスのUseCaseやEntityには**一切触れずに**、出力アダプタだけを差し替える。
- `world_model.json` を作成する代わりに、MQTTブローカー（中継局）へ「世界モデル」のデータを **Publish（公開）** できるようにする。

---

## 🧩 変更の概要

このステップで変更・追加するファイルは **`adapters/` フォルダ**と **`main.py`** のみです。

- **`domain/entities.py`**: 変更なし
- **`application/use_cases.py`**: 変更なし
- **`application/boundaries.py`**: 変更なし
- **`adapters/mqtt_publisher.py`**: 👈 **（新規作成）**
- **`adapters/file_publisher.py`**: （不要になるが、参照用に残しておいても良い）
- **`adapters/stub_sensor.py`**: 変更なし
- **`adapters/repositories.py`**: 変更なし
- **`main.py`**: 👈 **（インポートとDI部分を修正）**

---

## 🛠️ 手順1：MQTTクライアントのインストール

まず、PythonからMQTTブローカーと通信するための標準的なライブラリ `paho-mqtt` をインストールします。（各サービスのPython環境にインストールが必要です）

```bash
pip install paho-mqtt

```

---

## ⚙️ 手順2：MqttWorldModelPublisher の作成

`application/boundaries.py` に定義されている `PlanningServiceAdapterInterface`（インターフェース）を**実装する**、新しい「道具」クラスを作成します。

このクラスが、`File...Publisher` の代わりとなります。

```python
# adapters/mqtt_publisher.py (認識サービス内に新規作成)
import paho.mqtt.client as mqtt
import json
import asyncio
from domain.entities import WorldModel
from application.boundaries import PlanningServiceAdapterInterface

# -----------------------------------------------------------------------------
# Service Adapter Implementation (MQTT Publisher)
# - クラス図の位置: ServiceAdapter (DataAccessなどと同じ外部実装)
# - 同心円図の位置: Adapters (外側の円)
# -----------------------------------------------------------------------------
class MqttWorldModelPublisher(PlanningServiceAdapterInterface):
    """
    UseCaseの要求(I/F)に基づき、WorldModelを
    MQTTブローカーに公開（Publish）するアダプタ。
    """
    def __init__(self, broker_address: str, broker_port: int, topic: str):
        self._broker_address = broker_address
        self._broker_port = broker_port
        self._topic = topic

        # MQTTクライアントの初期化
        self._client = mqtt.Client(mqtt.CallbackAPIVersion.VERSION2)
        # 接続が切れた場合の自動再接続を有効化
        self._client.reconnect_delay_set(min_delay=1, max_delay=30)

        # 接続コールバックの設定
        self._client.on_connect = self._on_connect
        self._client.on_disconnect = self._on_disconnect

        # MQTTブローカーへの接続（非同期でバックグラウンド実行）
        try:
            self._client.connect_async(self._broker_address, self._broker_port, 60)
            # ネットワーク処理（接続、再接続、メッセージ送信）を
            # バックグラウンドスレッドで実行開始
            self._client.loop_start()
        except Exception as e:
            print(f"[Adapter] MQTT Publisher: Failed to connect initially: {e}")

    def _on_connect(self, client, userdata, flags, rc, properties=None):
        if rc == 0:
            print(f"[Adapter] MQTT Publisher: Connected to broker at {self._broker_address}")
        else:
            print(f"[Adapter] MQTT Publisher: Failed to connect, return code {rc}")

    def _on_disconnect(self, client, userdata, rc, properties=None):
        print(f"[Adapter] MQTT Publisher: Disconnected from broker. Reconnecting...")

    async def publish_world_model(self, world_model: WorldModel):
        """
        インターフェース(async)に基づき、世界モデルを公開する
        """
        # 1. WorldModelを辞書形式に変換
        world_model_dict = {
             "timestamp": world_model.timestamp.isoformat(),
             # ... objectsやparking_spacesも辞書に変換 ...
        }

        # 2. 辞書をJSON文字列（ペイロード）に変換
        payload = json.dumps(world_model_dict, indent=2)

        try:
            # 3. MQTTブローカーに公開 (publish)
            # loop_start()しているので、このpublish自体は非ブロッキング（即座に完了）
            result = self._client.publish(self._topic, payload, qos=1)

            if result.rc == mqtt.MQTT_ERR_SUCCESS:
                print(f"[Adapter] MQTT Publisher: World Model published to topic '{self._topic}'")
            else:
                # キューがいっぱい、または接続が切れている
                print(f"[Adapter] MQTT Publisher: Failed to publish (rc: {result.rc}). Will retry.")

            # インターフェースが 'async' であるため、
            # イベントループに制御を戻す（お作法）
            await asyncio.sleep(0)

        except Exception as e:
            print(f"[Adapter] MQTT Publisher: Error publishing: {e}")

```

---

## 🚀 手順3：[main.py](http://main.py/) の修正（DIの差し替え）

最後に、認識サービスの `main.py` を開き、古い `FileWorldModelPublisher` を使っていた部分を、今作成した `MqttWorldModelPublisher` に差し替えます。

```python
# main.py (認識サービス内)
import asyncio
from application.use_cases import UpdateWorldModelUseCase
from adapters.stub_sensor import StubSensorAdapter       # <- 変更なし
from adapters.repositories import InMemoryWorldModelRepository # <- 変更なし
# from adapters.file_publisher import FileWorldModelPublisher  # <- 古いアダプタ（コメントアウトまたは削除）
from adapters.mqtt_publisher import MqttWorldModelPublisher  # <- 👈 新しいアダプタをインポート

# -----------------------------------------------------------------------------
# Entry Point (Main Application)
# - クラス図の位置: Main (DIコンテナの役割)
# - 同心円図の位置: 最も外側の層 (Frameworks & Drivers)
# -----------------------------------------------------------------------------
async def main():
    """
    アプリケーションを起動し、依存関係を注入 (DI) する。
    """
    print("--- [Perception Service] Starting Up ---")

    # 1. Adapters層（具体的な実装）をインスタンス化
    sensor_adapter = StubSensorAdapter()

    # ▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼ 差し替え部分 ▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼
    # world_model_publisher = FileWorldModelPublisher(filepath="world_model.json") # <- 古いアダプタ

    # 新しいMQTTアダプタをインスタンス化
    # ブローカーの「住所」と「トピック（銘柄）」を指定する
    world_model_publisher = MqttWorldModelPublisher(
        broker_address="localhost", # ステップ1で起動したブローカー
        broker_port=1883,
        topic="autodrive/world_model" # このトピック名で公開する
    )
    # ▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲ 差し替え部分 ▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲

    world_model_repository = InMemoryWorldModelRepository()

    # 2. UseCase層に、具体的な実装を「依存性の注入 (DI)」
    #    UseCaseは差し替えられたことに気づかない
    use_case = UpdateWorldModelUseCase(
        sensor_interface=sensor_adapter,
        world_model_repo=world_model_repository,
        planning_adapter=world_model_publisher # <- 差し替え後のアダプタを渡す
    )

    # 3. アプリケーション（UseCase）の【ループ実行】
    # (※このループ部分は第4巡の最終統合で修正済み)
    print("\\n--- [Perception Service] Running in loop (Press Ctrl+C to stop) ---")
    while True:
        try:
            await use_case.handle()
            await asyncio.sleep(1)
        except Exception as e:
            print(f"--- [Perception Service] Error in loop: {e} ---")
            await asyncio.sleep(5)

if __name__ == "__main__":
    # このサービス（認識サービス）を実行
    asyncio.run(main())

```

---

## 💡 手順4：動作確認（サービス単体）

これで差し替えは完了です。動作確認をしましょう。

1. （ステップ1で起動した）**MQTTブローカーが起動している**ことを確認します。
    
    ```bash
    docker-compose up -d
    
    ```
    
2. `perception_service/` フォルダから `main.py` を実行します。
    
    ```bash
    python perception_service/main.py
    
    ```
    

### 確認するポイント

ターミナルに以下のようなログが表示されれば成功です。

```bash
--- [Perception Service] Starting Up ---
[Adapter] InMemoryRepo: Initialized.
[Adapter] MQTT Publisher: Connected to broker at localhost  # <- 👈 接続成功
...
--- [Perception Service] Running in loop (Press Ctrl+C to stop) ---
...
[Adapter] InMemoryRepo: Getting WorldModel from memory.
[Adapter] InMemoryRepo: Saving WorldModel to memory.
[Adapter] MQTT Publisher: World Model published to topic 'autodrive/world_model' # <- 👈 公開成功
...

```

そして、第4巡とは異なり、プロジェクトフォルダに `world_model.json` という**ファイルが一切作成されなくなった**ことを確認してください。
データはファイルではなく、MQTTブローカー（中継局）に直接送信されています。

---

## 🛡️ このステップの鉄則

**UseCaseは、アダプタがファイルに書こうが、ネットワークに投げようが、知る必要はない。**

`UpdateWorldModelUseCase` のコードを一切変更することなく、データの出力先をファイルからネットワーク（MQTT）に変更できました。
`UseCase` が依存していたのは、あくまで抽象的な「`PlanningServiceAdapterInterface`（窓口）」だけだったからです。
これが、クリーンアーチャクチャがもたらす「アダプタの差し替え可能性」という強力な利点です。

---

次は、「ステップ3：経路計算サービスのアダプタ差し替え」に進み、`File...Subscriber` と `File...Publisher` の両方をMQTTに置き換えます。