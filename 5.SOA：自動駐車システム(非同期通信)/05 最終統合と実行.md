# 05 最終統合と実行

# 🚀 ステップ5：最終統合と実行（＆ 振り返り）

第5巡の最終ステップへようこそ。
ステップ2〜4を通じて、3つのサービス全てのファイルI/Oアダプタを、MQTT（実通信）アダプタに差し替えました。ステップ4では、ターミナル3つを個別に起動し、それらが連携することを確認しました。

このステップでは、第4巡で作成した統合起動スクリプト `run_all_services.py` を使い、ワンコマンドでシステム全体を起動・実行します。そして、この第5巡で達成したことを振り返ります。

---

## 🎯 このステップのゴール

- 第4巡で作成した統合起動スクリプト `run_all_services.py` が、**一切の変更なしで**動作することを確認する。
- 第4巡の補足で予告した「現実の課題」（ネットワーク切断、シリアライズなど）が、新しいアダプタ層でどのように対処されたかを総括する。

---

## 🚀 手順1：統合起動スクリプトの実行

第4巡で、3つのサービスの `main()` 関数を並行実行する `run_all_services.py` をプロジェクトルートに作成しました。

このスクリプトの役割は、各サービスの `main()` 関数を呼び出すことだけです。私たちは今回、各サービスの `main()` 関数の**内部**（DIの部分）を変更しましたが、呼び出し方は変えていません。

したがって、`run_all_services.py` は**一切変更する必要がありません。**

---

## 💡 手順2：動作確認（統合スクリプト版）

`run_all_services.py` を実行し、システム全体が起動することを確認します。

1. （ステップ1で起動した）**MQTTブローカーが起動している**ことを確認します。
2. **ターミナルを1つ**開き、プロジェクトルートから統合起動スクリプトを実行します。
    
    ```bash
    python run_all_services.py
    
    ```
    

### 確認するポイント

ターミナルに、3つのサービスの起動ログと、MQTT経由でデータが連携されていくログが**混ざり合って**表示されることを確認します。

```bash
$ python run_all_services.py
=========================================
=== AUTONOMOUS PARKING SYSTEM STARTUP ===
=========================================

--- [Perception Service] Starting Up ---
[Adapter] InMemoryRepo: Initialized.
[Adapter] MQTT Publisher: Connected to broker at localhost  # <- 認識サービスが接続
...
--- [Planning Service] Starting Up ---
[Adapter] InMemoryRepo: Initialized.
[Adapter] MQTT Subscriber: Connected to broker at localhost # <- 経路計算(入力)が接続
...
--- [Control Service] Starting Up ---
[Adapter] InMemoryRepo: Initialized.
[Adapter] MQTT Subscriber: Connected to broker at localhost # <- 制御サービスが接続
...
# --- 連携開始 (ログが混在して表示される) ---
[Adapter] MQTT Publisher: World Model published to topic 'autodrive/world_model' # (1) 認識が公開
[Adapter] MQTT Subscriber: Received message from topic 'autodrive/world_model' # (2) 経路計算が受信
[UseCase] Calculating parking plan...
[Adapter] MQTT Publisher: Parking Plan published to topic 'autodrive/plan'     # (3) 経路計算が公開
[Adapter] MQTT Subscriber: Received message from topic 'autodrive/plan'        # (4) 制御が受信
[UseCase] Executing plan with 3 commands...
[Adapter] StubActuator: STEER set to -30.0 degrees                     # (5) 実行
...

```

そして、第4巡と同様に、`world_model.json` や `plan.json` ファイルが一切作成・更新されていないことも確認してください。

---

## 🔄 第5巡の振り返り：アダプタが吸収した「現実の課題」

UseCaseのコードを1行も変更せずに、ファイル連携を実ネットワーク通信に移行できました。
これは、新しく作成した `Mqtt...` アダプタが、第4巡の補足で予告した「現実の課題」をすべて引き受けてくれたおかげです。

`adapters/mqtt_subscriber.py` や `adapters/mqtt_publisher.py` のコードを見返してみましょう。

### 1. 課題：ネットワークの「不安定さ」への対処

ファイルI/Oは失敗しませんが、ネットワークは切断されます。
`Mqtt...` アダプタは、UseCaseにこの「失敗」を意識させないよう、以下の2つの処理（回復性）を実装しています。

- **自動再接続**:
    
    ```python
    self._client.reconnect_delay_set(min_delay=1, max_delay=30)
    
    ```
    
    これは `paho-mqtt` ライブラリの機能で、「接続が切れても、1秒後、次は2秒後、4秒後…（最大30秒まで）と、自動的に再接続を試み続ける」設定です。
    
- **切断時のログ**:
    
    ```python
    def _on_disconnect(self, client, userdata, rc, properties=None):
        print(f"[Adapter] MQTT ...: Disconnected from broker. Reconnecting...")
    
    ```
    
    UseCaseは「切断された」という事実さえ知る必要がありません。アダプタがバックグラウンドで静かに再接続を試みてくれます。
    

### 2. 課題：契約（シリアライズ）の実行

ネットワークで送れるのは「バイト列」だけです。`ParkingPlan` というPythonオブジェクト（Entity）をそのまま送ることはできません。
アダプタが「オブジェクト → バイト列」の変換（**シリアライズ**）を担っています。

```python
# MqttPlanPublisher.py より
async def publish_plan(self, plan: ParkingPlan):
    # 1. Entity -> 辞書 (Python)
    plan_dict = { ... }
    # 2. 辞書 -> JSON文字列 (Text)
    payload = json.dumps(plan_dict, indent=2)
    # 3. JSON文字列 -> バイト列 (UTF-8)
    #    (※ paho-mqttが内部で自動的に .encode('utf-8') している)
    result = self._client.publish(self._topic, payload, qos=1)

```

UseCaseは `ParkingPlan` オブジェクトをアダプタに渡すだけです。アダプタがそれをJSON文字列（今回の契約）に変換する作業をすべて担当しました。
もし将来、契約をJSONから**Protobuf**（より高速なバイナリ形式）に変更したくなっても、このアダプタ内部のシリアライズ処理を変更するだけで、UseCaseは影響を受けません。

### 3. 課題：サービスディスカバリ（住所録）の解決

「ブローカーの住所（IPアドレス）はどこか？」という問題（サービスディスカバリ）は、`main.py` で解決しました。

```python
# main.py より
world_model_subscriber = MqttWorldModelSubscriber(
    broker_address="localhost", # 👈 ココ (設定)
    broker_port=1883,
    topic="autodrive/world_model"
)

```

アダプタのコンストラクタ（`__init__`）に、ブローカーの住所（`localhost:1883`）を渡しています。
これは「**設定（Configuration）による依存性の注入**」の一種です。
現在はコードに直接（ハードコード）書いていますが、本番環境ではこの `"localhost"` という文字列を環境変数や設定ファイルから読み込むように変更します。
`UseCase` は、ブローカーの住所が `localhost` なのか、`192.168.1.100` なのかを一切気にする必要がありません。

---

## 🛡️ 第五巡の鉄則

**ネットワークは不安定であることを前提とせよ。そして、その不安定さをUseCaseから隠蔽せよ。**

「接続が切れたらどうしよう？」「JSONに変換しなきゃ」といった技術的な心配事は、すべて `Adapters` 層の責務です。
`UseCase` 層は、あたかもデータが必ず手に入るかのように、ビジネスロジック（経路計算）の実行だけに集中できるように設計すること。
これが、クリーンアーキテクチャがSOA（サービス指向アーキテクチャ）において絶大な力を発揮する理由です。