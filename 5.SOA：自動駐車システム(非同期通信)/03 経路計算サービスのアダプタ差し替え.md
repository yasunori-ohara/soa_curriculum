# 03 経路計算サービスのアダプタ差し替え

# 🚀 ステップ3：経路計算サービスのアダプタ差し替え (Subscriber & Publisher)

第5巡の3番目のステップです。
「経路計算サービス」の「入り口」と「出口」の両方を、ファイルI/OからMQTTに差し替えます。

- **入力**: `FileWorldModelSubscriber` ➔ `MqttWorldModelSubscriber`
- **出力**: `FilePlanPublisher` ➔ `MqttPlanPublisher`

---

## 🎯 このステップのゴール

- 経路計算サービスのUseCaseやEntityには**一切触れずに**、入力・出力の両アダプタを差し替える。
- `world_model.json` を**購読（Subscribe）** し、`plan.json` を**公開（Publish）** するように変更する。

---

## 🧩 変更の概要

このステップで変更・追加するファイルは **`adapters/` フォルダ**と **`main.py`** のみです。

- **`domain/entities.py`**: 変更なし
- **`application/use_cases.py`**: 変更なし
- **`application/boundaries.py`**: 変更なし
- **`adapters/mqtt_subscriber.py`**: 👈 **（新規作成）**
- **`adapters/mqtt_publisher.py`**: 👈 **（新規作成）**
- **`adapters/file_...`**: （不要になる）
- **`adapters/repositories.py`**: 変更なし
- **`main.py`**: 👈 **（インポートとDI部分を修正）**

---

## 🛠️ 手順1：MQTTクライアントのインストール（確認）

（ステップ2で `paho-mqtt` をインストール済みであれば、この手順は不要です。）

```bash
pip install paho-mqtt

```

---

## ⚙️ 手順2：MqttWorldModelSubscriber の作成

`application/boundaries.py` に定義されている `WorldModelSubscriberInterface`（インターフェース）を実装する、新しい「入力アダプタ」クラスを作成します。

これはMQTTの「プッシュ型（データが来たら通知）」の動作を、UseCaseが要求する「プル型（`get_world_model()`）」に変換する、重要なアダプタです。

```python
# adapters/mqtt_subscriber.py (経路計算サービス内に新規作成)
import paho.mqtt.client as mqtt
import json
import asyncio
from domain.entities import WorldModel, DetectedObject, ParkingSpace # Entity定義
from application.boundaries import WorldModelSubscriberInterface
from typing import Optional
from datetime import datetime

# -----------------------------------------------------------------------------
# Service Adapter Implementation (MQTT Subscriber)
# - クラス図の位置: ServiceAdapter
# - 同心円図の位置: Adapters (外側の円)
# -----------------------------------------------------------------------------
class MqttWorldModelSubscriber(WorldModelSubscriberInterface):
    """
    UseCaseの要求(I/F)に基づき、MQTTブローカーから
    WorldModelを購読（Subscribe）するアダプタ。
    """
    def __init__(self, broker_address: str, broker_port: int, topic: str):
        self._broker_address = broker_address
        self._broker_port = broker_port
        self._topic = topic

        # UseCaseに渡すための、最新のWorldModelを保持する変数
        self._latest_world_model: Optional[WorldModel] = None

        # MQTTクライアントの初期化
        self._client = mqtt.Client(mqtt.CallbackAPIVersion.VERSION2)
        self._client.reconnect_delay_set(min_delay=1, max_delay=30)

        # コールバック関数の設定
        self._client.on_connect = self._on_connect
        self._client.on_disconnect = self._on_disconnect
        self._client.on_message = self._on_message # 👈 メッセージ受信時の関数

        # 接続とバックグラウンド実行
        try:
            self._client.connect_async(self._broker_address, self._broker_port, 60)
            self._client.loop_start() # バックグラウンドで受信処理を開始
        except Exception as e:
            print(f"[Adapter] MQTT Subscriber: Failed to connect initially: {e}")

    def _on_connect(self, client, userdata, flags, rc, properties=None):
        if rc == 0:
            print(f"[Adapter] MQTT Subscriber: Connected to broker at {self._broker_address}")
            # 接続成功時に、指定されたトピックを購読（Subscribe）する
            client.subscribe(self._topic)
            print(f"[Adapter] MQTT Subscriber: Subscribed to topic '{self._topic}'")
        else:
            print(f"[Adapter] MQTT Subscriber: Failed to connect, return code {rc}")

    def _on_disconnect(self, client, userdata, rc, properties=None):
        print(f"[Adapter] MQTT Subscriber: Disconnected from broker. Reconnecting...")

    def _on_message(self, client, userdata, msg):
        """
        [MQTT Push] ブローカーからメッセージを受信したときに呼び出される
        """
        try:
            print(f"[Adapter] MQTT Subscriber: Received message from topic '{msg.topic}'")
            payload = msg.payload.decode('utf-8')
            data = json.loads(payload)

            # JSON辞書からWorldModel Entityに変換
            world_model = WorldModel(
                timestamp=datetime.fromisoformat(data["timestamp"]),
                # (※ ネストしたオブジェクトの変換は別途必要)
            )

            # 受信した最新のWorldModelを内部に保存
            self._latest_world_model = world_model

        except json.JSONDecodeError:
            print("[Adapter] MQTT Subscriber: Failed to decode JSON message")
        except Exception as e:
            print(f"[Adapter] MQTT Subscriber: Error processing message: {e}")

    async def get_world_model(self) -> Optional[WorldModel]:
        """
        [UseCase Pull] UseCaseから呼び出されたときに、
        内部に保存されている最新のWorldModelを返す
        """
        # UseCaseは非同期I/O（await）を期待しているため、
        # イベントループに制御を戻す（お作法）
        await asyncio.sleep(0)

        # _on_message で保存された最新のモデルを返す
        return self._latest_world_model

```

---

## ⚙️ 手順3：MqttPlanPublisher の作成

次に、`application/boundaries.py` の `PlanPublisherInterface` を実装する、「出口」用のアダプタを作成します。
これはステップ2で作成した `MqttWorldModelPublisher` とほぼ同じですが、公開するトピック名が異なります。

```python
# adapters/mqtt_publisher.py (経路計算サービス内に新規作成)
import paho.mqtt.client as mqtt
import json
import asyncio
from domain.entities import ParkingPlan # 👈 出力するEntity
from application.boundaries import PlanPublisherInterface # 👈 実装するI/F

# -----------------------------------------------------------------------------
# Service Adapter Implementation (MQTT Publisher)
# - クラス図の位置: ServiceAdapter
# - 同心円図の位置: Adapters (外側の円)
# -----------------------------------------------------------------------------
class MqttPlanPublisher(PlanPublisherInterface):
    """
    UseCaseの要求(I/F)に基づき、ParkingPlanを
    MQTTブローカーに公開（Publish）するアダプタ。
    """
    def __init__(self, broker_address: str, broker_port: int, topic: str):
        self._broker_address = broker_address
        self._broker_port = broker_port
        self._topic = topic

        self._client = mqtt.Client(mqtt.CallbackAPIVersion.VERSION2)
        self._client.reconnect_delay_set(min_delay=1, max_delay=30)
        self._client.on_connect = self._on_connect
        self._client.on_disconnect = self._on_disconnect

        try:
            self._client.connect_async(self._broker_address, self._broker_port, 60)
            self._client.loop_start()
        except Exception as e:
            print(f"[Adapter] MQTT Publisher: Failed to connect initially: {e}")

    def _on_connect(self, client, userdata, flags, rc, properties=None):
        if rc == 0:
            print(f"[Adapter] MQTT Publisher: Connected to broker at {self._broker_address}")
        else:
            print(f"[Adapter] MQTT Publisher: Failed to connect, return code {rc}")

    def _on_disconnect(self, client, userdata, rc, properties=None):
        print(f"[Adapter] MQTT Publisher: Disconnected from broker. Reconnecting...")

    async def publish_plan(self, plan: ParkingPlan):
        """
        インターフェース(async)に基づき、駐車計画を公開する
        """
        # ParkingPlanを辞書形式に変換
        plan_dict = {
             "timestamp": plan.timestamp.isoformat(),
             "commands": [cmd.__dict__ for cmd in plan.commands]
        }
        payload = json.dumps(plan_dict, indent=2)

        try:
            # MQTTブローカーに公開 (publish)
            result = self._client.publish(self._topic, payload, qos=1)

            if result.rc == mqtt.MQTT_ERR_SUCCESS:
                print(f"[Adapter] MQTT Publisher: Parking Plan published to topic '{self._topic}'")
            else:
                print(f"[Adapter] MQTT Publisher: Failed to publish (rc: {result.rc}). Will retry.")

            await asyncio.sleep(0)

        except Exception as e:
            print(f"[Adapter] MQTT Publisher: Error publishing: {e}")

```

---

## 🚀 手順4：[main.py](http://main.py/) の修正（DIの差し替え）

最後に、経路計算サービスの `main.py` を開き、ファイルI/Oアダプタを使っていた部分を、今作成した2つのMQTTアダプタに差し替えます。

```python
# main.py (経路計算サービス内)
import asyncio
from application.use_cases import CalculateParkingPlanUseCase
# from adapters.file_subscriber import FileWorldModelSubscriber # <- 古いアダプタ
from adapters.mqtt_subscriber import MqttWorldModelSubscriber # <- 👈 新しい入力アダプタ
from adapters.repositories import InMemoryPlanRepository        # <- 変更なし
# from adapters.file_publisher import FilePlanPublisher       # <- 古いアダプタ
from adapters.mqtt_publisher import MqttPlanPublisher       # <- 👈 新しい出力アダプタ

# -----------------------------------------------------------------------------
# Entry Point (Main Application)
# - クラス図の位置: Main (DIコンテナの役割)
# - 同心円図の位置: 最も外側の層 (Frameworks & Drivers)
# -----------------------------------------------------------------------------
async def main():
    """
    アプリケーションを起動し、依存関係を注入 (DI) する。
    """
    print("--- [Planning Service] Starting Up ---")

    # 1. Adapters層（具体的な実装）をインスタンス化

    # ▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼ 差し替え部分1 (入力) ▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼
    # world_model_subscriber = FileWorldModelSubscriber(filepath="world_model.json") # <- 古いアダプタ

    # 新しいMQTT Subscriberをインスタンス化
    world_model_subscriber = MqttWorldModelSubscriber(
        broker_address="localhost",
        broker_port=1883,
        topic="autodrive/world_model" # 👈 認識サービスが公開するトピックを購読
    )
    # ▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲ 差し替え部分1 ▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲

    # ▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼ 差し替え部分2 (出力) ▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼
    # plan_publisher = FilePlanPublisher(filepath="plan.json") # <- 古いアダプタ

    # 新しいMQTT Publisherをインスタンス化
    plan_publisher = MqttPlanPublisher(
        broker_address="localhost",
        broker_port=1883,
        topic="autodrive/plan" # 👈 このトピック名で計画を公開
    )
    # ▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲ 差し替え部分2 ▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲

    plan_repository = InMemoryPlanRepository()

    # 2. UseCase層に、具体的な実装を「依存性の注入 (DI)」
    #    UseCaseは差し替えられたことに気づかない
    use_case = CalculateParkingPlanUseCase(
        world_model_sub=world_model_subscriber,
        plan_repo=plan_repository,
        plan_pub=plan_publisher
    )

    # 3. アプリケーション（UseCase）の【ループ実行】
    # (※このループ部分は第4巡の最終統合で修正済み)
    print("\\n--- [Planning Service] Running in loop (Press Ctrl+C to stop) ---")
    while True:
        try:
            await use_case.handle()
            await asyncio.sleep(1)
        except Exception as e:
            print(f"--- [Planning Service] Error in loop: {e} ---")
            await asyncio.sleep(5)

if __name__ == "__main__":
    # このサービス（経路計算サービス）を実行
    asyncio.run(main())

```

---

## 💡 手順5：動作確認（2サービス連携）

これで差し替えは完了です。動作確認をしましょう。

1. （ステップ1で起動した）**MQTTブローカーが起動している**ことを確認します。
2. **ターミナルを2つ**開きます。
3. **ターミナル1**で、**認識サービス**（ステップ2で修正済み）を実行します。
    
    ```bash
    python perception_service/main.py
    
    ```
    
4. **ターミナル2**で、今回修正した**経路計算サービス**を実行します。
    
    ```bash
    python planning_service/main.py
    
    ```
    

### 確認するポイント

ターミナル1（認識サービス）:

```bash
...
[Adapter] MQTT Publisher: Connected to broker...
...
[Adapter] MQTT Publisher: World Model published to topic 'autodrive/world_model' # <- 公開
...

```

ターミナル2（経路計算サービス）:

```bash
...
[Adapter] MQTT Subscriber: Connected to broker...
[Adapter] MQTT Subscriber: Subscribed to topic 'autodrive/world_model' # <- 購読
[Adapter] MQTT Publisher: Connected to broker...
...
[Adapter] MQTT Subscriber: Received message from topic 'autodrive/world_model' # <- 👈 受信成功！
[UseCase] Calculating parking plan...
[Adapter] InMemoryRepo: Saving ParkingPlan to memory.
[Adapter] MQTT Publisher: Parking Plan published to topic 'autodrive/plan'     # <- 👈 公開成功！
...

```

`world_model.json` や `plan.json` ファイルが一切使われず、ネットワーク（MQTT）経由でデータが連携されていることを確認してください。

---

## 🛡️ このステップの鉄則

**UseCaseは、入出力がファイルでもネットワークでも、その違いを吸収するのがアダプタの責務である。**

`MqttWorldModelSubscriber` は、MQTTの「プッシュ型」の動作を、UseCaseが要求する「プル型（`get_world_model()`）」に見事に変換（アダプト）しました。
これにより、UseCaseは通信方式の変更に一切気づくことなく、ビジネスロジックに集中し続けることができます。

---

次は、「ステップ4：車両制御サービスのアダプタ差し替え」に進み、最後の `Subscriber` を置き換えます。