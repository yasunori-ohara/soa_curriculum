# 04 車両制御サービスのアダプタ差し替え

# 🚀 ステップ4：車両制御サービスのアダプタ差し替え (Subscriber)

第5巡の4番目のステップです。
「車両制御サービス」の「入り口」であるアダプタを、ファイル読み込み（`File...Subscriber`）から、MQTT（`Mqtt...Subscriber`）に差し替えます。

- **入力**: `FilePlanSubscriber` ➔ `MqttPlanSubscriber`
- **出力**: `StubActuatorAdapter` （※これはハードウェアへの出力であり、サービス間連携ではないため**変更なし**）

---

## 🎯 このステップのゴール

- 車両制御サービスのUseCaseやEntityには**一切触れずに**、入力アダプタだけを差し替える。
- `plan.json` を読み込む代わりに、MQTTブローカーから「駐車計画」を **購読（Subscribe）** できるようにする。

---

## 🧩 変更の概要

このステップで変更・追加するファイルは `adapters/` フォルダと `main.py` のみです。

- **`domain/entities.py`**: 変更なし
- **`application/use_cases.py`**: 変更なし
- **`application/boundaries.py`**: 変更なし
- **`adapters/mqtt_subscriber.py`**: 👈 **（新規作成）**
- **`adapters/file_subscriber.py`**: （不要になる）
- **`adapters/stub_actuator.py`**: 変更なし
- **`adapters/repositories.py`**: 変更なし
- **`main.py`**: 👈 **（インポートとDI部分を修正）**

---

## 🛠️ 手順1：MQTTクライアントのインストール（確認）

（ステップ2または3で `paho-mqtt` をインストール済みであれば、この手順は不要です。）

```bash
pip install paho-mqtt

```

---

## ⚙️ 手順2：MqttPlanSubscriber の作成

`application/boundaries.py` に定義されている `PlanSubscriberInterface`（インターフェース）を実装する、新しい「入力アダプタ」クラスを作成します。
これは、ステップ3で作成した `MqttWorldModelSubscriber` とほぼ同じロジックですが、購読するトピックと、受け取るデータ（Entity）が異なります。

```python
# adapters/mqtt_subscriber.py (車両制御サービス内に新規作成)
import paho.mqtt.client as mqtt
import json
import asyncio
from domain.entities import ParkingPlan, ControlCommand # 👈 駐車計画のEntity
from application.boundaries import PlanSubscriberInterface # 👈 実装するI/F
from typing import Optional
from datetime import datetime

# -----------------------------------------------------------------------------
# Service Adapter Implementation (MQTT Subscriber)
# - クラス図の位置: ServiceAdapter
# - 同心円図の位置: Adapters (外側の円)
# -----------------------------------------------------------------------------
class MqttPlanSubscriber(PlanSubscriberInterface):
    """
    UseCaseの要求(I/F)に基づき、MQTTブローカーから
    ParkingPlanを購読（Subscribe）するアダプタ。
    """
    def __init__(self, broker_address: str, broker_port: int, topic: str):
        self._broker_address = broker_address
        self._broker_port = broker_port
        self._topic = topic

        # UseCaseに渡すための、最新のParkingPlanを保持する変数
        self._latest_plan: Optional[ParkingPlan] = None
        # 一度実行した計画を再度実行しないためのID管理（簡易的）
        self._last_plan_timestamp: Optional[datetime] = None

        # MQTTクライアントの初期化
        self._client = mqtt.Client(mqtt.CallbackAPIVersion.VERSION2)
        self._client.reconnect_delay_set(min_delay=1, max_delay=30)

        # コールバック関数の設定
        self._client.on_connect = self._on_connect
        self._client.on_disconnect = self._on_disconnect
        self._client.on_message = self._on_message # 👈 メッセージ受信時の関数

        # 接続とバックグラウンド実行
        try:
            self._client.connect_async(self._broker_address, self._broker_port, 60)
            self._client.loop_start() # バックグラウンドで受信処理を開始
        except Exception as e:
            print(f"[Adapter] MQTT Subscriber: Failed to connect initially: {e}")

    def _on_connect(self, client, userdata, flags, rc, properties=None):
        if rc == 0:
            print(f"[Adapter] MQTT Subscriber: Connected to broker at {self._broker_address}")
            # 接続成功時に、指定されたトピックを購読（Subscribe）する
            client.subscribe(self._topic)
            print(f"[Adapter] MQTT Subscriber: Subscribed to topic '{self._topic}'")
        else:
            print(f"[Adapter] MQTT Subscriber: Failed to connect, return code {rc}")

    def _on_disconnect(self, client, userdata, rc, properties=None):
        print(f"[Adapter] MQTT Subscriber: Disconnected from broker. Reconnecting...")

    def _on_message(self, client, userdata, msg):
        """
        [MQTT Push] ブローカーからメッセージを受信したときに呼び出される
        """
        try:
            print(f"[Adapter] MQTT Subscriber: Received message from topic '{msg.topic}'")
            payload = msg.payload.decode('utf-8')
            data = json.loads(payload)

            # JSON辞書からParkingPlan Entityに変換
            plan_timestamp = datetime.fromisoformat(data["timestamp"])

            # (簡易的な重複実行防止)
            if self._last_plan_timestamp and self._last_plan_timestamp == plan_timestamp:
                # print("[Adapter] MQTT Subscriber: Received plan is same as last one. Ignoring.")
                return # 同じ計画は無視

            self._last_plan_timestamp = plan_timestamp
            plan = ParkingPlan(
                timestamp=plan_timestamp,
                commands=[ControlCommand(**cmd) for cmd in data["commands"]]
            )

            # 受信した最新のParkingPlanを内部に保存
            self._latest_plan = plan

        except json.JSONDecodeError:
            print("[Adapter] MQTT Subscriber: Failed to decode JSON message")
        except Exception as e:
            print(f"[Adapter] MQTT Subscriber: Error processing message: {e}")

    async def get_plan(self) -> Optional[ParkingPlan]:
        """
        [UseCase Pull] UseCaseから呼び出されたときに、
        内部に保存されている最新のParkingPlanを返す
        """
        await asyncio.sleep(0)

        # _on_message で保存された最新の計画を返す
        plan_to_execute = self._latest_plan

        # 一度返したら（実行したら）計画をクリアし、多重実行を防ぐ
        self._latest_plan = None

        return plan_to_execute

```

*(補足: `get_plan()` で `_latest_plan = None` としているのは、`handle()` ループが高速で回った場合に、同じ計画を何度も実行してしまうのを防ぐための簡易的な「実行済み」管理です)*

---

## 🚀 手順3：[main.py](http://main.py/) の修正（DIの差し替え）

最後に、車両制御サービスの `main.py` を開き、`FilePlanSubscriber` を使っていた部分を、今作成した `MqttPlanSubscriber` に差し替えます。

```python
# main.py (車両制御サービス内)
import asyncio
from application.use_cases import ExecutePlanUseCase
# from adapters.file_subscriber import FilePlanSubscriber       # <- 古いアダプタ
from adapters.mqtt_subscriber import MqttPlanSubscriber       # <- 👈 新しい入力アダプタ
from adapters.repositories import InMemoryVehicleStateRepository # <- 変更なし
from adapters.stub_actuator import StubActuatorAdapter           # <- 変更なし

# -----------------------------------------------------------------------------
# Entry Point (Main Application)
# - クラス図の位置: Main (DIコンテナの役割)
# - 同心円図の位置: 最も外側の層 (Frameworks & Drivers)
# -----------------------------------------------------------------------------
async def main():
    """
    アプリケーションを起動し、依存関係を注入 (DI) する。
    """
    print("--- [Control Service] Starting Up ---")

    # 1. Adapters層（具体的な実装）をインスタンス化

    # ▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼ 差し替え部分 (入力) ▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼
    # plan_subscriber = FilePlanSubscriber(filepath="plan.json") # <- 古いアダプタ

    # 新しいMQTT Subscriberをインスタンス化
    plan_subscriber = MqttPlanSubscriber(
        broker_address="localhost",
        broker_port=1883,
        topic="autodrive/plan" # 👈 経路計算サービスが公開するトピックを購読
    )
    # ▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲ 差し替え部分 ▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲

    state_repository = InMemoryVehicleStateRepository()
    actuator_adapter = StubActuatorAdapter()

    # 2. UseCase層に、具体的な実装を「依存性の注入 (DI)」
    #    UseCaseは差し替えられたことに気づかない
    use_case = ExecutePlanUseCase(
        plan_sub=plan_subscriber,
        state_repo=state_repository,
        actuator=actuator_adapter
    )

    # 3. アプリケーション（UseCase）の【ループ実行】
    # (※このループ部分は第4巡の最終統合で修正済み)
    print("\\n--- [Control Service] Running in loop (Press Ctrl+C to stop) ---")
    while True:
        try:
            await use_case.handle()
            await asyncio.sleep(1)
        except Exception as e:
            print(f"--- [Control Service] Error in loop: {e} ---")
            await asyncio.sleep(5)

if __name__ == "__main__":
    # このサービス（車両制御サービス）を実行
    asyncio.run(main())

```

---

## 💡 手順4：動作確認（全サービス連携）

これで、3つすべてのサービスがMQTTに対応しました。システム全体を通して動作確認をしましょう。

1. （ステップ1で起動した）**MQTTブローカーが起動している**ことを確認します。
2. **ターミナルを3つ**開きます。
3. **ターミナル1**で、**認識サービス**（ステップ2で修正済み）を実行します。
    
    ```bash
    python perception_service/main.py
    
    ```
    
4. **ターミナル2**で、**経路計算サービス**（ステップ3で修正済み）を実行します。
    
    ```bash
    python planning_service/main.py
    
    ```
    
5. **ターミナル3**で、今回修正した**車両制御サービス**を実行します。
    
    ```bash
    python control_service/main.py
    
    ```
    

### 確認するポイント

3つのターミナルがそれぞれ起動し、以下のようにデータが**ネットワーク（MQTT）経由で**流れていくことを確認します。

**ターミナル1 (認識サービス)**

```bash
...
[Adapter] MQTT Publisher: Connected to broker...
...
[Adapter] MQTT Publisher: World Model published to topic 'autodrive/world_model'
...

```

**ターミナル2 (経路計算サービス)**

```bash
...
[Adapter] MQTT Subscriber: Connected to broker...
[Adapter] MQTT Subscriber: Subscribed to topic 'autodrive/world_model'
...
[Adapter] MQTT Subscriber: Received message from topic 'autodrive/world_model'
[UseCase] Calculating parking plan...
[Adapter] MQTT Publisher: Parking Plan published to topic 'autodrive/plan'
...

```

**ターミナル3 (車両制御サービス)**

```bash
...
[Adapter] MQTT Subscriber: Connected to broker...
[Adapter] MQTT Subscriber: Subscribed to topic 'autodrive/plan'
...
[Adapter] MQTT Subscriber: Received message from topic 'autodrive/plan'
[UseCase] Executing plan with 3 commands...
[Adapter] StubActuator: STEER set to -30.0 degrees
[Adapter] StubActuator: THROTTLE set to -0.5 m/s^2
...

```

`world_model.json` や `plan.json` ファイルが一切作成・更新されていないことも確認してください。

---

## 🛡️ このステップの鉄則

**UseCaseは、入出力がファイルでもネットワークでも、その違いを吸収するのがアダプタの責務である。**

`MqttWorldModelSubscriber` は、MQTTの「プッシュ型」の動作を、UseCaseが要求する「プル型（`get_world_model()`）」に見事に変換（アダプト）しました。
これにより、UseCaseは通信方式の変更に一切気づくことなく、ビジネスロジックに集中し続けることができます。

---

次は、「ステップ5：最終統合と実行（＆ 振り返り）」に進み、この第5巡の学びをまとめます。