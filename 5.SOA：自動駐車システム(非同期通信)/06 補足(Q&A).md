# 06 補足（Q&A）

# 🎓 第5巡：補足（Q&A）

第5巡（実通信）を完了したことで、ファイルI/Oでは見えなかった、より実践的な疑問が出てくるかもしれません。このページでは、そうした疑問点をQ&A形式で補足していきます。

---

## ❓ Q1: SOAの通信は REST (OpenAPI) ではないのですか？

**SOAの学習を始めると、まず REST や OpenAPI といった技術に触れることが多いため、「SOA = REST」というイメージを持つかもしれませんが**、それはSOAの**一面**にすぎません。

結論から言うと、**REST (OpenAPI) も MQTT (Pub/Sub) も、どちらもSOAを実現するための立派な「通信手段」**です。どちらを採用するかは、システムの「目的」によって使い分けられます。

---

### 2つのSOA通信パターン

SOAの通信パターンは、大きく「同期的」か「非同期的」かに分かれます。

### 1. 同期的SOA（リクエスト/レスポンス型）

- **代表技術**: REST (OpenAPI), gRPC
- **動作イメージ**: レストランでの「注文」
- **概要**: サービスB（客）が、サービスA（店員）に「データをください」と**要求（リクエスト）**し、サービスAが「はい、どうぞ」と**応答（レスポンス）**するまで、サービスBは（基本的に）待ちます。
- **契約**: OpenAPIは、この「メニュー表と注文方法（リクエストとレスポンスの仕様）」を厳格に定義する「契約書」です。
- **適した用途**: 銀行の残高照会、ユーザー認証など、「今すぐ答えが欲しい」1対1のやり取り。

### 2. 非同期的SOA（イベント駆動型 / Pub/Sub）

- **代表技術**: MQTT, AMQP (RabbitMQ), Kafka
- **動作イメージ**: 「新聞」や「ラジオ放送」
- **概要**: サービスA（新聞社/放送局）は、中継局（ブローカー）に対して「データができたよ」と**公開（Publish）**するだけです。サービスAは、誰が聞いているか知りません。
- **契約**: MQTTでは、「トピック名（`/world_model`など）」と「メッセージの中身（JSONやProtobuf）」が「契約」となります。
- **適した用途**: センサーデータの配信、交通情報のブロードキャストなど、「最新情報を一方的に流し、必要な人が勝手に利用する」1対多のやり取り。

---

### なぜ今回はMQTT（非同期）を選んだのか？

今回の自動駐車システムには、MQTT（非同期）が最適でした。

1. **ユースケースとの一致**:
認識サービスは「現在の状況」をブロードキャスト（放送）する役割です。経路計算サービスは「ユーザー情報をくれ」と要求するのではなく、その「放送」を聞いて（購読して）勝手に判断します。これは典型的なPub/Subモデルです。
2. **第4巡との互換性**:
第4巡のファイル連携（書きっぱなし・読みっぱなし）は、まさに「非同期」モデルでした。MQTTを採用したことで、UseCaseのロジックを一切変更せず、アダプタの差し替えだけで第5巡に移行できました。もしREST（同期的）を採用していたら、UseCaseの `handle()` の中身を「リクエストを待つ」「リクエストを送る」といったロジックに根本的に変更する必要がありました。

## ❓ Q2: DDD（ドメイン駆動設計）は学ばなくてもSOAへ進める？

「クリーンアーキテクチャ(CA)からSOAへ進む前に、ドメイン駆動設計(DDD)を学ぶべきか？」という疑問を持つかもしれません。

結論から言うと、**CAをしっかり理解・実践できていれば、DDDを（意識的に）挟まなくても、SOAへは非常に素直に移行できます**。

---

### なぜ「素直に行ける」のか？

理由は、**クリーンアーキテクチャが、DDDの最も重要な設計原則（戦術的パターン）をすでに実装しているから**です。

私たちが第1〜3巡で学んだこと：

1. **ドメインの隔離**: `Entity`（ドメイン）を円の中心に置き、`UseCase` や `Adapters`（インフラ）から隔離しました。
2. **依存関係の逆転**: `Adapters` が `UseCase` に依存し、`UseCase` が `Entity` に依存するルールを徹底しました。

これらは、まさにDDDが目指す「**ドメイン（ビジネスの本質）を、技術的な詳細（DBやUI）から守る**」という思想そのものです。

CAをマスターした時点で、学習者はDDDの「どう作るか（How）」の部分を既に達成しています。そのため、第4巡・第5巡でSOA（＝サービスという単位で分割する）へ移行する際も、抵抗なく進められるのです。

---

### では、DDDの価値はどこにあるのか？

CAは「ドメインの**守り方**」は教えてくれましたが、「**そもそも何がドメインで、どこまでがそのドメインの範囲か？**」という「境界線の引き方」については、あまり深く触れませんでした。

DDDは、この「**境界線の引き方（戦略的パターン）**」を学ぶための強力な手法を提供します。

### 1. ユビキタス言語（＝境界線を「見つける」道具）

- **課題**: 今回は「認識」「経路計算」「制御」という境界線が比較的明確でした。しかし、例えばECサイトで「どこまでが『注文』サービスで、どこからが『決済』サービスか？」という境界線を引くのは非常に困難です。
- **DDDの答え**: 専門家（ドメインエキスパート）と開発者が「**ユビキタス言語（共通言語）**」で会話し、業務の文脈（コンテキスト）を明確にすることで、自然な「境界線（＝**境界づけられたコンテキスト**）」が見えてきます。

### 2. 集約（＝境界線を「守る」道具）

- **課題**: DDDの核心と言われる「**集約 (Aggregate)**」は、「**データの整合性を保つべき最小単位（＝ひとまとまりのEntity群）**」を定義します。これは、境界線を引いた後の「守り方」にも関係します。
- **例**: 「注文」という集約があった場合、「注文明細」だけを勝手に変更・削除することは許されません。必ず「注文」という窓口（集約ルート）を通して操作し、「注文合計金額」も同時に更新される必要があります。
- **SOAとの関係**: この「**集約」の境界線が、そのまま「サービス」の境界線になる**ことが非常に多いのです。
    - 「注文」集約 ➔ 「注文サービス」が管理する
    - 「在庫」集約 ➔ 「在庫サービス」が管理する

---

### 結論

CAからSOAへスムーズに進めたと感じるのは、CAの教育効果が高い証拠です。

DDDは、今回の「自動駐車システム」のように境界線が比較的見えやすいケースよりも、**より複雑な業務ドメインに直面し、どこでサービスを分割すべきか（境界線）を見つけるのが困難な場合**に、その真価（ユビキタス言語、境界づけられたコンテキスト、集約など）を発揮します。

したがって、「まずはCAをしっかり学び、SOAへ進む。そして、より複雑なドメインに挑戦する際にDDDの戦略的パターンを深く学ぶ」という学習順序は、非常に合理的と言えます。

## ❓ Q3: サービスの境界線は、どうやって見つけるのですか？

今回の「自動駐車システム」では、「認識」「経路計算」「制御」という境界線が比較的自然に見えましたが、もっと複雑なシステムでは、どこでサービスを分割すべきか悩むことがよくあります。

完璧な「正解」はありませんが、境界線を見つけるための**ヒント**となる考え方がいくつかあります。

---

### ヒント1：ドメイン駆動設計（DDD）の「境界づけられたコンテキスト」

- **考え方**: DDDの**戦略的設計**と呼ばれる部分が、まさにこの「境界線の引き方」を扱います。専門家と開発者が**ユビキタス言語**（共通言語）で会話し、言葉の意味が変わる場所（＝業務の文脈が変わる場所）を見つけ、そこを「**境界づけられたコンテキスト (Bounded Context)**」として区切ります。このコンテキストが、多くの場合、サービスの境界と一致します。
- **例**: ECサイトで「商品」という言葉が、「カタログ管理」の文脈と「在庫管理」の文脈では意味が異なる（前者：説明文や画像、後者：SKUや数量）場合、それぞれ別のコンテキスト（＝サービス）として分割します。
- **深掘り**: このアプローチは強力ですが、DDDの戦略的設計の学習が必要です。

### ヒント2：「関心の分離」をより大きな視点で

- **考え方**: クリーンアーキテクチャで学んだ「関心の分離」を、UseCaseよりも大きな視点（システム全体）で適用します。「これは独立した専門家チームに任せられそうか？」と考えてみます。
- **今回の例**: 「周りを見る（認識）」「考える（計画）」「動かす（制御）」は、それぞれ独立した専門分野として分離できました。
- **ポイント**: 分割したチーム（サービス）が、**なるべく他のチームに依存せずに**仕事を進められるか？（＝**凝集度が高く、結合度が低いか**）が重要です。

### ヒント3：組織構造（チーム編成）を参考にする

- **考え方**: **コンウェイの法則**という有名な法則があります。「システムを設計する組織は、その組織のコミュニケーション構造をそっくりまねた構造の設計を生み出してしまう」。これを逆手に取り、開発チームの体制に合わせてサービスを分割することがあります。
- **例**: 「商品カタログチーム」と「決済チーム」が別々に存在する場合、それぞれ「商品カタログサービス」と「決済サービス」を開発・運用する方が、コミュニケーションがスムーズになる可能性があります。
- **注意**: 組織構造は変化する可能性があるため、これだけに頼るのは危険ですが、現実的な境界線を見つけるヒントにはなります。

### ヒント4：技術的な特性で分ける

- **考え方**: 特定の技術基盤（データベース、ハードウェア、外部API）に強く依存する部分を、独立したサービスとして切り出す方法です。
- **例**:
    - 高度な画像認識ライブラリが必要な部分 → 「画像認識サービス」
    - 特殊なセンサーハードウェアと通信する部分 → 「センサーサービス」
    - 外部の決済APIと連携する部分 → 「決済ゲートウェイサービス」
- **メリット**: 特定の技術への依存をそのサービス内に閉じ込めることができます。

### ヒント5：変更の頻度やスケール（拡張性）の要求で分ける

- **考え方**:
    - **変更頻度**: 頻繁に変更される機能と、安定している機能を別のサービスに分けることで、変更の影響範囲を限定できます。
    - **スケール**: 特定の機能だけ負荷が高い場合、その機能だけを独立したサービスにして、サーバー台数を増やす（スケールアウトさせる）ことができます。
- **例**: ECサイトで、「商品検索」は非常に負荷が高いが、「ユーザー登録」はそうでもない場合、「商品検索サービス」を独立させ、多くのサーバーで動かす構成が考えられます。

---

### まとめ

これらのヒントを参考に、「どこで区切ると、各サービスが**独立性を保ちつつ**、**責務に集中**できるか？」という視点で境界線を探していくのが、サービス分割の勘所です。最初は小さく分割しすぎず、必要に応じて後から分割していく（進化させる）アプローチも有効です。