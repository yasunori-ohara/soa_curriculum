# 20 拡張：UI変更

# 🔄 UIの変更: Djangoへの換装

この章では、クリーンアーキテクチャの真価を体験します。これまで作成してきた**コンソール版の図書館貸出アプリ**のUI部分だけを、WebフレームワークであるDjangoに差し替えます。

ここで一番大事なのはこれです👇

> **ドメイン層とアプリケーション層（`UseCase`）のコードには一切手を加えない。**

ビジネスロジックはそのままにして、ユーザーとの接点だけを“プラグ交換”できることを確認します。これがクリーンアーキテクチャの「UIは詳細にすぎない」という思想です。

![クリーンアーキテクチャ](../クリーンアーキテクチャ.png)

---

## 🎯 この章の目的

* UIが「詳細」であり、ビジネスルールから独立していることを証明する。
* `interface_adapters` 層の役割（内側の世界と外側の世界を繋ぐ翻訳）を体験する。
* 依存性逆転の原則のおかげで、UI技術の変更がビジネスロジックに影響しないことを実感する。

---

## 📁 ここまでのフォルダ構成（Django導入後バージョン）

図書館アプリ版の完成イメージはこうなります👇
Djangoの追加部分を含めて、最終的な全体像を示します。

```text
clean_architecture_library/
├─ core/
│   ├─ domain/
│   │   ├─ book.py                      # Book, BookStatus
│   │   ├─ member.py                    # Member
│   │   ├─ loan.py                      # Loan
│   │   └─ repository.py                # BookRepository / MemberRepository / LoanRepository (<I>)
│   │
│   └─ usecase/
│       ├─ boundary/
│       │   ├─ dto.py                   # <DS> CheckOutBookInputData / OutputData / BookViewModel
│       │   ├─ input_boundary.py        # <I> CheckOutBookInputBoundary
│       │   └─ output_boundary.py       # <I> CheckOutBookOutputBoundary
│       │
│       └─ interactor/
│           └─ check_out_book.py        # 02 Use Case Interactor (CheckOutBookUseCase)
│
├─ interface_adapters/
│   ├─ data_access/
│   │   └─ in_memory_repositories.py    # 07 Data Access
│   │       # InMemoryBookRepository / InMemoryMemberRepository / InMemoryLoanRepository
│   │
│   ├─ presenters/
│   │   ├─ checkout_presenter.py        # 04 Presenter(コンソール用) / CheckOutBookPresenter
│   │   └─ django_presenter.py          # (New✨) DjangoCheckOutBookPresenter
│   │
│   ├─ controllers/
│   │   ├─ checkout_controller.py       # 05 Controller(コンソール用) / CheckOutBookController
│   │   └─ (Djangoでは専用Controllerは不要: View関数が兼任)
│   │
│   ├─ views/
│   │   ├─ view_console.py              # 06 View(コンソールUI) / ConsoleView
│   │   └─ django_views.py              # (New✨) DjangoのView関数
│   │
│   └─ templates/
│       └─ checkout.html                # (New✨) Djangoテンプレート
│
├─ web_app/
│   └─ urls.py                          # (New✨) DjangoのURLルーティング
│
├─ main.py                              # 11 Main(コンソール版: Composition Root)
│                                       # Django版では manage.py / runserver 側が担う
└─ tests/
    └─ ...                              # 12 テストまとめ（pytest）
```

ポイントは：

* 追加・変更は `interface_adapters/` と `web_app/` のみ。
* `core/`（ドメインとユースケース）には一切触れない。これが勝ち。

---

## ✅ 今回「変更・追加」が必要なファイル

UIという「詳細」に関わる部分だけが変更対象です。

* `interface_adapters/presenters/django_presenter.py` (New✨)
  Djangoのテンプレートに渡せる形（辞書）をつくるPresenter

* `interface_adapters/views/django_views.py` (New✨)
  DjangoのView関数。HTTPリクエストを受け取り、Use Caseを呼び、テンプレートを返す
  → ここは実質 Controller も兼任します

* `interface_adapters/templates/checkout.html` (New✨)
  レンタル処理フォーム＋結果表示

* `web_app/urls.py` (New✨)
  URLとView(Django側)を結びつける

* コンソール時代の `main.py` はそのまま残してOK（コンソール起動用として）。
  Djangoでは `runserver` がエントリポイントになるので、役割的には「mainが外側で差し替わる」イメージです。

---

## ❌ 変更が**不要**なファイル

ここがクリーンアーキテクチャの真骨頂です。次のファイル群は**一行も変更しません**。

* **`core/domain/*.py`**

  * `book.py`, `member.py`, `loan.py`（＝Entity）
* **`core/usecase/interactor/check_out_book.py`**

  * `CheckOutBookUseCase`（＝ユースケースの本体）
* **`core/usecase/boundary/*.py`**

  * `input_boundary.py`, `output_boundary.py`, `dto.py`
* **`interface_adapters/data_access/in_memory_repositories.py`**

  * インメモリのRepository実装（DBモック）

つまり、**Django対応のためにビジネスロジックもドメインルールも触らない。差し替えるのはUIアダプタだけ。**

---

## 💻 ソースコードの詳細解説

### 1. Django用の新しい Presenter

`CheckOutBookUseCase` は、呼び出し側として `CheckOutBookOutputBoundary`（出力境界インターフェース）に依存しています。
コンソール版ではそれを `CheckOutBookPresenter` が実装して `BookViewModel` を更新していました。

Django版では、同じインターフェースを別のクラスで実装し、テンプレートに渡すための **コンテキスト辞書** を組み立てます。

```python
# interface_adapters/presenters/django_presenter.py

from typing import Dict, Any
from core.usecase.boundary.output_boundary import CheckOutBookOutputBoundary
from core.usecase.boundary.dto import CheckOutBookOutputData

# -----------------------------------------------------------------------------
# Django Presenter
# - クラス図の位置: Presenter
# - 同心円図の位置: Adapters (外側の円)
# -----------------------------------------------------------------------------
class DjangoCheckOutBookPresenter(CheckOutBookOutputBoundary):
    """
    Djangoのテンプレートエンジンに渡すためのContext（辞書）を生成するPresenter。
    UseCaseから渡された業務結果(OutputData)を、人間向けの表示文に整形する。
    """
    def __init__(self):
        # View側から取り出せるように、最後に生成したコンテキストを覚えておく
        self._context: Dict[str, Any] = {}

    def present(self, output_data: CheckOutBookOutputData):
        """
        OutputBoundaryの実装。
        UseCaseから「貸出が成功したよ、これが結果だよ」と呼ばれる。
        ここで人が読める文言に整形し、テンプレート用の辞書として保持する。
        """
        due_date_str = output_data.due_date.strftime('%Y年%m月%d日')

        display_text = (
            f"貸出処理が完了しました。\n"
            f"  書籍: 『{output_data.book_title}』\n"
            f"  会員: {output_data.member_name} 様\n"
            f"  返却期限: {due_date_str}"
        )

        # Djangoテンプレートに渡すための辞書を用意する
        self._context = {
            "message": display_text,
            "book_title": output_data.book_title,
            "member_name": output_data.member_name,
            "due_date_str": due_date_str,
        }

    def get_context(self) -> Dict[str, Any]:
        """
        View(django側)から呼ばれる。
        テンプレートに描画させたい値をまとめて返す。
        """
        return self._context
```

* これは「Presenterはプレゼンテーションのためだけに存在する」という原則そのものです。
* ビジネスルールはここにはありません。日付の整形や文言の組み立てといった“見せ方”だけを担当します。

---

### 2. Djangoの View 関数

Djangoでは「View関数（またはクラスベースView）」がHTTPリクエストを受け取る窓口になります。
ここが Controller 的な役割も兼任します。

* ユーザー入力（POSTされた `book_id` / `member_id`）を受け取る
* 公式な入力DTO（`CheckOutBookInputData`）に変換する
* Use Case（`CheckOutBookUseCase`）を叩く
* Presenterから受け取った結果（コンテキスト辞書）をテンプレートに渡す

```python
# interface_adapters/views/django_views.py

from django.shortcuts import render
from interface_adapters.presenters.django_presenter import DjangoCheckOutBookPresenter
from interface_adapters.data_access.in_memory_repositories import (
    InMemoryBookRepository,
    InMemoryMemberRepository,
    InMemoryLoanRepository,
)
from core.usecase.interactor.check_out_book import CheckOutBookUseCase
from core.usecase.boundary.dto import CheckOutBookInputData

# -----------------------------------------------------------------------------
# Django View
# - クラス図の位置: View + Controller（兼任）
# - 同心円図の位置: Adapters (外側の円)
# -----------------------------------------------------------------------------
def checkout_view(request):
    """
    DjangoのView関数。
    HTTPリクエストを受け取り、UseCaseを呼び、テンプレートを返す。
    この関数はリクエストごとの「ミニComposition Root」としてふるまう。
    """
    context = {}

    if request.method == "POST":
        try:
            # --- 依存関係の組み立て（DI）ここから -----------------
            presenter = DjangoCheckOutBookPresenter()
            book_repo = InMemoryBookRepository()
            member_repo = InMemoryMemberRepository()
            loan_repo = InMemoryLoanRepository()

            use_case = CheckOutBookUseCase(
                presenter=presenter,
                book_repository=book_repo,
                member_repository=member_repo,
                loan_repository=loan_repo,
            )
            # --- 依存関係の組み立て（DI）ここまで -----------------

            # 1. View層の生データを公式なInputDataに変換
            input_data = CheckOutBookInputData(
                book_id=int(request.POST.get("book_id")),
                member_id=int(request.POST.get("member_id")),
            )

            # 2. ユースケースの実行
            use_case.handle(input_data)

            # 3. Presenterが用意したテンプレート用データを受け取る
            context = presenter.get_context()

        except Exception as e:
            # UIレベルの例外メッセージ整形（ビジネス例外の中身をそのまま見せるかは運用判断）
            context["message"] = f"エラー: {e}"

    # GETでもPOSTでも、同じテンプレートにコンテキストを渡して描画
    return render(request, "checkout.html", context)
```

💡 重要な観察ポイント

* `checkout_view()` は毎リクエスト呼ばれるので、この中で依存オブジェクトを組み立てています。
  これは「リクエストごとの Composition Root」です。
* この関数は**内側の世界（UseCase / Entity）に依存してもいい**立場です。なぜなら一番外側 (`interface_adapters/views`) だから。

---

### 3. Djangoテンプレート (HTML)

`Presenter`が作ってくれた`context`（辞書）を表示するだけの、薄いテンプレートです。
ユーザーから書籍IDと会員IDを入力してもらい、POSTで送ります。

```html
<!-- interface_adapters/templates/checkout.html -->

<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>書籍貸出システム</title>
</head>
<body>
    <h1>📚 書籍貸出</h1>

    <form method="post">
        {% csrf_token %}
        <div>
            <label>書籍ID:</label>
            <input type="text" name="book_id">
        </div>
        <div>
            <label>会員ID:</label>
            <input type="text" name="member_id">
        </div>
        <button type="submit">貸出実行</button>
    </form>

    {% if message %}
        <hr>
        <h2>処理結果</h2>
        <pre>{{ message }}</pre>
    {% endif %}
</body>
</html>
```

* Console版 `ConsoleView.render()` が担当していた「画面表示」が、ここではHTMLテンプレートになります。
* でも中身は同じノリですよね？
  `ViewModel.display_text` → `context["message"]` になっただけです。

---

### 4. URL設定

Djangoに対して「どのURLに来たらどのView関数を呼べばいいか」を教えるルーティング設定です。

```python
# web_app/urls.py

from django.urls import path
from interface_adapters.views.django_views import checkout_view

urlpatterns = [
    path("checkout/", checkout_view, name="checkout"),
]
```

これで `/checkout/` にアクセスすれば、貸出フォームと結果画面に到達できます。

---

## 🔁 main.py と Django の関係

* コンソール版では `main.py` が Composition Root（依存関係を全部つないでアプリを起動する地点）でした。
* Django版では、`checkout_view()` が各リクエストごとのミニComposition Rootになり、Django自体（`runserver`）がアプリの外側の起動スクリプトとして振る舞います。

つまり：

* **コンソールUIで動かす** → `python main.py`
* **Web UIで動かす** → `python manage.py runserver`（Djangoの世界）

どちらのUIも、呼んでいるビジネスロジックは同じ `CheckOutBookUseCase`。
差し替えているのは、UIアダプタ（View / Presenter）だけです。

---

## 🛡️ この章の鉄則

UIはあくまで詳細であり、交換可能な部品に過ぎません。

> UIは詳細である。ビジネスルールに触れるな。
> (The UI is a detail. Do not touch the business rules.)

* コンソールからWebアプリへの大規模なUI変更にもかかわらず、**`core/domain` と `core/usecase` は一行も変更していません。**
* これは、UseCaseが具体的なUI技術（`print` や `HTML` や `Django`）に依存せず、**抽象である Boundary（インターフェース）にだけ依存している**から実現できます。
* この構造があるから、将来GUIアプリ・スマホアプリ・REST APIに拡張する時も、ビジネスロジックはそのまま再利用できます。

この「UIは差し替えられる細部である」という思想こそが、クリーンアーキテクチャが約束する**保守性**と**拡張性**です。
