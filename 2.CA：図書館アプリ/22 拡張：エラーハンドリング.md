# 22 拡張：エラーハンドリング

# 🚦 エラーハンドリング: 失敗もビジネスの一部

これまでの実装では、`UseCase`でエラーが発生すると`ValueError`といった例外がスローされ、一番外側の`View`がそれを捕捉（`try-except`）していました。これは単純なアプリケーションでは機能しますが、より洗練されたエラーハンドリングを実装してみましょう。

**クリーンアーキテクチャでは、ビジネス上のエラー（例：「本の在庫がない」）は、プログラムのクラッシュを意味する技術的な例外とは区別されるべきです。** これらは、ユーザーに通知すべき、アプリケーションの正常な応答（レスポンス）の一部です。

![クリーンアーキテクチャ](../クリーンアーキテクチャ.png)

## 🎯 この章の目的

- `UseCase`がビジネスエラーを検出し、専用の出力ポート（`present_failure`）を通じて`Presenter`に通知する流れを実装する。
- 成功時と失敗時で、`Presenter`が受け取るデータ構造を分離する。
- `View`がビジネスロジックの例外を意識する必要がなくなり、より「愚直」な存在になることを体感する。

## ✅ クリーンアーキテクチャにおけるエラー処理の流れ

ご提案の通り、`Presenter`にエラー専用のメソッドを追加します。これにより、`UseCase`からの出力ルートが成功と失敗で明確に分かれます。

1. **`UseCase`**: ビジネスルール違反を検知します。（例：指定された本が見つからない）
2. **`UseCase`**: 成功用の`OutputData`ではなく、\*\*エラー専用の`ErrorOutputData`\*\*を作成します。
3. **`UseCase`**: `Presenter`が持つエラー専用のメソッド\*\*`present_failure()`\*\*を呼び出します。
4. **`Presenter`**: `ErrorOutputData`を受け取り、人間が読みやすいエラーメッセージに整形して`ViewModel`を更新します。
5. **`View`**: いつも通り、`ViewModel`の最新の状態を描画します。`View`は、それが成功メッセージなのかエラーメッセージなのかを区別する必要すらありません。

## 💻 ソースコードの詳細解説

### 1. 境界（Boundary）とデータ構造の更新

まず、「契約書」である`boundaries.py`と`data_structures.py`に、失敗ルートのための定義を追加します。

```python
# application/data_structures.py

class ErrorOutputData(NamedTuple):
    """UseCase -> Presenter へ渡す、失敗時のデータ構造"""
    error_message: str

# ... 他のData Structureはそのまま ...

```

```python
# application/boundaries.py

class CheckOutBookOutputBoundary(ABC):
    """
    UseCaseの「出力ポート」。成功と失敗、両方のメソッドを定義する。
    """
    @abstractmethod
    def present_success(self, output_data: CheckOutBookOutputData):
        """成功結果を提示する"""
        raise NotImplementedError

    @abstractmethod
    def present_failure(self, error_data: ErrorOutputData):
        """失敗結果を提示する"""
        raise NotImplementedError

# ... 他のBoundaryはそのまま ...

```

### 2. UseCaseの更新

`UseCase`が例外を捕捉し、新しい`present_failure`メソッドを呼び出すように変更します。

```python
# application/use_cases/check_out_book.py

class CheckOutBookUseCase(CheckOutBookInputBoundary):
    def __init__(self, presenter: CheckOutBookOutputBoundary, ...): # 引数は同じ
        self._presenter = presenter
        # ... 他のリポジトリも同じ ...

    def handle(self, input_data: CheckOutBookInputData):
        try:
            # --- 成功時のロジック（これまでとほぼ同じ）---
            book = self._book_repository.find_by_id(input_data.book_id)
            if not book:
                # ★例外を投げる代わりに、エラーデータを生成してpresenterを呼ぶ
                error_data = ErrorOutputData("指定された本が見つかりません。")
                self._presenter.present_failure(error_data)
                return

            # ... 他のチェックや処理 ...

            book.check_out() # ここでValueErrorがスローされる可能性

            # ... Loanの作成と保存 ...

            output_data = CheckOutBookOutputData(...)
            self._presenter.present_success(output_data) # ★成功メソッドを呼び出す

        except ValueError as e:
            # ★Entityがスローした例外を捕捉し、エラーデータを生成してpresenterを呼ぶ
            error_data = ErrorOutputData(str(e))
            self._presenter.present_failure(error_data)

```

### 3. Presenterの更新

`Presenter`が新しい`present_failure`メソッドを実装するようにします。

```python
# adapters/presenter.py

class CheckOutBookPresenter(CheckOutBookOutputBoundary):
    # ... __init__ は同じ ...

    def present_success(self, output_data: CheckOutBookOutputData):
        # ... これまでのpresentメソッドの中身をここに移動 ...
        # ... メッセージを組み立ててViewModelを更新 ...

    def present_failure(self, error_data: ErrorOutputData):
        # 失敗データを受け取り、エラーメッセージとしてViewModelを更新
        display_text = f"エラーが発生しました: {error_data.error_message}"
        self._view_model.display_text = display_text

```

### 4. Viewの更新（★最も重要な変化）

`UseCase`が例外を内部で処理してくれるようになったため、`View`の`try-except`ブロックが劇的にシンプルになります。

```python
# adapters/view.py

class ConsoleView:
    # ... __init__ は同じ ...

    def run(self):
        # ★ try-except ブロックがシンプルに！
        try:
            book_id_str = input("貸し出す本のIDを入力してください: ")
            member_id_str = input("貸し出す会員のIDを入力してください: ")

            book_id = int(book_id_str)
            member_id = int(member_id_str)

            # Controllerを呼び出すだけ。UseCaseからの例外はもう飛んでこない。
            self._controller.check_out(book_id=book_id, member_id=member_id)

        except ValueError:
            # このexceptは、純粋なViewの入力エラー（intへの変換失敗）だけを捕捉すればよくなる
            self._view_model.display_text = "エラー: IDは数字で入力してください。"

        # どの場合でも、最後はrenderを呼ぶだけ
        self.render()

    # ... renderメソッドは同じ ...

```

## 💡 ユニットテストでエラーハンドリングを証明する

エラー発生時に、`present_failure`が正しく呼ばれることをテストします。

```python
# tests/application/use_cases/test_check_out_book.py の例

def test_存在しない本を貸し出そうとすると失敗ルートを通る():
    # 1. Arrange (準備)
    spy_presenter = SpyCheckOutBookPresenter() # 成功/失敗両方のメソッド呼び出しを記録できるスパイ
    fake_book_repo = FakeBookDataAccess(initial_books=[]) # 空のDB
    # ... 他の偽物リポジトリ ...
    use_case = CheckOutBookUseCase(spy_presenter, fake_book_repo, ...)
    input_data = CheckOutBookInputData(book_id=999, member_id=1)

    # 2. Act (実行)
    use_case.handle(input_data)

    # 3. Assert (検証)
    # ✅ 失敗メソッドが呼ばれたか？
    assert spy_presenter.failure_was_called is True
    assert "指定された本が見つかりません" in spy_presenter.received_error_data.error_message

    # ✅ 成功メソッドは呼ばれていないか？
    assert spy_presenter.success_was_called is False

```

## 🛡️ この章の鉄則

ビジネスエラーは、プログラムの異常終了を意味するものではありません。

> エラーは例外ではない。ビジネスの応答である。 (An error is a business response, not an exception.)
> 
- このアプローチにより、`UseCase`はビジネス上の失敗を制御し、それをアプリケーションの正常なフローの一部として扱うことができます。
- `DB-Connection-Error`のような技術的な例外が、`View`まで漏れ出すのを防ぎます。`DataAccess`で発生した技術的例外は、`UseCase`が捕捉し、「現在データベースに接続できません」のような、よりビジネス的なエラーに**翻訳**してから`Presenter`に渡すべきです。
- これにより、各レイヤーは自身の関心事に集中でき、システムの堅牢性が向上します。