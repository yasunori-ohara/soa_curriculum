# 22 拡張：エラーハンドリング

# 🚦 エラーハンドリング: 失敗もビジネスの一部

これまでの実装では、`UseCase` で何か不正な状態が起きたとき（例：存在しない本を借りようとしたとき）、`ValueError`のような例外をスローしていました。例外は最終的に一番外側の `View` で `try-except` して、エラーメッセージを表示していました。

この方式はシンプルですが、もう一歩進めたいところがあります。

**クリーンアーキテクチャでは「ビジネス上の失敗」は、プロセス全体をクラッシュさせる”異常”ではなく、ユーザーに返すべき正当なレスポンスだとみなします。**

* 「その本は今借りられません」は、落ちるべきエラーではなく、
* 「この操作はできませんでした」という**ビジネスメッセージ**です。

この章では、ビジネスエラー（本がない、会員がいない、など）を一級の結果として扱う設計にアップグレードします。

![クリーンアーキテクチャ](../クリーンアーキテクチャ.png)

---

## 🎯 この章の目的

* `UseCase` がビジネス上の失敗を検知したとき、例外を投げずに「失敗しました」という結果をプレゼンターへ伝える。
* 成功と失敗で、Presenterに渡すデータ構造（DTO）とメソッドを分ける。
* `View` はただ `ViewModel` を描画するだけでよくなり、ますます「愚直なUI」に近づく。

---

## 📁 フォルダ構成（エラールート対応後）

この段階の図書館アプリのフォルダイメージは次のとおりです👇
今回の変更ポイントは `core/usecase/boundary/` と `core/usecase/interactor/` と `interface_adapters/presenters/` です。それ以外（Controller / View / Repository / Entity）はほぼそのままです。

```text
clean_architecture_library/
├─ core/
│   ├─ domain/
│   │   ├─ book.py                          # Book, BookStatus とそのビジネスルール
│   │   ├─ member.py                        # Member
│   │   ├─ loan.py                          # Loan
│   │   └─ repository.py                    # 抽象Repo (BookRepositoryなど)
│   │
│   └─ usecase/
│       ├─ boundary/
│       │   ├─ dto.py                       # ✅ ここに ErrorOutputData を追加
│       │   ├─ input_boundary.py            # CheckOutBookInputBoundary
│       │   └─ output_boundary.py           # ✅ 成功/失敗の2メソッドに拡張
│       │
│       └─ interactor/
│           └─ check_out_book.py            # ✅ UseCaseがpresent_success/present_failureを呼び分ける
│
├─ interface_adapters/
│   ├─ presenters/
│   │   ├─ checkout_presenter.py            # ✅ present_success/present_failureを実装
│   │   └─ django_presenter.py              # Django版Presenterも同じインターフェースに合わせて拡張
│   │
│   ├─ controllers/
│   │   └─ checkout_controller.py           # (ほぼ変更なし)
│   │
│   ├─ views/
│   │   ├─ view_console.py                  # try-exceptが軽くなる
│   │   └─ django_views.py                  # (原則ほぼ変更なし。Presenterの結果を表示)
│   │
│   └─ templates/
│       └─ checkout.html                    # エラーメッセージも message として表示
│
├─ infrastructure/
│   └─ repositories/
│       ├─ in_memory/in_memory_repositories.py
│       └─ mongo/mongo_repositories.py
│
├─ main.py
└─ tests/
    └─ unit/
        ├─ test_usecase_checkout.py         # ✅ 失敗ルート用のアサーションを追加
        ├─ test_presenter_checkout.py       # ✅ 失敗メッセージ整形の確認を追加
        └─ ...                              # ほかは同様
```

---

## ✅ エラーフローの全体像

エラー時の流れ（成功時とは別ルート）を明文化します。

1. **UseCase**

   * ビジネスルール違反を検知（例：「その本は存在しない」「すでに貸出中」）
   * `ErrorOutputData` を作成する
   * `present_failure()` を呼ぶ（←これが新設✨）

2. **Presenter**

   * エラーデータを受け取る
   * 人間が読める文面に整形して、`ViewModel` に書き込む

3. **View**

   * いつも通り `ViewModel` の `display_text` を描画するだけ
   * 成功/失敗の区別を知らなくていい。UIは「愚直」でいてOK

この分離によって、`View` 側が「例外で落ちたのか？」「ビジネス的に失敗したのか？」と頭を悩ませる必要がなくなります。

---

## 💻 ソースコードの詳細解説

### 1. DTO（データ構造）に失敗用の型を追加する

`core/usecase/boundary/dto.py`

```python
# core/usecase/boundary/dto.py
from datetime import date
from typing import NamedTuple

# --------------------------------------------------------
# 成功系 DTO
# --------------------------------------------------------
class CheckOutBookInputData(NamedTuple):
    """
    Controller -> UseCase に渡す入力データ
    """
    book_id: int
    member_id: int

class CheckOutBookOutputData(NamedTuple):
    """
    UseCase -> Presenter (成功時)
    """
    book_title: str
    member_name: str
    due_date: date  # ビジネス的な日付; フォーマットはPresenterの責任

class BookViewModel:
    """
    Presenter -> View
    Viewがレンダリングするための表示用データ。
    シンプルな状態オブジェクトとして扱うので NamedTuple ではなく
    後から値を書き換え可能なクラスにしておく想定。
    """
    def __init__(self, display_text: str = ""):
        self.display_text = display_text


# --------------------------------------------------------
# 失敗系 DTO（New✨）
# --------------------------------------------------------
class ErrorOutputData(NamedTuple):
    """
    UseCase -> Presenter (失敗時)
    ビジネス的なエラーメッセージを表す。
    """
    error_message: str
```

ポイント：

* 成功用と失敗用のデータを**明確に分ける**ことで、
  「成功だったのか？失敗だったのか？」という分岐をPresenter・Viewでわざわざ if 判定しなくて済みます。
* `ErrorOutputData` は、アプリ内で「これはビジネス上の失敗レスポンスだよ」ということをはっきり示す型です。

---

### 2. OutputBoundary（出力境界インターフェース）を拡張する

`core/usecase/boundary/output_boundary.py`

```python
# core/usecase/boundary/output_boundary.py
from abc import ABC, abstractmethod
from .dto import CheckOutBookOutputData, ErrorOutputData

class CheckOutBookOutputBoundary(ABC):
    """
    UseCaseの「出力ポート」。
    Presenterがこれを実装する。
    成功と失敗で別メソッドを用意し、呼び分ける。
    """

    @abstractmethod
    def present_success(self, output_data: CheckOutBookOutputData) -> None:
        """貸出処理が成功したときに呼ばれる"""
        raise NotImplementedError

    @abstractmethod
    def present_failure(self, error_data: ErrorOutputData) -> None:
        """貸出処理がビジネス的に失敗したときに呼ばれる"""
        raise NotImplementedError
```

これまで `present()` の1本だったところを `present_success()` / `present_failure()` の2本に分けます。
境界（Boundary）の契約自体が「成功と失敗は別のルートです」と宣言しているイメージです。

---

### 3. UseCaseを修正して、失敗時に present_failure() を呼ぶ

`core/usecase/interactor/check_out_book.py`

```python
# core/usecase/interactor/check_out_book.py
from datetime import date
from core.usecase.boundary.input_boundary import CheckOutBookInputBoundary
from core.usecase.boundary.output_boundary import CheckOutBookOutputBoundary
from core.usecase.boundary.dto import (
    CheckOutBookInputData,
    CheckOutBookOutputData,
    ErrorOutputData,
)
from core.domain.repository import (
    BookRepository,
    MemberRepository,
    LoanRepository,
)
from core.domain.loan import Loan


class CheckOutBookUseCase(CheckOutBookInputBoundary):
    """
    「本を貸し出す」というユースケース。
    成功ならpresent_success()、失敗ならpresent_failure()を呼ぶ。
    """

    def __init__(
        self,
        presenter: CheckOutBookOutputBoundary,
        book_repository: BookRepository,
        member_repository: MemberRepository,
        loan_repository: LoanRepository,
    ):
        self._presenter = presenter
        self._book_repository = book_repository
        self._member_repository = member_repository
        self._loan_repository = loan_repository

    def handle(self, input_data: CheckOutBookInputData) -> None:
        """
        ビジネスフロー全体を指揮する。
        ただし、UIやDBの詳細は知らない。
        """
        # 1. 必要なEntityを取得
        book = self._book_repository.find_by_id(input_data.book_id)
        member = self._member_repository.find_by_id(input_data.member_id)

        # 2. 事前条件チェック（存在しない場合など）
        if not book:
            self._presenter.present_failure(
                ErrorOutputData("指定された本が見つかりません。")
            )
            return

        if not member:
            self._presenter.present_failure(
                ErrorOutputData("指定された会員が見つかりません。")
            )
            return

        # 3. ビジネスルール適用
        #    例: すでに貸出中の本なら、Book Entity側が例外を投げる設計だったとする
        try:
            book.check_out()  # ここで ValueError 等が発生しうる
        except ValueError as e:
            # ← Entityから上がってきた「ビジネス的にNG」というメッセージ
            self._presenter.present_failure(
                ErrorOutputData(str(e))
            )
            return

        # 4. Loanエンティティを作成
        new_loan = Loan(
            id=None,  # 採番はLoanRepository側の責務
            book_id=book.id,
            member_id=member.id,
            loan_date=date.today(),
        )

        # 5. 永続化
        self._book_repository.save(book)
        self._loan_repository.save(new_loan)

        # 6. 成功レスポンスをPresenterへ
        self._presenter.present_success(
            CheckOutBookOutputData(
                book_title=book.title,
                member_name=member.name,
                due_date=new_loan.due_date,  # Loanが返却期限を計算して持っている想定
            )
        )
```

ポイント：

* これまでは `raise ValueError("〜")` で外側に丸投げ → Viewが例外に怯えるしかない構造でした。
* これからは、UseCaseが**責任を持って**エラーを`ErrorOutputData`に変換し、`present_failure()`を呼び出します。
* つまり、UseCaseは「ビジネス的にこれは失敗」という判断を、自分の責務として明示的に扱います。

---

### 4. Presenterを成功・失敗の両ルートに対応させる

`interface_adapters/presenters/checkout_presenter.py`
（コンソール版 Presenter の例）

```python
# interface_adapters/presenters/checkout_presenter.py
from datetime import date
from core.usecase.boundary.output_boundary import CheckOutBookOutputBoundary
from core.usecase.boundary.dto import (
    CheckOutBookOutputData,
    ErrorOutputData,
    BookViewModel,
)


class CheckOutBookPresenter(CheckOutBookOutputBoundary):
    """
    UseCaseからの結果（成功 / 失敗）を、
    ViewModelにわかりやすい文字列として格納する役割。
    ViewはこのViewModelを描画するだけでよい。
    """

    def __init__(self, view_model: BookViewModel):
        self._view_model = view_model

    def present_success(self, output_data: CheckOutBookOutputData) -> None:
        # 1. ビジネスデータ（due_dateはdate型）をUI向け文字列に変換
        if isinstance(output_data.due_date, date):
            due_date_str = output_data.due_date.strftime("%Y年%m月%d日")
        else:
            # 念のためのフォールバック
            due_date_str = str(output_data.due_date)

        # 2. ユーザーに読ませる文章に組み立てる
        display_text = (
            "貸出処理が完了しました。\n"
            f"  書籍: 『{output_data.book_title}』\n"
            f"  会員: {output_data.member_name} 様\n"
            f"  返却期限: {due_date_str}"
        )

        # 3. ViewModelを更新
        self._view_model.display_text = display_text

    def present_failure(self, error_data: ErrorOutputData) -> None:
        # 失敗時用のメッセージをViewModelに格納する
        self._view_model.display_text = f"エラー: {error_data.error_message}"
```

Django版 Presenter（`django_presenter.py`）も同じインターフェース（`CheckOutBookOutputBoundary`）に合わせて `present_success` / `present_failure` の2メソッドを持てばOKです。Django側では `ViewModel` の代わりに `dict`（テンプレートコンテキスト）を書き換えることになります。

---

### 5. View側はさらに「おバカさん」にできる

`interface_adapters/views/view_console.py`（コンソールUI）の例です。
ここがうれしいところ。

```python
# interface_adapters/views/view_console.py
from core.usecase.boundary.dto import BookViewModel
from interface_adapters.controllers.checkout_controller import CheckOutBookController

class ConsoleView:
    """
    ユーザーとの入出力だけを担当するUI。
    ここではビジネスロジックを一切判断しない。
    """

    def __init__(self, controller: CheckOutBookController, view_model: BookViewModel):
        self._controller = controller
        self._view_model = view_model

    def run(self) -> None:
        try:
            book_id_str = input("貸し出す本のIDを入力してください: ")
            member_id_str = input("貸し出す会員のIDを入力してください: ")

            book_id = int(book_id_str)
            member_id = int(member_id_str)

            # ここでControllerを呼ぶだけ。
            # 以降の失敗はUseCase→Presenter→ViewModelに反映されるので、
            # ここでビジネスエラーをキャッチする必要はない。
            self._controller.check_out(book_id=book_id, member_id=member_id)

        except ValueError:
            # ここで扱うのは「数字じゃない」といった純粋なUI入力エラーだけ
            self._view_model.display_text = "エラー: IDは数字で入力してください。"

        # 成功でも失敗でも、最終結果はViewModelに書かれている
        self.render()

    def render(self) -> None:
        print("\n--- 処理結果 ---")
        print(self._view_model.display_text)
        print("----------------")
```

ここが超重要です 👇

* 以前は `UseCase` の深いところで例外が発生 → `View` まで飛んできてたので、`View` は「なんか落ちた！」と例外のことまで考えないといけませんでした。
* 今は `UseCase` がビジネスエラーを**例外ではなくビジネスレスポンスとしてPresenterに渡す**ので、`View` は「最新の `ViewModel.display_text` を出力すればいい」という、とてもシンプルな責務に戻れます。

---

## 💡 ユニットテストでエラーハンドリングを検証する

`tests/unit/test_usecase_checkout.py` のイメージ：

```python
# tests/unit/test_usecase_checkout.py

from core.usecase.interactor.check_out_book import CheckOutBookUseCase
from core.usecase.boundary.dto import CheckOutBookInputData, ErrorOutputData, CheckOutBookOutputData
from core.usecase.boundary.output_boundary import CheckOutBookOutputBoundary

# スパイPresenter
class SpyPresenter(CheckOutBookOutputBoundary):
    def __init__(self):
        self.success_called = False
        self.failure_called = False
        self.success_data: CheckOutBookOutputData | None = None
        self.failure_data: ErrorOutputData | None = None

    def present_success(self, output_data: CheckOutBookOutputData) -> None:
        self.success_called = True
        self.success_data = output_data

    def present_failure(self, error_data: ErrorOutputData) -> None:
        self.failure_called = True
        self.failure_data = error_data


# フェイクリポジトリ（本が存在しないケースを再現）
class FakeEmptyBookRepository:
    def find_by_id(self, book_id: int):
        return None
    def save(self, book):
        raise AssertionError("save() should not be called when book is missing")

class FakeMemberRepository:
    def find_by_id(self, member_id: int):
        # 会員は見つかる想定
        return type("M", (), {"id": member_id, "name": "ダミー会員"})

class FakeLoanRepository:
    def save(self, loan):
        # 呼ばれないはず（本が無いので処理中断）
        raise AssertionError("save() should not be called when book is missing")


def test_存在しない本を貸し出そうとすると_failureルートが呼ばれる():
    presenter = SpyPresenter()
    use_case = CheckOutBookUseCase(
        presenter,
        book_repository=FakeEmptyBookRepository(),
        member_repository=FakeMemberRepository(),
        loan_repository=FakeLoanRepository(),
    )

    input_data = CheckOutBookInputData(book_id=999, member_id=1)
    use_case.handle(input_data)

    assert presenter.failure_called is True
    assert presenter.success_called is False
    assert "見つかりません" in presenter.failure_data.error_message
```

テストの狙いはこうです👇

* UseCaseが「本がない」という業務的な失敗を検出できているか？
* その失敗が `present_failure()` という“正式なルート”で Presenter に伝わっているか？
* 成功ルート `present_success()` は呼ばれないことを保証できているか？

---

## 🛡️ この章の鉄則

ビジネスエラーは、プログラムの異常終了を意味するものではありません。

> エラーは例外ではない。ビジネスの応答である。
> (An error is a business response, not an exception.)

* 「もう貸し出せません」「その会員は存在しません」は、ビジネスの世界では“想定内の出来事”です。
  それらを例外でぶん投げるのではなく、Presenterに整形を依頼し、ユーザーに伝えます。
* 技術的なクラッシュ（DB接続エラーなど）は最外周（インフラ層）で捕捉し、
  UseCaseはそれを「ビジネス的に意味があるメッセージ」（例：「現在システムが利用できません」）に翻訳して Presenter に渡すべきです。
* これにより、`View` はますます「愚直であること」に集中できます。
  Viewは、成功なのか失敗なのかを知らなくても、`ViewModel.display_text` をそのまま表示すればいいだけになります。

---

まとめると：

* `UseCase` は「成功」か「ビジネス的失敗」かを判断し、その両方をハンドルできる。
* `Presenter` は2種類の入力（成功DTO / エラーDTO）を受け取り、人に見せる形に翻訳する。
* `View` はとことんおバカでいい。`ViewModel` を表示するだけでいい。

これが、堅牢でテストしやすく、長生きするアプリケーションのエラーハンドリングです 🚦
