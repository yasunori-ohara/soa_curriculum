# 23 拡張：DIコンテナ

# ⚙️ DIコンテナ: 依存関係の自動組立工場

これまでの `main.py`（あるいは Django なら各ビュー関数）は、私たちが手で

* Presenter を作って
* Repository を作って
* UseCase に渡して
* Controller に渡して
* View に渡して…

というふうに、全部「配線」していました。

小さなサンプルならそれでOKですが、機能や画面が増えると、配線コードはどんどん増えていきます。差し替えやテストもしづらくなります。

そこで登場するのが **DIコンテナ（Dependency Injection Container）** です。
これはアプリ全体の「組立工場」みたいなもので、**各部品の作り方と依存関係さえ宣言しておけば、必要なオブジェクトを自動で組み上げて渡してくれる**存在です。

つまり、手作業での配線を「設計図化」して、あとは工場にまかせるイメージです 🏭

![クリーンアーキテクチャ](../クリーンアーキテクチャ.png)

---

## 🎯 この章の目的

* 手動DI（手で `Foo(presenter, repo)` するやつ）が、アプリの成長とともにキツくなる理由を知る。
* DIコンテナを導入し、依存関係の解決と生成を自動化する。
* `main.py`（Composition Root）から配線ロジックを追い出す。
* テスト時に「本番用の依存関係」と「テストダブル（偽物）」を簡単に切り替えられる状態にする。

---

## 📁 フォルダ構成（DIコンテナ導入後）

図書館アプリ版の構成になっています。今回新しく追加されるのは `container/` ディレクトリです。

```text
clean_architecture_library/
├─ core/                                      # 内側2層（Entity + UseCase）
│   ├─ domain/                                # 📘 エンティティとリポジトリ抽象
│   │   ├─ book.py
│   │   ├─ member.py
│   │   ├─ loan.py
│   │   └─ repository.py                      # BookRepository / MemberRepository / LoanRepository 抽象
│   │
│   └─ usecase/                               # 🎯 アプリケーション固有のビジネスルール
│       ├─ boundary/
│       │   ├─ dto.py                         # CheckOutBookInputData / OutputData / ErrorOutputData / BookViewModel
│       │   ├─ input_boundary.py              # CheckOutBookInputBoundary
│       │   └─ output_boundary.py             # CheckOutBookOutputBoundary
│       └─ interactor/
│           └─ check_out_book.py              # CheckOutBookUseCase
│
├─ interface_adapters/                        # 🔌 Adapters層
│   ├─ presenters/
│   │   ├─ checkout_presenter.py              # コンソール用 Presenter
│   │   └─ django_presenter.py                # Django用 Presenter（Web向け）
│   │
│   ├─ controllers/
│   │   └─ checkout_controller.py             # Controller
│   │
│   ├─ views/
│   │   ├─ view_console.py                    # コンソールUI
│   │   └─ django_views.py                    # Djangoビュー（View + Controller 的な役）
│   │
│   └─ templates/
│       └─ checkout.html                      # Djangoテンプレート
│
├─ infrastructure/                            # 🏗 インフラ詳細
│   └─ repositories/
│       ├─ in_memory/
│       │   └─ in_memory_repositories.py      # InMemoryBookDataAccess / etc.
│       └─ mongo/
│           └─ mongo_repositories.py          # MongoBookDataAccess / etc.（DB換装章で追加）
│
├─ container/
│   └─ app_container.py                       # 🌱 DIコンテナ（New ✨）
│
├─ main.py                                    # Composition Root（コンソール起動用）
│
└─ tests/
    └─ unit/
        ├─ test_usecase_checkout.py
        ├─ test_presenter_checkout.py
        └─ ... (略)
```

ポイント：

* `container/app_container.py` が今回の主役。
* `main.py` は「コンテナを起動して、出来上がった View（UI最前線）を動かすだけ」に縮みます。
* Djangoで動かす場合は、`django_views.py` が「1リクエストごとのミニComposition Root」をやっていましたが、この役割もコンテナに肩代わりさせられます。（後述）

---

## ✅ DIコンテナにやらせるべきこと / やらせちゃダメなこと

⭕️ コンテナにやらせていいこと

* どのクラスがどの依存を必要としているか宣言する
  （例：`CheckOutBookUseCase` は `CheckOutBookPresenter` と `BookRepository` を必要とする）
* 依存関係グラフ（だれがだれを使うか）を解決し、インスタンスを組み上げて返す
* ライフサイクル管理（毎回新しく作る？1個を使い回す？）

❌ コンテナに入れるべきでないこと

* ビジネスロジック
* ルール判定
* ドメインの知恵（「この本は借りられるか？」など）

コンテナは「配線係」「工場長」であって、「司書」や「受付係」ではありません。

---

## 💻 ソースコードの詳細解説

ここでは Python の `dependency-injector` ライブラリを例にします。
（`pip install dependency-injector`）

### 1. DIコンテナ定義ファイルを追加する

`container/app_container.py`

```python
# container/app_container.py
from dependency_injector import containers, providers

# --- アプリ内の部品をインポート -----------------

# UseCase
from core.usecase.interactor.check_out_book import CheckOutBookUseCase

# Boundaries / DTO
from core.usecase.boundary.dto import BookViewModel

# Presenter
from interface_adapters.presenters.checkout_presenter import CheckOutBookPresenter

# Controller
from interface_adapters.controllers.checkout_controller import CheckOutBookController

# View (コンソール版)
from interface_adapters.views.view_console import ConsoleView

# DataAccess (インフラ)
from infrastructure.repositories.in_memory.in_memory_repositories import (
    InMemoryBookDataAccess,
    InMemoryMemberDataAccess,
    InMemoryLoanDataAccess,
)
# MongoDB版に差し替えたい場合は、次のようなimportに変えるだけ👇
# from infrastructure.repositories.mongo.mongo_repositories import (
#     MongoBookDataAccess,
#     MongoMemberDataAccess,
#     MongoLoanDataAccess,
# )


class AppContainer(containers.DeclarativeContainer):
    """
    アプリケーション全体の依存関係を宣言するDIコンテナ。
    依存の「宣言」をここに集約することで、
    main.py や Djangoビューから配線ロジックを追い出す。
    """

    # -----------------------------
    # ViewModel
    # -----------------------------
    # ViewModelはPresenterとViewで共有される「状態オブジェクト」なので Singleton にする
    view_model = providers.Singleton(
        BookViewModel,
        display_text="",  # 初期表示テキスト
    )

    # -----------------------------
    # Data Access層（Repository実装）
    # -----------------------------
    # ここを InMemory / Mongo などに切り替えるだけで永続化先を差し替えできる
    book_repo = providers.Singleton(InMemoryBookDataAccess)
    member_repo = providers.Singleton(InMemoryMemberDataAccess)
    loan_repo = providers.Singleton(InMemoryLoanDataAccess)

    # -----------------------------
    # Presenter
    # -----------------------------
    presenter = providers.Factory(
        CheckOutBookPresenter,
        view_model=view_model,
    )
    # もしWeb用(Django)のPresenterにしたい場合は、ここを
    # DjangoCheckOutBookPresenter に差し替えることで、UIスタックを一気にWeb向けに切替できる。

    # -----------------------------
    # UseCase（アプリケーションビジネスルールの中心）
    # -----------------------------
    use_case = providers.Factory(
        CheckOutBookUseCase,
        presenter=presenter,
        book_repository=book_repo,
        member_repository=member_repo,
        loan_repository=loan_repo,
    )

    # -----------------------------
    # Controller（View→UseCaseの橋渡し）
    # -----------------------------
    controller = providers.Factory(
        CheckOutBookController,
        use_case=use_case,
    )

    # -----------------------------
    # View（最前線のUI）
    # -----------------------------
    # コンソールUI版
    view_console = providers.Factory(
        ConsoleView,
        controller=controller,
        view_model=view_model,
    )

    # Django版の「1リクエスト用ミニComposition Root」としても
    # providers.Factory(...) を用意しておける
    # (例: checkout_django_handler = providers.Factory(...))
```

💡 ここでやっていることは「宣言」。
`CheckOutBookUseCase` は `presenter` や `book_repo` が必要なんだよ、と宣言しています。
コンテナはそれを見て、自動的にインスタンスを組み立ててくれます。

* `providers.Singleton(...)`
  同じインスタンスをアプリ全体で共有したいもの向け（DBコネクション、ViewModelなど）
* `providers.Factory(...)`
  呼ぶたびに新しいインスタンスがほしいもの向け（UseCaseやControllerなど、基本 stateless なものは毎回新規でもOK）

---

### 2. main.py を超シンプルにする

もともとの `main.py` は、Presenter / Repository / UseCase / Controller / View を全部手でnewしていました。
DIコンテナ導入後は、アプリのエントリポイントはこうなります👇

```python
# main.py
from container.app_container import AppContainer

def main():
    """
    Composition Root:
    - コンテナを初期化し
    - そのコンテナから「完成済みのView」をもらい
    - そのViewを動かすだけ
    """
    container = AppContainer()

    # Consoleアプリを起動する場合は、コンソール用Viewを取得
    view = container.view_console()

    # UIを開始
    view.run()


if __name__ == "__main__":
    main()
```

これでOKです。
もはや `main.py` は「コンテナを起動して、できあがったUIを回すだけ」の場所になります。
依存の配線（PresenterとRepositoryをUseCaseに渡す等）は、いっさいここに書きません。最高。

---

### 3. Djangoでも同じ恩恵がある

Django版では、1リクエストごとに `django_views.py` が「ミニComposition Root」っぽいことをやっていました。

```python
# 以前のイメージ（ざっくり）
presenter = DjangoCheckOutBookPresenter()
book_repo = InMemoryBookDataAccess()
...
use_case = CheckOutBookUseCase(presenter, book_repo, member_repo, loan_repo)
...
use_case.handle(...)
context = presenter.get_context()
return render(request, 'checkout.html', context)
```

DIコンテナ導入後は、この「部品の組み立て」もコンテナから取得する形にできます。

たとえば `AppContainer` に

* Django用Presenter
* Django用 "controller-ish handler"

などの providers.Factory(...) を用意しておけば、DjangoのView関数側は

```python
def checkout_view(request):
    container = AppContainer()

    # requestからbook_id/member_idを読む
    # その値を controller に渡すだけ、という構成にできる
```

といった方向に整理できます。
＝ Django側のコードは「HTTPのことだけに集中」できて、ビジネスロジックの配線はコンテナに任せられるようになります。

---

## 💡 テストでのDIコンテナの真価

DIコンテナはテストでもめちゃくちゃ便利です。
たとえば、実際のコードは `InMemoryBookDataAccess` を使っているけど、テストでは「こういう本が登録されていることにしたい」というフェイクを使いたい、という状況。

差し替え（オーバーライド）はこんなふうにできます👇

```python
# tests/unit/test_usecase_checkout_with_container.py
from container.app_container import AppContainer
from core.usecase.boundary.dto import CheckOutBookInputData

# テスト用のフェイクRepository
class FakeBookRepo:
    def __init__(self, books):
        self._books = {b.id: b for b in books}
    def find_by_id(self, book_id: int):
        return self._books.get(book_id)
    def save(self, book):
        self._books[book.id] = book

def test_貸出処理がフェイクRepoでも動く():
    container = AppContainer()

    # BookRepositoryだけテスト用に差し替える
    test_book_repo = FakeBookRepo(books=[
        # ここでテスト用のBookエンティティを準備しておく
        # Book(id=1, title="テスト用の本", author="ダミー", status=BookStatus.AVAILABLE)
    ])

    with container.book_repo.override(test_book_repo):
        # コンテナにUseCaseを組ませると、自動的にこのfakeが注入されたものが返る
        use_case = container.use_case()

        # あとはいつも通りUseCaseをテスト
        input_data = CheckOutBookInputData(book_id=1, member_id=123)
        use_case.handle(input_data)

        # presenter などに渡った結果をアサートする...
```

ここが超・大事なポイント：

* 本番コードは変えない
* UseCaseもPresenterもまるごと本物のまま
* 一部の依存先（Repoなど）だけ、テスト用のフェイクやスパイに入れ替えられる

これは「ビジネスロジックをUIやDBから切り離す」というクリーンアーキテクチャの利点と、DIコンテナの「差し替えが一瞬」という利点が合わさって生まれる、めちゃくちゃ強いテスト性です 🧪

---

## 🛡️ この章の鉄則

依存性の管理という退屈で壊れやすい作業は、道具にやらせましょう。

> 依存関係を宣言せよ、生成はコンテナに任せよ。
> (Declare dependencies; let the container create.)

* `main.py` や DjangoのView関数から、「組み立てロジック」を追い出し、アプリ本体のコードをスリムにする。
* アプリ全体の依存関係ツリーを、`container/app_container.py` に“宣言”として一元管理できる。
* データベースを InMemory → MongoDB に切り替える時も、インスタンス生成箇所ではなく**コンテナのプロバイダ定義を1行変えるだけで済む**。
* テスト時は一部の依存だけ簡単に差し替えでき、ビジネスロジックを外部の事情（DB・UIなど）から完全に解放した形で検証できる。

DIコンテナは「アプリの骨格」を保ったまま、規模を大きくしていくための土台です。
大規模化しても、クリーンアーキテクチャの約束「内側は守り、外側は差し替える」を現実にしてくれます。
