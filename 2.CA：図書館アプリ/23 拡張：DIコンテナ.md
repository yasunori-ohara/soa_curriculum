# 23 拡張：DIコンテナ

# ⚙️ DIコンテナ: 依存関係の自動組立工場

これまでの`main.py`では、私たちが手作業で全ての部品を組み立て（インスタンス化し、注入し）てきました。小規模なアプリケーションではこれで十分ですが、部品が増えるにつれて`main.py`は複雑になり、メンテナンスが困難になります。

そこで登場するのが**DIコンテナ**です。これは、各部品の「作り方」と「誰がどの部品を必要としているか」を定義しておくだけで、実行時に必要なオブジェクトを自動で組み立ててくれる、まさに「依存関係の自動組立工場」です。

![クリーンアーキテクチャ](../クリーンアーキテクチャ.png)

## 🎯 この章の目的

- 手動での依存性注入（DI）が、アプリケーションの成長に伴い複雑化する問題を理解する。
- DIコンテナ（今回は`dependency-injector`ライブラリを使用）を導入し、依存関係の解決を自動化する方法を学ぶ。
- `main.py`（Composition Root）を劇的にシンプルにし、設定をコードから分離する。
- テスト時に、本番用とテスト用の実装を簡単に切り替えられるようになることの利点を理解する。

## ✅ DIコンテナにあるべき処理

⭕️ **含めるべき処理の例:**

- アプリケーションの各コンポーネント（`UseCase`, `Presenter`, `DataAccess`など）の「プロバイダ」を定義する。
- プロバイダ間の依存関係（「`UseCase`は`Presenter`と`Repository`を必要とする」など）を宣言する。

❌ **含めてはいけない処理の例:**

- ビジネスロジックそのもの。コンテナの責務は、あくまでオブジェクトの生成と配線に専念します。

## 💻 ソースコードの詳細解説

### 1. DIコンテナの定義ファイルを作成

まず、`dependency-injector`ライブラリをインストールします (`pip install dependency-injector`)。
次に、依存関係の「設計図」となるコンテナ定義ファイルを作成します。

```python
# containers.py (New File)

from dependency_injector import containers, providers

# --- アプリケーションの全コンポーネントをインポート ---
from application.use_cases.check_out_book import CheckOutBookUseCase
from adapters.presenter import CheckOutBookPresenter
from adapters.controller import CheckOutBookController
from adapters.view import ConsoleView
from adapters.data_access import (
    InMemoryBookDataAccess, InMemoryMemberDataAccess, InMemoryLoanDataAccess
)
# from adapters.mongo_data_access import ... # DB版も同様にインポート可能
from application.data_structures import BookViewModel

# -----------------------------------------------------------------------------
# DI Container
# - クラス図の位置: (図の外) 全ての部品の生成と配線を管理する
# - 同心円図の位置: (円の外) アプリケーション全体のインフラ
# -----------------------------------------------------------------------------
class AppContainer(containers.DeclarativeContainer):
    """アプリケーション全体の依存関係を定義するDIコンテナ"""

    # --- 各コンポーネントのプロバイダを定義 ---

    # ViewModel: PresenterとViewで共有されるので、Singletonとして定義
    # Singleton = アプリケーション内で常に同一のインスタンスを返す
    view_model = providers.Singleton(BookViewModel, display_text="")

    # Presenter: ViewModelに依存
    presenter = providers.Factory(
        CheckOutBookPresenter,
        view_model=view_model
    )

    # DataAccess: それぞれSingletonとして定義
    book_repo = providers.Singleton(InMemoryBookDataAccess)
    member_repo = providers.Singleton(InMemoryMemberDataAccess)
    loan_repo = providers.Singleton(InMemoryLoanDataAccess)

    # UseCase: Presenterと3つのRepositoryに依存
    use_case = providers.Factory(
        CheckOutBookUseCase,
        presenter=presenter,
        book_repository=book_repo,
        member_repository=member_repo,
        loan_repository=loan_repo
    )

    # Controller: UseCaseに依存
    controller = providers.Factory(
        CheckOutBookController,
        use_case=use_case
    )

    # View: ControllerとViewModelに依存
    view = providers.Factory(
        ConsoleView,
        controller=controller,
        view_model=view_model
    )

```

- **`providers.Singleton`**: アプリケーション全体で一つのインスタンスを使い回したい場合に使います。DB接続や状態を持つViewModelなどが該当します。
- **`providers.Factory`**: 呼び出されるたびに新しいインスタンスを生成したい場合に使います。リクエストごとに状態を持たない`UseCase`や`Controller`などが該当します。
- **依存関係の宣言**: `CheckOutBookUseCase`のプロバイダ定義を見ると、引数として他のプロバイダ（`presenter`, `book_repo`など）を指定しています。DIコンテナはこれを見て、`UseCase`を生成する前に必要な部品を自動で組み立ててくれます。

### 2. `main.py` の更新 (劇的な簡素化)

DIコンテナを使うことで、手動での組み立て作業が不要になり、`main.py`は非常にスッキリします。

```python
# main.py (Updated)

from containers import AppContainer

def main():
    """DIコンテナを使ってアプリケーションを組み立て、起動する"""
    # 1. コンテナのインスタンスを作成
    container = AppContainer()

    # 2. コンテナに必要な部品の生成を依頼する
    view = container.view()

    # 3. アプリケーションを実行する
    view.run()

if __name__ == "__main__":
    main()

```

以前は十数行あったオブジェクト生成と注入のコードが、たった2行になりました。**依存関係の複雑さはすべて`AppContainer`にカプセル化され**、`main.py`は「コンテナから完成品の`View`を取り出して実行する」という単純な役割に変わりました。

## 💡 ユニットテストにおけるDIコンテナの威力

DIコンテナは、テストの実装も容易にします。テスト実行時に、本番用の実装をテスト用の「偽物」に簡単に差し替えることができます。

```python
# tests/application/use_cases/test_check_out_book_with_container.py

from containers import AppContainer
from tests.doubles import FakeBookDataAccess # 偽物クラス

def test_DIコンテナを使ってUseCaseをテストする():
    # 1. Arrange (準備): コンテナのインスタンスを作成
    container = AppContainer()

    # 2. Act (実行): コンテナの定義を、テスト用に上書き（オーバーライド）する
    #    「book_repoプロバイダが返すものを、FakeBookDataAccessのインスタンスに差し替えて」と指示
    with container.book_repo.override(FakeBookDataAccess(initial_books=[...])):
        # このwithブロック内では、container.use_case()を呼び出すと、
        # 自動的にFakeBookDataAccessが注入されたUseCaseが生成される
        use_case = container.use_case()

        # ... あとは通常通りUseCaseのテストを実行 ...

    # 3. Assert (検証)
    # ...

```

このように、`override`を使うことで、アプリケーション全体の複雑な依存関係を維持したまま、テストしたい部品の依存先だけを安全に差し替えることができます。

## 🛡️ この章の鉄則

依存関係の管理という面倒な作業は、専門家に任せましょう。

> 依存関係を宣言せよ、生成はコンテナに任せよ。 (Declare dependencies; let the container create.)
> 
- `main.py`や各クラスから、具体的な実装クラスをインスタンス化するコードを排除し、依存関係の解決をDIコンテナに一任します。
- これにより、アプリケーションの構成が`containers.py`という一つのファイルに集約され、見通しが良くなります。
- データベースをインメモリからMongoDBに切り替える際も、`containers.py`の`providers.Singleton(InMemoryBookDataAccess)`を`providers.Singleton(MongoBookDataAccess)`に**一行書き換えるだけ**で済むようになります。

DIコンテナは、クリーンアーキテクチャを大規模で複雑なアプリケーションに適用するための、非常に強力なツールです。

## ❓ Q&A

### **Q. `main.py`はシンプルになりましたが、結局その分の複雑さが`containers.py`に移動しただけではないですか？ DIコンテナの本当のメリットは何でしょうか？**

**A.** はい、その通りです。複雑さは移動しましたが、その**「移動先」と「管理方法」が劇的に改善される点**に、DIコンテナの絶大なメリットがあります。

手作業の`main.py`が**「現場で指示を出しながら行う、行き当たりばったりの組み立て作業」**だとすれば、`containers.py`は**「事前に用意された、精巧な建築設計図」**に例えられます。設計図自体は情報量が多くて複雑に見えるかもしれませんが、それによって現場作業（アプリケーションの起動）は驚くほどスムーズになります。

具体的なメリットは以下の通りです。

1. **依存関係の「見える化」と「一元管理」 🏛️**
    - `main.py`では「どの順番で何を作るか」という**手続き**が書かれていましたが、`containers.py`には「`UseCase`は`Presenter`と`Repository`から**構成される**」という**宣言**が書かれています。
    - これにより、アプリケーション全体の構造が`containers.py`という一つのファイルに集約され、**システムの全体像を把握するための設計図**として機能します。新しい開発者が参加した際も、このファイルを見ればすぐにアーキテクチャを理解できます。
2. **実装の「差し替え」が圧倒的に容易に 🔩**
    - データベースを`InMemoryDataAccess`から`MongoDataAccess`に切り替える場合を考えてみてください。
        - **手作業の場合**: `main.py`のインスタンス生成コードを**直接書き換える**必要がありました。
        - **DIコンテナの場合**: `containers.py`の`book_repo = providers.Singleton(InMemoryBookDataAccess)`という**設定を一行書き換えるだけ**で完了します。
    - このように、実装の切り替えが**「コードの変更」から「設定の変更」に変わる**ため、より安全かつ迅速に対応できます。
3. **オブジェクトの「寿命（ライフサイクル）」を管理できる 🔄**
    - `providers.Singleton`（常に同じもの）と`providers.Factory`（毎回新しいもの）を使い分けることで、「DB接続はアプリ中で一つだけ」「`UseCase`はリクエストごとに新しいもの」といった、オブジェクトの寿命の管理をコンテナに任せることができます。これを手作業でやろうとすると、コードはさらに複雑になります。
4. **テストが劇的に書きやすくなる 🧪**
    - 前の章で見た`override`機能が非常に強力です。
    - 「`UseCase`をテストしたいが、`Repository`だけは本物ではなく偽物（`Fake`）に差し替えたい」といった場合に、`with container.book_repo.override(...)`と書くだけで、他の依存関係はそのままに、一部分だけを安全に交換できます。これにより、テストの準備が大幅に簡素化されます。

**結論として、DIコンテナは単に複雑さを移動させるだけでなく、依存関係の管理を「手続き的なプログラミング」から「宣言的な設定」へと昇華させます。** これにより、アプリケーションが大規模になればなるほど、その保守性、拡張性、テスト容易性の面で計り知れない恩恵をもたらすのです。