# 00 はじめに

# 📚 はじめに：シンプルな図書館の貸し出しシステム

TODOアプリよりも少しだけビジネスルールが豊かで、クリーンアーキテクチャの各層の役割がさらに明確になる題材として、「シンプルな図書館の貸出管理システム」をやっていきます。

---

## 🌟 この題材が優れている理由

- **状態（ステート）を持つ豊かなEntity**:
TODOは「完了/未完了」という単純な状態でしたが、図書館の`Book`（本）は「貸出可能」「貸出中」といった、より豊かな**状態**を持ちます。また、本と会員の関係性を示し、貸出記録そのものである **`Loan` (貸出) Entity** は、**ビジネスの核心**と言えます。Entityに状態遷移や、関連Entityとの整合性を保つロ-ジックを持たせる、良い練習になります。
- **より実践的なUse Case**:
「本を貸し出す」というユースケースには、「その会員は貸出可能か？」「その本は在庫があるか？」といった複数の条件をチェックし、さらに`Loan`というEntityを作成・永続化する、より実践的なビジネスロジックが含まれます。
- **明確な関心の分離と「依存性の方向」の体感**:
「貸出ルール」というビジネスの核心（EntityとUse Case）と、「司書が使う管理画面(UI)」や「本の情報を保存するデータベース」といった技術的な詳細を、綺麗に分離して考えることができます。特に`Loan` Entity**を通じて、ビジネスルールの中心が、データベースやUIといった**「詳細」に依存してはいけない（依存性反転の原則）ことを体感できます。

---

## 🧩 クリーンアーキテクチャの登場人物（フローのクラス図に相当）

![クリーンアーキテクチャ](../クリーンアーキテクチャ・クラス図.png)

この題材を、クリーンアーキテクチャの**フローのクラス図**に当てはめると、登場人物（クラスやインターフェース）は以下のようになります。

| カテゴリ | クラス/インターフェース名 | 役割（責務） | クラス図のどこに相当するか |
| --- | --- | --- | --- |
| **Entities** | `Book` | 書籍の属性と状態（貸出可能/中など）を管理。**ビジネスの核**。 | 中心層（Entities） |
|  | `Member` | 会員の属性と資格（有効/停止中など）を管理。**ビジネスの核**。 | 中心層（Entities） |
|  | `Loan` | **貸出記録そのもの**。どの本を、誰に、いつからいつまで貸したかの情報と、返却や延滞のロジックを持つ。 | 中心層（Entities） |
| **Data Structures** | `CheckOutBookInputData` | **Controller (I/F)** から **Use Case (I/F)** へ渡すデータ。`member_id`, `book_id`など。 | DTO (データ転送オブジェクト) |
|  | `CheckOutBookOutputData` | **Use Case** から **Presenter** へ渡すデータ。`book_title`, `member_name`, `due_date`など。 | DTO (データ転送オブジェクト) |
| **Boundaries** | `CheckOutBookInputBoundary` | **Use Case** の「ポート」（入り口）。**Controller** がこの**抽象**に依存する。 | Use Case層のI/F |
|  | `CheckOutBookOutputBoundary` | **Presenter** の「ポート」（出口）。**Use Case** がこの**抽象**に依存する。 | Use Case層のI/F |
| **Repositories** | `BookDataAccessInterface` | `Book`の永続化I/F。**Use Case** は具体的なDBではなく**この抽象**に依存。 | Repository I/F (Gateway) |
|  | `MemberDataAccessInterface` | `Member`の永続化I/F。 | Repository I/F (Gateway) |
|  | `LoanDataAccessInterface` | `Loan`の永続化I/F。 | Repository I/F (Gateway) |
| **Use Case** | `CheckOutBookInteractor` | **「本の貸出」という業務ロジック**（処理手順）を実行する。 | Use Case層の実装 |
| **Adapters** | `InMemoryBookDataAccess` | `BookDataAccessInterface`の具体的な**DB実装**（例:メモリ、SQL、NoSQL）。 | Adapters層の実装 |
|  | `CheckOutBookPresenter` | `CheckOutBookOutputData`をUI表示形式（`ViewModel`）に変換する。 | Adapters層の実装 |
|  | `CheckOutBookController` | UI/フレームワークからの入力を受け取り、\*\*`CheckOutBookInputBoundary`\*\*に渡す。 | Adapters層の実装 |

---

## 🚀 具体的なシナリオ例：「本の貸出」

**`CheckOutBookInteractor`が実行する処理の流れは、`Loan` Entityが関わることで、TODOアプリより一層複雑で面白くなります。この処理手順こそが、「ビジネスルールは叫ぶ」**（ビジネスルールがアプリケーションの中心に位置し、外部のAdapterに依存しない）という鉄則を体現します。

1. `Controller`から`CheckOutBookInputData`(`member_id`, `book_id`)を受け取ります。
2. `MemberDataAccessInterface`を使い、`member_id`で`Member` Entityを探します。
3. 見つかった`Member` Entityの`membership_status`をチェックし、貸出が許可されているか確認します。
4. `BookDataAccessInterface`を使い、`book_id`で`Book` Entityを探します。
5. 見つかった`Book` Entityの`status`をチェックし、「貸出可能」であるか確認します。
6. **`Loan` Entityを新しく作成**し、返却期限日を計算します（例：現在日から2週間後）。
7. `book.check_out()`メソッドを呼び出して、本の状態を「貸出中」に変更します。（`Book`自身が状態変更のロジックを持つ）
8. 変更された`Book` Entityと、新しく作成した\*\*`Loan` Entity\*\*を、それぞれの`DataAccessInterface`を通じて永続化します。
    - **鉄則を強調！** ここで`Book`や`Loan`が具体的なDBクラスを直接触ることはありません。**抽象（Interface）に依存**しています。
9. 成功した結果（本のタイトル、会員名、返却期限日）を`CheckOutBookOutputData`に詰めて、`Presenter`を呼び出します。

---

## 💡 練習問題：ユニットテストで「責務」を理解する

この題材では、**責務に集中**するために、\*\*`CheckOutBookInteractor`\*\*のロジックに対するユニットテストを最初に書いてみます。

ユニットテストは、**フレームワークやデータベースといった詳細（外側）を完全に排除**し、`CheckOutBookInteractor`（内側）が純粋にビジネスルールだけを実行していることを証明します。

```python
# UseCase層のユニットテストの例 (Python)
def test_貸出が成功するシナリオ(self):
    # 1. Arrange: 準備
    # モック（偽物）を使って、外部への依存を切る
    mock_book_repo = MockBookRepository(貸出可能な本)
    mock_member_repo = MockMemberRepository(有効な会員)
    mock_loan_repo = MockLoanRepository() # Loanの永続化はここが担当

    # 2. Act: 実行
    interactor = CheckOutBookInteractor(mock_book_repo, mock_member_repo, mock_loan_repo)
    input_data = CheckOutBookInputData(member_id="M001", book_id="B001")
    # Presenterもモック化し、出力データを検証する
    mock_presenter = MockPresenter()
    interactor.handle(input_data, mock_presenter)

    # 3. Assert: 検証
    # ✅ 貸出記録がDBに永続化されたこと
    self.assertTrue(mock_loan_repo.saveが呼ばれた)
    # ✅ 本の状態が「貸出中」に変わったこと
    self.assertEqual(mock_book_repo.getBook("B001").status, "貸出中")
    # ✅ Presenterに成功データが渡されたこと
    self.assertTrue(mock_presenter.success_outputが渡された)
# (補足) データベースの接続やUI表示のコードは一切出てきません。
# UseCaseの責務（ビジネスロジック）に集中してテストできるのが、クリーンアーキテクチャの強みです。

```

## 🐍 PythonとC言語の比較（初心者の方へ）

- **Python (オブジェクト指向)**: クリーンアーキテクチャでは、データと振る舞いをEntity（`Book`, `Loan`など）として一つのクラスにまとめます。メソッド（`book.check_out()`）を呼び出すことで、**データ自身が**ロジックを実行する感覚です。
- **C言語 (手続き型)**: もしC言語で書くなら、データ（構造体）と処理（関数）は分かれ、「`check_out(book_data, member_data)`」のように、**関数が外部からデータを受け取って**処理を実行する形になります。
- **クリーンアーキテクチャ**: Pythonのオブジェクト指向の考え方を最大限に活かし、Entityを「自律的なデータとロジックの塊」として設計することで、**変更に強い**構造を作ります。

この題材で一度アプリケーションを構築してみることで、クリーンアーキテクチャがどのようにして複雑なビジネスルールを整理し、**見通しの良い構造**に保つのかを、より深く体感できるはずです。