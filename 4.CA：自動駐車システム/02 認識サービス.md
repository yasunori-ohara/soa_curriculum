# 02 認識サービス

# 👀 認識サービス (Perception Service)

自動駐車システムの最初のステップを担当する「認識サービス」について解説します。このサービスは、システムの「目」として、周囲の状況を把握し、それを後続のサービスが理解できる形に翻訳する責任を持ちます。

---

## 🗺️ このサービスの全体像（ファイル構成と依存関係）

この「認識サービス」も、これまでの三巡で学んだクリーンアーキテクチャのルールに従って設計されます。
UseCase（ビジネスロジック）を中心（内側）に置き、具体的な実装（センサー、ファイル入出力など）を**Adapters層**（外側）に配置します。

![クリーンアーキテクチャ](../クリーンアーキテクチャ.png)

### ファイル構成

この依存関係ルールに基づき、ファイルを以下のようにフォルダ分けします。ご指摘に基づき、具体的な実装はすべて `adapters/` フォルダに統一します。

```
perception_service/
├── domain/
│   └── entities.py         # [Entity] WorldModel など、核となるルール
├── application/
│   ├── boundaries.py       # [境界] SensorInterface などのインターフェース定義
│   └── use_cases.py        # [UseCase] UpdateWorldModelUseCase ロジック
├── adapters/
│   ├── file_publisher.py   # [Adapters層] FileWorldModelPublisher (出力実装)
│   ├── repositories.py     # [Adapters層] InMemoryWorldModelRepository (状態実装)
│   └── stub_sensor.py      # [Adapters層] StubSensorAdapter (入力実装)
├── tests/
│   └── ...                 # (テストコード)
└── main.py                 # [起動] DIコンテナ、実行ファイル

```

---

## 🎯 責務：世界を理解し、モデル化する

認識サービスの唯一の責務は、「センサー（目）から入ってくる生の情報を解釈し、システム（頭脳）が理解できる抽象化された\_世界モデル\_を作成すること」です。

```
[ ハードウェア (入力) ] --------> [ 認識サービス ] --------> [ 世界モデル (データ) ]
(カメラ、ソナー)                  (Perception)              (駐車スペース位置など)
                                - センサー解釈
                                - 環境マップ作成

```

このサービスは、カメラ映像から白線を認識したり、ソナーの距離データから障害物を検出したりといった、高度なセンサーフュージョンや認識アルゴリズム（今回は詳細を省略）を実行し、その結果を構造化されたデータとして出力します。

---

## 🧩 主要コンポーネント

このサービスも独立したクリーンアーキテクチャで構成されます。第四巡では、EntityとUseCaseの役割を再確認しつつ、境界の設計に焦点を当てます。

### 主要なEntities

ビジネスの核となる概念とルールを定義します。

- **DetectedObject**: 検出された物体（他の車、歩行者、壁など）の位置、形状、速度などの属性を持ちます。
- **ParkingSpace**: 検出された駐車スペースの位置、サイズ、向きなどの属性を持ちます。`is_available()`のような状態チェックメソッドを持つことも考えられます。
- **WorldModel**: 認識サービスの中心となるEntity。`DetectedObject`や`ParkingSpace`のリストを保持し、「現在の環境マップ」全体を表現します。`update_objects()`や`find_nearest_space()`のような、マップを操作・問い合わせるためのビジネスルールを持ちます。

<!-- end list -->

```python
# domain/entities.py (認識サービス内)
from dataclasses import dataclass, field
from datetime import datetime
from typing import List

# (DetectedObject, ParkingSpace, RawImageData, SonarReading などの定義 ... 省略)

# -----------------------------------------------------------------------------
# WorldModel Entity
# - クラス図の位置: Entities
# - 同心円図の位置: Entities (最も内側)
# -----------------------------------------------------------------------------
@dataclass
class WorldModel:
    timestamp: datetime
    objects: List[DetectedObject] = field(default_factory=list)
    parking_spaces: List[ParkingSpace] = field(default_factory=list)

    def update_objects(self, new_objects: List[DetectedObject]):
        """[ビジネスルール] 検出されたオブジェクトリストを更新する"""
        # (例: IDが一致するものを更新、新しいものを追加、消えたものを削除など)
        self.objects = new_objects
        self.timestamp = datetime.now()

    # ... 他のマップ操作メソッド ...

```

### 主要なUseCase

特定のシナリオを実行するためのビジネスフローを定義します。

- **UpdateWorldModelUseCase**: センサーからの新しい情報（`RawImageData`, `SonarReading`など）を受け取り、認識アルゴリズムを実行し、その結果を使って`WorldModel` Entityを更新し、最後に更新された`WorldModel`を外部（次のサービス）に公開する、という一連の流れを担当します。

<!-- end list -->

```python
# application/use_cases/update_world_model.py (認識サービス内)
from application.boundaries import (
    SensorInterface,
    WorldModelRepositoryInterface,
    PlanningServiceAdapterInterface,
    UpdateWorldModelInputBoundary # InputBoundaryもboundaries.pyで定義想定
)

# -----------------------------------------------------------------------------
# Use Case
# - クラス図の位置: UseCase
# - 同心円図の位置: Use Cases
# -----------------------------------------------------------------------------
class UpdateWorldModelUseCase(UpdateWorldModelInputBoundary):
    def __init__(self,
                 sensor_interface: SensorInterface,
                 world_model_repo: WorldModelRepositoryInterface, # WorldModel永続化用
                 planning_adapter: PlanningServiceAdapterInterface):
        # DIにより、インターフェース(抽象)のみを受け取る
        self._sensor_interface = sensor_interface
        self._world_model_repo = world_model_repo
        self._planning_adapter = planning_adapter

    async def handle(self):
        # 1. センサーから生データを取得 (非同期I/O)
        #    (具体的なセンサーの実装は知らない)
        image_data = await self._sensor_interface.get_camera_image()
        sonar_data = await self._sensor_interface.get_sonar_readings()

        # 2. 認識アルゴリズムを実行 (今回は詳細省略)
        #    (生データからDetectedObjectやParkingSpaceを生成する処理)
        new_objects = self._run_object_detection(image_data, sonar_data)
        new_spaces = self._run_space_detection(image_data) # (メソッドは仮)

        # 3. WorldModel Entityを取得し、更新
        #    (具体的なDBやメモリの実装は知らない)
        current_world_model = self._world_model_repo.get()
        current_world_model.update_objects(new_objects)
        # current_world_model.update_spaces(new_spaces) # (メソッドは仮)

        # 4. 更新されたWorldModelを永続化（内部状態の保存）
        self._world_model_repo.save(current_world_model)

        # 5. 結果を次のサービスに公開 (非同期I/O)
        #    (具体的なファイル書き出しや通信の実装は知らない)
        await self._planning_adapter.publish_world_model(current_world_model)

```

---

## 🔌 重要な境界 (Boundaries)

このサービスの核心は、入力（センサー）と出力（世界モデル）の境界をどう設計するかです。これらのインターフェースが、このサービスを他の部分から「隔離」する壁となります。

（※この `application/boundaries.py` ファイルに、UseCaseが必要とするすべてのインターフェース定義を集約します）

```python
# application/boundaries.py (認識サービス内)
from abc import ABC, abstractmethod
from domain.entities import RawImageData, SonarReading, WorldModel # 生データ用Entity
from typing import List # (entities.pyから移動・または両方で定義)

# --- 1. 入力境界：SensorInterface ---
# --------------------------------------------------------------------
# - クラス図の位置: <I>HardwareInterface (DataAccessInterfaceの一種)
# - 同心円図の位置: 円と円の境界線そのもの
# --------------------------------------------------------------------
class SensorInterface(ABC):
    @abstractmethod
    async def get_camera_image(self) -> RawImageData:
        """カメラから最新の画像を取得する (非同期)"""
        raise NotImplementedError

    @abstractmethod
    async def get_sonar_readings(self) -> List[SonarReading]:
        """ソナーから距離測定値のリストを取得する (非同期)"""
        raise NotImplementedError

# --- 2. 出力境界：PlanningServiceAdapterInterface ---
# --------------------------------------------------------------------
# - クラス図の位置: <I>ServiceAdapterInterface (DataAccessInterfaceの一種)
# - 同心円図の位置: 円と円の境界線そのもの
# --------------------------------------------------------------------
class PlanningServiceAdapterInterface(ABC):
    @abstractmethod
    async def publish_world_model(self, world_model: WorldModel):
        """計算された世界モデルを次の経路計算サービスに渡す (非同期)"""
        raise NotImplementedError

# --- 3. 内部状態境界：WorldModelRepositoryInterface ---
# --------------------------------------------------------------------
# - クラス図の位置: <I>DataAccessInterface
# - 同心円図の位置: 円と円の境界線そのもの
# --------------------------------------------------------------------
class WorldModelRepositoryInterface(ABC):
    @abstractmethod
    def get(self) -> WorldModel:
        """現在のWorldModelを取得する"""
        raise NotImplementedError

    @abstractmethod
    def save(self, world_model: WorldModel):
        """WorldModelを保存する"""
        raise NotImplementedError

# --- 4. UseCase自体の入力境界 (参考) ---
class UpdateWorldModelInputBoundary(ABC):
    @abstractmethod
    async def handle(self):
        raise NotImplementedError

```

- `async def`: センサーからのデータ取得やサービスへのデータ送信は時間がかかる（I/O待ちが発生する）可能性があるため、非同期メソッドとして定義します。
- `RawImageData`, `SonarReading`: これらも`domain/entities.py`で定義される、生データのための単純なデータクラス（EntityまたはValue Object）です。

---

## ⚙️ Adapters層：具体的な実装（アダプタ）

ここでは、`application/boundaries.py`で定義されたインターフェース（契約書）を、**具体的に実装**します。センサーのダミー（スタブ）、ファイル書き出し（Publisher）、メモリ上のリポジトリなど、具体的な「道具」がこの `adapters/` フォルダに集められます。

### 1. センサーアダプタの実装 (入力)

`SensorInterface`を実装します。実際のハードウェア（カメラ、ソナー）と通信するコードはここに書かれますが、今回はテストや開発のためにダミーデータ（スタブ）を返すクラスを作成します。

```python
# adapters/stub_sensor.py (認識サービス内)
import asyncio
from domain.entities import RawImageData, SonarReading
from application.boundaries import SensorInterface
from typing import List # (型ヒントのために必要)

# -----------------------------------------------------------------------------
# Hardware Adapter Implementation (Stub)
# - クラス図の位置: HardwareAdapter
# - 同心円図の位置: Adapters (外側の円)
# -----------------------------------------------------------------------------
class StubSensorAdapter(SensorInterface):
    """
    センサーハードウェアのダミー（スタブ）。
    UseCaseが必要とするインターフェースを実装し、テスト用の固定データを返す。
    """
    async def get_camera_image(self) -> RawImageData:
        print("[Adapter] StubSensor: Generating dummy image data...")
        await asyncio.sleep(0.1) # I/O待ちをシミュレート
        return RawImageData(data="<dummy_image_bytes_>")

    async def get_sonar_readings(self) -> List[SonarReading]:
        print("[Adapter] StubSensor: Generating dummy sonar data...")
        await asyncio.sleep(0.05) # I/O待ちをシミュレート
        return [SonarReading(distance=5.0), SonarReading(distance=3.2)]

```

### 2. 出力アダプタの実装 (サービス間出力)

`PlanningServiceAdapterInterface`を実装します。今回はSOAのシミュレーションとして、ファイル書き出しを行う `Publisher` を作成します。

```python
# adapters/file_publisher.py (認識サービス内)
import json
import asyncio
from domain.entities import WorldModel
from application.boundaries import PlanningServiceAdapterInterface

# -----------------------------------------------------------------------------
# Service Adapter Implementation (File Publisher)
# - クラス図の位置: ServiceAdapter (DataAccessなどと同じ外部実装)
# - 同心円図の位置: Adapters (外側の円)
# -----------------------------------------------------------------------------
class FileWorldModelPublisher(PlanningServiceAdapterInterface):
    """
    UseCaseの要求(I/F)に基づき、WorldModelを
    ファイル（JSON）として書き出す（公開する）アダプタ。
    """
    def __init__(self, filepath="world_model.json"):
        self._filepath = filepath

    async def publish_world_model(self, world_model: WorldModel):
        # WorldModelを辞書形式に変換する処理 (仮)
        # 実際にはEntityに to_dict() のようなメソッドがあると良い
        world_model_dict = {
             "timestamp": world_model.timestamp.isoformat(),
             # ... objectsやparking_spacesも辞書に変換 ...
        }
        try:
            # (※ 本来は非同期ファイルI/Oライブラリを使うべきだが簡潔化)
            await asyncio.sleep(0.01) # 非同期I/Oのシミュレーション
            with open(self._filepath, "w") as f:
                json.dump(world_model_dict, f, indent=2)
            print(f"[Adapter] FilePublisher: World Model saved to {self._filepath}")
        except IOError as e:
            print(f"[Adapter] FilePublisher: Error saving World Model: {e}")
            # 本来はエラーをUseCaseに通知する仕組みが必要

```

### 3. リポジトリアダプタの実装 (内部状態)

`WorldModelRepositoryInterface`を実装します。`WorldModel`をデータベースに保存することもできますが、今回は単純にPythonのメモリ上に保持するクラスを作成します。

```python
# adapters/repositories.py (認識サービス内)
from domain.entities import WorldModel
from application.boundaries import WorldModelRepositoryInterface
from datetime import datetime # (初期化で使うため)

# -----------------------------------------------------------------------------
# Data Access Implementation (In-Memory)
# - クラス図の位置: DataAccess
# - 同心円図の位置: Adapters (外側の円)
# -----------------------------------------------------------------------------
class InMemoryWorldModelRepository(WorldModelRepositoryInterface):
    """
    WorldModelをメモリ上に保持するリポジトリ。
    アプリケーションが実行されている間だけ状態を記憶する。
    """
    def __init__(self):
        # アプリ起動時に空のWorldModelをメモリ上に作成
        self._world_model = WorldModel(timestamp=datetime.now())
        print("[Adapter] InMemoryRepo: Initialized.")

    def get(self) -> WorldModel:
        print("[Adapter] InMemoryRepo: Getting WorldModel from memory.")
        # メモリ上のWorldModelインスタンスを返す
        return self._world_model

    def save(self, world_model: WorldModel):
        print("[Adapter] InMemoryRepo: Saving WorldModel to memory.")
        # この例では、get()で渡されたインスタンス(参照)がUseCase側で
        # 直接変更されるため、このsave()は実質何もしなくても
        # _world_modelは更新されている。
        # ここではタイムスタンプの最終更新などを行う。
        self._world_model.timestamp = datetime.now()

```

---

## 🚀 起動ファイル ([main.py](http://main.py/))：すべてを結合する

ここまで作成した`Entity`, `UseCase`, `Adapters`（アダプタ）は、すべてバラバラの部品です。
アプリケーションのエントリーポイント（起動ファイル、`main.py`）の役割は、これらの**具体的な部品（実装）を組み立てて、UseCaseに「注入」し、アプリケーションを実行する**ことです。

```python
# main.py (認識サービス内)
import asyncio
from application.use_cases import UpdateWorldModelUseCase
from adapters.stub_sensor import StubSensorAdapter
from adapters.repositories import InMemoryWorldModelRepository
from adapters.file_publisher import FileWorldModelPublisher

# -----------------------------------------------------------------------------
# Entry Point (Main Application)
# - クラス図の位置: Main (DIコンテナの役割)
# - 同心円図の位置: 最も外側の層 (Frameworks & Drivers)
# -----------------------------------------------------------------------------
async def main():
    """
    アプリケーションを起動し、依存関係を注入 (DI) する。
    """
    print("--- [Perception Service] Starting Up ---")

    # 1. Adapters層（具体的な実装）をインスタンス化
    #    「どの道具を使うか」をここで決定する。
    sensor_adapter = StubSensorAdapter()
    world_model_publisher = FileWorldModelPublisher(filepath="world_model.json")
    world_model_repository = InMemoryWorldModelRepository()

    # 2. UseCase層に、具体的な実装を「依存性の注入 (DI)」
    #    UseCaseはインターフェース（窓口）だけを要求し、
    #    Mainが具体的な実装（担当者）を割り当てる。
    use_case = UpdateWorldModelUseCase(
        sensor_interface=sensor_adapter,
        world_model_repo=world_model_repository,
        planning_adapter=world_model_publisher
    )

    # 3. アプリケーション（UseCase）の実行
    print("\\n--- [Perception Service] Running UseCase ---")
    try:
        # UseCaseのhandleメソッドを呼び出す
        await use_case.handle()
        print("--- [Perception Service] UseCase Finished ---")
    except Exception as e:
        print(f"--- [Perception Service] Error: {e} ---")

if __name__ == "__main__":
    # このサービス（認識サービス）を実行
    asyncio.run(main())

```

---

## 💡 ユニットテストでサービス境界を検証する

UseCaseのテストでは、これらの境界（インターフェース）が正しく使われているかを検証します。センサーや次のサービスは偽物（モック）に差し替えます。

```python
# tests/application/use_cases/test_update_world_model.py (認識サービス内)
import pytest
from unittest.mock import MagicMock # テスト用のモックライブラリ
# (MockSensorInterface, MockWorldModelRepository, MockPlanningServiceAdapter を
#  テスト用に別途定義する想定)
# (RawImageData, SonarReading, WorldModel などのEntityもインポートが必要)

@pytest.mark.asyncio
async def test_UseCaseはセンサーデータを取得しWorldModelを公開する():
    # 1. Arrange (準備): 全ての依存先を偽物(モック)にする
    #    これらは、インターフェースを満たすテスト用のダミークラス。
    mock_sensor = MockSensorInterface()
    mock_repo = MockWorldModelRepository()
    mock_planner_adapter = MockPlanningServiceAdapter()

    # 偽センサーが返すデータを設定
    mock_sensor.set_next_image(RawImageData(...))
    mock_sensor.set_next_sonar([SonarReading(...)])

    # 偽リポジトリが返すWorldModelを設定
    initial_world_model = WorldModel(...)
    mock_repo.set_world_model(initial_world_model)

    # 2. Act (実行)
    #    テスト対象のUseCaseに、偽物の依存先を注入する
    use_case = UpdateWorldModelUseCase(mock_sensor, mock_repo, mock_planner_adapter)
    await use_case.handle()

    # 3. Assert (検証)
    # 意図: 「センサーからデータを読み取り(1)、WorldModelを取得し(3)、更新し(4)、
    #       最後にPlanningAdapterに公開したか(5)？」をテスト
    assert mock_sensor.get_camera_image_called is True
    assert mock_repo.get_called is True
    assert mock_repo.save_called is True
    assert mock_planner_adapter.publish_world_model_called is True

    # 公開されたWorldModelの内容が期待通りかも検証できる
    assert mock_planner_adapter.published_model.timestamp is not None
    # 認識アルゴリズムが正しく実行されたかも検証できる
    # (例: mock_planner_adapter.published_model.objects の中身を検証)

```

---

## 🐍 PythonとC言語の比較（初心者の方へ）

Python (オブジェクト指向): `SensorInterface`のような抽象インターフェースを定義し、UseCaseはそれに依存します。アダプター（`RealCameraAdapter`や`StubSensorAdapter`）がそのインターフェースを実装することで、具体的なハードウェア制御コードがUseCaseから隠蔽されます。

C言語 (手続き型): ハードウェアアクセスは、特定のヘッダーファイル (`camera_driver.h`) をインクルードし、`read_camera_sensor()`のような関数を直接呼び出す形になりがちです。これだと、UseCase相当のロジックが特定のドライバに密結合してしまい、センサーを変更したり、テストで偽物に差し替えたりするのが困難になります。関数ポインタや構造体に関数ポインタを持せるなどの工夫で、ある程度の抽象化は可能ですが、言語レベルでの支援はありません。

---

## 🛡️ このサービスの鉄則

**センサーと世界を結びつけよ。ただし経路は考えるな。** (Connect sensors to the world, but don't plan the path.)

認識サービスの責務は、あくまで「現在の状況」を正確に把握し、それを標準化された形式（`WorldModel`）で表現することに限定されます。
「この後どう動くべきか」という判断は、完全に次の経路計算サービスの責務です。この明確な分離が、SOAの基本となります。

---

## 🔄 認識サービスの構成（復習）

```
perception_service/
├── domain/
│   └── entities.py         # [Entity] WorldModel など、核となるルール
├── application/
│   ├── boundaries.py       # [境界] SensorInterface などのインターフェース定義
│   └── use_cases.py        # [UseCase] UpdateWorldModelUseCase ロジック
├── adapters/
│   ├── file_publisher.py   # [Adapters層] FileWorldModelPublisher (出力実装)
│   ├── repositories.py     # [Adapters層] InMemoryWorldModelRepository (状態実装)
│   └── stub_sensor.py      # [Adapters層] StubSensorAdapter (入力実装)
├── tests/
│   └── ...                 # (テストコード)
└── main.py                 # [起動] DIコンテナ、実行ファイル

```

このページで実装した「認識サービス」は、クリーンアーキテクチャの原則に厳密に従いました。

1. **中心 (Entity, UseCase)**:
    - `WorldModel` というルール（**Entity**）を定義しました。
    - `UpdateWorldModelUseCase` というビジネスロジック（**UseCase**）を定義しました。
2. **境界 (Interfaces)**:
    - UseCaseは、具体的な道具（センサー、ファイル、メモリ）を直接知る代わりに、3つの抽象的な「窓口」（**Interfaces**）を定義しました (`SensorInterface`, `PlanningServiceAdapterInterface`, `WorldModelRepositoryInterface`)。
3. **外側 (Adapters)**:
    - 3つの窓口（Interfaces）に対応する、具体的な「道具」（**Adapters**）を実装しました (`StubSensorAdapter`, `FileWorldModelPublisher`, `InMemoryWorldModelRepository`)。
4. **組立 ([main.py](http://main.py/))**:
    - 最後に、`main.py`が「UseCase」と「Adapters」を\*\*注入（DI）\*\*によって結合し、アプリケーションを起動しました。

この「中心と外側を分離する」設計により、例えばセンサーをダミー（`Stub`）から本物（`RealCameraAdapter`）に差し替える場合でも、UseCaseのコードを一切変更する必要がありません。

## 🎓 補足：設計上の用語・フォルダ名について

このカリキュラムを進める上で、学習者が疑問に思う可能性のある2つの点について補足します。

### 1. `adapters/` と `infrastructure/` のフォルダ分けについて

一般的に、クリーンアーキテクチャの外側の層を実装する際、開発現場では以下のように役割でフォルダを分ける「慣習」があります。

- **`adapters/`**: アプリケーションの出入り口（Webコントローラ、サービス間連携アダプタ）
- **`infrastructure/`**: 技術的基盤（DB、センサー、ファイルシステム）

これは必須ルールではありませんが、プロジェクトが大きくなった際の整理術の一つです。

ただし、このカリキュラムでは、学習の混乱を避けるため、ご指摘の通り「**`adapters/`**」フォルダに**すべての具体的な実装（アダプタ）を統一する**構成を採用しています。

### 2. `Publisher` と `Subscriber` の使い分けについて

「認識サービス」の入力アダプタ名が `StubSensorAdapter` となっており、`Subscriber`（購読者）ではない理由をここで明確にしておきます。

これは、`Subscriber` という名前が、SOAの「Pub/Sub（公開/購読）」モデルにおける**サービス間連携**（ファイル読み込み）のために予約されているためです。

- **認識サービス（今回）**:
    - **入力**: センサー（ハードウェア）。`SensorInterface` で抽象化します。
    - **出力**: `FileWorldModelPublisher`（公開側）。
- **経路計算サービス（次回）**:
    - **入力**: `FileWorldModelSubscriber`（購読側）。ここで `Subscriber` の名前が登場します。
    - **出力**: （次のサービスへのPublisher）。

このように、「認識サービス」の入力はサービス間のデータではなく、ハードウェア（センサー）であるため、`SensorAdapter` という名前が適切となります。

---

次は、「経路計算サービス」について見ていきましょう。