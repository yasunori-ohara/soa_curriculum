# 08 リファクタリング（発展編）

## 🔧 目的：アダプタ層をより実務的にする

ここまでで、あなたはすでに以下を満たした自動販売機アプリケーションを完成させています。

* `domain/`
  ビジネスルール（`Item`, `PaymentManager` など）

* `usecase/`
  ビジネスフロー（`InsertCoinUseCase`, `SelectItemUseCase` など）と、その入出力や周辺契約（`dto.py`, `boundaries.py`）

* `interface_adapters/`
  現実世界とつなぐアダプタ類

  * `controller.py`
  * `presenter.py`
  * `view_console.py`
  * `data_access.py`
  * `hardware_adapter.py`

* `main.py`
  すべてを束ね、依存関係を注入して、アプリを起動する

この構成はすでにクリーンアーキテクチャの原則（依存が内向き、責務が分離）を満たしています。
そのため「このままでも正しい」です。

この章では、その上でさらに一歩踏み込み、**より大きな現場・より長期の運用**を見据えた改善（リファクタリング）案を紹介します。

このリファクタリングは必須ではありません。設計の成熟度を高めるための「任意課題」です。

---

## 🧭 目標となる改善ポイント

この章では、次の3点を検討します。

1. 💳 PaymentManagerをリポジトリ化し、UIから状態を追い出す
2. 🚦 成功ルートと失敗ルートを分け、Presenterでエラーも扱う
3. 🤖 HardwareAdapterのインターフェースを拡張し、実機制御を見据える

順番に見ていきます。

---

## 1. 💳 PaymentManagerをリポジトリ化する

### 🐞 改善前の課題（におい）

現状では、`PaymentManager`（投入金額や支払い状態を保持するオブジェクト）を、`main.py` で1つ生成し、そのインスタンスを `InsertCoinUseCase` や `SelectItemUseCase` に直接渡しています。

これは単純でわかりやすいのですが、将来次のような問題になります。

* UI（例：`ConsoleView`）側が、特定の `PaymentManager` インスタンスに事実上依存する
  → UIがビジネス状態を抱える形になりやすい
* マルチユーザー（複数の購入セッション）に対応したい場合に拡張しにくい
  → 「誰のお金なのか？」をUI層で意識する必要が出てしまう
* テスト時に「状態の初期化」「途中状態の永続化」の扱いが不明確になる

このように、**「お金の状態」がUI寄りに見えてしまう**のは中長期では不利です。

### ✅ 目指す形

`Item` が `InMemoryItemDataAccess` で扱われるように、
`PaymentManager` も「アクセス用インターフェース＋データアクセス実装」で扱います。

要するに：

* UseCase は「PaymentManager を取得・保存できる何か」を受け取る
* 具体的にどこに保存するか（メモリ、外部ストレージ等）は interface_adapters 側に隠す

このパターンを導入することで、**UIは支払い状態をまったく意識しなくてよくなる**というメリットが生まれます。

---

### 🧱 1-1. インターフェースを追加する

`usecase/boundaries.py` に、`PaymentManagerAccessInterface` を追加します。
このファイルにはすでに、UseCaseが外部に依頼する契約（データアクセス、ハードウェア、プレゼンターなど）がまとまっています。そこに「支払い状態へのアクセス」という契約も追加します。

```python
# vending_machine/usecase/boundaries.py
from abc import ABC, abstractmethod
from vending_machine.domain.entities import PaymentManager

class PaymentManagerAccessInterface(ABC):
    """
    PaymentManager（投入金額や残額などの状態）にアクセスするための契約。

    UseCase はこのインターフェースを通じて
    - 現在のお金の状態を読み取り
    - 更新後の状態を書き戻す
    ことができる。
    """

    @abstractmethod
    def get(self) -> PaymentManager:
        """現在の支払い状態を取得する"""
        raise NotImplementedError

    @abstractmethod
    def save(self, payment_manager: PaymentManager) -> None:
        """更新済みの支払い状態を保存する"""
        raise NotImplementedError
```

ここで重要なのは、**UseCaseがこのインターフェース（抽象）に依存する**という点です。
UseCase はまだどこにも具体的な保存先（メモリかDBか）を知っていません。

---

### 🗄 1-2. その実装を interface_adapters 側に追加する

次に、この契約を満たす具体実装を `interface_adapters/data_access.py` に追加します。

```python
# vending_machine/interface_adapters/data_access.py

from vending_machine.usecase.boundaries import PaymentManagerAccessInterface
from vending_machine.domain.entities import PaymentManager

class InMemoryPaymentManagerAccess(PaymentManagerAccessInterface):
    """
    PaymentManager のインメモリ保持版。

    - 自販機全体に1つある支払い状態（投入金額など）をここで保持する。
    - 本来は、ユーザーごとのセッションや外部ストレージ等に拡張できる。
    """

    def __init__(self):
        # 最初は0円の状態など、初期状態で用意
        self._state = PaymentManager()

    def get(self) -> PaymentManager:
        """現在の支払い状態を返す"""
        return self._state

    def save(self, payment_manager: PaymentManager) -> None:
        """更新された状態を書き戻す"""
        self._state = payment_manager
```

ここでは1台の自販機につき1つの `PaymentManager` を持つという想定で `self._state` に保持しています。
将来的には「ユーザーごとに状態を分けたい」という場合、ここにセッションIDなどのキーを持たせるだけで拡張できます。UseCaseはそのまま再利用できます。

---

### 🔁 1-3. UseCase をこのリポジトリ経由に変更する

`SelectItemUseCase` や `InsertCoinUseCase` 等は、これまで `PaymentManager` インスタンスそのものを渡されていた前提でした。これを「リポジトリ経由で取得・保存」という形に置き換えます。

イメージは次のようになります。

```python
# vending_machine/usecase/select_item_usecase.py

from vending_machine.usecase.boundaries import (
    ItemDataAccessInterface,
    PaymentManagerAccessInterface,
    HardwareInterface,
    SelectItemOutputBoundary,
    SelectItemInputData,
    SelectItemOutputData,
)

class SelectItemUseCase:
    """
    商品購入フローを担当するユースケース。
    """

    def __init__(
        self,
        presenter: SelectItemOutputBoundary,
        item_repository: ItemDataAccessInterface,
        hardware: HardwareInterface,
        payment_repository: PaymentManagerAccessInterface,
    ):
        self._presenter = presenter
        self._item_repository = item_repository
        self._hardware = hardware
        self._payment_repository = payment_repository

    def handle(self, input_data: SelectItemInputData) -> None:
        """
        1. 支払い状態を取得
        2. 商品を取得
        3. 購入可否チェック
        4. ハードウェア動作
        5. 在庫と支払い状態を永続化
        6. Presenterに成功/失敗を伝える
        """
        try:
            # 1. 現在の支払い状態を取得
            payment_manager = self._payment_repository.get()

            # 2. 商品を在庫から取得
            item = self._item_repository.get_item(input_data.slot_id)
            if item is None:
                raise ValueError("商品が見つかりません。")
            if item.stock <= 0:
                raise ValueError("売り切れです。")

            # 3. 料金判定とお釣り計算（ドメインに委譲）
            change = payment_manager.process_purchase(item)

            # 4. ハードウェア作動
            self._hardware.dispense_item(item.slot_id)
            if change > 0:
                self._hardware.return_change(change)

            # 5. 在庫・支払い状態の更新を保存
            item.dispense()  # 在庫を1減らす
            self._item_repository.save_item(item)
            self._payment_repository.save(payment_manager)

            # 6. Presenterに成功結果を渡す
            output_data = SelectItemOutputData(
                item_name=item.name,
                change=change,
            )
            self._presenter.present_success(output_data)

        except ValueError as e:
            # 購入不可・不足金額などのビジネス例外はここで吸収してPresenterに任せる
            self._presenter.present_failure(str(e))
```

ポイントは次の3つです。

* UseCaseはもう`PaymentManager`の実体を直接保持しない（外部から渡されない）。
  → `payment_repository.get()` で取りにいく

* 状態の保存もUseCaseの責務になった
  → `payment_repository.save(payment_manager)`
  UI側は「お金の状態」を知らなくてよい

* エラー時に例外を投げっぱなしにせず、Presenterの `present_failure()` を呼ぶ
  （これは後述「成功/失敗ルート分離」と連動します）

---

### 🎁 1-4. このリファクタリングの効果

* View（UI）はもう投入金額や残額といった業務状態を追いません
  → 「使いやすいコンソールUI」から「マルチユーザー対応のWeb UI」へ移行する場合も、UI側の修正を最小化できます

* UseCaseが状態管理の主語になる
  → 「購入の一連の流れ」は UseCase が司令塔として完結できる
  → テストも UseCase 単体に集中できる

* `PaymentManager` が「ビジネスルールとしての“お金の管理”」に専念できる
  → どこに保存・共有されるかといった外部事情から切り離される

この「お金の状態をUIから切り離す」だけでも、アーキテクチャの伸びしろが一段変わります。

---

## 2. 🚦 成功ルートと失敗ルートを分ける

### 🐞 改善前の課題（におい）

今までの構成では、エラーが起きると View 側が例外を拾って、
`"エラー: ○○"` のような文言を組み立てていました。

これは次の問題を引き起こします。

* View がビジネスエラーの意味を知ってしまう
  （「お金が足りません」「在庫切れです」などの領域知識がUI層に漏れる）
* UI種類が増えたときに文言の重複・不一致が起こる
  （CLI版とWeb版で違うメッセージが出てしまう）
* Presenter の責務（＝表示用メッセージ整形）が不完全になる

### ✅ 目指す形

`Presenter` に「成功用のpresent」と「失敗用のpresent」を分けて定義します。
UseCaseは例外を握りつぶして、Presenterに「失敗を表示してください」と依頼します。
Viewは Presenter が用意した `ViewModel` をそのまま表示するだけです。

---

### 📑 2-1. 境界（Presenter側インターフェース）の変更

`usecase/boundaries.py` には、UseCaseが呼び出すための出力用インターフェース（OutputBoundary）が定義されています。そこを「成功」「失敗」に分けます。

```python
# vending_machine/usecase/boundaries.py

from abc import ABC, abstractmethod
from vending_machine.usecase.dto import SelectItemOutputData

class SelectItemOutputBoundary(ABC):
    """
    商品選択ユースケースの結果を表示用に橋渡しするための契約。
    Presenter がこれを実装する。
    """

    @abstractmethod
    def present_success(self, output_data: SelectItemOutputData) -> None:
        """購入成功時のメッセージ整形"""
        raise NotImplementedError

    @abstractmethod
    def present_failure(self, error_message: str) -> None:
        """購入失敗時のエラーメッセージ整形"""
        raise NotImplementedError
```

---

### 🖋 2-2. Presenter をそれに合わせて実装する

`interface_adapters/presenter.py` では、成功時と失敗時で `ViewModel` の `display_text` を切り替えるようにします。

```python
# vending_machine/interface_adapters/presenter.py

from vending_machine.usecase.boundaries import SelectItemOutputBoundary
from vending_machine.usecase.dto import SelectItemOutputData
from vending_machine.usecase.dto import ViewModel  # 例: display_textだけを持つ表示用構造

class VendingMachinePresenter(SelectItemOutputBoundary):
    """
    UseCase結果をViewModelに整形する役割。
    ViewはこのViewModelを読むだけでよい。
    """

    def __init__(self, view_model: ViewModel):
        self._view_model = view_model

    def present_success(self, output_data: SelectItemOutputData) -> None:
        """
        正常購入時の文面を作成し、ViewModelに反映する。
        """
        message = f"「{output_data.item_name}」が出てきました。"
        if output_data.change > 0:
            message += f" お釣りは{output_data.change}円です。"
        self._view_model.display_text = message

    def present_failure(self, error_message: str) -> None:
        """
        ビジネス上の失敗（お金不足、売り切れなど）を人間向けメッセージに整形する。
        """
        self._view_model.display_text = f"エラー: {error_message}"
```

ここで注目してほしいことは：

* `present_failure()` が、業務的なエラーをUI用の文言に変換している
  → これまでは View がやっていたことを Presenter に集約できる

* View は最終的な文字列しか知らない
  → 「なぜ失敗したのか？」というビジネス知識を持たないで済む

このスタイルにより、UIの責務は一気に軽くなります。

---

### 🖥 2-3. View はより“愚直”になる

`view_console.py` はこのおかげでさらに薄くできます。
ビジネスエラー（残額不足など）をtry/exceptで理解する必要がなくなり、
単にControllerを呼んで、最後に`ViewModel.display_text`を表示するだけで成立します。

```python
# vending_machine/interface_adapters/view_console.py

class ConsoleView:
    def __init__(self, controller, view_model):
        self._controller = controller
        self._view_model = view_model

    def run_once(self) -> None:
        """
        1回分の入力→処理→表示を行う例。
        """
        action = input("操作を入力してください (i=コイン投入 / s=商品購入 / q=終了): ").strip().lower()

        if action == "i":
            amount_str = input("投入する金額: ")
            try:
                amount = int(amount_str)
                self._controller.insert_coin(amount)
            except ValueError:
                # ここはUIレベルのエラー（数字じゃない等）
                self._view_model.display_text = "エラー: 金額は数値で入力してください。"

        elif action == "s":
            slot_id = input("購入したいスロットID (例: A1): ").strip().upper()
            self._controller.select_item(slot_id)

        elif action == "q":
            print("ありがとうございました。")
            return

        # Presenterが整形した結果を表示する
        print(self._view_model.display_text)
```

ここでの大事な点は、Viewが「ビジネス判断の例外」を抱え込まないことです。
（売り切れ・不足金額などはPresenter側で文字列になっているため、ただ表示するだけでいい）

---

### 🎁 この改善の効果

* ビジネスエラー処理の一元化
  → 例外→Presenter→ViewModel という一定ルートになる

* テスト容易性
  → Presenter単体テストで、成功パターン / 失敗パターンのメッセージを検証できる

* UI差し替え耐性
  → CLIからWebに変わっても、Presenterの文言生成を流用できる

---

## 3. 🤖 HardwareAdapterのインターフェースを拡張する

### 🐞 改善前の課題（におい）

現状の `HardwareInterface` は、例えば `dispense_item(slot_id: str)` のように「スロットID」だけを渡す場合があります。この形でも動作はしますが、運用・ログ・診断を考えると、少し情報が物足りないことがあります。

たとえば本番環境ではこういう要求が出ます。

* どの商品（名前・価格）を実際に出したのかログに残したい
* 機器異常発生時に「どの操作が原因だったか」を復元したい
* 将来価格改定したとき、ハード側にも表示ログを残しておきたい

### ✅ 目指す形

`HardwareInterface` のメソッドを、もう少しリッチな引数にするという方向性があります。

たとえば、`dispense_item(item)` のように `Item` 全体（`name`, `price`, `slot_id`, など）を渡す形にします。

```python
# vending_machine/interface_adapters/hardware_adapter.py

from vending_machine.usecase.boundaries import HardwareInterface

class ConsoleHardwareAdapter(HardwareInterface):
    def dispense_item(self, item) -> None:
        # 本来はモーター制御など
        print(f"（ガコン！『{item.name}』({item.price}円) を排出しました）")

    def return_change(self, amount: int) -> None:
        # 本来はコインメカ制御など
        print(f"（チャリン！お釣り {amount} 円を返却しました）")
```

この変更は副作用が大きい（UseCase側の呼び出しも変わる）ため、現時点ではオプション扱いとします。ただし、実際の現場ではこうした情報量の増強はよく行われます。

→ ハードウェアログ、会計ログ、不正検知（不正排出や取り忘れ検知）などの機能が将来的に乗せやすくなるからです。

---

## 🧾 まとめと位置づけ

ここまでのリファクタリング提案を整理します。

| 改善内容                               | 効果                                                          |
| ---------------------------------- | ----------------------------------------------------------- |
| 💳 PaymentManagerをリポジトリ化           | UIから支払い状態を切り離し、UseCaseが状態管理の司令塔となる。スケールとテストがしやすくなる。         |
| 🚦 成功/失敗ルートをPresenterで分離           | ビジネスエラーメッセージがUIに漏れず、Presenterが一元的に整形。UIをより「薄く」「差し替えやすく」できる。 |
| 🤖 HardwareInterfaceの引数をリッチにする（任意） | 実機ログ・診断・監視などの現実的な要求に耐えやすい。将来の拡張を見据えたインターフェース設計になる。          |

---

## 🛡 最後に

このリファクタリングは「正しさを直す」ものではありません。
あなたが今持っている実装は、すでにクリーンアーキテクチャの要件を満たしています。

この章でやっているのは、次のステップです。

> ビジネスロジックをもっと中心に寄せる。
> UIやハードの詳細は、さらに外に押し出す。
> 状態とメッセージの責務を、より明確にする。

つまり、システムの将来に対して「交換しやすく」「壊れにくい」「テストしやすい」という性質を強めるための設計上の洗練です。

この観点は、現実の長期運用プロダクト（自販機に限らず、業務システムや組み込み機器、クラウドサービスでも同様）で非常に重要になります。


