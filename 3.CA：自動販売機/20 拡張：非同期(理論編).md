# 20 拡張：非同期(理論編)

# ⚡️ 非同期プログラミングへの招待 (理論編)

第三巡の最終章として、私たちはアプリケーションの動作方法そのものを変更する、高度なリファクタリングに挑戦します。それは、**同期処理から非同期処理への移行**です。

この変更は、UI（見た目）やDB（保存場所）が「詳細」であったように、プログラムの**実行方法**もまた、ビジネスルールからは分離されるべき「詳細」に過ぎないことを証明します。

この章では、まず非同期プログラミングの基本を学び、なぜ自動販売機がその学習に最適なのかを理解します。

## 🎯 非同期プログラミングとは？

一言で言えば、「**待ち時間（I/O）を有効活用して、処理を効率化する仕組み**」です。

料理に例えてみましょう。

- **同期的なシェフ 👨‍🍳 (これまでのプログラム)**
    1. トースターにパンを入れる。
    2. パンが焼けるまで、**じっとトースターの前で待つ。**
    3. パンが焼けたら、取り出してコーヒーを淹れ始める。
- **非同期的なシェフ 👨‍🍳 (これからのプログラム)**
    1. トースターにパンを入れる。
    2. パンが焼けている**待ち時間**に、コーヒーを淹れ始める。
    3. コーヒーの準備をしている間にパンが焼けたら、知らせ（イベント）が来るので取り出す。

明らかに、後者のシェフの方が効率的です。プログラムの世界では、「パンが焼けるのを待つ」時間は、**I/O（入出力）待ち**と呼ばれます。具体的には、データベースからの応答待ち、ネットワーク通信、そして**ハードウェアの動作待ち**などがこれにあたります。

非同期プログラミングは、このようなI/O待ちの時間にCPUを遊ばせておくのではなく、他の作業を進めることで、アプリケーション全体のパフォーマンスと応答性を向上させる技術です。

## 🤖 なぜ自動販売機が非同期化の学習に最適なのか？

この題材は、非同期処理を導入するための、非常に現実的で分かりやすいシナリオを提供してくれます。

- **ハードウェアの動作がI/O待ちそのものである**
「コイン識別機が硬貨を検証する時間」「商品排出モーターが動く時間」は、まさに非同期処理が輝く「待ち時間」です。これを`asyncio.sleep()`でシミュレートすることで、非同期化のメリットを現実感をもって学べます。
- **同期処理との対比が明確になる**
ここが最も重要な学びです。
    - **非同期にすべき処理**: ハードウェアを待つ、ネットワークを待つ、といった**I/Oバウンド**な処理。
    - **同期のままであるべき処理**: `PaymentManager`がお釣りを計算する、`Item`が在庫数をチェックするといった**CPUバウンド**な処理。
    
    お釣りの計算は、何かを待つ必要がなく、瞬時に終わるべき計算です。これを`async`にする意味はなく、コードを不必要に複雑にします。この\*\*「何を非同期にし、何はしないのか」\*\*を見極める良い訓練になります。
    

## 🐍 Pythonでの非同期プログラムの作り方

Pythonでは`asyncio`ライブラリを使い、いくつかの「合言葉」を覚えて非同期プログラムを記述します。

- `async def`
このキーワードを関数の前につけると、その関数は「**コルーチン関数**」という特別な関数になります。「この関数は処理の途中で中断し、再開することができますよ」という印です。
- `await`
コルーチン関数の中で、時間のかかる処理（I/O待ちなど）を呼び出す際に使います。「**ここで処理を中断して、他の作業を進めてください。この処理が終わったら、ここから再開します**」という意味です。`await`は`async def`の中でしか使えません。
- `asyncio.run()`
非同期の世界を開始し、一番最初のコルーチン関数を実行するための命令です。
- `asyncio.sleep(秒数)`
非同期版の`time.sleep()`です。`await asyncio.sleep(1)`と書くと、「1秒間処理を中断し、その間CPUを他の作業のために解放する」という意味になります。ハードウェアの待ち時間をシミュレートするのに最適です。

### 簡単なコード例

```python
import asyncio
import time

async def say_after(delay, what):
    print(f"[{time.time():.1f}s] {what} の準備開始")
    await asyncio.sleep(delay) # ここで処理を中断し、他のタスクにCPUを譲る
    print(f"[{time.time():.1f}s] {what} ができました！")

async def main():
    print(f"[{time.time():.1f}s] シェフが料理を始めます")

    # asyncio.gatherを使うと、複数の非同期処理を「同時並行」で実行できる
    await asyncio.gather(
        say_after(2, "トースト"), # 2秒かかる処理
        say_after(1, "コーヒー")  # 1秒かかる処理
    )

    print(f"[{time.time():.1f}s] すべての料理が完成しました")

# 非同期プログラムの実行
asyncio.run(main())

# --- 実行結果 ---
# [1729458000.0s] シェフが料理を始めます
# [1729458000.0s] トースト の準備開始
# [1729458000.0s] コーヒー の準備開始
# [1729458001.0s] コーヒー ができました！
# [1729458002.0s] トースト ができました！
# [1729458002.0s] すべての料理が完成しました
# (全体で約2秒で終わっている点に注目！)

```

---

理論の準備は整いました。次の章では、この知識を使って、実際に自動販売機アプリケーションを同期から非同期へとリファクタリングしていきます。