# 10 リファクタリング

# 🔧 発展編：アダプター層のさらなる洗練

おめでとうございます！
あなたはここまでで、自動販売機アプリケーションを**クリーンアーキテクチャの原則に従って完全に構築**しました。
依存方向、責務分離、疎結合のすべてを満たしています。
このままでも、十分に「クリーンアーキテクチャの完成形」と呼べる状態です。

しかし、優れた設計者は常に問い続けます。

> 「もっと良くできないだろうか？」

この章では、一度完成した`Adapters`層を**より厳密に分離し、現実的な大規模アプリにも耐える構造に高める**ための発展的リファクタリングを紹介します。

この章の目的は以下のとおりです👇

* 動くコードと、長く保守できるコードの違いを理解する
* 「コードの匂い（Code Smell）」を見抜き、アーキテクチャ原則に沿って解消する
* クリーンアーキテクチャの「実務への落とし込み」を体感する

![クリーンアーキテクチャ](../クリーンアーキテクチャ.png)

---

## 🎯 この章の前提と位置づけ

まず強調しておきましょう：

> **これまでのコードはすでにクリーンアーキテクチャを満たしています。**

この章の変更は「正しさを補う」ものではなく、「分離をより徹底して、テストしやすくする」ための**改善案（Optional）**です。
「プロダクション現場でより拡張性を高めたい人向けの発展編」として読んでください。

---

## ✅ 改善案A：PaymentManagerをリポジトリ化して、UIから状態管理を追い出す

### 🔍 匂いを見つける

現在の実装では、`ConsoleView`が`PaymentManager`というEntityを直接生成・保持しています。
これは少しだけ「Viewがビジネス状態を持っている」状態です。

たとえば将来、Web版UIや複数セッション対応のアプリにしたい場合、
UIが状態を持つ設計はスケールしにくくなります。
これが最初の「匂い（Smell）」です。

### 💡 改善の方向性

`Item`のように、`PaymentManager`も**リポジトリパターンで扱う**ようにします。
つまり：

* `UseCase`が`PaymentManager`の取得・保存をリポジトリに依頼する
* `View`や`Controller`は、`PaymentManager`の存在を知らなくてよくなる

これで、UIは純粋に「入力と表示」に専念できます。

---

### 🧩 改善後コード例

#### 1️⃣ 境界（Boundary）の追加

`usecase/boundaries.py` に `PaymentManagerAccessInterface` を追加します。

```python
# vending_machine/usecase/boundaries.py
from abc import ABC, abstractmethod
from vending_machine.domain.entities import PaymentManager

class PaymentManagerAccessInterface(ABC):
    """PaymentManagerを取得・保存するためのリポジトリ契約"""
    @abstractmethod
    def get(self) -> PaymentManager:
        raise NotImplementedError

    @abstractmethod
    def save(self, payment_manager: PaymentManager):
        raise NotImplementedError
```

---

#### 2️⃣ DataAccessの実装追加

`interface_adapters/data_access.py` に `InMemoryPaymentManagerAccess` を追加します。

```python
# vending_machine/interface_adapters/data_access.py
from vending_machine.usecase.boundaries import PaymentManagerAccessInterface
from vending_machine.domain.entities import PaymentManager

class InMemoryPaymentManagerAccess(PaymentManagerAccessInterface):
    """
    PaymentManagerのインメモリ実装。
    自販機全体で1つだけ存在する“投入金額の状態”を保持する。
    """
    _instance: PaymentManager = PaymentManager()

    def get(self) -> PaymentManager:
        """現在の状態を取得"""
        return self._instance

    def save(self, payment_manager: PaymentManager):
        """状態を更新"""
        self._instance = payment_manager
```

---

#### 3️⃣ UseCaseの変更

`PaymentManager`を引数で受け取らず、
`UseCase`内でリポジトリ経由で取得・保存するように変更します。

```python
# vending_machine/usecase/select_item_usecase.py
class SelectItemUseCase:
    def __init__(self, presenter, item_repository, hardware, pm_repository):
        self._presenter = presenter
        self._item_repository = item_repository
        self._hardware = hardware
        self._pm_repository = pm_repository

    def handle(self, input_data):
        """PaymentManagerをリポジトリ経由で取得する"""
        payment_manager = self._pm_repository.get()

        item = self._item_repository.find_by_slot_id(input_data.slot_id)
        if not item:
            raise ValueError("指定されたスロットに商品はありません。")

        change = payment_manager.process_purchase(item)
        self._hardware.dispense_item(item)
        if change > 0:
            self._hardware.return_change(change)

        item.dispense()
        self._item_repository.save(item)
        self._pm_repository.save(payment_manager)
```

---

#### 4️⃣ ControllerとViewの簡略化

`PaymentManager`を知らなくてよくなったため、引数がすっきりします。

```python
# vending_machine/interface_adapters/controller.py
class VendingMachineController:
    def select_item(self, slot_id: str):
        """PaymentManagerの引数が不要に！"""
        input_data = SelectItemInputData(slot_id=slot_id)
        self._select_item_use_case.handle(input_data)
```

```python
# vending_machine/interface_adapters/view_console.py
class ConsoleView:
    def run(self):
        # PaymentManagerを保持しない。純粋なUIに。
        while True:
            action = input("> ").strip().lower()
            if action == "s":
                slot_id = input("スロットIDを入力: ")
                self._controller.select_item(slot_id)
```

---

#### ✨ この改善の効果

* **UIからビジネス状態を完全に分離できる**
  Viewが愚直（Dumb）になり、本来の責務に専念できる
* **UseCaseが状態管理を一元化できる**
  複数UI・複数操作でも、一貫した支払い状態を扱える
* **テスト容易性がさらに上がる**
  UseCase単体で「PaymentManagerの動作」を検証できる

---

## ✅ 改善案B：成功／失敗ルートの分離（エラーハンドリングの洗練）

### 🔍 匂いを見つける

現状のコードでは、`View`が例外を`try-except`で捕まえて、
「エラー: 不正な入力です」とメッセージを組み立てています。

これだと、UIがビジネスエラー（「お金が足りません」「在庫がありません」など）を知ってしまうことになります。
結合度が上がり、`UseCase`の内部仕様が外部に漏れてしまう「匂い」です。

---

### 💡 改善の方向性

`Presenter`に「成功」「失敗」それぞれの出力ルートを用意し、
`UseCase`が明示的に呼び分けるようにします。

`View`は例外を知らず、ただ `ViewModel.display_text` を表示するだけの構造にします。

---

### 🧩 改善後コード例

#### 1️⃣ 境界（Boundary）の更新

```python
# vending_machine/usecase/boundaries.py
from abc import ABC, abstractmethod

class SelectItemOutputBoundary(ABC):
    @abstractmethod
    def present_success(self, output_data): ...
    @abstractmethod
    def present_failure(self, error_message: str): ...
```

---

#### 2️⃣ UseCaseの更新

```python
# vending_machine/usecase/select_item_usecase.py
class SelectItemUseCase:
    def handle(self, input_data):
        try:
            item = self._item_repository.find_by_slot_id(input_data.slot_id)
            if not item:
                raise ValueError("指定されたスロットに商品はありません。")

            payment_manager = self._pm_repository.get()
            change = payment_manager.process_purchase(item)

            self._hardware.dispense_item(item)
            if change > 0:
                self._hardware.return_change(change)

            item.dispense()
            self._item_repository.save(item)
            self._pm_repository.save(payment_manager)

            # 成功時
            output_data = SelectItemOutputData(item_name=item.name, change=change)
            self._presenter.present_success(output_data)

        except ValueError as e:
            # ビジネスエラーをPresenterに渡す
            self._presenter.present_failure(str(e))
```

---

#### 3️⃣ Presenterの改善

```python
# vending_machine/interface_adapters/presenter.py
class VendingMachinePresenter(SelectItemOutputBoundary):
    def present_success(self, output_data):
        message = f"「{output_data.item_name}」が出てきました。"
        if output_data.change > 0:
            message += f" お釣りは{output_data.change}円です。"
        self._view_model.display_text = message

    def present_failure(self, error_message: str):
        self._view_model.display_text = f"エラー: {error_message}"
```

---

#### 4️⃣ Viewの単純化

```python
# vending_machine/interface_adapters/view_console.py
class ConsoleView:
    def run(self):
        try:
            # ... 入力処理 ...
            self._controller.select_item(slot_id)
        except ValueError:
            self._view_model.display_text = "エラー: 入力が不正です。"
        # ★ UseCaseからのビジネスエラーはPresenterが処理するため、ここでは触らない
        self.render()
```

---

#### ✨ この改善の効果

* UIは「入力エラー」と「ビジネスエラー」を明確に分離できる
* UseCaseの中でビジネス失敗を完結して処理できる
* Presenterの責務（出力整形）がより強固に定義される

---

## ✅ 改善案C：HardwareAdapterをよりリッチにする

### 🔍 匂いを見つける

現状では、ハードウェア制御のメソッドが `dispense_item(slot_id: str)` です。
これでは、スロットIDしかわからず、「何の商品を出したのか」までは分かりません。

### 💡 改善の方向性

`dispense_item(item: Item)` に変更することで、ハードウェア側でも商品情報を使った表現が可能になります。

---

### 🧩 改善後コード例

```python
# vending_machine/interface_adapters/hardware_adapter.py
class ConsoleHardwareAdapter:
    def dispense_item(self, item):
        print(f"ガコンッ！『{item.name}』({item.price}円) を排出しました。")

    def return_change(self, amount):
        print(f"チャリン… お釣り {amount} 円を返却しました。")
```

> ⚠️ 注意
> これは `HardwareInterface` の契約（メソッドシグネチャ）を変更するリファクタリングです。
> すべての実装とUseCaseが影響を受けるため、変更範囲は広くなります。
> 実務では、こうした「契約変更」は十分にテストが整ってから行うのが基本です。

---

#### ✨ この改善の効果

* 表示がリッチになり、UIとしてのリアリティが増す
* 将来、ログ出力やハード制御信号の設計に拡張しやすくなる
* UseCaseは依然として「HardwareInterface」に依存するだけなので、依存方向は変わらない

---

## 🧭 まとめ：リファクタリング後の世界

| 改善案                      | 主な効果                             |
| ------------------------ | -------------------------------- |
| A. PaymentManagerのリポジトリ化 | Viewからビジネス状態を完全に分離               |
| B. 成功/失敗ルート分離            | エラーハンドリングをPresenterに集約し、UIをより愚直に |
| C. HardwareAdapterの強化    | インターフェースの表現力を向上（プロダクション設計への第一歩）  |

---

## 🧠 最後に — クリーンアーキテクチャは「終わらない設計」

あなたがいま持っているコードは、すでにクリーンアーキテクチャの原則を満たしています。
リファクタリングは「次のレベル」への入り口です。

> 動かす → 分ける → 任せる → 美しくする

設計とは、機能を分け、依存を整理し、責務を明確にする“終わりなき学び”です。
ここまで来たあなたは、もう「クリーンアーキテクチャを理解している側」の人です。


