# 10 リファクタリング

# 🔧 リファクタリング：アダプター層のさらなる洗練

おめでとうございます！あなたは自動販売機アプリケーションを構成する全ての部品を、クリーンアーキテクチャの原則に従って作り上げました。アプリケーションは、このままでも完全に機能します。

しかし、優れた設計者は常に問い続けます。「もっと良くできないだろうか？」と。

この章では、一度完成した`Adapters`層のコードを見直し、**「関心の分離」の原則をより厳密に適用する**ことで、さらに堅牢で、テストしやすく、美しい設計へと昇華させるリファクタリングのプロセスを体験します。

## 🎯 この章の目的

- 「動くコード」と「良い設計のコード」の違いを理解する。
- 「コードの匂い（Code Smell）」を特定し、クリーンアーキテクチャの原則に基づいてそれを解消するスキルを身につける。
- リファクタリングによって、各コンポーネントの責務がいかに明確になり、テストがさらに容易になるかを体感する。

![クリーンアーキテクチャ](../クリーンアーキテクチャ.png)

## ✅ 改善点1：`View`から状態管理を分離する (`PaymentManager`のリポジトリ化)

### 嗅ぎつけるべき「匂い」

現在の実装では、`ConsoleView`が`PaymentManager`という状態を持つ`Entity`のインスタンスを生成・管理しています。これは、「`View`は愚直であるべき」という原則に少し反しており、「UIがビジネスの状態を知りすぎている」という「匂い」がします。

### 解決策：リポジトリパターンの適用

`Item`と同様に、`PaymentManager`もリポジトリを通じて`UseCase`が管理するように変更します。これにより、`View`は状態管理の責務から完全に解放されます。

### 💻 具体的なコード変更

**1. 境界（Boundary）の追加**

```python
# application/boundaries.py
class PaymentManagerAccessInterface(ABC):
    @abstractmethod
    def get(self) -> PaymentManager:
        raise NotImplementedError
    @abstractmethod
    def save(self, payment_manager: PaymentManager):
        raise NotImplementedError

```

**2. DataAccessの実装追加**
(※これは`DataAccess`の章で先に追加したものです)

```python
# adapters/data_access.py
class InMemoryPaymentManagerAccess(PaymentManagerAccessInterface):
    _instance: PaymentManager = PaymentManager()
    def get(self) -> PaymentManager: return self._instance
    def save(self, payment_manager: PaymentManager): self._instance = payment_manager

```

**3. UseCaseの修正**`UseCase`が`PaymentManager`をリポジトリ経由で取得・保存するようにします。

```python
# application/use_cases/select_item.py
class SelectItemUseCase:
    # __init__でPaymentManagerRepositoryを受け取る
    def __init__(self, ..., pm_repository: PaymentManagerAccessInterface):
        # ...
        self._pm_repository = pm_repository

    # handleメソッドからpayment_manager引数を削除
    def handle(self, input_data: SelectItemInputData):
        # UseCase自身がリポジトリ経由でPaymentManagerを取得・保存する
        payment_manager = self._pm_repository.get()
        item = self._item_repository.find_by_slot_id(input_data.slot_id)
        # ...
        change = payment_manager.process_purchase(item)
        # ...
        self._pm_repository.save(payment_manager)
        # ...

```

**4. ControllerとViewの単純化**`Controller`と`View`は`PaymentManager`の存在を知る必要がなくなります。

```python
# adapters/controller.py
class VendingMachineController:
    # select_itemメソッドからpayment_manager引数を削除
    def select_item(self, slot_id: str):
        input_data = SelectItemInputData(slot_id=slot_id)
        self._select_item_use_case.handle(input_data)

# adapters/view.py
class ConsoleView:
    def run(self):
        # ★★★ PaymentManagerのインスタンス管理がViewから消える！ ★★★
        while True:
            # ...
            if action == 's':
                slot_id = input("購入する商品のスロットID: ")
                # Controllerを呼び出すだけ
                self._controller.select_item(slot_id)
            # ...

```

### ✨ リファクタリングによるメリット

この変更により、`View`はUIの入出力という本来の責務に専念できるようになり、アーキテクチャ全体の見通しがさらによくなりました。

## ✅ 改善点2：エラーハンドリングの洗練

### 嗅ぎつけるべき「匂い」

現在の`View`は、`UseCase`から送出される`ValueError`を`try-except`で捕捉しています。これは、UIがビジネスエラーの詳細を知ってしまっている状態であり、結合度を高める原因となります。

### 解決策：成功/失敗ルートの分離

第二巡と同様に、`Presenter`にエラー専用のメソッドを用意し、`UseCase`がビジネスエラーを内部で処理して`Presenter`に通知するようにします。

### 💻 具体的なコード変更

**1. 境界（Boundary）の更新**

```python
# application/boundaries.py
class SelectItemOutputBoundary(ABC):
    @abstractmethod
    def present_success(self, output_data: SelectItemOutputData): pass
    @abstractmethod
    def present_failure(self, error_message: str): pass

```

**2. UseCaseの更新**

```python
# application/use_cases/select_item.py
class SelectItemUseCase:
    def handle(self, input_data: SelectItemInputData):
        try:
            # ... 従来のロジック ...
            self._presenter.present_success(output_data)
        except ValueError as e:
            # ★例外を捕捉し、失敗ルートでPresenterを呼ぶ
            self._presenter.present_failure(str(e))

```

**3. Presenterの更新**

```python
# adapters/presenter.py
class VendingMachinePresenter(SelectItemOutputBoundary):
    # ...
    def present_success(self, output_data: SelectItemOutputData):
        # ... 成功メッセージを組み立てる ...
        self._view_model.display_text = message

    def present_failure(self, error_message: str):
        # ★失敗メッセージを組み立てる
        self._view_model.display_text = f"エラー: {error_message}"

```

**4. Viewの単純化**`View`はビジネスエラーを気にする必要がなくなり、純粋な入力エラー（`int`への変換失敗など）だけを気にすればよくなります。

```python
# adapters/view.py
class ConsoleView:
    def run(self):
        # ...
        try:
            # ... Controllerを呼び出す ...
        except ValueError: # このexceptは、'int(coin_str)'のようなUI起因のエラーのみを捕捉
            self._view_model.display_text = "エラー: 不正な入力です。"
        # ...

```

### ✨ リファクタリングによるメリット

`View`が`UseCase`の内部実装（どんな例外を投げるか）を知る必要がなくなり、より疎結合で堅牢なシステムになりました。

## ✅ 改善点3：`Hardware Adapter`をよりリッチにする

これは小さな改善ですが、アダプターの役割をより明確にします。

- **変更前**: `dispense_item(slot_id: str)`
- **変更後**: `dispense_item(item: Item)`

`UseCase`は`Item`オブジェクト全体を知っているので、それをそのまま渡します。これにより、`ConsoleHardwareAdapter`は「（ガコンッ！『お茶』を排出しました）」のように、よりリッチなシミュレーションが可能になります。

## 🛡️ まとめ：リファクタリング後の世界

これらのリファクタリングを通じて、私たちは以下の原則をより深くコードに反映させました。

- **単一責任の原則**: `View`はUIのことに、`UseCase`はビジネスのことに、それぞれがより集中できるようになりました。
- **依存性反転の原則**: `View`が`Entity`に直接依存する箇所がなくなり、依存関係がよりクリーンになりました。

動くコードを書くことは第一歩です。しかし、そのコードを原則に照らし合わせて見直し、より良い設計へと改善し続けることこそが、クリーンアーキテクチャを実践する上で最も重要なスキルなのです。