# 21 拡張：非同期(実践編)

# ⚡️ 非同期プログラミングへのリファクタリング (実践編)

理論編で学んだ`async`/`await`の知識を使い、いよいよ自動販売機アプリケーションを同期から非同期へとリファクタリングしていきます。

この作業を通じて、「ビジネスの核心」と「それをどう実行するかという技術的な仕組み」とを分離する、クリーンアーキテクチャの真髄を体感しましょう。

## 🎯 カリキュラムへの組み込み方：具体的な変更ステップ

UIやDBを差し替えた時と同じように、変更は外側から行われ、中心に近づくほど変更点が少なくなります。

![クリーンアーキテクチャ](../クリーンアーキテクチャ.png)

---

### ステップ1：変わらないもの（ビジネスの核心）を確認する

まず最も重要なことは、このリファクタリングにおいて、**`domain/entities.py`のコードは一行も変更されない**という事実です。

お釣りの計算方法(`PaymentManager`)や在庫のチェック方法(`Item`)は、何かを「待つ」必要のない、純粋な計算処理（CPUバウンド）です。プログラムの実行方法が同期だろうが非同期だろうが、これらのビジネスルールが変わることはありません。

これが、ビジネスの核心をインフラストラクチャの変更から守る、クリーンアーキテクチャの力です。

---

### ステップ2：境界（Interface）を非同期化する

I/O待ちが発生する可能性があるのはハードウェアとの通信です。そこで、`HardwareInterface`のメソッドを`async def`で定義し直し、これが非同期の処理であることを示す新しい「契約書」とします。

```python
# application/boundaries.py

class HardwareInterface(ABC):
    @abstractmethod
    async def dispense_item(self, item: Item): # async def に変更
        """指定されたスロットの商品を物理的に排出する"""
        raise NotImplementedError

    @abstractmethod
    async def return_change(self, amount: int): # async def に変更
        """指定された金額のお釣りを物理的に排出する"""
        raise NotImplementedError

```

---

### ステップ3：`UseCase`を適応させる

`UseCase`は、非同期化された`HardwareInterface`を呼び出す（`await`する）必要があるため、自身も`async def`に適応します。

重要なのは、`UseCase`のビジネスロジック自体が非同期になったわけではなく、**非同期の部品を呼び出すために構文を合わせているだけ**、という点です。

```python
# application/use_cases/select_item.py

class SelectItemUseCase(SelectItemInputBoundary):
    # __init__ は変更なし

    # handleメソッドを async def に変更
    async def handle(self, input_data: SelectItemInputData):
        # ... リポジトリからEntityを取得する処理は同期のまま ...

        # ... Entityを使ったビジネスルールのチェックも同期のまま ...
        change = payment_manager.process_purchase(item)

        # ★非同期のハードウェア操作を待つ (await)
        await self._hardware.dispense_item(item)
        if change > 0:
            await self._hardware.return_change(change)

        # ... 在庫更新や永続化、Presenter呼び出しは同期のまま ...

```

---

### ステップ4：`Adapters`層を非同期化する

`UseCase`を呼び出す`Controller`から一番外側の`View`まで、外側に向かってすべてを非同期化していきます。

### `ConsoleHardwareAdapter`の変更

`async def`に適応し、`await asyncio.sleep()`でI/O待ちをシミュレートします。

```python
# adapters/hardware.py
import asyncio

class ConsoleHardwareAdapter(HardwareInterface):
    # 各メソッドを async def に変更
    async def dispense_item(self, item: Item):
        print("（商品を排出しています...）")
        await asyncio.sleep(1) # モーターが動く時間を1秒と仮定
        print(f"（ガコンッ！『{item.name}』を排出しました）")

    async def return_change(self, amount: int):
        print("（お釣りを計算しています...）")
        await asyncio.sleep(0.5) # 計算と排出準備に0.5秒と仮定
        print(f"（チャリン！お釣り {amount} 円を返却しました）")

```

### `Controller`と`View`の変更

`Controller`は`UseCase`を、`View`は`Controller`を、それぞれ`await`で呼び出すように変更します。

```python
# adapters/controller.py

class VendingMachineController:
    # __init__ は変更なし

    # 各メソッドを async def に変更
    async def select_item(self, slot_id: str):
        # ...
        # UseCaseの呼び出しを await にする
        await self._select_item_use_case.handle(input_data)
    # ... 他のメソッドも同様に async def と await を追加 ...

```

```python
# adapters/view.py

class ConsoleView:
    # __init__ は変更なし

    # runメソッドを async def に変更
    async def run(self):
        while True:
            # ...
            if action == 'c':
                # ...
                # Controllerの呼び出しを await にする
                await self._controller.insert_coin(int(coin_str))
            # ... 他の呼び出しも同様に await を追加 ...

```

---

### ステップ5：起動方法（main）を変更する

アプリケーションの起動方法が、`asyncio.run()`を使ったものに変わります。

```python
# main.py
import asyncio

# ... 各クラスのimport ...

# main関数を async def に変更
async def main():
    # 部品の組み立ては全く同じ
    container = AppContainer()
    view = container.view()

    # Viewの非同期メソッドを await で実行
    await view.run()

if __name__ == "__main__":
    # 非同期アプリケーションとして実行
    asyncio.run(main())

```

これで、リファクタリングは完了です。

---

## 🐛 非同期プログラムのデバッグの仕方

非同期プログラムは処理の実行順序が一直線ではないため、デバッグが少し難しく感じることがあります。しかし、基本は同期プログラムと同じです。

- **`print`デバッグは健在**: 最もシンプルで強力な方法です。「どの処理がいつ実行されたか」を知るために、`print`文を要所に入れるのは非常に有効です。
- **ログを活用する**: `print`の代わりに`logging`モジュールを使えば、タイムスタンプやタスクIDといった、より豊富な情報を記録できます。
- **デバッガを使う**: `pdb`や、VSCodeなどのIDEに統合された最新のデバッガは、`async`/`await`構文をサポートしています。ブレークポイントを置いて、変数の状態をステップごとに確認できます。
- **タスクの可視化**: `asyncio`にはデバッグモードがあり、実行中のタスク一覧や、完了までに時間がかかりすぎているコルーチンなどを警告してくれます。

---

## 🛡️ まとめ：分離された「実行方法」

このリファクタリングを通じて、私たちは以下の重要な事実を証明しました。

> 実行方法は詳細である。 (The execution model is a detail.)
> 

アプリケーションが同期的か非同期か、という根本的な動作方法の変更ですら、ビジネスの核心である`Entity`には一切影響を与えませんでした。

これは、クリーンアーキテクチャが「ビジネスルール」**と**「デリバリーメカニズム（UI、DB、実行方法などの技術的詳細）」をいかに綺麗に分離できるかを示す、究極のデモンストレーションです。この原則を体得すれば、将来どんな技術が登場しても、その変化に柔軟に対応できる真に堅牢なソフトウェアを設計できるようになるでしょう。