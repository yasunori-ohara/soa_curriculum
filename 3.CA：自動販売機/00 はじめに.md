# 00 はじめに

# 🥤 第三巡：自動販売機で“本質だけ”のクリーンアーキテクチャを構築する

これまで私たちは以下の2つの題材を通じて、クリーンアーキテクチャの理論と実践を段階的に学んできました。

* ✅ **第1巡（ToDoアプリ）**
  クリーンアーキテクチャの「層構造」と「依存方向」の基本原則を体感しました。

* ✅ **第2巡（図書館システム）**
  現実的なWebアプリケーション規模でも、同じ設計思想が通用することを確認しました。

そして本章（第三巡）では、これまでとは異なる領域である **ハードウェア制御を伴う「自動販売機」** を題材とします。
目的は、クリーンアーキテクチャがWebや業務アプリケーションに限らず、**あらゆるドメインで通用する普遍的な設計原則である**ことを実感することです。

---

## 🧭 第三巡の目的と設計方針

本章の目的は、**アーキテクチャの“原則そのもの”を明確に体得すること**にあります。
そのため、以下の二つの方針に基づいて設計を進めます。

1. **構造の簡略化**

   * 第2巡では、現実的な大規模システム構成（`core / interface_adapters / infrastructure`）を採用しました。
     本巡では、学習効果を高めるためにフォルダ構成を最小限に整理し、各層の関係性をより直接的に理解できるようにします。

2. **依存方向の一方向性を維持**

   * フォルダ階層を削減しても、依存方向（内側 → 外側）は不変です。
     クリーンアーキテクチャの本質は階層の多寡ではなく、**依存の流れと抽象による分離**にあります。

---

## 🗂 フォルダ構成（第三巡）

```text
vending_machine/
├─ domain/
│   ├─ entities.py             # 🍾 Item, 💰 PaymentManager など（ビジネスルールの中心）
│   └─ errors.py               # ドメイン固有の例外
│
├─ usecase/
│   ├─ dto.py                  # 📦 入出力データ構造（InputData / OutputData / ViewModel）
│   ├─ boundaries.py           # 🔌 UseCaseが外部に要求する契約（インターフェース定義）
│   ├─ select_item_usecase.py  # 🛒 商品購入ユースケース
│   └─ insert_coin_usecase.py  # 🪙 コイン投入ユースケース
│
├─ interface_adapters/
│   ├─ controller.py           # 🎛 入力を受付け、UseCaseを呼び出す
│   ├─ presenter.py            # 🎨 結果をViewModelへ整形する
│   ├─ view_console.py         # 📺 コンソール表示（CLI）
│   ├─ data_access.py          # 💾 在庫データアクセス（InMemoryリポジトリ実装）
│   └─ hardware_adapter.py     # 🤖 ハードウェア制御（排出・返却動作を模擬）
│
└─ main.py                     # 🧠 依存注入（Composition Root）
```

この構成では、

* **domain**：ビジネスルール
* **usecase**：アプリケーションロジック
* **interface_adapters**：外部世界との接続点
* **main.py**：依存関係の明示的な組み立て

という最小限の形で「内から外へ一方向の依存」を明確化します。

---

## 🧳 Repositoryが「domain」からなくなった理由

第1・第2巡では、以下の構成を採用していました。

* `domain/repository.py`：Repositoryのインターフェース定義（抽象）
* `infrastructure/repositories/...`：Repositoryの具象実装（InMemoryやPostgres等）

この構成は、ドメイン駆動設計（DDD）に基づく「リポジトリ＝集約の再構築窓口」という考え方に沿ったものです。
しかし、学習効果を重視して構造を簡略化する第三巡では、以下のように整理しています。

| 分類              | 新たな配置                               | 役割                                               |
| --------------- | ----------------------------------- | ------------------------------------------------ |
| 🔌 抽象（インターフェース） | `usecase/boundaries.py`             | UseCaseが外部に要求する契約（例：`ItemRepository`）            |
| 💾 具象（実装クラス）    | `interface_adapters/data_access.py` | Repository契約を実装するクラス（例：`InMemoryItemRepository`） |

### 意図

* `domain` 層はビジネスルールのみを保持し、**外部への依存を完全に排除**します。
* `usecase` 層は「外部に必要とする機能（契約）」を自ら宣言し、契約の中心として機能します。
* `interface_adapters` 層は、その契約を満たす実装を提供し、外界との接続を担います。

> ✅ つまり、Repositoryは削除されたのではなく、
> 抽象が `usecase` に、具象が `interface_adapters` に**分担移動**しました。
> 層間の依存方向（内→外）はこれまでと同じです。

---

## 🛠 infrastructureフォルダを廃止した理由

第2巡では、外部技術（DBやAPI、ハードウェア等）を扱うために `infrastructure/` を設けていました。
第3巡では、階層の理解コストを減らすため、このフォルダを廃止し、以下のように整理しています。

| ファイル                  | 従来の位置          | 現在の位置              | 理由                                          |
| --------------------- | -------------- | ------------------ | ------------------------------------------- |
| `data_access.py`      | infrastructure | interface_adapters | Repository契約の具象実装であり、UseCaseの外部詳細にあたるため     |
| `hardware_adapter.py` | infrastructure | interface_adapters | HardwareInterface契約の具象実装であり、外部装置の制御詳細にあたるため |

### 設計上の位置付け

* 両者とも、**UseCaseが要求する契約を実装する層（外側）**です。
* 教育目的では、UI関連（Controller, Presenter, View）と同列の「外部アダプタ」として統一的に扱う方が理解しやすく、構造を単純に保てます。
* 実務においては `infrastructure` 層を再分離しても構いませんが、学習段階では「外部の詳細を1か所に集約する」構成が有効です。

> ✅ 本巡では、**外部依存を伴う実装はすべて `interface_adapters/` に配置**し、
> 新たに仲介フォルダを設けることは行いません。

---

## 🧠 層構造の全体像（概要）

以降の章では各層を独立ページで解説しますが、ここでは全体像を簡潔に把握しておきます。

---

### 🧊 `domain/` 層 — ビジネスルールの中心

* 商品（`Item`）や金銭管理（`PaymentManager`）といった、業務上の不変ルールを保持します。
* 外部依存は一切なく、「在庫が0のときは販売不可」「価格は1円以上である」といった**純粋なビジネス制約**を定義します。

---

### 🧠 `usecase/` 層 — アプリケーションロジックの制御

* ビジネスルールを組み合わせて操作手順を実現する層です。
* 自身では外部を直接操作せず、**契約（インターフェース）を通して依頼**します。
* `boundaries.py` がその契約定義を集約します。

  * `ItemRepository`：在庫操作を依頼するための契約
  * `HardwareInterface`：物理動作を依頼するための契約
  * `SelectItemOutputBoundary`：結果出力を依頼する契約（Presenter）

---

### 🔌 `interface_adapters/` 層 — 外部世界との接続

* `usecase/boundaries.py` に定義された契約を実装し、現実世界の処理に変換します。
* 主な構成：

  * `controller.py`：ユーザー入力を受け取りUseCaseを呼び出す
  * `presenter.py`：結果を整形してViewへ渡す
  * `view_console.py`：入出力を処理（コンソールUI）
  * `data_access.py`：在庫リポジトリ（InMemory実装）
  * `hardware_adapter.py`：ハードウェア制御（排出・返却シミュレーション）

---

### 🧩 `main.py` — Composition Root（依存注入の実施）

* すべてのクラスを生成し、依存関係を明示的に接続する場所です。
* ビジネスロジックを記述せず、**「どの実装を使うか」を決定するのみ**が責務です。
* 層の依存方向（内→外）を実際のコードで示すことができます。

---

## 🛡 第三巡で貫く基本原則

> 1. 🧱 **Domain層は他の層に依存しない。**
>    純粋なビジネスルールのみを保持する。

> 2. 🧠 **UseCase層は“手順の司令塔”である。**
>    自ら処理せず、各役割に指示を分配する。

> 3. 🔌 **契約（インターフェース）は内側が定義し、外側が従う。**
>    `usecase/boundaries.py` が中心的役割を担う。

> 4. 🤖 **UI・ハードウェア・データストアはすべて「詳細（Detail）」である。**
>    差し替え可能であり、ビジネスロジックから独立している。

> 5. 🧪 **実機がなくてもロジックを検証できる構造を目指す。**
>    ハードウェアを抽象化し、ユニットテスト可能な環境を整える。

---

## 🚀 次のステップ

この後の章では、各層を順に取り上げて構造と責務を学習します。

1. `01 Entities` — ドメイン層（Item / PaymentManager）
2. `02 UseCase` — アプリケーション層（ユースケースの制御）
3. `03 Boundaries` — 契約定義（インターフェース）
4. `04 InterfaceAdapters` — 具象実装群（外部との接続）
5. `05 Main` — 依存注入と起動処理

---

> **最終目標**
> ハードウェアを含むあらゆる外部要素を「詳細」として扱い、
> ビジネスロジックを外的要因から完全に独立させた設計を構築すること。
