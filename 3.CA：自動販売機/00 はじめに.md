# 00 はじめに

# 🥤 はじめに：シンプルな自動販売機

TODOアプリ（基本）、図書館システム（Webアプリの典型）と進んできた私たちの旅は、いよいよ最終目的地に到着します。

Web系とは全く異なるドメインである「組み込み」**を題材にすることで、クリーンアーキテクチャが特定の分野のためだけのものではなく、真に普遍的な設計思想であることを証明しましょう。そのための最高の題材が、この**「シンプルな自動販売機」です。

## 🌟 なぜ第三巡に「自動販売機」なのか？

もし第一巡・第二巡が「家の建て方」を学ぶことだったとすれば、この第三巡は「学んだ建築原則を使って、家だけでなく橋や工場も建てられることを証明する」段階です。これにより、単なるパターンの暗記ではなく、あらゆる状況に応用できる本質的な設計スキルが身につきます。

- **「詳細」の概念を拡張する 🔌**
これが最大の学びです。Web系では「DBやWebフレームワークが詳細である」と学びましたが、自動販売機ではハードウェアそのものが「詳細」になります。「コイン投入口」「商品排出モーター」「選択ボタン」といった物理デバイスも、`MongoDB`や`Django`と同じ、交換可能な`Adapters`層の部品に過ぎないことを体感します。
- **ハードウェアからの独立性を証明する ⏳**
組み込み開発では、ハードウェアの完成を待たずにソフトウェア開発を進めたい、という要求が常にあります。クリーンアーキテクチャを使えば、物理デバイスの代わりに偽物（モック）を用意することで、`UseCase`や`Entity`のロジックを100%テストできます。これは「決定を遅らせる」ことの真の価値を証明します。

## 🎯 この題材が優れている理由

- **明確な状態とルール**:
自動販売機は「投入金額」「各商品の在庫」という明確な**状態**を持ちます。「投入金額が足りなければ商品は買えない」「在庫がなければ売り切れランプが点灯する」といった、実践的で分かりやすい**ビジネスルール**が豊富にあります。
- **多様なユースケース**:
「コインを入れる」「ボタンを押す」といったユーザー操作だけでなく、「在庫を補充する」といった管理者操作、「一定時間ごとに温度をチェックする」といったイベント駆動のシナリオも`UseCase`として綺麗にモデル化できます。
- **ハードウェアの抽象化**:
これこそが組み込みを題材にする最大のメリットです。「コインを識別する装置」「商品を排出するモーター」といった**物理的な詳細**を、ビジネスロジックから完全に隔離する、というクリーンアーキテクチャの真価を体験できます。

## 🧩 クリーンアーキテクチャの登場人物

![クリーンアーキテクチャ](../クリーンアーキテクチャ.png)

| カテゴリ | クラス/インターフェース名 | 役割（責務） |
| --- | --- | --- |
| **Entities** | `Item` | 商品。スロット番号、名前、価格、在庫数といった属性と、`dispense()`（在庫を1減らす）というルールを持つ。 |
|  | `PaymentManager` | お金の管理。`current_amount`（投入金額）という状態と、`insert_coin()`や`calculate_change()`といったルールを持つ。 |
| **Data Structures** | `SelectItemInputData` | `Controller`から`UseCase`へ渡すデータ。`slot_id`など。 |
|  | `SelectItemOutputData` | `UseCase`から`Presenter`へ渡すデータ。排出商品名、お釣りなど。 |
| **Boundaries** | `SelectItemInputBoundary` | `SelectItemUseCase`の入力ポート。 |
|  | `SelectItemOutputBoundary` | `SelectItemUseCase`の出力ポート。 |
|  | `ItemDataAccessInterface` | 在庫情報の読み書きを抽象化する。 |
|  | **`HardwareInterface`** | **最重要**。コイン投入口、商品排出装置などの**物理デバイスを抽象化**する。 |
| **Use Case** | `SelectItemUseCase` | ユーザーが商品選択ボタンを押した際のシナリオを担当。 |
|  | `InsertCoinUseCase` | コインが投入された際のシナリオを担当。 |
| **Adapters** | `InMemoryItemDataAccess` | 在庫情報をメモリ上で管理するリポジトリ実装。 |
|  | **`ConsoleHardwareAdapter`** | `HardwareInterface`を実装し、コンソールでハードウェア動作を**シミュレート**する。 |
|  | `VendingMachinePresenter` | `OutputData`を表示用メッセージに変換する。 |

## 🚀 具体的なシナリオ例：「商品の選択」

`SelectItemUseCase`が実行する処理の流れは、ハードウェアとの連携が加わり、より実践的になります。

1. `Controller`から`SelectItemInputData`(`slot_id`)を受け取ります。
2. `ItemDataAccessInterface`を使い、`slot_id`で`Item` Entityを探します。
3. `Item` Entityの在庫と、`PaymentManager` Entityの投入金額をチェックします。
4. 全てのチェックをパスしたら、以下を**オーケストレーション**します。
a. `HardwareInterface`を通じて、商品排出装置に指示を出します。（物理的な詳細を知らない）
b. `payment_manager.calculate_change()`を呼び出し、お釣りを計算させます。
c. `HardwareInterface`を通じて、お釣り排出装置に指示を出します。
d. `item.dispense()`を呼び出して在庫を減らします。
e. 変更された`Item`を`ItemDataAccessInterface`を通じて永続化します。
5. 成功結果を`Presenter`に渡します。

## 💡 ユニットテストで「ハードウェアからの独立」を証明する

物理的な自動販売機が手元になくても、`UseCase`のロジックは100%テストできます。

```python
# tests/application/use_cases/test_select_item.py の例

def test_お金が足りていれば商品が排出される():
    # 1. Arrange (準備): すべての依存先を偽物（モック/フェイク）で用意
    fake_item_repo = FakeItemRepository(在庫がある商品)
    fake_payment_manager = FakePaymentManager(十分な投入金額)
    # ★ハードウェアも偽物！
    fake_hardware = FakeHardwareAdapter()

    # 2. Act (実行)
    use_case = SelectItemUseCase(..., hardware=fake_hardware)
    use_case.handle(...)

    # 3. Assert (検証)
    # ✅ 偽物ハードウェアの商品排出メソッドが、正しく呼ばれたか？
    assert fake_hardware.dispense_item_was_called_with("お茶")
    # ✅ 在庫が1つ減っているか？
    assert fake_item_repo.get_stock("お茶") == 9

```

## 🐍 PythonとC言語の比較（初心者の方へ）

- **Python (オブジェクト指向)**: `HardwareInterface`という抽象（契約）に依存します。`self._dispenser.dispense(item)`のように、具体的なモーターの制御方法を知らなくても、抽象的な「排出」という操作を指示できます。
- **C言語 (手続き型)**: ハードウェアを直接制御するコードがビジネスロジックに混在しがちです。`PORTB |= (1 << PB3);`のように、特定のレジスタを直接操作するコードが、商品購入ロジックのど真ん中に現れることも少なくありません。これでは、ハードウェアの仕様変更がビジネスロジック全体に影響を及ぼしてしまいます。

## 🛡️ この第三巡の鉄則

Webアプリケーションで学んだ原則が、物理的な世界にも適用されることを学びましょう。

> ハードウェアは詳細である (Hardware is a detail.)
> 

この題材に取り組むことで、「ビジネスロジック」と、移り変わりやすい「ハードウェアの詳細」とをいかにして分離するか、という組み込み開発における非常に重要なスキルを、クリーンアーキテクチャを通じて学ぶことができます。