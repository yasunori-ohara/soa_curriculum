# 00 はじめに

# 🥤 第三巡：シンプルな自動販売機で学ぶ「普遍的な設計原則」

これまで私たちは、

* **第1巡：ToDoアプリ** でクリーンアーキテクチャの**基本構造と依存方向**を体感し、
* **第2巡：図書館システム** でそれを**現実的なWebアプリケーションに拡張**してきました。

そしていよいよ第三巡では、**まったく異なるドメイン「組み込み（ハードウェア制御）」**に挑戦します。
題材は「**シンプルな自動販売機**」。
クリーンアーキテクチャがWebだけの話ではなく、「どんな世界でも通用する思想」であることを体感する最終章です。

---

## 🧭 まず：なぜ構成を“シンプル化”するのか？

第二巡（図書館アプリ）では、現実的な構成として次のように多層のディレクトリを設けました。

```
core/
  ├─ domain/
  └─ usecase/
interface_adapters/
infrastructure/
container/
```

これは企業システムや大規模開発に近い、**理想的な設計**でした。
しかし、学習の最終段階に入った今、私たちはもう一段深く本質を掘り下げるために、**構造をあえて単純化**します。

### 🎯 目的は「原則そのもの」を際立たせること

今回の題材は「ハードウェア制御 × クリーンアーキテクチャ」。
ここではフォルダの階層よりも、「どの層がどの層を知らないか」を明確に感じ取ることが重要です。

したがって第三巡では、次のような**最小構成**で進めます。

```text
vending_machine/
├─ domain/
│   ├─ entities.py          # Item, PaymentManager など
│   ├─ errors.py            # ドメインルール違反例外
│
├─ usecase/
│   ├─ dto.py               # InputData / OutputData / ViewModel
│   ├─ boundaries.py        # UseCaseが外部とやり取りする契約
│   ├─ insert_coin_usecase.py
│   └─ select_item_usecase.py
│
├─ interface_adapters/
│   ├─ controller.py        # Controller（入力受付）
│   ├─ presenter.py         # Presenter（出力整形）
│   ├─ view_console.py      # CLIでの動作確認
│   ├─ data_access.py       # 在庫リポジトリのインメモリ実装
│   └─ hardware_adapter.py  # ハードウェア操作のコンソール版実装
│
└─ main.py                  # Composition Root（全配線）

```

この「3層＋main構成」は、

* ドメイン（ビジネスルール）
* ユースケース（アプリケーションロジック）
* インターフェースアダプタ（UI・ハードウェア）
  の最小限の関係を保ちながら、階層の理解コストを最小化します。

> つまり、ここから先は「実装構造の暗記」ではなく、
> **依存方向と抽象化という思想そのもの**を磨くフェーズです。

### 💡補足
- 第三巡では、HardwareAdapter を interface_adapters/ に追加しています。
- これは、UseCase が依存する外部装置（モーターやコインメカなど）を
ソフトウェア的に“交換可能な部品”として扱うためです。
- クリーンアーキテクチャでは「ハードウェアも詳細（detail）」とみなします。
- HardwareAdapter を別ファイルに分けることで、
「データアクセス」と「物理動作」という２種類の詳細を明確に区別できます。
---

## 🌟 なぜ第三巡に「自動販売機」なのか？

もし第一巡・第二巡が「家の建て方」を学ぶ旅だったとすれば、
この第三巡は「**学んだ原則で家だけでなく工場や橋も建てられることを証明する**」段階です。

* **詳細（Detail）の概念を拡張する 🔌**
  Webでは「DBやWebフレームワークが詳細」でしたが、
  今回は「**ハードウェアそのものが詳細**」。
  コイン投入口、ボタン、モーターなども `Adapters` 層に属する“交換可能な部品”です。

* **ハードウェアからの独立性を証明する ⏳**
  実機がなくてもロジックをテストできる。
  「決定を遅らせる設計」が、組み込み開発でも有効であることを示します。

---

## 🎯 この題材が優れている理由

| 観点             | 内容                                                                    |
| -------------- | --------------------------------------------------------------------- |
| **明確な状態とルール**  | 投入金額・在庫数・価格などの「状態」と、「購入条件」「売り切れ時の動作」などの「ルール」がはっきりしている。                |
| **複数のユースケース**  | 「コイン投入」「商品選択」「在庫補充」「自動チェック」など多様なシナリオが構築できる。                           |
| **ハードウェアの抽象化** | コインセンサーやモーターを**HardwareInterface**として抽象化できる。ハードが変わっても`UseCase`を再利用可能。 |

---

## 💡 クリーンアーキテクチャの登場人物（再整理）

| カテゴリ                 | クラス/インターフェース                                           | 役割             |
| -------------------- | ------------------------------------------------------ | -------------- |
| **Entities**         | `Item` / `PaymentManager`                              | 商品とお金の管理。      |
| **Boundaries**       | `SelectItemInputBoundary` / `SelectItemOutputBoundary` | ユースケースの入出力ポート。 |
| **Interfaces**       | `ItemDataAccessInterface` / `HardwareInterface`        | 在庫とハードウェアの抽象化。 |
| **UseCases**         | `InsertCoinUseCase` / `SelectItemUseCase`              | 実際の操作ロジック。     |
| **Adapters**         | `ConsoleHardwareAdapter` / `InMemoryItemDataAccess`    | シミュレーション実装。    |
| **Presenter / View** | `VendingMachinePresenter` / `ConsoleView`              | 表示や操作の橋渡し。     |

---

## 🚀 具体的なシナリオ例：「商品の選択」

1. `Controller` → `SelectItemInputData(slot_id)` を受け取る
2. `ItemDataAccessInterface` → `Item` を検索
3. `PaymentManager` で金額チェック
4. 条件が整えば以下を実行：
   a. `HardwareInterface` → モーター作動指示
   b. `PaymentManager.calculate_change()` → お釣り計算
   c. `HardwareInterface` → お釣り排出
   d. `Item.dispense()` → 在庫減算
   e. `ItemDataAccessInterface.save()` → 永続化
5. 結果を `Presenter` に通知し、`View` が表示

---

## 🧪 ユニットテストで「ハードウェアからの独立」を証明する

```python
def test_お金が足りていれば商品が排出される():
    fake_repo = FakeItemRepository(在庫あり)
    fake_payment = FakePaymentManager(投入金額100円)
    fake_hw = FakeHardwareAdapter()

    use_case = SelectItemUseCase(
        item_repo=fake_repo,
        payment_manager=fake_payment,
        hardware=fake_hw
    )
    use_case.handle(SelectItemInputData(slot_id=1))

    assert fake_hw.dispense_called_with("お茶")
    assert fake_repo.get_stock("お茶") == 9
```

---

## 🧩 PythonとC言語の比較（組み込み開発の観点）

| 観点   | Python的設計                  | C的設計（従来）       |
| ---- | -------------------------- | -------------- |
| 依存関係 | 抽象(`HardwareInterface`)に依存 | 直接レジスタ操作       |
| 変更影響 | 低い（Adapter差し替えで済む）         | 高い（全ロジック修正が必要） |
| テスト性 | 実機不要・モック可                  | 実機依存・自動化困難     |

---

## 🛡️ この第三巡の鉄則

> **ハードウェアは詳細である（Hardware is a detail.）**

クリーンアーキテクチャの思想は、
Web・デスクトップ・モバイル・そして組み込み機器をも貫く普遍的な原則です。

この章では、**ビジネスロジックを物理的な制約から解放する**設計を、
最も身近でわかりやすい「自動販売機」という題材で実践していきます。

## 🛡️ 補足：重要なのでこのページの前半での説明の確認

### 🎯 1. フォルダをシンプルにした理由

「これまであえて分割していたけど、もう原則は理解できているから、現場寄りのシンプルな構成にまとめる」という説明は正しいです。
実際の現場でも、小規模プロジェクトは `domain / usecase / interface_adapters` の3階層＋`main.py` 程度から始まることは普通にあります。

つまり「学習だから複雑だった→これからはより実践的な最小形にする」というストーリーは、建前じゃなくてちゃんと現実的な線です。

### 🎯 2. boundaries.py の扱い

「usecase/boundaries.py に、リポジトリやハードウェアやプレゼンターなどのインターフェースを全部まとめる」という説明も正しい範囲です。

なぜなら、UseCaseは「外部にこう動いてほしい」という要求を持つ層なので、その要求（契約）をひとまとめに置く、というのは合理的な整理だからです。
これはクリーンアーキテクチャが要求する“依存方向（内から外への逆依存）”と両立しています。矛盾しません。

> つまり「Repositoryはdomainの隣に置かないとダメ」というような決まりは、クリーンアーキテクチャそのものにはありません。
> 大事なのは「内側が外側の詳細を知らないこと」であって、「どのフォルダに置くか」はプロジェクト流です。

この説明は教材としても安全です。

### 🎯 3. ハードウェアを「詳細」として扱うこと

「ハードウェアは interface_adapters の外側詳細」「UseCaseからはインターフェース越しに命令するだけ」というのは、めちゃくちゃクリーンアーキテクチャ的です。
ここに変な点はありません。


