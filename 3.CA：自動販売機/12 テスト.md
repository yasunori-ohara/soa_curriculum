# 12 テスト

# 🧪 テスト：クリーンアーキテクチャの「強さ」を証明する

ここまでで、自販機アプリはいちおう完成しました。
でも「設計が良い」という話は、言葉だけだと信用しにくいですよね。

では実際に証明してみましょう。
この章では、`SelectItemUseCase` を単体テストします。

ポイントはここです👇

> 物理ハードウェアも、本物のDBも、コンソールUIも、いりません。
> それでもビジネスルールだけを正確にテストできます。

これが、クリーンアーキテクチャで層を分けた**ご褒美**です。

![クリーンアーキテクチャ](../クリーンアーキテクチャ.png)

---

## 🎯 このテストで確認すること

この章のテストでは、`SelectItemUseCase` が正しくふるまうことだけをチェックします。

具体的には：

1. 💰 お金が足りていて在庫もあるとき

   * ハードウェアに「その商品を出せ」が指示される
   * お釣りが正しく計算される
   * Presenterに「成功メッセージ用データ」が渡される
   * 在庫が1本減る
   * PaymentManagerの投入金額がリセットされる

2. 🪙 お金が足りないとき

   * ハードウェアは動かない
   * 在庫も減らない
   * PaymentManagerの金額も変わらない
   * Presenterには「エラーメッセージ用データ」が渡される

3. 🈳 在庫切れのとき

   * ハードウェアは動かない
   * お金は消費されない（お釣りにもならない）
   * Presenterには「売り切れエラー」が渡される

> つまり「ビジネスとして正しいか？」だけを見ます。
> UIの表示文言とか、printの見た目とかはこのテストの対象外です。

---

## 🧪 まずは前提：リファクタ後のUseCaseとPresenterの形

テストを書きやすくするために、ここではリファクタ済みのインターフェースを使います。

### usecase/boundaries.py（抜粋）

```python
from abc import ABC, abstractmethod
from typing import Optional
from vending_machine.usecase.dto import SelectItemInputData, SelectItemOutputData
from vending_machine.domain.entities import Item, PaymentManager

class SelectItemInputBoundary(ABC):
    @abstractmethod
    def handle(self, input_data: SelectItemInputData):
        raise NotImplementedError

class SelectItemOutputBoundary(ABC):
    @abstractmethod
    def present_success(self, output_data: SelectItemOutputData):
        """購入成功時に呼ばれる"""
        raise NotImplementedError

    @abstractmethod
    def present_failure(self, error_message: str):
        """失敗時に呼ばれる（お金不足・在庫切れなど）"""
        raise NotImplementedError


class ItemDataAccessInterface(ABC):
    @abstractmethod
    def find_by_slot_id(self, slot_id: str) -> Optional[Item]:
        raise NotImplementedError

    @abstractmethod
    def save(self, item: Item) -> Item:
        raise NotImplementedError


class PaymentManagerAccessInterface(ABC):
    @abstractmethod
    def get(self) -> PaymentManager:
        raise NotImplementedError

    @abstractmethod
    def save(self, payment_manager: PaymentManager):
        raise NotImplementedError


class HardwareInterface(ABC):
    @abstractmethod
    def dispense_item(self, item: Item):
        """商品を物理的に排出させる"""
        raise NotImplementedError

    @abstractmethod
    def return_change(self, amount: int):
        """お釣りを物理的に排出させる"""
        raise NotImplementedError
```

### usecase/select_item_usecase.py（骨格イメージ）

```python
from vending_machine.usecase.boundaries import (
    SelectItemInputBoundary,
    SelectItemOutputBoundary,
    ItemDataAccessInterface,
    PaymentManagerAccessInterface,
    HardwareInterface,
)
from vending_machine.usecase.dto import SelectItemInputData, SelectItemOutputData

class SelectItemUseCase(SelectItemInputBoundary):
    def __init__(
        self,
        presenter: SelectItemOutputBoundary,
        item_repository: ItemDataAccessInterface,
        payment_manager_repo: PaymentManagerAccessInterface,
        hardware: HardwareInterface,
    ):
        self._presenter = presenter
        self._item_repository = item_repository
        self._payment_manager_repo = payment_manager_repo
        self._hardware = hardware

    def handle(self, input_data: SelectItemInputData):
        # 1. 必要な情報を集める
        item = self._item_repository.find_by_slot_id(input_data.slot_id)
        if item is None:
            self._presenter.present_failure("指定されたスロットに商品がありません。")
            return

        pm = self._payment_manager_repo.get()

        # 2. ビジネスルールを実行する
        try:
            # 在庫チェック（dispense内でもチェックするが、先に知りたい場合はここでもOK）
            if not item.is_in_stock():
                raise ValueError(f"「{item.name}」は売り切れです。")

            # お釣り計算＆支払い確定（足りないと ValueError）
            change = pm.process_purchase(item)

            # 実際に出す・お釣り出す
            self._hardware.dispense_item(item)
            if change > 0:
                self._hardware.return_change(change)

            # 在庫減らす＆保存
            item.dispense()
            self._item_repository.save(item)

            # お金の状態も保存
            self._payment_manager_repo.save(pm)

            # Presenterに「成功したよ」と伝える
            output = SelectItemOutputData(
                item_name=item.name,
                change=change,
            )
            self._presenter.present_success(output)

        except ValueError as e:
            # ここに来るのは主に「お金が足りない」などのビジネス的失敗
            self._presenter.present_failure(str(e))
```

↑ このような形を前提に、テストを書きます。
（※本カリキュラムではこの形を「リファクタ後の最終版」として扱います）

---

## 🎭 テスト用の「偽物」（テストダブル）を作る

`SelectItemUseCase` は、4種類の依存先に頼っています👇

* Presenter（結果を受け取る相手）
* ItemRepository（在庫管理）
* PaymentManagerRepository（投入金額管理）
* HardwareInterface（実際に“ガコン”するやつ）

テストでは、これらの「本物」を使いません。
代わりに、テストのためだけの軽い偽物を用意します。

それぞれの偽物は、以下の役割を持ちます：

* Spy（スパイ）
  「どんな呼び出しが行われたか」を記録する
* Fake（フェイク）
  軽いメモリ実装を持つ“なんちゃって本番”

```python
# tests/doubles.py

from typing import Dict, Optional
from vending_machine.usecase.boundaries import (
    SelectItemOutputBoundary,
    ItemDataAccessInterface,
    PaymentManagerAccessInterface,
    HardwareInterface,
)
from vending_machine.usecase.dto import SelectItemOutputData
from vending_machine.domain.entities import Item, PaymentManager


# ---------------------------------------------------------------------
# 🎥 SpyPresenter
# - UseCase が「成功」「失敗」どちらを報告してきたか記録する
# ---------------------------------------------------------------------
class SpyPresenter(SelectItemOutputBoundary):
    def __init__(self):
        self.success_called_with: Optional[SelectItemOutputData] = None
        self.failure_called_with: Optional[str] = None

    def present_success(self, output_data: SelectItemOutputData):
        self.success_called_with = output_data

    def present_failure(self, error_message: str):
        self.failure_called_with = error_message


# ---------------------------------------------------------------------
# 🗃️ FakeItemRepository
# - メモリ内の辞書を「在庫DB」と見立てる
# ---------------------------------------------------------------------
class FakeItemRepository(ItemDataAccessInterface):
    def __init__(self, initial_items: Dict[str, Item]):
        # 例: {"A1": Item(...), "B2": Item(...)}
        self._items = dict(initial_items)

    def find_by_slot_id(self, slot_id: str) -> Optional[Item]:
        return self._items.get(slot_id)

    def save(self, item: Item) -> Item:
        self._items[item.slot_id] = item
        return item


# ---------------------------------------------------------------------
# 💰 FakePaymentManagerRepository
# - 1台の自販機につき1つの PaymentManager を握っている体で動く
# ---------------------------------------------------------------------
class FakePaymentManagerRepository(PaymentManagerAccessInterface):
    def __init__(self, payment_manager: PaymentManager):
        self._pm = payment_manager

    def get(self) -> PaymentManager:
        return self._pm

    def save(self, payment_manager: PaymentManager):
        # 今回は同じインスタンスを書き戻すだけ
        self._pm = payment_manager


# ---------------------------------------------------------------------
# 🛠️ SpyHardware
# - UseCase がハードウェアに何を指示したか記録する
# ---------------------------------------------------------------------
class SpyHardware(HardwareInterface):
    def __init__(self):
        self.dispensed_item: Optional[Item] = None
        self.returned_change: Optional[int] = None

    def dispense_item(self, item: Item):
        # 「どの商品を出せ」と言われたか記録する
        self.dispensed_item = item

    def return_change(self, amount: int):
        # 「いくら釣り銭を出せ」と言われたか記録する
        self.returned_change = amount
```

---

## 🔬 UseCaseのテスト本体

`pytest` を使います。
テストは「Arrange（準備）→Act（実行）→Assert（検証）」の3ステップで書きます。

```python
# tests/usecase/test_select_item_usecase.py

from vending_machine.usecase.select_item_usecase import SelectItemUseCase
from vending_machine.usecase.dto import SelectItemInputData, SelectItemOutputData
from vending_machine.domain.entities import Item, PaymentManager
from tests.doubles import (
    SpyPresenter,
    FakeItemRepository,
    FakePaymentManagerRepository,
    SpyHardware,
)


def test_お金が足りていて在庫もある場合_商品が排出されてお釣りが返る():
    # 1. Arrange (準備)
    # 商品A1: 160円, 在庫5本
    item_a1 = Item(slot_id="A1", name="お茶", price=160, stock=5)

    # ユーザーは200円投入済みという状態からスタート
    pm = PaymentManager(current_amount=200)

    presenter = SpyPresenter()
    item_repo = FakeItemRepository({"A1": item_a1})
    pm_repo = FakePaymentManagerRepository(pm)
    hardware = SpyHardware()

    use_case = SelectItemUseCase(
        presenter=presenter,
        item_repository=item_repo,
        payment_manager_repo=pm_repo,
        hardware=hardware,
    )

    input_data = SelectItemInputData(slot_id="A1")

    # 2. Act (実行)
    use_case.handle(input_data)

    # 3. Assert (検証)

    # ✅ Presenterに成功として報告されたこと
    assert presenter.success_called_with is not None
    assert presenter.failure_called_with is None

    # ✅ Presenterに渡された出力データの中身が正しいこと
    output: SelectItemOutputData = presenter.success_called_with
    assert output.item_name == "お茶"
    # 200円入れて160円のものを買ったので、お釣りは40円
    assert output.change == 40

    # ✅ Hardwareに正しい命令が出ていること
    assert hardware.dispensed_item is not None
    assert hardware.dispensed_item.slot_id == "A1"
    assert hardware.returned_change == 40

    # ✅ 在庫が1本減って、repoにも保存されていること
    saved_item = item_repo.find_by_slot_id("A1")
    assert saved_item.stock == 4  # 5 → 4

    # ✅ PaymentManagerの金額がリセットされたこと
    assert pm_repo.get().current_amount == 0


def test_お金が足りない場合_ハードウェアは動かずエラーメッセージがPresenterに渡る():
    # 1. Arrange
    # 商品A1: 160円, 在庫5本
    item_a1 = Item(slot_id="A1", name="お茶", price=160, stock=5)

    # 100円しか入っていない
    pm = PaymentManager(current_amount=100)

    presenter = SpyPresenter()
    item_repo = FakeItemRepository({"A1": item_a1})
    pm_repo = FakePaymentManagerRepository(pm)
    hardware = SpyHardware()

    use_case = SelectItemUseCase(
        presenter=presenter,
        item_repository=item_repo,
        payment_manager_repo=pm_repo,
        hardware=hardware,
    )

    input_data = SelectItemInputData(slot_id="A1")

    # 2. Act
    use_case.handle(input_data)

    # 3. Assert

    # ✅ Presenterには失敗として報告されていること
    assert presenter.success_called_with is None
    assert presenter.failure_called_with is not None
    assert "不足" in presenter.failure_called_with or "足り" in presenter.failure_called_with

    # ✅ ハードウェアは一切動いていない
    assert hardware.dispensed_item is None
    assert hardware.returned_change is None

    # ✅ 在庫も減っていない
    assert item_repo.find_by_slot_id("A1").stock == 5

    # ✅ お金も消費されていない（＝まだ100円のまま）
    assert pm_repo.get().current_amount == 100


def test_在庫が0本の場合_商品は出ずエラーになる():
    # 1. Arrange
    # 在庫0のスロット
    sold_out_item = Item(slot_id="C3", name="水", price=110, stock=0)

    # 十分すぎる金額が投入されている
    pm = PaymentManager(current_amount=500)

    presenter = SpyPresenter()
    item_repo = FakeItemRepository({"C3": sold_out_item})
    pm_repo = FakePaymentManagerRepository(pm)
    hardware = SpyHardware()

    use_case = SelectItemUseCase(
        presenter=presenter,
        item_repository=item_repo,
        payment_manager_repo=pm_repo,
        hardware=hardware,
    )

    input_data = SelectItemInputData(slot_id="C3")

    # 2. Act
    use_case.handle(input_data)

    # 3. Assert

    # ✅ Presenterには失敗が報告される
    assert presenter.success_called_with is None
    assert presenter.failure_called_with is not None
    assert "売り切れ" in presenter.failure_called_with

    # ✅ ハードウェア動かない
    assert hardware.dispensed_item is None
    assert hardware.returned_change is None

    # ✅ 在庫は当然0のまま
    assert item_repo.find_by_slot_id("C3").stock == 0

    # ✅ お金もまだ保持されている（勝手にリセットされない）
    assert pm_repo.get().current_amount == 500
```

---

## 👍 なぜこのテストは「ラク」なのか？

### ① 実機がいらない

ハードウェアは `SpyHardware` に置き換わっているので、
モーターもリレーもお金払い出し機構も不要です。

### ② DBがいらない

在庫は `FakeItemRepository` のただの辞書。
MongoDBもSQLも準備しなくていい。

### ③ UIがいらない

View（コンソール入出力）を動かしていません。
`input()` / `print()` のモックすら不要です。

> つまり「ドメインルール」と「ユースケースの流れ」だけを
> 超高速・超安定にテストできます。

---

## 🐍 Python と 🔧 C言語のイメージ比較

* 🐍 Python / クリーンアーキテクチャ:

  * UseCaseは外部（DB / ハードウェア / UI）に直接依存しない。
  * だから依存先をテスト用の偽物に入れ替えるだけでビジネスロジックを検証できる。

* 🔧 C言語でありがちな構成:

  * 「商品を出す関数」が直接 `PORTB |= (1 << PB3);` のようなレジスタいじりを書いている。
  * その関数をテストしたいだけなのに、ハードウェアが無いと動かない。
  * あるいは `#ifdef TEST` で条件コンパイル地獄になる。

この差が、保守性の差になります。
テストがしやすい＝変更に強い、ということです。

---

## 🛡️ テストで守りたい原則

> ビジネスをテストせよ。技術の詳細は別でテストせよ。
> (Test the business, not the technology.)

* UseCaseテスト
  → ビジネスルール（お金が足りる／足りない、在庫あり／なし）を確認する場
* DataAccessテスト
  → 保存や読み出しのロジックを確認する場
* Viewテスト
  → 入力がControllerに正しく渡されるか、Presenterのメッセージが表示されるかを確認する場

これらを**混ぜない**のがコツです。
混ぜると「テストが遅くて壊れやすい」大きな一枚岩テストになってしまいます。

---

## 🎉 まとめ

* UseCaseは「外の世界」に依存していないので、安心して単体テストできる
* Presenter / Repository / Hardwareは全部「差し替え前提の契約（インターフェース）」でつながっている
* つまり、**ハードウェアがなくてもハードウェア込みのビジネスフローを検証できる**

あなたはいま、ただの「動くコード」ではなく、
**変更に強いコード**を手に入れています。

これがクリーンアーキテクチャの本当の価値です。
