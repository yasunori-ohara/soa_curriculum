# 07 UI独立性

# 🏛️ UI独立性

「フレームワーク独立性」と密接に関連するのが、「**UI独立性 (UI Independence)**」です。UI（ユーザーインターフェース）は、システムが外部（ユーザー）と対話するための手段であり、クリーンアーキテクチャ(CA)では、これもまた「詳細」として扱われます。

---

## ❓ 原則の定義

> ビジネスルールは、UI（Web、ネイティブ、コンソールなど）の具体的な実装から独立しているべきである。UIは簡単に交換可能でなければならない。
> 
> 
> \--- (Clean Architecture の原則に基づく)
> 

### 💡 簡単に言うと

「見た目（画面）が変わっても、裏側の仕事（ビジネスロック）は影響を受けないようにしよう」ということです。Web画面だろうが、スマホアプリだろうが、あるいはコマンドラインだろうが、中心となるロジックは同じように動くべきです。

### 🤔 なぜ重要か？

UIは、技術の流行り廃りや、ユーザー要求の変化によって、**非常に変更されやすい**部分です。UIにビジネスロジックが依存していると、以下のような問題が発生します。

1. **UI変更のコスト増大**:
見た目を少し変えたいだけなのに、ビジネスロックが絡んでいるために大規模な修正が必要になったり、意図しない動作変更（バグ）を引き起こしたりします。
2. **マルチプラットフォーム対応の困難化**:
Web版とモバイルアプリ版で同じビジネスロックを使いたいのに、UI固有のコードが混入しているため、ロジックの共通化や再利用が難しくなります。
3. **テストの困難化**:
ビジネスロックをテストするために、UI（画面）を実際に操作したり、UIフレームワークを起動したりする必要が出てきてしまい、自動テスト（特にユニットテスト）が非常に困難になります。
4. **技術移行の阻害**:
古いUI技術（例：jQuery）から新しい技術（例：React, Vue）へ移行したいと思っても、ビジネスロックが古い技術と密結合しているため、移行が非常に困難または不可能になります。

UIから独立することで、ビジネスロックという**システムの核**を、変化しやすい**見た目の詳細**から守り、長期的な保守性・拡張性を確保できます。

---

## ✅ これまでの実践例（どこで使ったか）

今回のSOA（自動駐車システム）の例では直接的なUIはありませんでしたが、CAの構造自体がUI独立性を保証するように作られています。

### 📌 UIをAdapters層として扱う (概念)

- **具体例**: もし自動駐車システムにWeb UIを追加する場合、そのUI（HTML生成、JavaScript、CSS）や、UIとUseCaseをつなぐController/Presenterは、すべて**Adapters層**（またはFrameworks & Drivers層）に配置されます。
- **実践**: `UseCase` はUIのことを一切知りません。`UseCase` は、処理に必要なデータを `InputBoundary` (インターフェース) 経由で受け取り、処理結果を `OutputBoundary` (インターフェース) 経由で返します。UIとの具体的なやり取り（HTTPリクエストの解析、HTMLの生成など）は、Adapters層に属する `Controller` や `Presenter` が担当します。
    
    ```
      UI (Web/Mobile/CLI) <--> Controller/Presenter (Adapters) <--> <I> UseCase Boundary <--> UseCase
                                     (implements I/F)             (depends on I/F)
    
    ```
    

### 📌 依存性のルールによる隔離 (第1巡〜第5巡)

- **具体例**: 「依存性は常に外側から内側へ」というルールを徹底しました。
- **実践**: UI（最外層）は `UseCase`（内側）を知って呼び出すことができますが、`UseCase` はUI（外側）を知りません。これにより、UIがWebからモバイルアプリに変わっても、`UseCase` は影響を受けません。

### 📌 (参考) 第1巡 ToDoアプリ (コンソールUI)

- **具体例**: 最初のToDoアプリはコンソール（CUI）で動作しました。
- **実践**: もしあのアプリにCAを適用していたら、`UseCase`（ToDoの追加、完了など）は、CUI（`print`, `input`）について何も知らずに実装されたはずです。CUIとのやり取りは `ConsoleAdapter` (Adapters層) が担当し、もし将来Web UIに変更するとしても、`UseCase` は変更せずに `WebAdapter` を追加・差し替えるだけで済んだでしょう。

---

## ❌ 間違った適用例（アンチパターン）

UI独立性が低いコードは、UIの変更がビジネスロックに直接影響を与えてしまいます。

- **例1：UseCaseがHTMLタグやDOM操作を含む**
    
    ```python
    # アンチパターン：UseCaseがUI(HTML)に依存
    class ShowUserProfileUseCase:
        def handle(self, user_id):
            user = user_repository.find_by_id(user_id)
            if not user:
                # ビジネスロジックがHTMLタグを知ってしまっている！
                return "<p>Error: User not found</p>"
    
            # ビジネスロジックがHTMLの構造を知ってしまっている！
            html = f"<h1>{user.name}</h1>"
            html += f"<div class='profile'>Email: {user.email}</div>"
            return html
    
    ```
    
    この `UseCase` は、ユーザー情報を取得するというビジネスロジックだけでなく、それをHTML形式で表現するというUI固有の関心事まで担当してしまっています。もしUIをJSON APIに変更したい場合、この `UseCase` を修正しなければなりません。
    
    **改善策**: `UseCase` は `User` Entity（またはDTO）を返します。HTMLへの変換は、`Presenter`（Adapters層）が担当します。
    
- **例2：ビジネスルールがUIコンポーネント内に直接書かれている**
（関心の分離アンチパターン2と同じ例です）
    
    ```jsx
    // アンチパターン：UIコンポーネント内にビジネスルール
    // function onCheckoutButtonClick() {
    //   ... (UIからの値取得) ...
    
    //   // 割引ルールの適用 (ビジネスルール！)
    //   if (totalPrice > 10000) {
    //     totalPrice *= 0.9; // 10%割引
    //   }
    
    //   // UI表示の更新 (UIの関心)
    //   document.getElementById('total-price').innerText = totalPrice;
    //   ...
    // }
    
    ```
    
    割引ルール（10000円以上で10%引き）というビジネスルールが、UIのボタンクリック処理の中に直接書かれています。もし割引ルールを変更する場合、UIのコードを修正する必要があり、また、このルールを別の場所（例：モバイルアプリ）で再利用することも困難です。
    
    **改善策**: 割引ルールは `UseCase` や `Entity` (例: `Order` Entityのメソッド) に実装します。UIイベントハンドラは `UseCase` を呼び出すだけにし、ビジネスルールから独立させます。
    

---

## 📝 まとめ

UI独立性は、「**ビジネスロジックを、変わりやすい『見た目』から守る**」ための原則です。

UIはシステムにとって重要な要素ですが、それはあくまで「詳細」の一つです。クリーンアーキテクチャのレイヤー構造と依存性のルールに従い、UIへの依存を**Adapters層**（ControllerやPresenter）に閉じ込めることで、将来のUI変更やマルチプラットフォーム展開に柔軟に対応できるシステムを構築することができます。

---

## ➡️ 次へ

次は、UI独立性と同様に重要な、「**(8/10) データベース独立性**」について復習しましょう。