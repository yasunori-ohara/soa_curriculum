# 03 境界インターフェース

# 🏛️ 境界インターフェース

クリーンアーキテクチャのレイヤー構造を機能させる上で、**接着剤**のような役割を果たすのが「**境界インターフェース (Boundary Interfaces)**」です。これは、依存性のルールを具体的に実現するための重要な要素です。
ヘキサゴナルアーキテクチャでは「**ポート (Ports)**」とも呼ばれます。

---

## ❓ 定義

> レイヤーの境界を越える通信は、シンプルなデータ構造で行われる。境界を越える際に渡すデータは、常に内側の円にとって都合の良い形式でなければならない。
> 
> 
> \--- (Clean Architecture より意訳)
> 

境界インターフェースは、*内側のレイヤー（例：UseCase）が、外側のレイヤー（例：Adapters）に「何を要求するか」を定義した契約（API）*です。
通常、Pythonでは `abc.ABC` を使った抽象基底クラスとして定義されます。

### 💡 簡単に言うと

内側の円（例：UseCase）が、外側の円（例：Adapters）に仕事を依頼するための「**注文窓口**」や「**仕様書**」のようなものです。UseCaseは窓口に注文するだけで、窓口の向こうで誰がどうやって作業するかは知りません。

### 🤔 なぜ重要か？

境界インターフェースは、依存性逆転の原則(DIP)を具体化し、以下の利点をもたらします。

1. **依存性の方向の制御**:
インターフェースは内側の円（例：`application/boundaries.py`）で定義されます。外側の円（例：`adapters/`）にある具体的な実装クラスが、このインターフェースを実装（`implements`）することで、依存性の矢印が「外側 → 内側」に向くことを保証します。
2. **実装の差し替え可能性**:
内側の円はインターフェース（抽象）にのみ依存するため、外側の円でそのインターフェースを満たす別の実装クラスに差し替えても、内側の円は影響を受けません（オープン/クローズドの原則）。
3. **関心の分離の強化**:
インターフェースは「何をしたいか（What）」だけを定義し、「どうやるか（How）」は実装クラス（Adapter）に委ねられます。これにより、ビジネスロジックと技術的詳細が明確に分離されます。
4. **テスト容易性の向上**:
内側の円をテストする際に、インターフェースを満たす「偽物（モックやスタブ）」を簡単に差し込むことができます。

---

## ✅ これまでの実践例（どこで使ったか）

私たちは、各サービスの `application/boundaries.py` ファイルに、これらのインターフェースを集約的に定義してきました。

### 📌 UseCaseとAdapters間のインターフェース (第1巡〜第5巡)

- **具体例**: `UpdateWorldModelUseCase` が必要とする「窓口」として、以下のインターフェースを定義しました。
    - `SensorInterface`: センサーからのデータ取得という「要求」を定義。
    - `PlanningServiceAdapterInterface`: 計算結果の外部公開という「要求」を定義。
    - `WorldModelRepositoryInterface`: 内部状態の永続化という「要求」を定義。
- **実践**: `UseCase` はこれらのインターフェース型だけを使って実装されました。具体的な `StubSensorAdapter`, `MqttWorldModelPublisher`, `InMemoryWorldModelRepository` などのクラス名は `UseCase` のコードには一切登場しませんでした。
    
    ```
      UseCase -----> <I> Boundary Interface <----- Adapter
                     (depends on)                  (implements)
                     (内側が定義)                   (外側が実装)
    
    ```
    

### 📌 (参考) UseCase自体のインターフェース

- **具体例**: `UpdateWorldModelInputBoundary` （`application/boundaries.py` 内で参考として記載）。これは `UpdateWorldModelUseCase` 自身が実装すべきインターフェースです。
- **実践**: これは、さらに外側の層（例：WebフレームワークのControllerや `main.py`）が `UseCase` を呼び出す際の「窓口」となります。呼び出し側は、具体的な `UpdateWorldModelUseCase` クラスを知らなくても、この `InputBoundary` インターフェースを通じて `handle()` メソッドを呼び出すことができます。

---

## ❌ 間違った適用例（アンチパターン）

境界インターフェースが適切に設計・利用されていない場合、依存性のルールが破られやすくなります。

- **例1：インターフェースを使わず直接実装クラスに依存する**
（依存性のルール違反のアンチパターンと同じです）
    
    ```python
    # アンチパターン：インターフェース不在
    from adapters.stub_sensor import StubSensorAdapter # 👈 インターフェースではなく実装に依存
    
    class UpdateWorldModelUseCase:
        def __init__(self):
            # インターフェースを介さず、直接インスタンス化
            self._sensor_adapter = StubSensorAdapter()
    
        async def handle(self):
            # 実装クラスのメソッドを直接呼び出す
            image_data = await self._sensor_adapter.get_camera_image()
            # ...
    
    ```
    
    インターフェースという「抽象的な壁」がないため、`UseCase` が `Adapter` という「詳細」に直接依存してしまっています。
    
- **例2：インターフェースが外側（Adapters層）で定義されている**
インターフェースの「所有権」が重要です。インターフェースは、それを利用する内側の層が定義すべきです。
    
    ```
    # アンチパターン：インターフェースの所有権が逆
    
    # adapters/sensor_interface.py (外側で定義！) ❌
    class SensorInterface(ABC): ...
    
    # application/use_cases.py (内側)
    # from adapters.sensor_interface import SensorInterface # 👈 NG! 内側が外側に依存している！
    
    class MyUseCase:
        # def __init__(self, sensor: SensorInterface): ...
        pass
    
    ```
    
    もしインターフェースが `Adapters` 層で定義されていたら、`UseCase` 層がそのインターフェースを利用するために `Adapters` 層を `import` しなければならず、依存性のルール（内側は外側を知らない）に違反します。
    
- **例3：インターフェースが実装の詳細（データ形式など）を漏洩している**
（インターフェース分離の原則違反にも関連します）
インターフェースは抽象的であるべきで、特定の実装でしか使えないような具体的なデータ形式などを要求してはいけません。
    
    ```python
    # アンチパターン：漏洩のあるインターフェース
    # import specific_db_driver # 👈 実装の詳細
    
    class UserRepositoryInterface(ABC):
        @abstractmethod
        # def find_by_sql(self, raw_sql_query: str) -> list[specific_db_driver.Row]: # 👈 NG!
        #     pass
    
        # 良い例：抽象的な操作を定義
        def find_by_name(self, name: str) -> list[User]: # UserはEntity
            pass
    
    ```
    
    もしインターフェースが特定のDBドライバの型（`specific_db_driver.Row`）やSQL文字列を直接要求していたら、それは実装の詳細を漏洩しており、DBを変更する際にインターフェース自体の変更が必要になってしまいます。インターフェースは、ドメインの言葉（`find_by_name`）で定義されるべきです。
    

---

## 📝 まとめ

境界インターフェースは、クリーンアーキテクチャのレイヤー間を繋ぐ「**契約書**」であり、「**防波堤**」です。

- **契約書**: 内側の層が外側の層に「何を期待するか」を定義します。
- **防波堤**: 外側の層の変更が、内側の層に直接影響するのを防ぎます。

インターフェースを適切に定義し、依存性の注入（DI）と組み合わせることで、**依存性のルール**が守られ、柔軟でテストしやすいシステムが実現します。

---

## ➡️ 次へ

次は、これらの原則によって達成される重要な効果、「**(4/10) 関心の分離**」について復習しましょう。