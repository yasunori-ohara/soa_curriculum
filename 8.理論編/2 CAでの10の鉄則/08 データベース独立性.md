# 08 データベース独立性

# 🏛️ データベース独立性

「フレームワーク独立性」や「UI独立性」と同様に、クリーンアーキテクチャ(CA)が重視するのが「**データベース独立性 (Database Independence)**」です。データベースはデータを永続化するための重要なツールですが、これもまた「詳細」として扱われます。

---

## ❓ 原則の定義

> ビジネスルールは、データベース（RDB, NoSQL, ファイルシステムなど）の具体的な実装から独立しているべきである。データベースは簡単に交換可能でなければならない。
> 
> 
> \--- (Clean Architecture の原則に基づく)
> 

### 💡 簡単に言うと

「どのデータベース（MySQL, MongoDB, あるいはただのファイル）を使うにしても、ビジネスロジックは影響を受けないようにしよう」ということです。データがどこに、どのように保存されているかは、ビジネスルール（中心）が知るべきことではありません。

### 🤔 なぜ重要か？

データベース技術も、フレームワークと同様に変化が激しく、特定のデータベースにビジネスロジックが依存していると、以下のような問題が発生します。

1. **DB移行の困難化**:
パフォーマンスやコスト、機能要件の変化により、データベースを変更したい（例：MySQLからPostgreSQLへ、RDBからNoSQLへ）と思っても、ビジネスロジックにDB固有のコード（SQL方言、特定のドライバAPI）が混入していると、移行が非常に困難または不可能になります。
2. **ベンダーロックイン**:
特定のデータベース製品（特に商用DB）に深く依存すると、そのベンダーの意向（ライセンス変更、サポート終了など）に振り回されやすくなります。
3. **ビジネスロジックの汚染**:
SQL文字列やORM固有のクエリメソッドが `UseCase` や、最悪の場合 `Entity` に混入し、本来のビジネスルールが読み取りにくくなったり、特定のDBなしでは理解・テストできなくなったりします。
4. **テストの困難化**:
ビジネスロジックをテストするために、実際のデータベースを起動・接続する必要が出てきてしまい、単体テストが遅く、不安定になり、環境構築も複雑になります。

データベースから独立することで、ビジネスロジックという**システムの核**を、データ永続化という**技術的な詳細**から守り、長期的な保守性・拡張性を確保できます。

---

## ✅ これまでの実践例（どこで使ったか）

私たちは、**リポジトリパターン (Repository Pattern)** と **インターフェース** を活用することで、データベース独立性を実現してきました。

### 📌 リポジトリパターンの適用 (第1巡〜第5巡)

- **具体例**: 各サービスで、データの永続化アクセスを抽象化する「リポジトリ」を導入しました（例: `WorldModelRepositoryInterface`, `BookRepositoryInterface`）。
- **実践**: `UseCase` は、具体的なデータベース操作（`INSERT`, `SELECT`, `db.collection.find()` など）を直接実行する代わりに、リポジトリインターフェースのメソッド（`save()`, `get()`, `find_by_id()` など）を呼び出しました。`UseCase` は、データがメモリ上にあるのか、ファイルにあるのか、MongoDBにあるのかを知る必要はありませんでした。データアクセスに関する「関心事」は、リポジトリの実装クラス（`Adapters`層）に完全に分離されました。
    
    ```
      UseCase -----> <I> Repository Interface <----- Repository Implementation (Adapter)
                 (depends on)                     (implements)
                                             (DBアクセス詳細を隠蔽)
    
    ```
    

### 📌 依存性のルールによる隔離 (第1巡〜第5巡)

- **具体例**: 「依存性は常に外側から内側へ」というルールを徹底しました。
- **実践**: データベースドライバ（`pymongo` など）やORM（SQLAlchemyなど）は、`Adapters`層（またはFrameworks & Drivers層）に属します。`UseCase` や `Entity`（内側）は、これらの具体的なライブラリを `import` せず、依存性のルールによって隔離されました。

### 📌 (参考) 第2巡 図書館システム

- **具体例**: データ保存先をインメモリ（リスト）からMongoDBに変更するシナリオを考えました。
- **実践**: `BookRepositoryInterface` は変更せず、`InMemoryBookRepository` に加えて `MongoBookRepository` を `Adapters` 層に**追加**し、`main.py` で注入するクラスを差し替えるだけで、`UseCase` に影響を与えずにデータベースを変更できることを確認しました（オープン/クローズドの原則）。

---

## ❌ 間違った適用例（アンチパターン）

データベース独立性が低いコードは、特定のDB技術に縛られ、テストや移行が困難になります。

- **例1：UseCase内にSQL文字列やDBドライバAPIが混在する**
（関心の分離アンチパターン1と同じ例です）
    
    ```python
    # アンチパターン：UseCaseがDBに依存
    # import mysql.connector # 👈 DBドライバ(外側)をUseCase(内側)がimport
    
    class RegisterUserUseCase:
        def handle(self, user_data):
            # UseCaseが直接DB接続やSQL実行を行っている！
            # cnx = mysql.connector.connect(...)
            # cursor = cnx.cursor()
            # query = ("INSERT INTO users (name, email) VALUES (%s, %s)")
            # cursor.execute(query, (user_data['name'], user_data['email']))
            # cnx.commit()
            # ...
            pass
    
    ```
    
    この `UseCase` は、MySQLという特定のデータベースとそのドライバに強く依存しています。PostgreSQLに変えるだけでも、`import` 文から接続方法、SQLの（微妙な）方言まで、多くの修正が必要になります。テストには実際のMySQLデータベースが必要です。
    
- **例2：EntityがORMのアクティブレコードパターンを採用する**
アクティブレコードパターンは、データとそのデータ操作（CRUD）を一つのオブジェクトにまとめる設計ですが、Entityが永続化の責務を持つことになり、DB独立性を損なう可能性があります。
    
    ```python
    # アンチパターン：Entityが永続化ロジックを持つ (Active Record風)
    # from some_orm import ActiveRecordBase, Column ...
    
    # class User(ActiveRecordBase): # 👈 ORMの基底クラスを継承
    #     name = Column(...)
    #     email = Column(...)
    
    #     def is_valid(self): # ビジネスルール
    #         return "@" in self.email
    
    #     def save_to_db(self): # 👈 NG! Entityが永続化の責務を持っている
    #         # self.session.add(self)
    #         # self.session.commit()
    #         pass
    
    #     @classmethod
    #     def find_by_id_from_db(cls, user_id): # 👈 NG! Entityが検索の責務を持っている
    #         # return cls.session.query(cls).get(user_id)
    #         pass
    
    ```
    
    この `User` Entityは、ビジネスルール（`is_valid`）だけでなく、データベースへの保存（`save_to_db`）や検索（`find_by_id_from_db`）の責務まで持っています。ORMやデータベース接続（`session`）の詳細に依存してしまい、テストも困難になります。
    
    **改善策**: Entityは純粋なデータとビジネスルールだけを持ちます（POPO/POJO）。永続化の責務はリポジトリパターン（Adapters層）に分離します。
    

---

## 📝 まとめ

データベース独立性は、「**ビジネスロジックを、データが『どこに』『どうやって』保存されるかという詳細から守る**」ための原則です。

データベースは強力なツールですが、それはあくまで永続化という「関心事」を実現するための「詳細」の一つです。クリーンアーキテクチャの**リポジトリパターン**と**依存性のルール**に従い、データベースへの依存を**Adapters層**に閉じ込めることで、将来のデータベース変更に柔軟に対応でき、テスト容易性の高いシステムを構築することができます。

---

## ➡️ 次へ

次は、これまで `Adapters` 層の一部としてまとめて扱ってきた要素の中から、「**(9/10) Presenters / Controllers**」の役割について、もう少し詳しく見ていきましょう。