# 10 DTO

# 🏛️ DTO (Data Transfer Objects)

クリーンアーキテクチャのレイヤー間、特に **Use Cases 層**と **Interface Adapters 層**（Controllers, Presenters, Gateways）の間でデータをやり取りする際に使われる単純なデータ構造が「**DTO (Data Transfer Object)**」です。

---

## ❓ 定義

> プロセス（レイヤーやサービス）間でデータを運ぶための（通常は振る舞いを持たない）オブジェクト。
> 
> 
> \--- (一般的な定義、Martin Fowler らによる解説に基づく)
> 

DTO は、単にデータを保持し、転送することだけを目的とした、シンプルな構造（多くの場合、単純なクラスや辞書）です。**ビジネスロジック（メソッド）は持ちません**。

### 💡 簡単に言うと

レイヤー間を移動するデータの「**運び屋**」あるいは「**小包**」のようなものです。中身（データ）を運ぶだけで、自分で何か複雑な仕事（ロジック）はしません。

### 🤔 なぜ重要か？

DTO を使う主な目的は、レイヤー間の**結合度を下げる**ことです。

1. **内部構造の隠蔽**:
例えば、`UseCase` が `Entity` オブジェクトをそのまま `Presenter` に渡すと、`Presenter`（外側）が `Entity`（内側）の内部構造（すべての属性やメソッド）を知ってしまいます。DTO を間に挟むことで、`Presenter` は `UseCase` が渡したいデータだけを受け取り、`Entity` の詳細を知る必要がなくなります。
2. **インターフェースの安定化**:
`Entity` はビジネスルールの変更によって内部構造が変わることがあります。もし `Presenter` が `Entity` に直接依存していると、`Entity` の変更が `Presenter` の修正を引き起こします。DTO を使うことで、`Entity` の内部変更が外側の層に波及するのを防ぐ「緩衝材」の役割を果たします。
3. **関心の分離**:
データの「転送」という関心事を DTO が担うことで、`Entity` は純粋なビジネスルールに、`UseCase` はビジネスフローに、`Presenter`/`Controller` はデータ変換に、それぞれ集中できます。
4. **シリアライズの容易化**:
DTO は単純なデータ構造なので、JSON や Protobuf など、ネットワーク転送やファイル保存のための形式への変換（シリアライズ）が容易です。

---

## ✅ これまでの実践例（どこで使ったか）

私たちは、DTO を明示的に定義する場面は少なかったかもしれませんが、その考え方は随所に現れていました。

### 📌 UseCase の入力データ (第1巡〜第5巡)

- **具体例**: `UseCase` の `handle()` メソッドが受け取るデータ（例：`order_data`）。
- **実践**: これらは多くの場合、`Controller` が HTTP リクエストなどから抽出・変換した単純な辞書やデータクラスであり、DTO の役割を果たしていました。`UseCase` は、フレームワークの `Request` オブジェクトのような複雑なものではなく、必要なデータだけが詰められたシンプルな DTO を受け取ることで、入力の詳細から独立していました。

### 📌 UseCase の出力データ (概念)

- **具体例**: `UseCase` が処理結果として返すデータ。
- **実践**: 今回の例では `UseCase` が `Entity` (`WorldModel`, `ParkingPlan`) を直接返す場面もありました。これは、`Entity` 自体が比較的シンプルで、かつその情報がそのまま次の層（Adapter や次の Service）で必要だったため、許容される場合もあります。
しかし、より厳密に関心を分離する場合や、`Entity` が複雑な内部状態を持つ場合は、`UseCase` は `Entity` の中から必要な情報だけを抽出した DTO を作成し、それを `Presenter` や `Adapter` に渡す方が望ましい設計となります。
    
    ```python
    # UseCase内 (より厳密な例)
    def handle(self, input_dto: InputData) -> OutputData: # 👈 DTOで返す
        # ... ビジネスロジック ...
        result_entity = ... # Entityを操作
    
        # Entityから必要な情報だけを抽出してDTOを作成
        output_dto = OutputData(
            relevant_info=result_entity.get_some_data(),
            status_message="Success"
        )
        return output_dto
    
    ```
    

### 📌 サービス間連携データ (第4巡, 第5巡)

- **具体例**: `WorldModel` や `ParkingPlan` が JSON としてファイルや MQTT で送受信されました。
- **実践**: これらの JSON データは、サービス間でデータを転送するための DTO と見なすことができます。各サービスは、相手のサービスの内部実装（`UseCase` や `Repository`）を知ることなく、合意された DTO（JSON のスキーマ）に基づいてデータをやり取りしました。`Adapter` 層が Entity と DTO（JSON）の相互変換を担当しました。

---

## ❌ 間違った適用例（アンチパターン）

DTO の使い方を誤ると、かえって複雑さを増したり、利点を失ったりすることがあります。

- **例1：DTO にビジネスロジックを含める**
    
    ```python
    # アンチパターン：ロジックを持つDTO
    @dataclass
    class OrderDTO:
        order_id: int
        items: List[dict]
        total_price: float = 0.0 # データのみを持つべき
    
        # NG! DTOがビジネスロジック(価格計算)を持っている！
        # def calculate_total_price(self):
        #     self.total_price = sum(item['price'] * item['quantity'] for item in self.items)
        #     # 割引ルールなどもここに入ってしまうとEntityの役割を侵食する
    
    ```
    
    DTO は単なるデータの「入れ物」であるべきです。価格計算やバリデーションといったビジネスロジックは `Entity` や `UseCase` が担当すべきです。
    
- **例2：あらゆる場面で Entity の代わりに DTO を使いすぎる**
DTO はレイヤー境界での結合度を下げるために有効ですが、`UseCase` の内部で `Entity` を使うべき場面でまで DTO を使うと、`Entity` が持つドメインロジック（メソッド）を利用できなくなったり、`Entity` と DTO の間の冗長な変換コードが増えすぎたりする可能性があります。DTO は主に「境界を越える」ときに使うもの、と考えるのが基本です。
- **例3：内部 Entity をそのまま API レスポンスにしてしまう**`UseCase` が内部で使っている `Entity` オブジェクトを、そのまま（シリアライズして）Web API のレスポンスとして返してしまう場合です。
    
    ```python
    # アンチパターン：内部Entityの漏洩
    # @app.get("/users/{user_id}")
    # def get_user(user_id: int):
    #     use_case = GetUserUseCase(...)
    #     user_entity = use_case.handle(user_id) # User Entity (内部表現) を受け取る
    
    #     # NG! Entityをそのまま返す -> パスワードハッシュなど不要/危険な情報も漏洩する可能性
    #     return user_entity
    
    ```
    
    `User` Entity には、パスワードのハッシュ値や内部的なフラグなど、API の利用者に見せるべきでない情報が含まれている可能性があります。`Presenter`（または Controller/ハンドラ）が `Entity` から必要な情報だけを抽出した DTO (例: `UserResponseDTO`) を作成し、それを返すようにすべきです（関心の分離）。
    

---

## 📝 まとめ

DTO は、クリーンアーキテクチャの**レイヤー境界**（特に UseCase と Adapters の間）でデータを安全かつ効率的に転送するためのシンプルな「**データキャリア**」です。

DTO を適切に使うことで、

- レイヤー間の**結合度を下げ**、
- 内部実装の**詳細を隠蔽**し、
- インターフェースを**安定**させ、
- **関心の分離**を促進します。

ただし、DTO はロジックを持たず、主に境界を越える際に使うという点を意識することが重要です。

---

## ✅ クリーンアーキテクチャ復習完了！

これで、クリーンアーキテクチャの核心となる10個の原則・実践事項の復習が終わりました。

1. **依存性のルール**: 内側は外側を知らない。
2. **レイヤー構造**: 関心事で層を分ける。
3. **境界インターフェース**: 層の間はインターフェースで繋ぐ。
4. **関心の分離**: 混ぜるな危険。
5. **テスト容易性**: 部品ごとにテストしやすくする。
6. **フレームワーク独立性**: 道具に依存しない。
7. **UI独立性**: 見た目に依存しない。
8. **データベース独立性**: 保存場所に依存しない。
9. **Presenters / Controllers**: 入出力の変換役。
10. **DTO**: レイヤー間のデータの運び屋。

これらは、私たちが第1巡から第5巡まで実践してきたことの理論的な裏付けとなります。これらの原則を理解し、意識することで、今後さらに堅牢で保守しやすいソフトウェアを設計・開発していくことができるでしょう。