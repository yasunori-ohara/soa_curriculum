# 03 L：リスコフの置換原則

# 🏛️ 理論編：SOLID原則（L）- リスコフの置換原則

SOLID原則の3番目は、「**L：リスコフの置換原則 (Liskov Substitution Principle)**」です。これは、オブジェクト指向の「継承」を正しく使うための、少し難解ですが重要な原則です。
以降、この原則を **LSP** と呼びます。

---

## ❓ 原則の定義

> 「もしSがTのサブタイプならば、プログラム内でT型のオブジェクトが使われている箇所は全て、S型のオブジェクトで置換可能でなければならない。その際にプログラムの振る舞いを変えてはならない。」
> 
> 
> \--- Barbara Liskov
> 

### 💡 簡単に言うと

「親クラス（基底型）の代わりに子クラス（派生型）を使っても、プログラムが期待通りに動き続けなければならない」ということです。子クラスは、親クラスの「ルール（振る舞い）」を破ってはいけません。

### 🤔 なぜ重要か？

LSPが守られていない継承関係（親子関係）があると、以下のような問題が発生します。

1. **予期せぬ動作**:
親クラスのつもりで子クラスのオブジェクトを使ったら、想定外の動きをしてバグの原因になります。
2. **ポリモーフィズムの破綻**:
ポリモーフィズム（親クラスの型で、様々な子クラスのオブジェクトを統一的に扱える性質）がうまく機能しなくなります。
3. **条件分岐の増加**:
「もしこのオブジェクトが『特別な子クラス』だったら…」のような `if` 文（型チェック）がコード中に増え、オープン/クローズドの原則(OCP)にも違反しやすくなります。

LSPは、「継承を使うなら、ちゃんと『is-a』（〜は〜の一種である）関係を守り、親のルールを引き継ぎなさい」と要求する原則です。

---

## ✅ これまでの実践例（どこで使ったか）

私たちは、具象クラス（具体的な実装を持つクラス）同士の継承をあまり使わず、主に**抽象基底クラス (ABC) によるインターフェースの実装**を活用してきました。これはLSPの問題を回避する上で非常に有効な戦略でした。

### 📌 インターフェースの実装 (第1巡〜第5巡)

- **具体例**: `MqttWorldModelPublisher` クラスは `PlanningServiceAdapterInterface` という**インターフェース (ABC)** を実装しました。
- **なぜLSPか**: `UpdateWorldModelUseCase` は `PlanningServiceAdapterInterface` 型のオブジェクトを期待していました。そこに `MqttWorldModelPublisher` のインスタンスが渡されても、`UseCase` は問題なく動作しました。なぜなら、`MqttWorldModelPublisher` はインターフェースで定義された `publish_world_model()` メソッドの「契約（＝WorldModelを外部に公開する）」を**正しく守っていた**からです。
もし `MqttWorldModelPublisher` の `publish_world_model()` が、実際にはデータを公開せず、ログに出力するだけ、あるいは全く違う処理をするような実装だったら、それはインターフェースの「契約」を破っており、LSP違反となります。
    
    ```
          UseCase -----> <I> PlanningServiceAdapterInterface
                              ^
                              | (implements)
                              +---- MqttWorldModelPublisher (契約を守る実装)
    
    ```
    

### 📌 抽象化による振る舞いの統一

- **具体例**: `UseCase` が依存する `SensorInterface` や `WorldModelRepositoryInterface` も同様です。
- **なぜLSPか**: `UseCase` はこれらのインターフェースを通じて、具体的な実装（`StubSensorAdapter` や `InMemoryWorldModelRepository`）とやり取りしました。これらのアダプタクラスは、インターフェースで定義されたメソッド（`get_camera_image()`, `save()` など）の**期待される振る舞い**（データを取得する、データを保存する）を正しく実装していたため、`UseCase` はアダプタの種類に関わらず（置換しても）一貫した動作を期待できました。

---

## ❌ 間違った適用例（アンチパターン）

LSPに違反する最も有名な例は「正方形と長方形」の問題です。

- **例1：正方形は長方形か？ (Square/Rectangle Problem)**
数学的には「正方形は長方形の一種 (is-a)」なので、クラス継承を使いたくなります。
    
    ```python
    # アンチパターン：LSP違反の継承
    class Rectangle:
        def __init__(self, width: float, height: float):
            self._width = width
            self._height = height
    
        def set_width(self, width: float):
            self._width = width
    
        def set_height(self, height: float):
            self._height = height
    
        def get_area(self) -> float:
            return self._width * self._height
    
    class Square(Rectangle):
        # 正方形は幅と高さが常に等しい
        def __init__(self, size: float):
            super().__init__(size, size)
    
        # 親クラスの振る舞いを変更（ルールを破る）
        def set_width(self, width: float):
            self._width = width
            self._height = width # 幅を変えたら高さも変わる！
    
        def set_height(self, height: float):
            self._width = height # 高さを変えたら幅も変わる！
            self._height = height
    
    # --- この関数は Rectangle を期待している ---
    def print_area_after_resize(rect: Rectangle, new_width: float, new_height: float):
        # この関数を書いた人は、幅と高さを独立して変更できると期待している
        rect.set_width(new_width)
        rect.set_height(new_height)
        # 期待する面積: new_width * new_height
        print(f"Expected area: {new_width * new_height}")
        print(f"Actual area: {rect.get_area()}")
    
    # --- 使ってみる ---
    rectangle = Rectangle(2, 3)
    square = Square(5)
    
    print("Resizing Rectangle:")
    print_area_after_resize(rectangle, 4, 6)
    # Expected area: 24
    # Actual area: 24  <-- OK!
    
    print("\\nResizing Square (as Rectangle):")
    print_area_after_resize(square, 4, 6)
    # Expected area: 24
    # Actual area: 36  <-- NG! 期待と違う！ (set_height(6)で幅も6になったため)
    
    ```
    
    `Square` クラスは、親クラス `Rectangle` の「幅と高さを独立して設定できる」という\*\*暗黙のルール（不変条件）\*\*を破っています。そのため、`Rectangle` 型として `Square` オブジェクトを使うと、予期せぬ動作（面積が期待通りにならない）を引き起こしました。これは典型的なLSP違反です。継承すべきではありませんでした。
    
- **例2：メソッドの事前条件を強める / 事後条件を弱める**
子クラスが親クラスのメソッドをオーバーライドする際に、
    - **事前条件 (Precondition) を強める**: 親クラスよりも「厳しい」引数しか受け付けなくなる。（例：親はintを受け付けるのに、子は正のintしか受け付けない）
    - **事後条件 (Postcondition) を弱める**: 親クラスよりも「緩い」結果しか保証しなくなる。（例：親はソート済みリストを返すと約束していたのに、子は未ソートリストを返すことがある）
    これらもLSP違反となります。親クラスを使っていたコードが、子クラスで動かなくなる可能性があるためです。

---

## 📝 まとめ

リスコフの置換原則(LSP)は、「**継承を使うなら、子クラスは親クラスの『ふり』をし続けなければならない**」というルールです。親クラスの期待される振る舞いや契約を、子クラスが破ってはいけません。

この原則を守ることで、ポリモーフィズムが正しく機能し、安全で予測可能なコードを書くことができます。

現実的には、具象クラスの継承はLSP違反を引き起こしやすいため、今回のカリキュラムのように**インターフェース（ABC）に対する実装**を使う方が、多くの場合でより安全で柔軟な設計となります。

---

## ➡️ 次へ

次は、SOLID原則の4番目、「**I：インターフェース分離の原則**」について見ていきましょう。