# 01 S：単一責任の原則

# 🏛️ 理論編：SOLID原則（S）- 単一責任の原則

これまでの5つのプロジェクト（ToDoから自動駐車v2まで）で、私たちは意識せずとも、オブジェクト指向設計における非常に重要な5つの原則、SOLID原則を実践してきました。

このページでは、最初の原則である「**S：単一責任の原則 (Single Responsibility Principle)**」について、これまでの実践例を振り返りながら深く理解していきます。

---

## ❓ 原則の定義

> 「クラス（やモジュール、関数）を変更する理由は、一つだけでなければならない。」
> 
> 
> \--- Robert C. Martin
> 

### 💡 簡単に言うと

「一つの部品（クラスや関数）には、一つの役割（責任）だけを持たせよう」ということです。

### 🤔 なぜ重要か？

一つの部品が複数の異なる責任を持つと、以下のような問題が発生しやすくなります。

1. **変更の影響範囲が広がる**:
一方の責任に関する変更が、もう一方の責任（関係ないはずの機能）に予期せぬ影響（バグ）を与える可能性があります。
2. **コードの複雑化**:
多くの責任を持つ部品は、必然的にコードが長くなり、理解するのが難しくなります。
3. **テストの困難化**:
複数の責任が絡み合っていると、特定の責任だけを分離してテストすることが難しくなります。
4. **再利用性の低下**:
「Aの責任」だけを使いたいのに、「Bの責任」も一緒に付いてきてしまうため、部品の再利用がしにくくなります。

---

## ✅ これまでの実践例（どこで使ったか）

私たちは、クリーンアーキテクチャ(CA)やサービス指向アーキテクチャ(SOA)を実践する中で、自然とこの単一責任の原則を適用してきました。

### 📌 クラスレベルでの実践

- **アダプタの分離 (第5巡)**:
認識サービスにおいて、世界モデルをファイルに書き出す責任を持つ `FileWorldModelPublisher` と、MQTTブローカーに公開する責任を持つ `MqttWorldModelPublisher` を明確に分けました。もし一つのクラスがファイルとMQTTの両方を扱っていたら、ファイルパスの変更がMQTTの接続処理に影響したり、その逆が起きたりする可能性があり、単一責任の原則に違反します。
- **UseCaseの責務限定 (第4巡, 第5巡)**:
`UpdateWorldModelUseCase` クラスは、「センサーデータを取得し、WorldModelを更新し、公開する」というアプリケーション固有の**ビジネスフローを実行する責任**だけを持ちました。具体的なセンサーの読み取り方（`StubSensorAdapter`）や、データの公開方法（`FileWorldModelPublisher` / `MqttWorldModelPublisher`）については一切関知しませんでした。これにより、UseCaseは純粋なビジネスロジックに集中できました。

### 📌 アーキテクチャレベルでの実践

- **クリーンアーキテクチャの各層 (第1巡〜第5巡)**:
CAの同心円構造（Entity, UseCase, Adapters）は、まさにこの原則の壮大な適用例です。
    - **Entity**: アプリケーションに依存しない、核となるビジネスルール（例: `WorldModel` の構造と更新ルール）。
    - **UseCase**: アプリケーション固有のビジネスフロー（例: センサーからデータを取ってきてEntityを更新し、Adapterに渡す）。
    - **Adapters**: 技術的な詳細（例: DBアクセス、ファイルI/O、MQTT通信、UI）。
    それぞれの層が明確に異なる責任を担うことで、変更の影響範囲を限定し、テスト容易性を高めています。
- **SOAのサービス分割 (第4巡, 第5巡)**:
自動駐車システム全体を、「認識」「経路計算」「制御」という3つの独立したサービスに分割しました。これも、システム全体を大きな「単一責任」の単位（それぞれの専門分野）に分割したと言えます。これにより、各サービスは自身の責務に集中でき、独立して開発・デプロイが可能になりました。

---

## ❌ 間違った適用例（アンチパターン）

単一責任の原則に違反すると、どのようなコードになってしまうのでしょうか？

- **例1：神クラス (God Class / Swiss Army Knife)**
一つのクラスが、あまりにも多くの、そして互いに関連性の低い責任を持ちすぎてしまう状態です。
    
    ```python
    # アンチパターン：神クラス
    class ParkingManager:
        def read_camera_sensor(self): # 責任1: センサー入力
            pass
        def detect_parking_space(self, image_data): # 責任2: 画像認識
            pass
        def calculate_optimal_path(self, world_model): # 責任3: 経路計算
            pass
        def control_steering(self, angle): # 責任4: ハードウェア制御
            pass
        def save_log_to_database(self, log_entry): # 責任5: ログ永続化
            pass
        # ... さらに多くのメソッド ...
    
    ```
    
    このようなクラスは、変更箇所が多岐にわたり、テストも非常に困難になります。どこかを修正すると、全く関係ない機能が壊れるリスクが高まります。
    
- **例2：ビジネスロジックとUIロジックの混在**
（第1巡でCAを導入する前の、シンプルなWebアプリケーションを想像してください）
Webフレームワーク（Flaskなど）のルートハンドラの中に、画面表示のためのHTML生成ロジックと、データベースからデータを取得・加工するビジネスロジックが混在している状態です。
    
    ```python
    # アンチパターン：UIとビジネスロジックの混在
    @app.route('/users/<user_id>')
    def show_user_profile(user_id):
        # 責任1: データ取得 (ビジネスロジック)
        user = db.get_user(user_id)
        if not user:
            abort(404)
    
        # 責任2: データ加工 (ビジネスロジック)
        display_name = user.last_name + " " + user.first_name
        registration_date_str = user.registered_at.strftime('%Y-%m-%d')
    
        # 責任3: HTML生成 (UIロジック)
        html = f"<h1>{display_name}</h1>"
        html += f"<p>Registered: {registration_date_str}</p>"
        # ...
        return html
    
    ```
    
    UIのデザインを変更したいだけなのに、データ取得や加工のロジックまで触る必要が出てきたり、その逆が起きたりします。テストも困難です。
    
- **例3：データ取得とフォーマットを兼ねる関数**
関数レベルでも、単一責任は重要です。
    
    ```python
    # アンチパターン：複数責任を持つ関数
    def get_and_format_user_data(user_id):
        # 責任1: データ取得
        user = db.get_user(user_id)
        if not user:
            return "Error: User not found"
    
        # 責任2: 文字列フォーマット
        return f"User: {user.name}, Email: {user.email}"
    
    ```
    
    この関数は、「ユーザーデータを取得する」責任と「それを特定の文字列形式にフォーマットする」責任の2つを持っています。もしフォーマットだけを変更したい場合や、取得したデータを別の形式で使いたい場合に、この関数は再利用しにくくなります。「取得する関数」と「フォーマットする関数」に分けるべきです。
    

---

## 📝 まとめ

単一責任の原則は、ソフトウェアの構成要素（クラス、関数、モジュール、サービス）を**小さく、目的に特化**させ続けるための基本原則です。

「変更する理由が一つだけ」になるように責任を分割することで、コードは**理解しやすく**、**テストしやすく**、そして**変更に強く**なります。

クリーンアーキテクチャの層分離や、SOAのサービス分割は、この原則を大規模なレベルで適用するための強力なパターンと言えます。

---

## ➡️ 次へ

次は、SOLID原則の2番目、「**O：オープン/クローズドの原則**」について見ていきましょう。