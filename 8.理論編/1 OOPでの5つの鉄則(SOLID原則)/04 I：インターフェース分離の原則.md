# 04 I：インターフェース分離の原則

はい、承知いたしました。
SOLID原則の4番目、「I：インターフェース分離の原則」のページを作成します。

---

# 🏛️ 理論編：SOLID原則（I）- インターフェース分離の原則

SOLID原則の4番目は、「**I：インターフェース分離の原則 (Interface Segregation Principle)**」です。これは、インターフェース（APIや抽象クラス）を適切に設計するための重要な指針です。
以降、この原則を **ISP** と呼びます。

---

## ❓ 原則の定義

> 「クライアント（利用側）に、自身が利用しないメソッドへの依存を強制されるべきではない。」
> 
> 
> \--- Robert C. Martin
> 

### 💡 簡単に言うと

「インターフェース（窓口）は、役割ごとに小さく、目的に特化させよう」ということです。一つの「何でもできる」巨大なインターフェースを作るのではなく、必要な機能だけを持つインターフェースを複数作りましょう。

### 🤔 なぜ重要か？

ISPが守られていない、いわゆる「**太ったインターフェース (Fat Interface)**」には、以下のような問題があります。

1. **不要な実装の強制**:
インターフェースを実装するクラスは、たとえ自分には不要なメソッドであっても、インターフェースに含まれる全てのメソッドを実装しなければなりません（例：空のメソッドや `NotImplementedError` を投げる実装が増える）。
2. **不要な依存の発生**:
インターフェースを利用するクライアントは、自分が使わないメソッドが変更されただけでも、再コンパイルや再テストが必要になる可能性があります。
3. **理解・利用の困難化**:
インターフェースが巨大だと、そのインターフェースが持つ「責任」が曖昧になり、利用者がどのメソッドを使えばよいのか理解しにくくなります。

ISPに従いインターフェースを小さく分割することで、各部品の**凝集度**（関連性の高さ）を高め、**結合度**（依存関係）を低く保つことができます。

---

## ✅ これまでの実践例（どこで使ったか）

私たちは、クリーンアーキテクチャ(CA)を実践する中で、UseCaseが必要とするインターフェースを自然と分離していました。

### 📌 UseCaseの依存インターフェース分離 (第4巡, 第5巡)

- **具体例**: `UpdateWorldModelUseCase`（認識サービス）は、以下の3つの独立したインターフェースに依存していました。
    - `SensorInterface`: センサー入力用
    - `PlanningServiceAdapterInterface`: サービス間出力用
    - `WorldModelRepositoryInterface`: 内部状態アクセス用
- **なぜISPか**: もしこれらを「`PerceptionDependencies`」のような一つの巨大なインターフェースにまとめていたらどうでしょうか？
この `PerceptionDependencies` インターフェースを実装するクラスは、センサー、出力、リポジトリの機能をすべて実装しなければなりません。また、例えばセンサー機能だけを使いたい別の `UseCase` があったとしても、この巨大なインターフェース全体に依存しなければならず、不要な `publish` や `repo` のメソッドにも依存することになってしまいます。
インターフェースを `SensorInterface`, `PlanningServiceAdapterInterface`, `WorldModelRepositoryInterface` と役割ごとに**小さく分離**したことで、各UseCaseは本当に必要な機能（メソッド）だけに依存し、実装クラスも自身の責任範囲だけを実装すればよくなりました。
    
    ```python
    # アンチパターン：太ったインターフェース
    class PerceptionDependencies(ABC):
        @abstractmethod
        async def get_camera_image(self): pass # センサー機能
        @abstractmethod
        async def get_sonar_readings(self): pass # センサー機能
        @abstractmethod
        async def publish_world_model(self, model): pass # 出力機能
        @abstractmethod
        def get_world_model_from_repo(self): pass # リポジトリ機能
        @abstractmethod
        def save_world_model_to_repo(self, model): pass # リポジトリ機能
    
    ```
    

### 📌 ライブラリやフレームワークのインターフェース

- **具体例**: （直接コードには書きませんでしたが）私たちが利用した `paho-mqtt` ライブラリも、ISPの良い例です。MQTTクライアントには `connect()`, `disconnect()`, `publish()`, `subscribe()`, `loop_start()` など多くの機能がありますが、コールバック（イベントハンドラ）として提供されるインターフェースは `on_connect`, `on_disconnect`, `on_message` など、イベントごとに分離されています。利用者は、必要なイベントに対するコールバック関数だけを実装（または設定）すればよく、すべてのイベント処理を一つの巨大な関数で実装する必要はありません。

---

## ❌ 間違った適用例（アンチパターン）

ISPに違反する「太ったインターフェース」の例を見てみましょう。

- **例1：多機能プリンターインターフェース**
印刷、スキャン、FAX送信の機能を持つ多機能プリンターを操作するインターフェースを考えます。
    
    ```python
    # アンチパターン：太ったプリンターインターフェース
    class MultiFunctionPrinterInterface(ABC):
        @abstractmethod
        def print_document(self, doc): pass
        @abstractmethod
        def scan_document(self): pass
        @abstractmethod
        def fax_document(self, doc, number): pass
    
    class SimplePrinter(MultiFunctionPrinterInterface):
        # このプリンターは印刷しかできないのに...
        def print_document(self, doc):
            print(f"Printing {doc}...")
    
        # 不要なメソッドも実装を強制される！
        def scan_document(self):
            raise NotImplementedError("This printer cannot scan.")
    
        def fax_document(self, doc, number):
            raise NotImplementedError("This printer cannot send fax.")
    
    # --- 利用側のコード ---
    def use_printer(printer: MultiFunctionPrinterInterface, document):
        # 印刷機能だけを使いたいのに、インターフェースには scan や fax も見える
        printer.print_document(document)
        # printer.scan_document() # 呼び出せてしまうが、SimplePrinterだとエラーになる！
    
    ```
    
    印刷機能しか持たない `SimplePrinter` クラスも、`scan_document` や `fax_document` を（エラーを投げる形で）実装しなければなりません。また、利用側の `use_printer` 関数は、印刷機能しか使わないにも関わらず、スキャンやFAXのメソッドも「見える」インターフェースに依存しています。
    
    **改善策（ISP適用）**: 役割ごとにインターフェースを分離する。
    
    ```python
    # ISP適用例：インターフェースを分離
    class PrinterInterface(ABC):
        @abstractmethod
        def print_document(self, doc): pass
    
    class ScannerInterface(ABC):
        @abstractmethod
        def scan_document(self): pass
    
    class FaxInterface(ABC):
        @abstractmethod
        def fax_document(self, doc, number): pass
    
    # シンプルプリンターは印刷インターフェースだけを実装すれば良い
    class SimplePrinter(PrinterInterface):
        def print_document(self, doc):
            print(f"Printing {doc}...")
    
    # 多機能プリンターは複数のインターフェースを実装する
    class MultiFunctionPrinter(PrinterInterface, ScannerInterface, FaxInterface):
        def print_document(self, doc): ...
        def scan_document(self): ...
        def fax_document(self, doc, number): ...
    
    # --- 利用側のコード ---
    # 印刷機能だけが必要な関数は、PrinterInterface にだけ依存する
    def use_printer(printer: PrinterInterface, document):
        printer.print_document(document)
        # printer.scan_document() # もう呼び出せない！安全。
    
    # スキャン機能が必要なら ScannerInterface に依存する
    def use_scanner(scanner: ScannerInterface):
        scanner.scan_document()
    
    ```
    
    インターフェースを役割ごとに分離したことで、`SimplePrinter` は不要なメソッドの実装を強制されなくなり、利用側の `use_printer` 関数も、本当に必要な `PrinterInterface` だけに依存するようになりました。
    

---

## 📝 まとめ

インターフェース分離の原則(ISP)は、「**インターフェースは、その利用者のニーズに合わせて、小さく保つべきである**」と教えてくれます。

「太ったインターフェース」は、不要な依存関係を生み出し、システムの柔軟性や保守性を損ないます。
インターフェースを設計する際は、「このインターフェースを使うクライアントは、本当にこれらのメソッドすべてを必要としているか？」と自問し、必要に応じてインターフェースを分割することを検討しましょう。

クリーンアーキテクチャで `UseCase` が依存する `Boundaries`（インターフェース群）を適切に分割することは、このISPを実践する上で非常に重要です。

---

## ➡️ 次へ

いよいよ最後の原則、SOLID原則の5番目、「**D：依存性逆転の原則**」について見ていきましょう。