# 4. 集約

# 🏛️ 戦術的設計：集約

DDD（ドメイン駆動設計）の戦術的設計において、「**集約 (Aggregate)**」は、**データの一貫性**を保つための境界を定義する、中心的なパターンです。エンティティ (Entity) と値オブジェクト (Value Object) をまとめ上げる単位となります。

---

## ❓ 集約とは？

> 関連するエンティティと値オブジェクトのまとまりであり、データ変更における一貫性の単位として扱われるもの。外部からのアクセスは、集約ルート (Aggregate Root) と呼ばれる特定のエンティティを通じてのみ行われる。
> 

### 💡 簡単に言うと

「**まとめて管理しないと話がおかしくなるモノたちのグループ**」のことです。例えば、「注文」とその「注文明細」は、別々に変更されると合計金額が合わなくなるかもしれません。だから、これらを一つの「注文集約」としてグループ化し、必ず「注文」（集約ルート）という窓口を通してのみ操作するようにします。

### 🤔 なぜ重要か？

ドメインモデルが複雑になると、関連するオブジェクトの状態を常に一貫性のある状態に保つのが難しくなります。集約は、この問題を解決するための強力な仕組みです。

1. **不変条件 (Invariants) の維持**:
集約は、「注文合計金額は、常に注文明細の合計と一致する」「在庫数はマイナスにならない」といった、常に守られるべきビジネスルール（＝**不変条件**）を保証するための境界となります。集約ルートが全ての変更の窓口となることで、これらのルールが破られないように制御します。
2. **トランザクション境界の明確化**:
集約への変更は、通常、**アトミック**（全て成功するか、全て失敗するかのどちらか）に行われるべきです。集約の境界は、データベーストランザクションの境界と一致することが多いです。
3. **所有権とライフサイクルの管理**:
集約ルートは、集約内部の他のオブジェクト（エンティティや値オブジェクト）のライフサイクル（生成や削除）を管理する責任を持ちます。
4. **複雑性の低減**:
システム全体を考える際に、個々の小さなオブジェクトではなく、より大きな単位である「集約」に注目することで、モデルの理解や操作が容易になります。

---

## 🧱 集約の構成要素

- **集約ルート (Aggregate Root)**:
集約の「代表」となる**エンティティ**。集約の唯一の入り口であり、外部のオブジェクトはこのルートを通じてのみ集約内部のオブジェクトにアクセスできます。集約ルートはグローバルなIDを持ちます。
- **内部エンティティ (Internal Entities)**:
集約ルートによって管理されるエンティティ。通常、集約内部でのみ一意なローカルIDを持ちます。（例：注文明細エンティティ。注文IDと明細番号で識別される）
- **値オブジェクト (Value Objects)**:
集約に含まれる値オブジェクト。（例：注文エンティティが持つ配送先住所の値オブジェクト）

<!-- end list -->

```
 +--------------------------+
 |   Order Aggregate        |  <-- 集約の境界
 | +----------------------+ |
 | | Order (Root Entity)  | |  <-- 集約ルート (グローバルIDを持つ)
 | | - orderId            | |
 | | - customerInfo (VO)  | |
 | | - shippingAddress(VO)| |
 | | - totalPrice (VO)    | |
 | | - status             | |
 | |                      | |
 | | - addItem()          | |  <-- 変更はルート経由
 | | - ship()             | |
 | +-------▲--------------+ |
 |         | (contains)     |
 | +-------|--------------+ |
 | | OrderItem (Entity)   | |  <-- 内部エンティティ (ローカルID)
 | | - itemId             | |
 | | - productId          | |
 | | - quantity (VO)      | |
 | | - unitPrice (VO)     | |
 | +----------------------+ |
 +--------------------------+

```

---

## ✅ これまでの実践例（どこで使ったか）

私たちの自動駐車システムは比較的シンプルだったため、厳密な「集約」を意識して設計する必要はありませんでした。しかし、その考え方の萌芽（ほうが）はありました。

### 📌 `WorldModel` と `ParkingPlan` (第4巡, 第5巡)

- **具体例**: `WorldModel` は `DetectedObject` や `ParkingSpace` のリストを持ち、`ParkingPlan` は `ControlCommand` のリストを持っていました。
- **実践**: これらは、暗黙的に一つの「集約」として機能していました。
    - `WorldModel` 全体が一つの単位として扱われ、`update_objects()` メソッドを通じて内部のオブジェクトリストが変更されました。外部から `DetectedObject` だけを直接変更するようなことはありませんでした。
    - 同様に `ParkingPlan` も、`add_command()` を通じて内部のコマンドリストが変更されました。
    これらは単純な例ですが、ルート（`WorldModel` や `ParkingPlan` 自体）を通して内部の状態を変更するという、集約の基本的な考え方を反映しています。

---

## ❌ 間違った適用例（アンチパターン）

集約のルールを破ると、データの一貫性が失われたり、モデルが不必要に複雑になったりします。

- **例1：集約の境界を越えて内部オブジェクトを直接変更する**
    
    ```python
    # アンチパターン：集約ルートを迂回する変更
    order = order_repository.find_by_id(order_id)
    first_item = order.items[0] # 集約内部のOrderItemを取得
    
    # NG! 集約ルート(Order)を通さずに、直接OrderItemの数量を変更！
    # first_item.set_quantity(new_quantity)
    
    # この後、order.total_price が古いままになってしまい、不整合が発生！
    # order_repository.save(order) # 不整合な状態で保存されてしまう
    
    ```
    
    `Order`（集約ルート）が持つべき「合計金額を再計算する」という不変条件を守るロジックが迂回されてしまい、データが壊れます。変更は必ず集約ルートのメソッド（例：`order.change_item_quantity(item_id, new_quantity)`）を通じて行うべきです。
    
- **例2：一つのトランザクションで複数の集約を変更する**
集約はトランザクションの境界となるべきです。もし一つのUseCaseやトランザクションで、複数の異なる集約（例：「注文」集約と「在庫」集約）を同時に変更する必要がある場合、それは集約の境界設定が間違っているか、あるいは「ドメインイベント」を使った結果整合性（Eventual Consistency）などを検討すべきサインかもしれません。
- **例3：集約が大きすぎる (God Aggregate)**
関連するものを何でもかんでも一つの巨大な集約（例：`Customer` 集約に、その顧客の全注文履歴、全サポート問合せ履歴、全支払い情報などを全て含める）にしてしまうと、その集約の読み込み・保存のコストが高くなり、複数ユーザーによる同時変更時の競合（ロック）も発生しやすくなります。集約は、一貫性を保つべき「最小限」の範囲に留めるべきです。
- **例4：集約間で直接オブジェクト参照を持つ**`Order` 集約が、`Product` 集約のインスタンスへの直接参照（メモリポインタやORMのリレーション）を持つべきではありません。他の集約を参照する場合は、その集約ルートの「ID」のみを持つべきです。
    
    ```python
    class Order:
        # def __init__(self, order_id, ..., product: Product): # 👈 NG! Product集約への直接参照
        #    pass
        def __init__(self, order_id, ..., product_id: ProductId): # 👍 OK! Product集約のIDのみを持つ
           self.product_id = product_id
           pass
    
    ```
    
    直接参照を持つと、`Order` を読み込む際に `Product` まで一緒に読み込む必要が出てきたり、依存関係が強くなったりします。他の集約の情報が必要な場合は、そのIDを使って別途リポジトリから取得します。
    

---

## 📝 まとめ

集約は、DDDの戦術的設計において**データの一貫性を保証するための重要な境界**です。

- **集約ルート**を通じてのみアクセス・変更を行う。
- 集約への変更は**トランザクション**として扱う。
- 集約は、一貫性を保つべき**最小限の単位**に留める。
- 他の集約への参照は**ID**で行う。

これらのルールを守ることで、ドメインモデルの整合性を保ち、複雑さを管理することができます。

---

## ➡️ 次へ

次は、集約の永続化を担う「**リポジトリ (Repository)**」について、CAでの実践と比較しながら復習しましょう。