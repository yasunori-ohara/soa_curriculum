# 7. ドメインサービス

# 🏛️ 戦術的設計：ドメインサービス

DDD（ドメイン駆動設計）の戦術的設計において、エンティティ (Entity) や値オブジェクト (Value Object) だけでは自然に表現できない、ドメイン固有の**プロセス**や**操作**が存在する場合があります。そのようなロジックの置き場所として、「**ドメインサービス (Domain Service)**」というパターンがあります。

---

## ❓ ドメインサービスとは？

> ドメインにおける重要なプロセスや操作であり、特定のエンティティや値オブジェクトの責務として自然に属さないもの。ドメインサービスは通常、ステートレス（状態を持たない）であり、そのインターフェース（メソッド）はユビキタス言語に基づいて定義される。
> 

### 💡 簡単に言うと

特定の「モノ」（エンティティや値オブジェクト）の仕事ではなく、「**複数のモノにまたがる活動**」や「**何かを変換するプロセス**」を表す、ドメイン層の部品です。多くの場合、動詞や動詞句で名前が付けられます（例: `TransferService`, `CurrencyConverter`）。

### 🤔 なぜ重要か？

すべてのドメインロジックをエンティティや値オブジェクトのメソッドとして実装しようとすると、不自然になったり、責務が曖昧になったりすることがあります。

1. **自然なモデリング**:
複数のエンティティが関わる操作（例：銀行口座間の資金移動）や、あるオブジェクトを別のオブジェクトに変換するプロセス（例：通貨換算）は、特定のエンティティの責務とするよりも、独立した「サービス」としてモデル化する方が自然な場合があります。
2. **エンティティ/値オブジェクトの責務の明確化**:
ドメインサービスを導入することで、エンティティや値オブジェクトは自身の状態とそれに関連する基本的な振る舞いに集中でき、単一責任の原則(SRP)を維持しやすくなります。
3. **関心の分離**:
複雑なドメインプロセスが、それを利用するアプリケーション層（UseCase）から分離され、ドメイン層（ビジネスルールの中核）の一部として明確に位置づけられます。
4. **再利用性の向上**:
複数の UseCase から共通して利用されるドメイン固有の計算やプロセスを、ドメインサービスとして一箇所にまとめることで、コードの重複を防ぎ、再利用性を高めます。

**注意**: 「ドメインサービス」は、インフラストラクチャ層のサービス（例：Email送信サービス、DBアクセスサービス）や、アプリケーション層のサービス（UseCase）とは異なります。ドメインサービスは、あくまで**ドメイン層**に属し、**ビジネスルール**の一部を表現します。

---

## ✅ これまでの実践例（どこで使ったか）

私たちの自動駐車システムは比較的シンプルだったため、明示的なドメインサービスは登場しませんでした。しかし、UseCase 内のロジックの一部は、ドメインサービスとして切り出すことも可能でした。

### 📌 (参考) UseCase内のアルゴリズム部分

- **具体例**: `CalculateParkingPlanUseCase` 内の `_run_planning_algorithm()` メソッド。
- **実践**: このメソッドは、`WorldModel`（入力）を受け取り、`ParkingPlan`（出力）を生成する、ドメイン固有の複雑な計算（今回はダミーでしたが）を行っていました。これは特定のエンティティの責務というよりは、「計画計算プロセス」そのものです。
もしこの経路計算アルゴリズムが他の UseCase からも利用される可能性がある場合や、アルゴリズム自体が非常に複雑で独立してテストしたい場合、これを `ParkingPlannerService` のようなドメインサービスとして切り出すことが考えられます。
このようにすることで、`UseCase` はビジネスフローの調整役に徹し、複雑なドメイン計算は `Domain Service` にカプセル化されます。
    
    ```python
    # domain/services.py (ドメインサービスを置く場所の例)
    class ParkingPlannerService:
        def calculate_plan(self, world_model: WorldModel) -> ParkingPlan:
            print("[Domain Service] Calculating parking plan...")
            # ... 複雑な経路計算アルゴリズム ...
            new_plan = ParkingPlan(...)
            # ... コマンドを追加 ...
            return new_plan
    
    # application/use_cases.py (UseCaseはドメインサービスを利用する)
    class CalculateParkingPlanUseCase:
        def __init__(self, ..., planner_service: ParkingPlannerService): # 👈 DIで受け取る
            ...
            self._planner_service = planner_service
    
        async def handle(self):
            world_model = await self._world_model_sub.get_world_model()
            ...
            # アルゴリズム実行をドメインサービスに委譲
            new_plan = self._planner_service.calculate_plan(world_model)
            ...
            await self._plan_pub.publish_plan(new_plan)
    
    ```
    

---

## ❌ 間違った適用例（アンチパターン）

ドメインサービスの概念を誤解すると、設計が歪んでしまう可能性があります。

- **例1：何でもドメインサービスにしてしまう（貧血ドメインモデルの助長）**
エンティティや値オブジェクトが持つべき基本的な振る舞いまで、すべてドメインサービスに移行してしまう。
    
    ```python
    # アンチパターン：貧血ドメインモデル + ドメインサービスの誤用
    
    # Order Entity (貧血)
    @dataclass
    class OrderEntity:
        order_id: int
        items: List[dict]
        total_price: float
        status: str
        # メソッドがない！
    
    # Order Domain Service (肥大化)
    class OrderService:
        def add_item(self, order: OrderEntity, item_data): # 本来OrderEntityのメソッド
            order.items.append(item_data)
            # order.total_price = self.calculate_total(order) # さらに別のメソッド呼び出し？
    
        def calculate_total(self, order: OrderEntity): # 本来OrderEntityのメソッド
            return sum(i['price'] * i['quantity'] for i in order.items)
    
        def ship_order(self, order: OrderEntity): # 本来OrderEntityのメソッド
             if order.status == 'PAID': order.status = 'SHIPPED'
    
        def apply_discount(self, order: OrderEntity, discount_code): # ドメインサービス向きかも？
             # ... 複数のEntity(Order, Coupon)が関わるなら ...
             pass
    
    ```
    
    エンティティが持つべき基本的な責務（アイテム追加、合計計算、状態変更）までドメインサービスが肩代わりしてしまっています。これは貧血ドメインモデルを助長し、オブジェクト指向の利点を失わせます。ドメインサービスは、エンティティや値オブジェクトに自然に属さない操作に限定すべきです。
    
- **例2：ドメインサービスが状態（ステート）を持つ**
ドメインサービスは、特定の操作を実行するための「動詞」であり、通常は状態（インスタンス変数）を持つべきではありません（ステートレス）。もし状態が必要なら、それはエンティティとしてモデル化すべきかもしれません。
- **例3：アプリケーションサービス（UseCase）との混同**
ドメインサービスは、あくまでドメイン層（ビジネスルール）の一部です。永続化（リポジトリの呼び出し）や外部サービス連携（通知アダプタの呼び出し）といった、アプリケーション層の関心事（UseCaseの責務）をドメインサービスが担当すべきではありません。

---

## 📝 まとめ

ドメインサービスは、DDDの戦術的設計において、「**特定のエンティティや値オブジェクトに属さない、ドメイン固有の重要なプロセスや操作**」をカプセル化するためのパターンです。

- **ステートレス**であるべき。
- **ドメイン層**に属する。
- インターフェース（メソッド）は**ユビキタス言語**で定義される。

適切に使うことで、エンティティや値オブジェクトの責務を明確に保ち、複雑なドメインロジックを自然な形でモデル化することができます。ただし、乱用すると貧血ドメインモデルを招く危険があるため、導入は慎重に行うべきです。

---

## ➡️ 次へ

次は、複雑なオブジェクト生成を担う「**ファクトリ (Factory)**」について見ていきましょう。