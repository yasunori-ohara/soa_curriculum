# 3. 値オブジェクト

# 🏛️ 戦術的設計：値オブジェクト

DDD（ドメイン駆動設計）の戦術的設計において、エンティティ (Entity) と対になる重要な概念が「**値オブジェクト (Value Object)**」です。これらを適切に使い分けることで、ドメインモデルはより表現豊かで堅牢になります。

---

## ❓ 値オブジェクトとは？

> 属性によって定義され、同一性（ID）を持たず、通常は\*\不変（Immutable）\\*であるオブジェクト。その値（属性）が等しければ、同じものとみなされる。
> 

### 💡 簡単に言うと

「それ自体が『何であるか』よりも、『**どんな値を持っているか**』だけが重要なモノ」のことです。例えば、「100円」という金額は、どの100円玉（個物）かは問題ではなく、「100円である」という値が重要です。「東京都中央区…」という住所も、その属性（都道府県、市区町村など）が同じであれば、同じ住所とみなされます。IDで区別する必要はありません。

### 🤔 なぜ重要か？

値オブジェクトを導入することで、多くのメリットがあります。

1. **表現力の向上**:
単なる基本型（文字列、数値）で表現していたドメインの概念（例：`email = "user@example.com"`）を、専用のクラス（`EmailAddress("user@example.com")`）として定義することで、コードの意図が明確になり、ドメインの知識がコードに直接反映されます。
2. **不変性 (Immutability)**:
値オブジェクトは通常、作成後にその状態（属性）を変更できない「不変」なものとして設計されます。これにより、意図しない副作用を防ぎ、オブジェクトを安全に共有・受け渡しできるようになります。値を変えたい場合は、新しい値オブジェクトを作成します。
3. **自己検証 (Self-validation)**:
値オブジェクトのコンストラクタ（`__init__`）やファクトリメソッドに、その値がドメインルール上「妥当」であるかの検証ロジック（例：メールアドレスの形式チェック、金額が負でないことのチェック）をカプセル化できます。これにより、不正な値を持つオブジェクトが存在できなくなり、システムの堅牢性が向上します。
4. **明確な等価性**:
値オブジェクトは属性がすべて等しければ「同じ」とみなされるため、比較（`==`）のロジックが明確になります。（Pythonの `dataclass(frozen=True)` などがこれを容易にします）

---

## ✅ これまでの実践例（どこで使ったか）

私たちは、明示的に「値オブジェクト」と呼ぶことは少なかったかもしれませんが、その考え方に近いものは使っていました。

### 📌 `ControlCommand` (第4巡, 第5巡)

- **具体例**: `domain/entities.py`（経路計算/車両制御サービス）で定義した `ControlCommand`。
    
    ```python
    @dataclass # (frozen=True を付けるとより値オブジェクトらしくなる)
    class ControlCommand:
        action: str
        value: float
        duration: float
    
    ```
    
- **実践**: このクラスは、「どんなアクションを、どのくらいの強さで、どれだけの時間行うか」という**属性の組み合わせ**によって定義されていました。個々の `ControlCommand` インスタンスをIDで区別する必要はなく、`action`, `value`, `duration` が同じであれば、同じコマンドとみなせます。まさに値オブジェクトの性質を持っています。

### 📌 基本型データ (第1巡〜第5巡)

- **具体例**: `WorldModel` の `timestamp` (datetime), `DetectedObject` の `position` (仮にタプル `(x, y)` とする), `ParkingSpace` の `size` (仮に `width`, `height` とする) など。
- **実践**: これらはPythonの組み込み型や標準ライブラリの型ですが、その使われ方は値オブジェクトの考え方に近いです。`timestamp` は特定の日時という「値」を表し、`position` や `size` も座標や寸法という「値」を表します。これらは通常、不変なものとして扱われます（例：`timestamp` を後から変更することはない）。DDDでは、これらの単純な値を専用の値オブジェクトクラス（例：`Position`, `Dimensions`）として定義することを推奨します。

### 📌 (参考) `RawImageData`, `SonarReading`

- **具体例**: 認識サービスの `domain/entities.py` で定義されたセンサー生データ。
- **実践**: これらも、特定の時点でのセンサー測定値という「値」を表しており、IDで区別されるものではありません。値オブジェクトとして設計することが可能です。（不変性や自己検証のルールを追加できる）

---

## ❌ 間違った適用例（アンチパターン）

値オブジェクトの概念を使わない、あるいは誤用すると、コードの可読性や安全性が低下します。

- **例1：プリミティブ型への執着 (Primitive Obsession)**
ドメインに明確な概念が存在するにも関わらず、それを専用のクラスとして定義せず、基本型（文字列、数値、真偽値）だけで表現しようとすること。
    
    ```python
    # アンチパターン：プリミティブ型への執着
    
    # Userクラス (Entity)
    class User:
        def __init__(self, user_id: int, email: str, phone_number: str, zip_code: str):
            # email, phone_number, zip_code がただの文字列！
            # 形式が正しいかの保証がない
            self.user_id = user_id
            self.email = email
            self.phone_number = phone_number
            self.zip_code = zip_code
    
    # 利用側
    # user = User(1, "invalid-email", "123", "abc") # 不正な値が入ってしまう！
    
    ```
    
    メールアドレス、電話番号、郵便番号は、それぞれ固有の形式（ルール）を持つドメイン概念です。これらを単なる `str` として扱うと、不正な値が混入しやすくなり、また、これらの値を扱うロジック（形式チェックなど）がコードのあちこちに散らばる原因になります。
    
    **改善策**: 専用の値オブジェクトを作成し、検証ロジックをカプセル化する。
    
    ```python
    # 改善例：値オブジェクトの導入
    @dataclass(frozen=True) # 不変にする
    class EmailAddress:
        value: str
        def __post_init__(self):
            # コンストラクタで形式を検証
            if "@" not in self.value:
                raise ValueError("Invalid email format")
    
    @dataclass(frozen=True)
    class ZipCode:
        value: str
        def __post_init__(self):
            # コンストラクタで形式を検証 (例: XXX-XXXX)
            if not (len(self.value) == 8 and self.value[3] == '-'):
                 raise ValueError("Invalid zip code format")
    
    class User:
         # 型ヒントがドメイン概念を表すように！
        def __init__(self, user_id: int, email: EmailAddress, ..., zip_code: ZipCode):
            self.user_id = user_id
            self.email = email # EmailAddress 型であることが保証される
            ...
            self.zip_code = zip_code # ZipCode 型であることが保証される
    
    # 利用側 (不正な値で User を作ろうとすると、値オブジェクトのコンストラクタでエラーになる)
    # email = EmailAddress("invalid-email") # ここで ValueError
    
    ```
    
- **例2：可変な値オブジェクト (Mutable Value Object)**
値オブジェクトを不変（Immutable）にせず、後から属性を変更できるようにしてしまう。
    
    ```python
    # アンチパターン：可変な値オブジェクト
    @dataclass # frozen=True がない！
    class Money:
        amount: int
        currency: str
    
    price = Money(1000, "JPY")
    discounted_price = price # 同じオブジェクトを参照
    
    # 意図せず元の価格も変わってしまう！
    discounted_price.amount = 800
    
    # print(price.amount) # -> 800 になってしまう！
    
    ```
    
    値オブジェクトが可変だと、意図しない副作用が発生しやすくなります。不変（`frozen=True`）にすることで、値を変えたい場合は常に新しいインスタンスを作成する（`new_price = Money(800, "JPY")`）ことになり、安全性が高まります。
    

---

## 📝 まとめ

値オブジェクトは、「**値そのものが重要**」なドメイン概念をモデル化するためのビルディングブロックです。

- **IDを持たない**
- **属性によって定義される**
- **不変（Immutable）** であるべき
- **自己検証ロジック** を持つことができる

適切に値オブジェクトを活用することで、コードの**表現力**、**安全性**、**堅牢性**を高めることができます。「プリミティブ型への執着」を避け、ドメインの概念を豊かなオブジェクトとしてモデル化しましょう。

---

## ➡️ 次へ

次は、エンティティと値オブジェクトをまとめ上げ、データ整合性の単位となる非常に重要な概念、「**集約 (Aggregate)**」について見ていきましょう。