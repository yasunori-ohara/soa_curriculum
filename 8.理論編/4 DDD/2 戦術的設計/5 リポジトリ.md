# 5. リポジトリ

# 🏛️ 戦術的設計：リポジトリ

DDD（ドメイン駆動設計）の戦術的設計において、「**リポジトリ (Repository)**」は、ドメインモデル（特に**集約**）の**永続化**を抽象化するための重要なパターンです。これは、クリーンアーキテクチャ(CA)で私たちが「リポジトリインターフェース」として定義・利用してきたものと、目的も役割もほぼ同じです。

---

## ❓ リポジトリとは？

> ドメインオブジェクト（主に集約ルート）へのアクセスを仲介するオブジェクト。あたかもメモリ上のコレクションのように振る舞い、永続化の技術的詳細（DBアクセス、ファイルI/Oなど）をカプセル化する。
> 

### 💡 簡単に言うと

ドメインモデル（特に集約）を「**保管庫（例：データベースやファイル）にしまったり、取り出したりする係**」です。利用側（UseCase）は、データが具体的にどこにどうやって保存されているかを知る必要はなく、この「係」に必要なもの（例：「IDがXXXの注文を持ってきて」「この注文を保存して」）を依頼するだけです。
[Image representing a librarian retrieving a book from shelves]

### 🤔 なぜ重要か？

リポジトリパターンは、ドメインモデルとデータ永続化メカニズムを分離するために不可欠です。

1. **永続化技術の隠蔽**:
`UseCase` や `Domain Service` は、データがリレーショナルデータベース(SQL)に保存されているのか、NoSQLデータベースに保存されているのか、あるいはファイルシステムや外部APIに保存されているのかを気にする必要がなくなります。リポジトリがその違いを吸収します。（データベース独立性の実現）
2. **ドメインモデルの純粋性の維持**:
`Entity` や `UseCase` のコードに、データアクセスに関する技術的なコード（SQL文字列、ORMのAPI呼び出しなど）が混入するのを防ぎます。ドメインモデルはビジネスロジックに集中できます。
3. **テスト容易性の向上**:
`UseCase` をテストする際に、実際のデータベースに接続する代わりに、インターフェースを満たすインメモリの偽リポジトリ（モックやスタブ）を簡単に差し替えることができます。
4. **コードの一元化**:
データアクセスに関するロジック（クエリの構築、データのマッピングなど）をリポジトリの実装クラスに集約することで、コードの重複を防ぎ、保守性を高めます。

---

## ✅ これまでの実践例（どこで使ったか）

私たちは、CAの実践において、まさにDDDのリポジトリパターンを適用していました。

### 📌 リポジトリインターフェースと実装 (第1巡〜第5巡)

- **具体例**: 各サービスで、`WorldModelRepositoryInterface`, `PlanRepositoryInterface`, `VehicleStateRepositoryInterface` などのインターフェースを `application/boundaries.py` に定義しました。そして、`InMemoryWorldModelRepository`, `InMemoryPlanRepository`, `InMemoryVehicleStateRepository` といった具体的な実装クラスを `adapters/repositories.py` に作成しました。
- **実践**:
    - `UseCase` はインターフェース（`WorldModelRepositoryInterface` など）にのみ依存し、「データを取得する(`get`)」「データを保存する(`save`)」といった抽象的な操作だけを呼び出しました。
    - 具体的なデータアクセス方法（今回はメモリ上での保持）は、`Adapters`層にある `InMemory...Repository` クラス内に完全に隠蔽されていました。
    - `main.py` でDI（依存性の注入）を行うことで、`UseCase` は具体的なリポジトリ実装を知ることなく、インターフェースを通じて永続化機能を利用できました。
    <!-- end list -->
    
    ```
      UseCase -----> <I> Repository Interface <----- Repository Implementation (Adapter)
                     (depends on)                     (implements)
                     (in application/boundaries.py)   (in adapters/repositories.py)
                                                      (Contains DB/Memory access logic)
    
    ```
    

### 📌 集約との関連 (第4巡, 第5巡)

- **具体例**: `WorldModelRepository` は `WorldModel`（暗黙的な集約）を、`PlanRepository` は `ParkingPlan`（暗黙的な集約）を扱いました。
- **実践**: DDDでは、リポジトリは通常、**集約ルート**ごとに定義されます。リポジトリは、集約全体を一つの単位として取得（`findById`, `findAll` など）および保存（`save`）する責任を持ちます。集約内部の個別のオブジェクト（例：`OrderItem`）に対するリポジトリは通常作成しません。集約の内部整合性は集約ルートが責任を持つため、永続化も集約ルート単位で行うのが原則です。

---

## ❌ 間違った適用例（アンチパターン）

リポジトリパターンを誤用すると、抽象化の利点が損なわれたり、不要な複雑さが生じたりします。

- **例1：UseCaseがリポジトリを使わず、直接DBドライバを使う**
（データベース独立性のアンチパターンと同じです）
リポジトリによる抽象化レイヤーが存在しないため、`UseCase` が永続化技術の詳細に依存してしまいます。
- **例2：リポジトリインターフェースが永続化技術の詳細を漏洩する**
    
    ```python
    # アンチパターン：漏洩のあるリポジトリインターフェース
    # from some_orm import OrmSession # 👈 ORM固有の型
    
    class OrderRepositoryInterface(ABC):
        @abstractmethod
        def find_by_id(self, order_id: int) -> Order: pass
    
        @abstractmethod
        # def save(self, order: Order, session: OrmSession): # 👈 NG! ORMのセッションを要求している
        #     pass
    
        # 良い例：永続化の詳細は隠蔽する
        def save(self, order: Order):
             pass
    
    ```
    
    インターフェースが特定のORMのセッションオブジェクトなどを引数で要求してしまうと、そのインターフェースはORMという「詳細」に依存してしまいます。`UseCase` もその詳細を知る必要が出てきてしまい、抽象化の利点が失われます。
    
- **例3：あらゆるクラスに対してリポジトリを作成する**
DDDでは、リポジトリは主に**集約ルート**に対して作成されます。集約内部のエンティティや、特に値オブジェクトに対して個別のリポジトリを作成する必要は通常ありません（それらは集約ルートを通じて永続化されるべきです）。リポジトリを作りすぎると、管理が煩雑になります。
- **例4：リポジトリがビジネスロジックを持つ**
リポジトリの責務は、あくまで「永続化の抽象化」です。データの検索や保存以外のビジネスロジック（例：価格計算、ステータス遷移の検証）をリポジトリ内に実装すべきではありません。それらは `Entity` や `UseCase`, `Domain Service` が担当すべきです。

---

## 📝 まとめ

リポジトリは、ドメインモデル（特に**集約**）と**永続化メカニズム**との間の「**仲介者**」です。

- **インターフェース**を通じて、`UseCase` に永続化の詳細を意識させません。
- **実装クラス**に、具体的なデータアクセスロジックをカプセル化します。

クリーンアーキテクチャで私たちが実践してきたリポジトリインターフェースと実装の分離は、まさにDDDのリポジトリパターンの考え方そのものです。これを活用することで、データベース独立性とテスト容易性を確保できます。

---

## ➡️ 次へ

次は、ドメイン内で起こった重要な「出来事」をモデル化する「**ドメインイベント (Domain Event)**」について見ていきましょう。