# 02 サービスは自律的であれ

# 🏛️ サービスは自律的であれ

SOAの4大原則の2番目は、「**サービスは自律的であれ (Service Autonomy)**」です。これは、各サービスが独立して機能するための重要な性質です。

---

## ❓ 原則の定義

> サービスは、自身がカプセル化するロジックの実行を制御し、他のサービスへの依存を最小限に抑えるべきである。
> 

### 💡 簡単に言うと

各サービスは「自分の仕事は自分で完結できる**一人前の専門家**」であるべき、ということです。他の専門家（サービス）に「あれやって、これやって」と細かく指示したり、逆に指示されたりするのではなく、自分の判断で仕事を進められるようにします。

### 🤔 なぜ重要か？

サービスの自律性が低い（他のサービスに強く依存している）と、以下のような問題が発生します。

1. **可用性の低下（連鎖障害）**:
あるサービスAが、別のサービスBの応答がないと自身の処理を進められない場合、サービスBが停止するとサービスAも停止してしまいます。障害が連鎖しやすくなります。
2. **パフォーマンスのボトルネック**:
サービスAの処理速度が、依存しているサービスBの応答速度に引きずられてしまいます。
3. **変更・デプロイの困難化**:
サービスBの仕様が変わると、それに依存しているサービスAも修正・再デプロイが必要になる可能性があります。独立したデプロイが困難になります。
4. **スケーラビリティの制約**:
サービスAの負荷が増えたときに、サービスAだけをスケールアウト（数を増やす）しても、依存先のサービスBがボトルネックになっていれば、全体の性能は向上しません。

サービスが自律的であれば、他のサービスの状態（停止している、遅いなど）の影響を受けにくくなり、システム全体としての\*\*回復力（Resilience）**や**拡張性（Scalability）\*\*が高まります。

---

## ✅ これまでの実践例（どこで使ったか）

私たちの自動駐車システムは、非同期通信（ファイル/MQTT）を採用したことで、比較的高い自律性を実現していました。

### 📌 非同期通信による自律性 (第4巡, 第5巡)

- **具体例**: 経路計算サービスは、認識サービスが `world_model` データを公開するのを「待つ」のではなく、自身が処理可能なタイミングで最新の `world_model` を取得（購読）しに行きました。
- **実践**:
    - **可用性**: もし認識サービスが一時的に停止して `world_model` の更新が止まっても、経路計算サービスは（古い `world_model` を使い続けるか、あるいは何もしないという判断は必要ですが）自身のプロセス自体は動き続けることができました。同期的に認識サービスを呼び出していたら、認識サービスの停止とともに経路計算サービスも応答不能になっていたでしょう。
    - **パフォーマンス**: 認識サービスの処理が重くても、経路計算サービスは自身のペースで動作できました（ただし、入力データの鮮度は落ちます）。
    - **独立デプロイ**: 認識サービスの内部実装（例：認識アルゴリズム）が変わっても、公開される `world_model` の「契約」が変わらない限り、経路計算サービスは再デプロイ不要でした。

### 📌 サービスが自身のデータを管理 (第4巡, 第5巡)

- **具体例**: 各サービスは、自身の内部状態（例：車両制御サービスの `VehicleState`）を自身のリポジトリ (`InMemoryVehicleStateRepository`) で管理していました。
- **実践**: 車両制御サービスが「現在の車両状態」を知るために、他のサービスに問い合わせる必要はありませんでした。自身の責任範囲のデータは自身で保持・管理することで、自律性を高めています。（これはマイクロサービスにおける「データごとにサービスを分割する」考え方にも繋がります）。

---

## ❌ 間違った適用例（アンチパターン）

サービスの自律性が低い設計は、サービス間の密結合を生み出し、SOAの利点を損ないます。

- **例1：同期的な連鎖呼び出し（Choreography vs Orchestration）**
ある処理（例：注文処理）を完了するために、サービスAがサービスBを呼び出し、BがCを呼び出し、CがDを呼び出す…という同期的な呼び出しが長く連鎖するパターンです。
    
    ```
      [A] --(req)--> [B] --(req)--> [C] --(req)--> [D]
      [A]    <--     [B]     <--    [C]    <--     [D] (resp)
    
    ```
    
    この場合、AはB, C, Dすべてが無事に完了するまで待たなければならず、途中のどれか一つでも失敗したり遅延したりすると、Aの処理全体が失敗・遅延します。各サービスの自律性が低く、障害の影響が広範囲に及びます。
    
    **改善策**: 非同期（イベント駆動）にするか、あるいは中央でプロセス全体を管理する「オーケストレータ」サービスを導入する（Orchestrationパターン）ことを検討します。ただし、オーケストレータが単一障害点にならないよう注意が必要です。
    
- **例2：共有データベース**
複数のサービスが、同じデータベース（の同じテーブル）を直接読み書きしてしまうパターンです。
    
    ```
                  +--------------+
      [Service A] |              | [Service B]
           -----> | Shared DB    | <-----
      [Service C] | (Same Table) |
           -----> +--------------+
    
    ```
    
    これは一見シンプルに見えますが、最悪のアンチパターンの一つです。
    
    - **可用性**: DBが停止すると、それに依存する全てのサービスが停止します。
    - **独立性**: あるサービスがテーブル構造を変更すると、それを参照している他の全てのサービスが影響を受け、同時に修正・デプロイが必要になります。
    - **自律性**: データの所有権が曖昧になり、各サービスが自身の責任範囲のデータを自律的に管理することができません。
    
    **改善策**: 各サービスは自身のデータを自身専用のデータベース（またはテーブルスキーマ）で管理し、他のサービスのデータが必要な場合は、そのサービスの公開APIを通じて取得します（境界と契約の原則）。
    

---

## 📝 まとめ

サービスの自律性は、「**各サービスが、他のサービスになるべく頼らず、自分の力で仕事を完遂できる能力**」を指します。

自律性を高めることで、サービス間の依存関係を減らし、システム全体を**障害に強く**、**変化に対応しやすく**、**スケールさせやすく**することができます。

非同期通信（Pub/Subなど）の採用や、サービスが自身のデータを責任持って管理することは、自律性を高めるための重要なテクニックです。

---

## ➡️ 次へ

次は、SOAの4大原則の3番目、「**(3/4) 疎結合を保て**」について見ていきましょう。これは自律性とも密接に関係します。