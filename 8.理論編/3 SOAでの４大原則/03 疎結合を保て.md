# 03 疎結合を保て

# 🏛️ 疎結合を保て

SOAの4大原則の3番目は、「**疎結合を保て (Loose Coupling)**」です。これは、サービスの「自律性」とも密接に関連し、変更に強いシステムを構築するための鍵となります。

---

## ❓ 原則の定義

> サービス間の依存関係を最小限にし、あるサービスの変更が他のサービスに与える影響を極力少なくするように設計すべきである。
> 

### 💡 簡単に言うと

サービス同士は「**浅い付き合い**」に留めましょう、ということです。お互いの内部事情（実装の詳細）に深入りせず、決められたインターフェース（契約）を通じて、必要最低限の情報だけをやり取りするようにします。

### 🤔 なぜ重要か？

サービス間の結合度が強い（**密結合 - Tight Coupling**）と、以下のような問題が発生します。

1. 変更の連鎖 (Ripple Effect):
    
    あるサービスAの内部実装を少し変更しただけで、それに依存していたサービスB、C、D…も連鎖的に修正が必要になる可能性があります。変更が広範囲に及び、コストとリスクが増大します。
    
2. 独立したデプロイの阻害:
    
    サービスAだけを新しいバージョンにデプロイしたいのに、密結合しているサービスBも同時にデプロイしないと動かない、といった状況が発生しやすくなります。
    
3. テストの複雑化:
    
    サービスAをテストするために、それに密結合しているサービスBやCも一緒に起動・設定する必要が出てきます。独立したテストが困難になります。
    
4. 再利用性の低下:
    
    特定のサービス群と密結合してしまっているサービスは、他のシステムで再利用することが難しくなります。
    

疎結合を保つことで、各サービスは**独立して変更・進化**できるようになり、システム全体としての**俊敏性（Agility）と保守性**が高まります。

---

## ✅ これまでの実践例（どこで使ったか）

私たちの自動駐車システムは、いくつかの設計選択によって疎結合を実現していました。

### 📌 非同期通信 (MQTT) の採用 (第5巡)

- **具体例**: 認識サービスは `/world_model` トピックにデータをPublishするだけで、誰が（経路計算サービスが）それをSubscribeしているかを知りませんでした。
- **実践**: PublisherとSubscriberが互いを直接知る必要がないMQTT（Pub/Sub）は、**時間的結合**（相手が同時に動いている必要がない）と**空間的結合**（相手の場所を知る必要がない）の両方を緩めます。認識サービスの実装が変わっても、経路計算サービスは影響を受けません（契約が変わらない限り）。逆も同様です。これは非常に疎な結合です。

### 📌 契約（インターフェース）による連携 (第4巡, 第5巡)

- **具体例**: サービス間の唯一の接点は、`world_model` や `plan` といったデータの形式（JSONスキーマ / Entity構造）だけでした。
- **実践**: サービスは、相手の内部ロジックや使用している技術（プログラミング言語、DBなど）について何も知りません。ただ合意された「契約」に従ってデータを送受信するだけです。これにより、**実装の詳細に関する結合**が排除されました。

### 📌 クリーンアーキテクチャの適用 (サービス内部)

- **具体例**: 各サービス内部で、`UseCase` は `Adapters` 層の実装を知らず、インターフェースのみに依存していました。
- **実践**: サービス内部の各レイヤーも疎結合に保たれています。例えば、MQTTアダプタの実装を変更しても、`UseCase` は影響を受けません。これも疎結合の一形態です。

---

## ❌ 間違った適用例（アンチパターン）

密結合な設計は、変更の影響範囲を広げ、システムの柔軟性を奪います。

- 例1：他のサービスの内部クラスや関数を直接呼び出す
    
    （※ RPC (Remote Procedure Call) でも、インターフェース定義なしに行うとこれに近い状態になりうる）
    
    `# 経路計算サービス内 (アンチパターン)
    # from perception_service.internal_logic import calculate_object_distance # 👈 NG! 他のサービスの内部関数をimport
    
    class CalculatePathUseCase:
        def handle(self):
            world_model = ...
            # 他のサービス(認識サービス)の内部関数を直接呼び出す！
            # distance = calculate_object_distance(world_model.objects[0], current_position)
            # ...
            pass`
    
    これは最悪の密結合です。認識サービスの内部実装（関数名、引数、ロジック）が変更されたら、経路計算サービスは即座に壊れます。サービス境界が完全に無視されています。
    
- 例2：共有データベース（再掲）
    
    複数のサービスが同じデータベーステーブルを共有することは、データ構造という「実装の詳細」を通じてサービス同士を密結合させてしまいます。テーブル構造の変更が、複数のサービスに影響を与えます。
    
- 例3：過度に「おしゃべり」な通信 (Chatty Communication)
    
    ある処理を完了するために、サービスAとサービスBの間で、何度も細かい同期的なリクエスト/レスポンス（例：REST呼び出し）を繰り返すパターンです。
    
     `[A] --(get user info)--> [B]
      [A] <-- (user info) ---- [B]
      [A] --(get user prefs)--> [B]
      [A] <-- (user prefs) --- [B]
      [A] --(get user address)--> [B]
      [A] <-- (user address) -- [B]
      (処理完了)`
    
    これは、パフォーマンスの低下（ネットワーク往復遅延）だけでなく、サービスAがサービスBのAPI（複数）に強く依存していることを示します。サービスBのAPIが変更されると、サービスAも修正が必要になる可能性が高まります。
    
    **改善策**: なるべく1回のリクエストで必要な情報をまとめて取得できるようにAPIを設計する（例：`getUserProfile` APIを作る）、あるいは非同期通信を検討します。
    

---

## 📝 まとめ

疎結合は、「**変更の影響範囲を限定し、各サービスが独立して進化できるようにする**」ための原則です。

サービス間の依存関係を、**安定した契約（インターフェース）**だけに限定し、**実装の詳細**への依存を徹底的に排除します。**非同期通信**は、疎結合を実現するための強力な手段の一つです。

疎結合なシステムは、変更に強く、テストしやすく、スケールしやすいという、SOAが目指す多くの利点を享受できます。

---

## ➡️ 次へ

いよいよ最後の原則、「**(4/4) 場所を透過的に扱え**」について見ていきましょう。これは、サービスの物理的な配置場所に関する原則です。