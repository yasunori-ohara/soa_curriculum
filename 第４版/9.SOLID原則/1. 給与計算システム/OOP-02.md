# OOP-02 : SOLID原則による「給与計算システム」の設計評価

`OOP-01`では、リファクタリングの題材となる「給与計算システム」の初期コードを確認しました。このコードは`employees.py`でポリモーフィズム（継承）を活用するなど、一見すると良いOOPの実践に見えます。

しかし、このコードは本当に「**変更に強い、良い設計**」と言えるでしょうか？

この章では、オブジェクト指向設計の健全性を測るための有名な指針である**SOLID原則**を使って、`OOP-01`のコードを評価（健康診断）してみましょう。

## 🎯 この章のゴール

* SOLID原則（S, O, L, I, D）の5つの概要を再確認する。
* 現状のコード（`OOP-01`）が、各原則をどの程度満たしているかを評価する。
* **クリーンアーキテクチャ（CA）**が解決しようとしている中心的な問題（SRP違反、DIP違反）が、このコードに存在することを特定する。

---

## 📗 S: 単一責任の原則 (Single Responsibility Principle)

> 「クラスを変更する理由は、一つだけであるべき」

### 評価： ❌ 甚だしい違反 (God Class)

この原則は「**関心の分離 (Separation of Concerns)**」の基礎です。

`employees.py`の各クラス（`FullTimeEmployee`など）は、「自身の給与計算方法」という単一の責任を持っており、SRPを満たしています。

しかし、**`system.py`の`PayrollSystem`クラス**を見てみましょう。
クリーンアーキテクチャ（CA）のレイヤー（関心）で分析すると、このクラスは**全く異なる複数の責任**を抱えています。

1.  **責任A: アプリケーション・ロジック（ユースケース層）**
    * `execute_payment`や`calculate_payroll`がこれに該当します。
    * 「全従業員の給与を計算し、ログを保存する」という**ビジネスの手順（ポリシー）**を定義しています。
    * 変更理由：「計算ロジックに控除処理を追加したい」

2.  **責任B: 従業員データの永続化（インフラ層）**
    * `self._employees = {}`や`add_employee`がこれに該当します。
    * **従業員データを「どう」保存するか**（この場合はメモリ上の辞書）という実装詳細を知っています。
    * 変更理由：「従業員の保存先をメモリからDBに変えたい」

3.  **責任C: 支払ログの永続化（インフラ層）**
    * `self._pay_logs = []`や`get_pay_logs`、`execute_payment`内の`append`処理がこれに該当します。
    * **支払ログを「どう」保存するか**（この場合はメモリ上のリスト）という実装詳細を知っています。
    * 変更理由：「支払ログの保存先をファイルに変えたい」

`PayrollSystem`クラスは、「ユースケース」と「2種類のインフラ（リポジトリ）」という、**変更理由が全く異なる3つの責任**を一つのクラスに押し込めています。
これは典型的な「**神クラス (God Class)**」であり、SRPに明確に違反しています。

---

## 📖 O: オープン・クローズドの原則 (Open/Closed Principle)

> 「クラスは拡張に対して開いており、修正に対して閉じているべき」

### 評価： ✅ 達成済み

これは`OOP-01`のコードの（意図的に）良い点です。
`PayrollSystem`の`calculate_payroll`メソッドは、`Employee`（抽象）に依存し、`emp.calculate_pay()`を呼び出すだけです。

もし将来、「**契約社員**（`ContractEmployee`）」という新しい`Employee`の子クラスを`employees.py`に**追加（＝拡張）**しても、`system.py`の`calculate_payroll`メソッドを**修正**する必要はありません。

この点において、システムはポリモーフィズムによってOCPを達成しています。

---

## 🔄 L: リスコフの置換原則 (Liskov Substitution Principle)

> 「親クラスのオブジェクトを、その子クラスのオブジェクトで置き換えても、プログラムの動作が変わらないべき」

### 評価： ✅ 達成済み

`FullTimeEmployee`も`PartTimeEmployee`も、`Employee`インターフェースの`calculate_pay()`という「契約」を正しく実装しています。

`PayrollSystem`（利用者）は、`emp`変数がどちらの具象クラスかを知る必要がなく（`isinstance`による型チェックが不要）、親である`Employee`として同一視して（＝**置換**して）扱えています。LSPは達成されています。

---

## 🖇️ I: インターフェース分離の原則 (Interface Segregation Principle)

> 「クライアント（クラスの利用者）に、利用しないインターフェース（メソッド）への依存を強制すべきではない」

### 評価： ✅ 適用できている

`Employee`インターフェースは`calculate_pay()`という一つのメソッド（と`__init__`）しか持っておらず、非常に「痩せた」インターフェースです。利用者に不要なメソッドを強制していません。

---

## 🔗 D: 依存性逆転の原則 (Dependency Inversion Principle)

> 「上位モジュールは下位モジュールに依存すべきではない。両方とも抽象に依存すべき」

### 評価： ❌ 甚だしい違反

これがSRPと並ぶ、このコードの**最大の違反**です。

* **上位モジュール（高レベルな方針）**:
    * `PayrollSystem`の`execute_payment`メソッド。
    * これは「どうやって給与を支払うか」という**ビジネスロジック（＝ユースケース）**です。
* **下位モジュール（低レベルな詳細）**:
    * `self._employees = {}` という辞書。
    * `self._pay_logs.append(...)` というリストへの操作。
    * これらは「データを**どうやって**保存するか」という**実装の詳細（＝インフラ）**です。

`OOP-01`では、上位モジュール（`execute_payment`）が、下位モジュール（辞書やリスト）という**具象の実装**に**ベッタリと直接依存**しています。

クリーンアーキテクチャを学んだ方なら、これがCAの「**依存性のルール**」に真っ向から違反していることにお気づきでしょう。


**DIP（依存性逆転の原則）**は、この「変更の連鎖（インフラの変更がユースケースの変更を引き起こす）」を防ぐために、「**抽象（インターフェース）**」に依存すべきだと説いています。

---

## 📋 評価まとめと次のステップ

`OOP-01`のコードは、ポリモーフィズム（継承）をうまく使い、OCP/LSPという「振る舞い」に関する原則はクリアしていました。

しかし、クラスの「責任」と「依存関係」において、
1.  **S（単一責任の原則）違反**
2.  **D（依存性逆転の原則）違反**

という、システムの**アーキテクチャ（骨格）**に関わる致命的な問題を抱えています。

次の章（`OOP-03`）からは、皆さんが学んだ**クリーンアーキテクチャ**のパターンを適用し、この「神クラス」を「**ユースケース**」層と「**インフラストラクチャ**」層に分離するリファクタリングを行います。

そのプロセスが、結果としてSRPとDIPの違反を**自動的に**解決していく様子を体験してください。