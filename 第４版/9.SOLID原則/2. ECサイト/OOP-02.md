# OOP-02: SOLID原則による「ECサイト注文処理」の設計評価

`OOP-01`では、リファクタリングの題材となる「ECサイト注文処理」の初期コードを確認しました。このコードは`logic.py`内でポリモーフィズムを活用するなど、一見すると良いOOPの実践に見えます。

しかし、このコードは本当に「**変更に強い、良い設計**」と言えるでしょうか？

この章では、オブジェクト指向設計の健全性を測るための有名な指針である**SOLID原則**を使って、`OOP-01`のコードを評価（健康診断）してみましょう。

## 🎯 この章のゴール

* SOLID原則（S, O, L, I, D）の5つの概要を再確認する。
* 現状のコード（`OOP-01`）が、各原則をどの程度満たしているかを評価する。
* **クリーンアーキテクチャ（CA）**が解決しようとしている中心的な問題（SRP違反、DIP違反）が、このコード（特に`Store`クラス）に存在することを特定する。

---

## 📗 S: 単一責任の原則 (Single Responsibility Principle)

> 「クラスを変更する理由は、一つだけであるべき」

### 評価： ❌ 甚だしい違反 (God Class)

この原則は「**関心の分離 (Separation of Concerns)**」の基礎です。

`logic.py`の`PhysicalProduct`や`DigitalProduct`クラスは、「自身の在庫管理方法」という単一の責任を持っており、SRPを満たしています。

しかし、**`logic.py`の`Store`クラス**を見てみましょう。
クリーンアーキテクチャ（CA）のレイヤー（関心）で分析すると、このクラスは**全く異なる複数の責任**を抱えています。

1.  **責任A: アプリケーション・ロジック（ユースケース層）**
    * `process_order`メソッドがこれに該当します。
    * 「1. 商品を探し → 2. 在庫を確認し → 3. 在庫を減らし → 4. 注文記録を作る」という**ビジネスの手順（ポリシー）**を定義しています。
    * 変更理由：「注文処理に割引ルールを追加したい」

2.  **責任B: 商品データの永続化（インフラ層）**
    * `self._products = {}`や`add_product`, `_find_product`がこれに該当します。
    * **商品データを「どう」保存するか**（この場合はメモリ上の辞書）という実装詳細を知っています。
    * 変更理由：「商品の保存先をメモリからDBに変えたい」

3.  **責任C: 注文記録の永続化（インフラ層）**
    * `self._orders = []`や`get_order_history`、`process_order`内の`append`処理がこれに該当します。
    * **注文記録を「どう」保存するか**（この場合はメモリ上のリスト）という実装詳細を知っています。
    * 変更理由：「注文記録の保存先をファイルに変えたい」

`Store`クラスは、「ユースケース」と「2種類のインフラ（リポジトリ）」という、**変更理由が全く異なる3つの責任**を一つのクラスに押し込めています。
これは典型的な「**神クラス (God Class)**」であり、SRPに明確に違反しています。

---

## 📖 O: オープン・クローズドの原則 (Open/Closed Principle)

> 「クラスは拡張に対して開いており、修正に対して閉じているべき」

### 評価： ✅ 達成済み

これは`OOP-01`のコードの良い点です。
`Store`クラスの`process_order`メソッドは、`IProduct`（抽象）に依存し、`product.check_stock()`などを呼び出すだけです。

もし将来、「**予約商品**（`PreOrderProduct`）」という新しい`IProduct`の子クラスを`logic.py`に**追加（＝拡張）**しても、`Store`クラスの`process_order`メソッドを**修正**する必要はありません。

この点において、システムはポリモーフィズムによってOCPを達成しています。

---

## 🔄 L: リスコフの置換原則 (Liskov Substitution Principle)

> 「親クラスのオブジェクトを、その子クラスのオブジェクトで置き換えても、プログラムの動作が変わらないべき」

### 評価： ✅ 達成済み

`PhysicalProduct`も`DigitalProduct`も、`IProduct`インターフェースの「契約」（`check_stock`など）を正しく実装しています。

`Store`（利用者）は、`product`変数がどちらの具象クラスかを知る必要がなく（`isinstance`による型チェックが不要）、親である`IProduct`として同一視して（＝**置換**して）扱えています。LSPは達成されています。

---

## 🖇️ I: インターフェース分離の原則 (Interface Segregation Principle)

> 「クライアント（クラスの利用者）に、利用しないインターフェース（メソッド）への依存を強制すべきではない」

### 評価： ✅ 適用できている

`IProduct`インターフェースは、商品として必要なメソッド（`check_stock`, `reduce_stock`など）に限定されており、`Store`クラスはそれらをすべて利用しています。「太ったインターフェース」にはなっていません。ISPは達成されています。

---

## 🔗 D: 依存性逆転の原則 (Dependency Inversion Principle)

> 「上位モジュールは下位モジュールに依存すべきではない。両方とも抽象に依存すべき」

### 評価： ❌ 甚だしい違反

これがSRPと並ぶ、このコードの**最大の違反**です。

* **上位モジュール（高レベルな方針）**:
    * `Store`クラスの`process_order`メソッド。
    * これは「どうやって注文を処理するか」という**ビジネスロジック（＝ユースケース）**です。
* **下位モジュール（低レベルな詳細）**:
    * `self._products = {}` という辞書。
    * `self._orders.append(...)` というリストへの操作。
    * これらは「データを**どうやって**保存するか」という**実装の詳細（＝インフラ）**です。

`OOP-01`では、上位モジュール（`process_order`）が、下位モジュール（辞書やリスト）という**具象の実装**に**ベッタリと直接依存**しています。

クリーンアーキテクチャを学んだ方なら、これがCAの「**依存性のルール**」に真っ向から違反していることにお気づきでしょう。


**DIP（依存性逆転の原則）**は、この「変更の連鎖（インフラの変更がユースケースの変更を引き起こす）」を防ぐために、「**抽象（インターフェース）**」に依存すべきだと説いています。（`Store`が`IProduct`に依存している点は部分的によいですが、データ保存に関しては全く達成されていません。）

---

## 📋 評価まとめと次のステップ

`OOP-01`のコードは、ポリモーフィズムをうまく使い、OCP/LSPという「振る舞い」に関する原則はクリアしていました。

しかし、クラスの「責任」と「依存関係」において、
1.  **S（単一責任の原則）違反**
2.  **D（依存性逆転の原則）違反**

という、システムの**アーキテクチャ（骨格）**に関わる致命的な問題を抱えています。

次の章（`OOP-03`）からは、皆さんが学んだ**クリーンアーキテクチャ**のパターンを適用し、この「神クラス（`Store`）」を「**ユースケース**」層と「**インフラストラクチャ**」層に分離するリファクタリングを行います。

そのプロセスが、結果としてSRPとDIPの違反を**自動的に**解決していく様子を体験してください。
（SOLID原則のことは一旦忘れ、CAの"型"にはめることに集中しましょう）


はい、その通りです。もし`OOP-01`でポリモーフィズムが活用されていなかった場合、**オープン・クローズドの原則（OCP）にも明確に違反していた**ことになります。

以下に、`OOP-02`の最後に補足として追加する文章案を作成します。

-----

## 🛠️🛠️ 補足：もしポリモーフィズムを使わなかったら？ (OCP違反の発生)

今回の`OOP-02`の評価では、OCP（オープン・クローズドの原則）は「達成済み」と評価しました。これは、`OOP-01`のコードが**最初からポリモーフィズム（`IProduct`インターフェースと継承）を活用していた**おかげです。

では、もし`OOP-01`がポリモーフィズムを使わず、`Store`クラスが`PhysicalProduct`と`DigitalProduct`という**具体的なクラス**を直接扱っていたらどうなっていたでしょうか？

`Store`の`process_order`メソッドは、おそらく以下のようになっていたはずです。

```python
# --- ポリモーフィズムを使わなかった場合の Store (悪い例) ---
# (具象クラスを直接インポート)
from logic import PhysicalProduct, DigitalProduct 

class Store:
    # ... (add_product なども具象クラスを受け取るように変更) ...

    def process_order(self, product_id: str, quantity: int):
        product = self._find_product(product_id) # 戻り値も具象の Union になる
        if not product:
            # ...
            return

        # ▼▼▼ 型チェックによる分岐が必須になる ▼▼▼
        if isinstance(product, PhysicalProduct):
            # 物理商品の在庫チェックと削減ロジック
            if not product.check_stock(quantity):
                print(f"エラー: {product.name}の在庫が不足...")
                return
            product.reduce_stock(quantity)
        elif isinstance(product, DigitalProduct):
            # デジタル商品の在庫チェックと削減ロジック (何もしない)
            pass
        else:
            # 未知の商品タイプへの対応
            print("エラー: 未対応の商品タイプです。")
            return
        # ▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲

        # ... (注文記録作成) ...
```

このコードの問題点は明らかです。もし将来、「**予約商品**（`PreOrderProduct`）」を追加したくなった場合、`Store`クラスの`process_order`メソッドに\*\*`elif isinstance(product, PreOrderProduct): ...`という条件分岐を追加する「修正」\*\*が必要になります。

これはまさにOCP（**修正に対して閉じて**いるべき）の違反です。

`OOP-01`がOCPを達成できていたのは、ポリモーフィズムによって`Store`が**具体的な商品の種類を知る必要がなく**、`IProduct`という\*\*抽象的な「契約」\*\*にのみ依存できていたからなのです。