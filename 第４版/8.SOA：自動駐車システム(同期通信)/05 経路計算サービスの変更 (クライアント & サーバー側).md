# 05 経路計算サービスの変更 (クライアント & サーバー側)

# ステップ３：経路計算サービスの変更 (クライアント & サーバー側)

ステップ2で認識サービスをAPIサーバーとして改修しました。
次のステップは、中間に位置する「経路計算サービス」の改修です。このサービスは、今回の改修で最も複雑な役割を担います。

## 🎯 課題

経路計算サービスは、第5巡（MQTT）ではWorldModelをSubscribe（受信）し、ParkingPlanをPublish（送信）していました。
今回の課題は、このMQTTの役割を削除し、以下の2つの機能を同時に実装することです。

1. **REST クライアント機能:** 認識サービス ( `http://localhost:8001` ) に `GET /world_model` をリクエストし、WorldModelを同期的に取得する。
2. **REST サーバー機能:** 車両制御サービスからの `GET /parking_plan` リクエストを受け付け、計算したParkingPlanをレスポンスとして提供する。

## 🔧 実装方針

サーバー機能の実現には、認識サービスと同様に **FastAPI** を導入します。
クライアント機能の実現には、Pythonで標準的に使われるHTTPクライアントライブラリである **requests** を導入します。

クリーンアーキテクチャの観点では、以下の変更を行います。

1. MQTTのSubscriber/Publisher Adapterを削除します。
2. 認識サービスAPIを呼び出すための新しい **Infrastructure (Adapter)** として `RecognitionClient` を実装します。
3. `/parking_plan` エンドポイントを提供する **Interface (Adapter)** として `FastAPI Controller` を実装します。
4. UseCase (`CalculateParkingPlanUseCase`) を修正します。MQTTからデータを受け取るのではなく、`RecognitionClient` を使って自らデータを同期的に取得（プル型）するように変更します。
5. `main.py` でFastAPIサーバーを起動します。

## 📁 ファイル構成（変更点）

`planning_service/` 配下の構成が以下のように変更されます。

```
planning_service/
├── adapter/
│   ├── __init__.py
│   ├── dto.py                 # (新規) Pydanticモデル (DTO) を定義
│   ├── recognition_client.py  # (新規) 認識サービスAPIクライアント
│   └── rest_api.py            # (新規) FastAPIコントローラー
├── domain/
│   └── ... (変更なし)
├── usecase/
│   └── calculate_parking_plan.py # (修正) データ取得方法を変更
└── main.py                    # (修正) FastAPIサーバーを起動

```

## 📜 コード実装 (Pydanticモデル)

まず、OpenAPIの `schemas` に対応するPydanticモデルを定義します。WorldModel (入力) と ParkingPlan (出力) の両方が必要です。

`planning_service/adapter/dto.py`

```python
# CA: Infrastructure (Adapter)
# 処理内容: OpenAPIの 'schemas' に基づき、Pydanticモデルを定義する。
# WorldModelはクライアントとして受信するデータ用、
# ParkingPlanはサーバーとして応答するデータ用。
from pydantic import BaseModel
from typing import List, Optional
from datetime import datetime
from uuid import UUID

# --- WorldModel (認識サービスから受信) ---
# ※認識サービスのdto.pyと重複するが、
# サービス境界を明確にするため、ここでは敢えて再定義する。
class Point(BaseModel):
    x: float
    y: float

class Pose(BaseModel):
    x: float
    y: float
    theta: float

class Obstacle(BaseModel):
    id: int
    polygon: List[Point]

class ParkingSpot(BaseModel):
    id: int
    is_occupied: bool
    polygon: List[Point]

class WorldModel(BaseModel):
    timestamp: datetime
    obstacles: List[Obstacle]
    parking_spots: List[ParkingSpot]
    vehicle_pose: Pose

    class Config:
        from_attributes = True

# --- ParkingPlan (制御サービスへ応答) ---
class ParkingPlan(BaseModel):
    plan_id: UUID
    status: str # "success", "failure", "pending"
    path: List[Pose]

    class Config:
        from_attributes = True

```

## 📜 コード実装 (クライアント側 - Recognition Client Adapter)

次に、認識サービス ( `port:8001` ) を呼び出すためのAdapterを実装します。

`planning_service/adapter/recognition_client.py`

```python
# CA: Infrastructure (Adapter)
# 処理内容: 認識サービスAPIへのHTTPクライアント。
# requestsライブラリを使い、同期的にWorldModelを取得する。

import requests
from requests.exceptions import RequestException
from adapter.dto import WorldModel # DTOをインポート
from typing import Optional

# 認識サービスのベースURL
RECOGNITION_SERVICE_URL = "<http://localhost:8001>"

class RecognitionClient:
    """
    認識サービス(Recognition Service)のREST APIクライアント
    """
    def fetch_world_model(self) -> Optional[WorldModel]:
        """
        認識サービスからGET /world_modelを呼び出し、
        現在のWorldModelを取得する。
        """
        try:
            # CA: Infrastructure
            # 処理内容: 同期HTTP GETリクエストを実行。
            # タイムアウトを5秒に設定。
            response = requests.get(
                f"{RECOGNITION_SERVICE_URL}/world_model",
                timeout=5.0
            )

            # CA: Infrastructure
            # 処理内容: HTTPステータスコードが200番台以外なら例外を発生
            response.raise_for_status()

            # CA: Infrastructure (Adapter) - Data Mapper
            # 処理内容: 成功した場合、JSONレスポンスをWorldModel DTOにパースして返す
            # Pydanticが自動でデータ型検証と変換を行う
            return WorldModel.model_validate(response.json())

        except RequestException as e:
            # CA: Infrastructure
            # 処理内容: 接続エラー、タイムアウト、HTTPエラーなど
            print(f"Error fetching WorldModel: {e}")
            return None

```

## 📜 コード実装 (UseCaseの修正)

UseCaseは、MQTTメッセージを待つのではなく、自ら `RecognitionClient` を使ってデータを取得するように修正します。

`planning_service/usecase/calculate_parking_plan.py`

```python
# CA: Application (UseCase)
# 処理内容: 駐車計画の計算ロジック。
# MQTTからのデータ(push)ではなく、
# Client Adapter(pull)を使ってデータを取得するよう変更。

# CA: Infrastructure (Adapter)
# 処理内容: インフラ層のアダプタ(クライアント)をインポート
from adapter.recognition_client import RecognitionClient
# (仮) DomainモデルとDTOが同一と仮定。
# 本来はDomainモデルを返すべき。
from adapter.dto import ParkingPlan, WorldModel
from uuid import uuid4
from typing import List
from adapter.dto import Pose # (仮)

# (仮) 本来はドメインモデル
class ParkingPlanResult(ParkingPlan):
    pass

class CalculateParkingPlanUseCase:
    """
    WorldModelを取得し、駐車計画を計算するユースケース
    """

    # CA: Application (UseCase)
    # 処理内容: UseCaseがインフラ層のアダプタに依存する
    # DI(依存性注入)により、呼び出し元(rest_api)からクライアントを受け取る
    def __init__(self, recognition_client: RecognitionClient):
        self.recognition_client = recognition_client

    def handle(self) -> Optional[ParkingPlanResult]:
        """
        ユースケースの実行
        """
        # 1. CA: Infrastructure (Adapter)
        # 処理内容: アダプタ経由で認識サービスを「同期的に」呼び出す。
        # この呼び出しが完了するまで、以降の処理は待機(ブロック)される。
        print("Fetching WorldModel from Recognition Service...")
        world_model: Optional[WorldModel] = self.recognition_client.fetch_world_model()

        if world_model is None:
            print("Failed to get WorldModel. Aborting planning.")
            return None

        # 2. CA: Application (UseCase) / Domain
        # 処理内容: WorldModelを使った駐車計画の計算ロジック(ダミー)
        print(f"Calculating plan based on WorldModel (timestamp: {world_model.timestamp})")

        # (ダミーの計算ロジック)
        dummy_path: List[Pose] = [
            world_model.vehicle_pose,
            Pose(x=1.0, y=1.0, theta=0.5),
            Pose(x=2.0, y=2.0, theta=0.0)
        ]

        # 3. CA: Application (UseCase)
        # 処理内容: 計算結果(ParkingPlan)を返す
        result = ParkingPlanResult(
            plan_id=uuid4(),
            status="success",
            path=dummy_path
        )
        print(f"Parking plan calculated: {result.plan_id}")
        return result

```

## 📜 コード実装 (サーバー側 - FastAPIコントローラー)

UseCaseがデータを取得できるようになったので、そのUseCaseを呼び出すAPIエンドポイント `/parking_plan` を実装します。

`planning_service/adapter/rest_api.py`

```python
# CA: Interface (Adapter)
# 処理内容: FastAPIを使用して '/parking_plan' エンドポイントを実装するコントローラー。

from fastapi import FastAPI, HTTPException
from adapter.dto import ParkingPlan # レスポンス用のDTO
from usecase.calculate_parking_plan import CalculateParkingPlanUseCase
from adapter.recognition_client import RecognitionClient # インフラ層のアダプタ

# CA: Infrastructure (Adapter)
# 処理内容: FastAPIアプリケーションのインスタンスを作成
app = FastAPI(
    title="Planning Service API",
    description="Calculates and provides parking plans.",
    version="1.0.0"
)

# CA: Interface (Adapter) - Controller
# 処理内容: HTTP GETリクエスト '/parking_plan' に対応するエンドポイント
@app.get("/parking_plan", response_model=ParkingPlan)
def get_parking_plan_endpoint():
    """
    駐車計画を計算して取得します。
    このAPIは内部で認識サービスを呼び出します。
    """
    # --- 依存性の注入 (DI) ---
    # 1. CA: Infrastructure (Adapter)
    # 処理内容: 認識サービスクライアントのインスタンスを作成
    client = RecognitionClient()

    # 2. CA: Application (UseCase)
    # 処理内容: UseCaseにクライアントを注入してインスタンスを作成
    use_case = CalculateParkingPlanUseCase(recognition_client=client)
    # ---------------------------

    # 3. CA: Application (UseCase)
    # 処理内容: ユースケースを実行
    plan = use_case.handle()

    # 4. CA: Interface (Adapter) - Presenter
    # 処理内容: UseCaseの実行結果をハンドリング
    if plan is None:
        # 処理が失敗した場合 (WorldModel取得失敗など)
        # HTTP 503 (Service Unavailable) を返す
        raise HTTPException(
            status_code=503,
            detail="Failed to calculate plan (maybe recognition service is down?)"
        )

    # 成功した場合、FastAPIが 'plan' オブジェクトをJSONにシリアライズして返す
    return plan

```

## 📜 コード実装 ([main.py](http://main.py/))

最後に、MQTTのロジックを削除し、FastAPIサーバーを起動します。認識サービス (8001) と重複しないよう、ポート `8002` で実行します。

`planning_service/main.py`

```python
# CA: Main / Infrastructure
# 処理内容: アプリケーションのエントリーポイント。
# FastAPIアプリをホストするUvicornサーバーを起動する。

import uvicorn
# CA: Infrastructure (Adapter)
# 処理内容: adapter/rest_api.py で定義したFastAPIアプリのインスタンスをインポート
from adapter.rest_api import app

if __name__ == "__main__":
    print("Starting Planning Service (REST API Server & Client)...")

    # CA: Infrastructure
    # 処理内容: Uvicornサーバーを起動する。
    # port=8002      : 経路計算サービスはポート8002番で実行する
    uvicorn.run("adapter.rest_api:app", host="0.0.0.0", port=8002, reload=True)

    # --- 第5巡のMQTT関連コードは全て削除 ---

```

## 💡 ポイント

経路計算サービスのUseCaseは、**データを待つ（受動的）立場から、自らデータを取りに行く（能動的）立場に変わりました。**`use_case.handle()` が呼ばれると、その内部で `recognition_client.fetch_world_model()` が実行されます。これは同期呼び出しであるため、認識サービスからレスポンスが返るまで、`handle()` メソッドの処理は一時停止（ブロック）します。

これが、第5巡（非同期）と第6巡（同期）の決定的な違いです。