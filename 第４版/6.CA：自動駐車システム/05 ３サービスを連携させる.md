# 05 ３サービスを連携させる

# 🚀 最終統合：3サービスを連携させる

これまでのステップで、自動駐車システムを構成する3つの独立した専門家チーム（サービス）を、それぞれクリーンアーキテクチャに基づいて構築しました。

1. **👀 認識サービス**: 世界モデル（`world_model.json`）を\*\*公開（Publish）\*\*する
2. **🧠 経路計算サービス**: `world_model.json` を\*\*購読（Subscribe）**し、駐車計画（`plan.json`）を**公開（Publish）\*\*する
3. **🦾 車両制御サービス**: `plan.json` を\*\*購読（Subscribe）\*\*し、ハードウェアを制御する

この最終ステップでは、これら3つの独立したサービスを**同時に起動**し、ファイル（`world_model.json`, `plan.json`）を介して非同期的に連携させ、システム全体として「自動駐車」を実行させる方法を学びます。

---

## 🗺️ 統合アーキテクチャの全体像（復習）

私たちが構築したシステムは、SOA（サービス指向アーキテクチャ）のシミュレーションです。各サービスは独立しており、決められた「契約」であるファイル（JSON）を介してのみ情報を交換します。

| サービス | 入力（購読 / Subscribe） | 出力（公開 / Publish） |
| --- | --- | --- |
| **👀 認識サービス** | センサー（HW） | `world_model.json` |
| **🧠 経路計算サービス** | `world_model.json` | `plan.json` |
| **🦾 車両制御サービス** | `plan.json` | 制御信号（HW） |

---

## 🎯 課題：どうやって「同時に」動かすか？

これまでの3ページでは、各サービスの `main.py` を個別に実行して「1回だけ」動作を確認しました。しかし、実際のシステムは「動き続ける」必要があります。

- 認識サービスは、周囲の状況を**継続的に**監視し、`world_model.json` を更新し続ける。
- 経路計算サービスは、`world_model.json` の更新を**継続的に**チェックし、`plan.json` を更新し続ける。
- 車両制御サービスは、`plan.json` の更新を**継続的に**チェックし、車を制御し続ける。

これは、本格的なSOA（マイクロサービス）では、各サービスが独立したプロセス（例：Dockerコンテナ）として「常駐」し、通信（MQTTやgRPC）でデータをやり取りすることで実現されます。

今回は、Pythonの `asyncio`（非同期I/O）を使い、これら3つのサービスを「常駐」させ、**1つのターミナル（プロセス）で並行に実行する**方法でシミュレートします。

---

## 🧩 ステップ1：各サービスの `main.py` を「常駐化」する

まず、各サービスの `main.py` が1回実行したら終わってしまうのを防ぐため、`UseCase` の実行部分を `while True:` の無限ループで囲み、「常駐サービス」のように振る舞うよう変更します。

（※変更するのは `main.py` の `main()` 関数の中だけです。UseCaseやAdaptersは一切変更しません。）

### 1. 認識サービス (`perception_service/main.py` の修正)

`UseCase` の実行（`await use_case.handle()`）を `while True:` で囲み、1秒ごと（`asyncio.sleep(1)`）に状況を更新し続けるように変更します。

```python
# perception_service/main.py (修正後)
import asyncio
from application.use_cases import UpdateWorldModelUseCase
from adapters.stub_sensor import StubSensorAdapter
from adapters.repositories import InMemoryWorldModelRepository
from adapters.file_publisher import FileWorldModelPublisher

# ( ... 依存関係の注入(DI)部分は省略 ... )

async def main():
    """
    アプリケーションを起動し、依存関係を注入 (DI) し、
    ループ実行する。
    """
    print("--- [Perception Service] Starting Up ---")

    # 1. Adapters層（具体的な実装）をインスタンス化
    sensor_adapter = StubSensorAdapter()
    world_model_publisher = FileWorldModelPublisher(filepath="world_model.json")
    world_model_repository = InMemoryWorldModelRepository()

    # 2. UseCase層に、具体的な実装を「依存性の注入 (DI)」
    use_case = UpdateWorldModelUseCase(
        sensor_interface=sensor_adapter,
        world_model_repo=world_model_repository,
        planning_adapter=world_model_publisher
    )

    # 3. アプリケーション（UseCase）の【ループ実行】
    print("\\n--- [Perception Service] Running in loop (Press Ctrl+C to stop) ---")
    while True:
        try:
            # UseCaseのhandleメソッドを呼び出す
            await use_case.handle()

            # 1秒待機（1秒ごとに世界を認識するイメージ）
            await asyncio.sleep(1)

        except Exception as e:
            print(f"--- [Perception Service] Error in loop: {e} ---")
            await asyncio.sleep(5) # エラー時は5秒待機

# ( if __name__ == "__main__": ... の部分は変更なし)

```

### 2. 経路計算サービス (`planning_service/main.py` の修正)

同様に、経路計算サービスも1秒ごとに `world_model.json` をチェック（`handle()` を実行）するように変更します。

```python
# planning_service/main.py (修正後)
import asyncio
from application.use_cases import CalculateParkingPlanUseCase
from adapters.file_subscriber import FileWorldModelSubscriber
from adapters.repositories import InMemoryPlanRepository
from adapters.file_publisher import FilePlanPublisher

async def main():
    """
    アプリケーションを起動し、依存関係を注入 (DI) し、
    ループ実行する。
    """
    print("--- [Planning Service] Starting Up ---")

    # 1. Adapters層（具体的な実装）をインスタンス化
    world_model_subscriber = FileWorldModelSubscriber(filepath="world_model.json")
    plan_publisher = FilePlanPublisher(filepath="plan.json")
    plan_repository = InMemoryPlanRepository()

    # 2. UseCase層に、具体的な実装を「依存性の注入 (DI)」
    use_case = CalculateParkingPlanUseCase(
        world_model_sub=world_model_subscriber,
        plan_repo=plan_repository,
        plan_pub=plan_publisher
    )

    # 3. アプリケーション（UseCase）の【ループ実行】
    print("\\n--- [Planning Service] Running in loop (Press Ctrl+C to stop) ---")
    while True:
        try:
            # UseCaseのhandleメソッドを呼び出す
            await use_case.handle()

            # 1秒待機（1秒ごとに計画を見直すイメージ）
            await asyncio.sleep(1)

        except Exception as e:
            print(f"--- [Planning Service] Error in loop: {e} ---")
            await asyncio.sleep(5)

# ( if __name__ == "__main__": ... の部分は変更なし)

```

### 3. 車両制御サービス (`control_service/main.py` の修正)

車両制御サービスは、`handle()` の内部で既に計画（`plan.json`）の全コマンドを実行するロジックになっています。
そのため、「新しい計画が来ているかチェックし、来ていれば実行する」という動作を1秒ごとに繰り返すよう変更します。

```python
# control_service/main.py (修正後)
import asyncio
from application.use_cases import ExecutePlanUseCase
from adapters.file_subscriber import FilePlanSubscriber
from adapters.repositories import InMemoryVehicleStateRepository
from adapters.stub_actuator import StubActuatorAdapter

async def main():
    """
    アプリケーションを起動し、依存関係を注入 (DI) し、
    ループ実行する。
    """
    print("--- [Control Service] Starting Up ---")

    # 1. Adapters層（具体的な実装）をインスタンス化
    plan_subscriber = FilePlanSubscriber(filepath="plan.json")
    state_repository = InMemoryVehicleStateRepository()
    actuator_adapter = StubActuatorAdapter()

    # 2. UseCase層に、具体的な実装を「依存性の注入 (DI)」
    use_case = ExecutePlanUseCase(
        plan_sub=plan_subscriber,
        state_repo=state_repository,
        actuator=actuator_adapter
    )

    # 3. アプリケーション（UseCase）の【ループ実行】
    print("\\n--- [Control Service] Running in loop (Press Ctrl+C to stop) ---")
    while True:
        try:
            # UseCaseのhandleメソッドを呼び出す
            # (handle内で plan.json がなければ即座にリターンされる)
            await use_case.handle()

            # 1秒待機（1秒ごとに新しい計画がないか確認するイメージ）
            await asyncio.sleep(1)

        except Exception as e:
            print(f"--- [Control Service] Error in loop: {e} ---")
            await asyncio.sleep(5)

# ( if __name__ == "__main__": ... の部分は変更なし)

```

---

## 🚀 ステップ2：統合起動スクリプトの作成

これで、3つのサービスがそれぞれ「常駐」できるようになりました。
最後に、これら3つの `main()` 関数を**並行**に実行するための、統合起動スクリプトをプロジェクトのルート（`perception_service/` などと同じ階層）に作成します。

```python
# run_all_services.py (プロジェクトルートに新規作成)
import asyncio
import sys
import os

# --- 各サービスのmain関数をインポート ---
# (Pythonが各サービスを見つけられるよう、パスを追加)
sys.path.append(os.path.abspath('./perception_service'))
sys.path.append(os.path.abspath('./planning_service'))
sys.path.append(os.path.abspath('./control_service'))

from perception_service.main import main as perception_main
from planning_service.main import main as planning_main
from control_service.main import main as control_main

# -----------------------------------------------------------------------------
# 統合エントリーポイント
# - クラス図の位置: - (システム全体の起動役)
# - 同心円図の位置: 最も外側 (OS / 環境)
# -----------------------------------------------------------------------------
async def run_system():
    """
    3つのサービス（のmain関数）を並行実行する
    """
    print("=========================================")
    print("=== AUTONOMOUS PARKING SYSTEM STARTUP ===")
    print("=========================================\\n")

    try:
        # asyncio.gather を使うと、複数の非同期関数を
        # 同時に（並行して）実行できる。
        await asyncio.gather(
            perception_main(),
            planning_main(),
            control_main()
        )
    except KeyboardInterrupt:
        print("\\n\\n========================================")
        print("=== AUTONOMOUS PARKING SYSTEM SHUTDOWN ===")
        print("========================================")

if __name__ == "__main__":
    # 統合システムを実行
    asyncio.run(run_system())

```

---

## 💡 実行結果（シミュレーション）

この `run_all_services.py` を実行すると、ターミナルには3つのサービスのログが\*\*非同期（バラバラ）\*\*に表示され始めます。

```bash
$ python run_all_services.py
=========================================
=== AUTONOMOUS PARKING SYSTEM STARTUP ===
=========================================

--- [Perception Service] Starting Up ---
[Adapter] InMemoryRepo: Initialized.
--- [Perception Service] Running in loop (Press Ctrl+C to stop) ---

--- [Planning Service] Starting Up ---
[Adapter] InMemoryRepo: Initialized.
--- [Planning Service] Running in loop (Press Ctrl+C to stop) ---

--- [Control Service] Starting Up ---
[Adapter] InMemoryRepo: Initialized.
--- [Control Service] Running in loop (Press Ctrl+C to stop) ---

# --- 1秒後 ---
[Adapter] StubSensor: Generating dummy image data...
[Adapter] StubSensor: Generating dummy sonar data...
[Adapter] InMemoryRepo: Getting WorldModel from memory.
[Adapter] InMemoryRepo: Saving WorldModel to memory.
[Adapter] FilePublisher: World Model saved to world_model.json   # <- 認識サービスが書き込み
[UseCase] World Model not found. Skipping plan calculation.      # <- 経路計算はまだ world_model.json が無かった
[Adapter] FileSubscriber: Parking Plan file not found.           # <- 制御はまだ plan.json が無い
[UseCase] Parking Plan not found. Skipping execution.

# --- 2秒後 ---
[Adapter] StubSensor: Generating dummy image data...
[Adapter] StubSensor: Generating dummy sonar data...
[Adapter] InMemoryRepo: Getting WorldModel from memory.
[Adapter] InMemoryRepo: Saving WorldModel to memory.
[Adapter] FilePublisher: World Model saved to world_model.json
[Adapter] FileSubscriber: Reading World Model from world_model.json... # <- 経路計算が world_model.json を発見！
[UseCase] Calculating parking plan...
[Adapter] InMemoryRepo: Saving ParkingPlan to memory.
[Adapter] FilePublisher: Parking Plan saved to plan.json         # <- 経路計算が plan.json を書き込み
[Adapter] FileSubscriber: Parking Plan file not found.           # <- 制御はまだ plan.json が無い
[UseCase] Parking Plan not found. Skipping execution.

# --- 3秒後 ---
[Adapter] StubSensor: Generating dummy image data...
...
[Adapter] FilePublisher: World Model saved to world_model.json
[Adapter] FileSubscriber: Reading World Model from world_model.json...
[UseCase] Calculating parking plan...
[Adapter] InMemoryRepo: Saving ParkingPlan to memory.
[Adapter] FilePublisher: Parking Plan saved to plan.json
[Adapter] FileSubscriber: Reading Parking Plan from plan.json... # <- 制御が plan.json を発見！
[UseCase] Executing plan with 3 commands...
[Adapter] InMemoryRepo: Getting VehicleState from memory.
[UseCase] Executing command: steer=-30.0 for 2.0s
[Adapter] StubActuator: STEER set to -30.0 degrees              # <- 制御がハードウェア（スタブ）を実行！
... (2秒待機) ...
[Adapter] InMemoryRepo: Getting VehicleState from memory.
[UseCase] Executing command: throttle=-0.5 for 5.0s
[Adapter] StubActuator: THROTTLE set to -0.5 m/s^2             # <- 制御がハードウェア（スタブ）を実行！
...

```

（※実際には `asyncio.sleep` のタイミングにより、ログの順番は実行ごとに多少前後します）

---

## 🐍 PythonとC言語の比較（初心者の方へ）

Python (非同期プログラミング): `asyncio.gather` を使うことで、OSのスレッドを（基本的には）1つしか使わなくても、複数のタスク（各サービス）がI/O待ち（`await asyncio.sleep()`など）の間に処理を切り替えることで、並行動作を実現できます。

C言語 (マルチプロセス/マルチスレッド): 同様のことをC言語で実現するには、`fork()`でプロセスを3つに分岐させたり、`pthread_create()`で3つのスレッドを作成したりする必要があります。これらはOSの機能を直接利用するため強力ですが、プロセス間・スレッド間の安全なデータ共有や同期（Mutex, Semaphore）といった、より複雑な排他制御の知識が必要になります。

---

## 🛡️ この第四巡のゴール（SOAの勘所）

この第四巡「自動駐車システム」で、私たちは最も重要なことを学びました。

1. **システムレベルの関心の分離**:
「認識」「計画」「制御」という、システム全体を構成する大きな関心事を、独立した「サービス」として分離しました。
2. **インターフェース（契約）の重要性**:
サービス間が唯一依存するものは、`world_model.json` や `plan.json` の「中身の構造（スキーマ）」だけである、ということを学びました。この「契約」こそが、SOA（API）設計の核心です。
3. **アダプタによる技術詳細の隔離**:
サービス間の連携方法が、今回のような「ファイルI/O」であっても、将来「MQTT」や「gRPC」といったネットワーク通信に変わっても、`FilePublisher` を `MQTTPublisher` に差し替える（＝アダプタを交換する）だけで、UseCaseのロジックは一切変更しなくて良い、というクリーンアーキテクチャの最大の利点を再確認しました。

この第四巡は、これまでの三巡で学んだ「部品（クリーンアーキテクチャ）」の作り方を応用し、「システム全体（SOA）」の設計図を描くための、非常に重要なステップでした。

---

（これで第四巡は完了です。次のステップに進まれますか？）