# 00 はじめに

# 🚗 はじめに：自動駐車システムと「大きな設計図」への挑戦

これまでの５巡（ToDo、図書館、会議室予約、自動販売機）で、私たちはクリーンアーキテクチャを**部品レベル**で身につけてきました。
`Entity`（ルールブック）、`UseCase`（仕事の手順）、`Adapters`（翻訳家・道具係）を分けることで、変更に強くテストしやすい構造を体験しました。

**第六巡**では、その知識を使って**もう一段大きい単位＝システム全体**を設計します。題材は **自動駐車システム**。
目標は、部品を作るだけでなく、**部品どうしをどう分割し、どう連携させるか（サービス指向）**を学ぶこと。これは次に進む **SOA（サービス指向アーキテクチャ）** への入口です。

---

## 🎯 なぜ自動駐車？なぜ「分割」？

自動駐車には、現実の車が持つ3つの専門機能が登場します。

* **Perception Service（認識）**：センサーから環境を理解（駐車枠・障害物など）
* **Planning Service（経路計画）**：認識結果をもとに安全な駐車ルートを計算
* **Control Service（車両制御）**：経路通りにステア・駆動を実行

1つの巨大プログラムでまとめると複雑化します。
**専門機能をサービスに分割**することで、各チームは自分の関心に集中でき、変更やテストも容易になります。これが **SOA の基本思想**です。

---

## 🧭 第６巡のアプローチ：3つの“小さなクリーンアーキ”を並べる

上の3機能を、**それぞれ独立したクリーンアーキテクチャ**として作ります。
つまり、**サービスの中にも `Entity / UseCase / Adapters` がある**構造にします（“サービスの中のクリーンアーキ”）。

---

## 🔌 サービス間のやりとり（今回はファイルで模擬）

本来は gRPC / MQTT / HTTP 等を使いますが、本巡では**境界設計に集中**するため、まずは**ファイルI/Oアダプタ**で連携を模擬します。

* 出力側（例：Perception）：**WorldModel** を **JSONファイル**に書き出す
* 入力側（例：Planning）：**JSONファイル**を読み取り、DTOとして解釈
* 後で**通信アダプタ**に差し替えても、変わるのは**アダプタ層のみ**（UseCase から外）

> これはこれまでの学びの延長です：UIやDBの差し替えと同じ発想で、**連携手段もアダプタとして差し替え可能**にします。

---

## 🗂 フォルダ構成（最小で“全体像が見える”版）

> 「サービス × クリーンアーキ」をはっきり見せるための、**教材最適化構成**です。

```text
autopark/
├─ services/
│  ├─ perception/
│  │  ├─ domain/            # WorldModel, Detection 等
│  │  ├─ usecase/           # BuildWorldModelUseCase
│  │  └─ adapters/          # sensor_stub.py, worldmodel_file_writer.py
│  │
│  ├─ planning/
│  │  ├─ domain/            # Trajectory, Pose 等
│  │  ├─ usecase/           # PlanParkingPathUseCase
│  │  └─ adapters/          # worldmodel_file_reader.py, plan_file_writer.py
│  │
│  └─ control/
│     ├─ domain/            # ControlCommand 等
│     ├─ usecase/           # FollowTrajectoryUseCase
│     └─ adapters/          # plan_file_reader.py, vehicle_actuator_stub.py
│
├─ platform/                 # 将来の置き換え先（通信・メッセージ基盤）
│  ├─ messaging/             # grpc_gateway.py, mqtt_gateway.py（後で差し替え）
│  └─ storage/               # file_bus.py（今回の連携はここで実装）
│
├─ shared/                   # サービス間で共通利用する定義
│  ├─ dto/                   # WorldModelDTO.json, PlanDTO.json, CommandDTO.json
│  └─ schemas/               # JSON Schema / Pydantic models（契約の唯一の真実）
│
└─ orchestrator/             # 全体の進行役（学習用）
   ├─ scenario_runner.py     # 1) 認識→ 2) 計画→ 3) 制御 の順に呼ぶ
   └─ main.py                # “今日の組み合わせ”を配線（DI）
```

* **services/**：各サービスが**小さなクリーンアーキ**
* **shared/**：**契約（DTO/Schema）の唯一の真実**を集中管理（バージョン付け可）
* **platform/**：将来、**通信アダプタ**に差し替える場所（今回は `storage/file_bus.py` を使用）
* **orchestrator/**：学習用に直列実行する最小オーケストレータ（本番では不要 or 別プロセス）

---

## 📦 サービス間契約（DTO）の最小例

**WorldModelDTO v1**（Perception → Planning）：

```json
{
  "schema": "shared/schemas/world_model.v1.json",
  "scene_id": "2025-10-31T16:00:00+09:00",
  "parking_slots": [
    {"id": "S1", "center": [10.0, 5.0], "yaw_deg": 90.0, "size": [2.5, 5.0], "free": true}
  ],
  "obstacles": [
    {"id": "O1", "center": [6.0, 3.0], "radius": 0.4}
  ],
  "ego_pose": {"x": 0.0, "y": 0.0, "yaw_deg": 0.0}
}
```

**PlanDTO v1**（Planning → Control）：

```json
{
  "schema": "shared/schemas/plan.v1.json",
  "target_slot_id": "S1",
  "trajectory": [
    {"t": 0.0, "x": 0.0, "y": 0.0, "yaw_deg": 0.0},
    {"t": 1.0, "x": -0.5, "y": 0.2, "yaw_deg": 8.0}
  ]
}
```

> ✅ **ポイント**：DTOは**共有ディレクトリで版管理**（`v1`, `v2`）。
> 互換性が崩れる変更は **新バージョンを追加**して移行。これが**SOAの契約管理**の基本です。

---

## 🧠 この巡で得る視点

1. **システムレベルの関心分離**：機能をサービス単位に分割して独立開発・独立デプロイの基礎を理解
2. **インターフェース設計の重要性**：**共有DTO/Schema**を“唯一の真実”として扱う習慣
3. **アダプタ差し替えの再確認**：ファイル連携 → gRPC/MQTT へ、**変わるのは外側だけ**
4. **オーケストレーションの選択**：学習中は同期直列、本番では**非同期＋最終的整合性**の選択肢もある
5. **冪等性／再実行性**：重複メッセージでも安全な**idempotent**なUseCase設計

---

## ▶ 学び方の道筋（この巡の構成）

1. **分割の設計**：サービス境界・共有DTOの決定
2. **Perception**：WorldModel を生成（ファイル出力アダプタ）
3. **Planning**：WorldModel を入力に Plan を計算（入出力アダプタ）
4. **Control**：Plan を入力に制御コマンドを生成（出力はモック）
5. **Orchestrator**：3サービスを直列に配線（DI）して通し動作
6. **発展**：file_bus → gRPC/MQTT に**アダプタ差し替え**／DTO v2 追加

---

## 🚀 SOAへの最終ステップ

今回の連携は**ファイルI/Oアダプタ**で十分です。
ここを **gRPC/MQTT/HTTP** に置き換えれば、そのまま **本格SOA** に進化します。
変えるのは**platform/adapters と各サービスの adapters**だけ。
**UseCase と Entity は不変**――これがクリーンアーキの“矢印の向き”の効力です。

さあ、**部品作り**から**サービス設計**へ。
「大きな設計図」を描くアーキテクトへの一歩を踏み出しましょう。
