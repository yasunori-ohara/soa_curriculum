# 01 サービス概要

# 🚗 サービス概要：独立した専門家チームの連携

第四巡では、自動駐車システムを複数の独立した「サービス」に分割して設計します。これは、クリーンアーキテクチャの原則をシステム全体に適用し、SOA（サービス指向アーキテクチャ）の考え方を学ぶための重要なステップです。

このセクションでは、システム全体の構成と、各サービスがどのように独立して役割を果たし、連携するのか、その概要を掴みます。

## 🎯 3つの独立した専門家チーム：サービス分割

自動駐車という複雑なタスクを、それぞれ専門分野を持つ3つの独立したサービスに分割します。各サービスは、他のサービスから独立して開発・テスト・実行が可能です。

- **認識サービス (Perception Service)**
    - 役割: システムの「目」👀。センサー情報を解釈し、「世界モデル（環境マップ）」を作成します。
    - 入力: ハードウェア（カメラ、ソナー）からのセンサーデータ
    - 出力: 世界モデル (ファイルなど)
- **経路計算サービス (Planning Service)**
    - 役割: システムの「頭脳」🧠。「世界モデル」を読み込み、最適な「動作コマンド」を計算します。
    - 入力: 世界モデル (ファイルなど)
    - 出力: 動作コマンド (ファイルなど)
- **車両制御サービス (Control Service)**
    - 役割: システムの「手足」🦾。「動作コマンド」を読み込み、ハードウェア（ステアリング、モーター）に指示を出します。
    - 入力: 動作コマンド (ファイルなど)
    - 出力: ハードウェアへの指示

## ➡️ サービス間の情報の受け渡し：非同期的なファイル交換

各サービスは独立して動作しますが、情報を交換することでシステム全体として機能します。今回は、その情報交換を**ファイル**を介して行います。

```markdown
1. ハードウェア (入力) ---> 認識サービス ---> 世界モデル (ファイル)
   (カメラ, ソナー)

2. 世界モデル (ファイル) ---> 経路計算サービス ---> 動作コマンド (ファイル)

3. 動作コマンド (ファイル) ---> 車両制御サービス ---> ハードウェア (出力)
                                               (ステアリング, モーター)

```

- **独立した動作**:
    - 認識サービスは、センサーデータを取得し、自身のタイミングで世界モデルファイルを更新します。
    - 経路計算サービスは、自身のタイミングで世界モデルファイルを読み込み、計算結果を動作コマンドファイルに書き出します。
    - 車両制御サービスは、自身のタイミングで動作コマンドファイルを読み込み、ハードウェアを制御します。
- **「バトンリレー」ではない**: これは、前のサービスが終わるのを待って次のサービスが動く、という逐次的な「バトンリレー」ではありません。各サービスは基本的に独立して動き、他のサービスが生成した最新の情報を、自分が必要なタイミングで参照（ファイル読み込み）します。いわば、\*\*共有の掲示板（ファイル）\*\*に各々が情報を書き込み、必要な情報を読みに行くイメージです。
- **ここがポイント！** 💡
このファイル入出力も、**アダプター層**の仕事です。これは、いままでの三巡でUIやDBを差し替えてきたのと同じ考え方です。
将来、このファイル入出力アダプターを、**通信アダプター（gRPCやMQTTなど）に差し替えれば**、`UseCase`などのビジネスロジックを変更することなく、そのまま本格的なSOAシステムに移行できます。サービス間の連携方法もまた、交換可能な「詳細」なのです。

## 🧩 各サービスは独立したクリーンアーキテクチャ

この第四巡の最も重要なポイントは、これら3つのサービスが、それぞれ独立した**クリーンアーキテクチャを持つアプリケーション**として設計されることです。

## ❓ Q&A

### **Q. 「世界モデル」や「動作コマンド」のデータ形式（ファイルの中身）は誰が決めるのですか？ 作る側？ 使う側？ クリーンアーキテクチャ内部のインターフェースの決め方と違うような…？**

**A.** これはサービス間の**インターフェース（API）設計**に関わる、非常に重要な質問です。クリーンアーキテクチャ内部の考え方を理解しているからこそ出てくる良い疑問ですね。

**結論から言うと、サービス間のインターフェースは、主にそれを利用する側（消費者、Consumer）の要求に基づいて、データを作成する側（生産者、Producer）が責任を持って定義する、という共同作業になります。**

- **クリーンアーキテクチャ内部との違い**:
    - **内部**: `UseCase`が安定性を保つため、自身のインターフェース（`InputData`, `OutputData`, `Boundaries`）を定義し、外側の`Adapters`がそれに合わせます。（依存の方向：**内側 → 外側**）
    - **サービス間**: 消費者サービス（例: 経路計算サービス）は、自分の仕事を遂行するために必要な情報を生産者サービス（例: 認識サービス）に要求します。生産者サービスはその要求に応える形で、インターフェース（データ形式）を定義・提供します。（依存の方向：**消費者 ← 生産者** のインタラクションが重要）
- **具体的なプロセス**:
    1. **要求定義 (消費者 → 生産者)**: 経路計算サービスが「経路計算には駐車スペースの位置と角度、障害物の位置が必要だ」と認識サービスに要求します。
    2. **インターフェース定義 (生産者)**: 認識サービスは、その要求を満たすように「世界モデル」のデータ形式（JSONスキーマやクラス定義）を設計し、「これが我々が提供するインターフェースです」と公開します。
    3. **合意と実装**: 両者がその形式に合意し、認識サービスは合意した形式でファイルを出力、経路計算サービスは合意した形式を読み込んで解釈するように実装します。
- **レストランの例え**: レストラン（生産者）がメニュー（インターフェース）を作る際、お客さん（消費者）がどんな料理を食べたいか（要求）を考慮するのに似ています。レストランは最終的なメニューを決めますが、それはお客さんのニーズに応える形で作られます。🍽️
- **誰が責任を持つか**:
最終的なインターフェースの**定義と提供の責任**は、データを作成する**生産者側**にあります。しかし、その内容は消費者の要求なしには決められません。

このように、サービス間のインターフェース設計は、単に生産者が一方的に決めるのではなく、利用側のニーズを汲み取りながら進める**共同設計**であり、明確な「契約」として定義することが、独立したサービス同士をうまく連携させる鍵となります。🔑