# 02 レイヤー構造

# 🏛️ レイヤー構造

クリーンアーキテクチャの視覚的な特徴であり、「依存性のルール」を具現化するのが、同心円状の「**レイヤー構造 (Layers)**」です。

---

## ❓ 構造の定義

クリーンアーキテクチャでは、ソフトウェアを**関心事**（Concern）ごとに、以下のような同心円状の層（レイヤー）に分割します。

1. **Entities (エンティティ)**: 最も内側の円。企業全体の（またはドメイン固有の）ビジネスルールとデータ構造をカプセル化します。アプリケーションに依存せず、最も安定しているべき層です。
2. **Use Cases (ユースケース)**: Entitiesのすぐ外側の円。アプリケーション固有のビジネスルール（特定のシナリオやフロー）を実装します。Entitiesを利用し、外側の層へのインターフェース（境界）を定義します。
3. **Interface Adapters (インターフェースアダプタ)**: Use Casesの外側の円。UseCaseやEntityにとって都合の良い形式のデータを、外部（DB、UI、Webなど）にとって都合の良い形式に変換するアダプタ群（Presenter, Controller, Gatewayなど）が含まれます。
4. **Frameworks and Drivers (フレームワークとドライバ)**: 最も外側の円。具体的な技術詳細（Webフレームワーク、データベースドライバ、UIフレームワークなど）が配置されます。この層は最も不安定で、変更されやすいと考えられます。

### 💡 簡単に言うと

ソフトウェアを「**ビジネスの核心（内側）**」と「**技術的な詳細（外側）**」に分け、その間に「**通訳・変換役**」を置く構造です。

### 🤔 なぜ重要か？

このレイヤー構造は、「依存性のルール」と密接に関連し、以下の利点をもたらします。

1. **関心の分離の明確化**:
各レイヤーが担当する責任（ビジネスルール、アプリロジック、変換、技術詳細）が明確になります。
2. **依存関係の強制**:
「依存性は常に外側から内側へ」というルールを、構造的に強制します。内側の円は外側の円の存在を知りません。
3. **変更の影響範囲の限定**:
外側のレイヤー（例：UIフレームワークやDB）を変更しても、依存性のルールにより、内側のレイヤー（UseCase, Entity）への影響を最小限に抑えることができます。
4. **テスト容易性の向上**:
内側のレイヤー（UseCase, Entity）は、外側の具体的な技術に依存しないため、独立してテストすることが容易になります。

---

## ✅ これまでの実践例（どこで使ったか）

私たちは、フォルダ構成によってこのレイヤー構造を表現してきました。

### 📌 フォルダ構成によるレイヤー表現 (第1巡〜第5巡)

- **具体例**: `perception_service/` などの各サービスフォルダ内に、以下のフォルダを作成しました。
    - **`domain/`**: **Entities層**に相当。`WorldModel`, `ParkingPlan` などの核となるデータ構造とビジネスルールを配置しました。
    - **`application/`**: **Use Cases層**に相当。`UpdateWorldModelUseCase` などのアプリケーション固有のフローと、境界インターフェース (`boundaries.py`) を配置しました。
    - **`adapters/`**: **Interface Adapters層** および **Frameworks and Drivers層** に相当。具体的な実装クラス（`MqttPublisher`, `StubSensorAdapter`, `InMemoryRepository`）を配置しました。`main.py` も最も外側の層（起動・DI）の一部と見なせます。
- **実践**: このフォルダ構成と `import` 文の規約（内側から外側を `import` しない）によって、レイヤー構造と依存性のルールをコードレベルで維持しました。

<!-- end list -->

```
perception_service/
├── domain/         # <-- Entities層 (最内)
├── application/    # <-- Use Cases層 (+境界)
├── adapters/       # <-- Adapters層 / Frameworks層 (最外)
└── main.py         # <-- Frameworks層 (最外)

```

---

## ❌ 間違った適用例（アンチパターン）

レイヤー構造が崩れると、依存性のルールも破られ、CAの利点が失われます。

- **例1：UseCaseが具体的なDBドライバを直接使う**
    
    ```python
    # アンチパターン：レイヤー違反
    # from pymongo import MongoClient # 👈 Frameworks層(外側)のライブラリをUseCase層(内側)がimport
    
    class RegisterUserUseCase:
        def handle(self, user_data):
            # UseCaseが直接DBドライバのAPIを呼び出している！
            # client = MongoClient("mongodb://localhost:27017/")
            # db = client.mydatabase
            # result = db.users.insert_one(user_data)
            # client.close()
            # ...
            pass
    
    ```
    
    `UseCase`層が、本来 `Adapters`層（または `Frameworks & Drivers`層）に属するべき `pymongo` ライブラリ（MongoDBドライバ）に直接依存してしまっています。レイヤーを飛び越えた依存であり、DBを変更する際に `UseCase` の修正が必要になります。
    
- **例2：Entityが外部ライブラリに依存する**
    
    ```python
    # アンチパターン：Entityが外部に依存
    # import requests # 👈 Frameworks層(外側)のライブラリをEntity層(最内)がimport
    
    class User:
        def __init__(self, user_id, name):
            self.user_id = user_id
            self.name = name
    
        def fetch_profile_image_url(self):
            # NG! Entityが自分で外部APIを呼び出してしまっている！
            # response = requests.get(f"<https://api.example.com/users/{self.user_id}/profile>")
            # return response.json()["image_url"]
            pass
    
    ```
    
    `Entity`層は、最も内側であり、外部のライブラリやフレームワークに依存すべきではありません。外部APIへのアクセスは、`Adapters`層が担当し、その結果を `UseCase` が `Entity` に渡すべきです。
    

---

## 📝 まとめ

クリーンアーキテクチャのレイヤー構造は、ソフトウェアを**関心事**に基づいて整理し、**依存性のルール**を強制するための強力な枠組みです。

- **Entities**: ビジネスルール
- **Use Cases**: アプリケーションロジック
- **Adapters**: 変換・技術詳細
- **Frameworks/Drivers**: 具体的なツール

この構造に従うことで、変更に強く、テストしやすく、理解しやすいソフトウェアを構築することができます。フォルダ構成をレイヤーに合わせて整理することは、この構造を維持するための良い実践方法です。

---

## ➡️ 次へ

次は、レイヤー間をつなぐ重要な要素、「**(3/10) 境界インターフェース**」について復習しましょう。