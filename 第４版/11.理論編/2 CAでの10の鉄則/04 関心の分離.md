# 04 関心の分離

# 🏛️ 関心の分離

「**関心の分離 (Separation of Concerns - SoC)**」は、クリーンアーキテクチャだけでなく、ソフトウェア設計全体における非常に基本的かつ重要な原則です。クリーンアーキテクチャのレイヤー構造や依存性のルールは、この原則をアーキテクチャレベルで実現するための手段と言えます。

---

## ❓ 原則の定義

> ソフトウェアシステムを、異なる関心事（Concern）を扱う重複しない要素（部品）に分割すること。
> 
> 
> \--- (一般的な定義)
> 

### 💡 簡単に言うと

「混ぜるな危険！」ということです。システムを作る上で考えなければならないこと（＝関心事）を、役割ごとにきれいに分け、それぞれの部品が自分の仕事だけに集中できるようにしましょう、という考え方です。

### 🤔 なぜ重要か？

関心事が混ざり合ったコード（スパゲッティコードなど）は、多くの問題を引き起こします。

1. **理解が困難**:
一つのコードを読むのに、ビジネスロジック、UIの見た目、データベースへのアクセス方法など、複数の異なる「関心事」を同時に頭の中で追わなければならず、非常に疲れます。
2. **変更の影響が大きい**:
例えばUIのボタンの色を変えたいだけなのに、データベースアクセスやビジネスロジックが書かれたコードまで修正が必要になることがあります。修正範囲が広がり、バグのリスクが高まります。
3. **テストが困難**:
ビジネスロジックだけをテストしたいのに、UIやデータベースが密接に絡んでいるため、分離してテストすることができません。
4. **再利用性が低い**:
ある部分のロジックを別の場所で再利用したいと思っても、他の関心事がくっついてきてしまっているため、簡単に切り出して使うことができません。

関心を適切に分離することで、各部品は**単純**になり、**独立性**が高まり、結果としてシステム全体が**理解しやすく**、**変更に強く**、**テストしやすく**なります。

---

## ✅ これまでの実践例（どこで使ったか）

クリーンアーキテクチャ(CA)の構造そのものが、関心の分離を強力に推進します。

### 📌 レイヤーによる関心の分離 (第1巡〜第5巡)

- **具体例**: CAの同心円（Entities, Use Cases, Adapters, Frameworks）は、ソフトウェアにおける主要な「関心事」に基づいて分割されています。
    - **Entities**: ビジネスルールという関心事
    - **Use Cases**: アプリケーション固有のフローという関心事
    - **Adapters**: 外部（UI, DB, ネットワークなど）とのやり取りという関心事
    - **Frameworks**: 具体的なツールやライブラリという関心事
- **実践**: 私たちはフォルダ構成（`domain/`, `application/`, `adapters/`）によって、これらの関心事を物理的に分離しました。`UseCase` はDBアクセス方法を知らず、`Adapter` はビジネスルールを知らない、という状態を作り出しました。

### 📌 SOAによる関心の分離 (第4巡, 第5巡)

- **具体例**: 自動駐車システムを「認識」「経路計算」「制御」という3つのサービスに分割しました。
- **実践**: これは、システム全体の機能を、より大きな粒度で「関心事」に基づいて分割した例です。「周りを見る」こと、「どう動くか考える」こと、「実際に動かす」ことは、それぞれ独立した専門分野（関心事）です。これらを分離することで、各サービスは自身の責任に集中でき、独立した開発・デプロイが可能になりました。

### 📌 単一責任の原則(SRP)との関係

- **具体例**: クラスや関数レベルでSRPを適用することも、関心の分離の実践です。`FilePublisher` は「ファイル書き出し」に関心を持ち、`MqttPublisher` は「MQTT送信」に関心を持つように分離しました。
- **実践**: SRPに従ってクラスや関数を設計することは、より細かい粒度で関心の分離を達成することにつながります。

---

## ❌ 間違った適用例（アンチパターン）

関心の分離ができていないコードは、しばしば「密結合」で「スパゲッティ」な状態になります。

- **例1：UseCase内にSQLクエリが書かれている**
    
    ```python
    # アンチパターン：UseCaseとデータアクセスの関心が混在
    class CreateOrderUseCase:
        def handle(self, order_data):
            # ... order_dataのバリデーション (UseCaseの関心) ...
    
            # データベース接続とSQL実行 (Adapter/Frameworksの関心！)
            connection = connect_to_database(...)
            cursor = connection.cursor()
            sql = f"INSERT INTO orders (item, quantity) VALUES ('{order_data['item']}', {order_data['quantity']})"
            cursor.execute(sql) # 脆弱性あり！
            connection.commit()
            cursor.close()
            connection.close()
    
            # ... 注文完了通知 (UseCaseの関心) ...
    
    ```
    
    `UseCase`（アプリケーションロジック）の中に、`SQL` というデータベース操作の詳細（Adapters/Frameworksの関心事）が混入しています。これではDBの種類を変えたり、テストしたりするのが非常に困難です。関心が分離されていません。
    
- **例2：UIコード内にビジネスルールが書かれている**
    
    ```python
    # アンチパターン：UIとビジネスルールの関心が混在 (例: JavaScript)
    // function onCheckoutButtonClick() {
    //   let totalPrice = 0;
    //   cartItems.forEach(item => { totalPrice += item.price * item.quantity; });
    
    //   // 割引ルールの適用 (ビジネスルール！)
    //   if (totalPrice > 10000) {
    //     totalPrice *= 0.9; // 10%割引
    //   }
    
    //   // UI表示の更新 (UIの関心)
    //   document.getElementById('total-price').innerText = totalPrice;
    
    //   // API呼び出し (Adapterの関心)
    //   sendOrderToServer({ items: cartItems, total: totalPrice });
    // }
    
    ```
    
    ボタンクリック時の処理の中に、合計金額の計算、割引ルールの適用（ビジネスルール）、画面表示の更新（UI）、API呼び出し（Adapter）という複数の関心事が混在しています。割引ルールを変更したいだけなのに、UIやAPI呼び出しのコードまで触る必要があり、非常に危険です。
    

---

## 📝 まとめ

関心の分離(SoC)は、複雑なソフトウェアを管理可能にするための基本戦略です。「**混ぜるな危険**」を合言葉に、役割や目的が異なるものは、意識的に別の部品（クラス、関数、レイヤー、サービス）に分けるように心がけましょう。

クリーンアーキテクチャのレイヤー構造と依存性のルールは、この関心の分離をアーキテクチャレベルで実現するための強力なガイドラインです。

---

## ➡️ 次へ

次は、関心の分離によって得られる大きなメリットの一つ、「**(5/10) テスト容易性**」について復習しましょう。