# 01 依存性のルール

# 🏛️ 依存性のルール

クリーンアーキテクチャを理解する上で最も重要であり、全ての基礎となるのが「**依存性のルール (The Dependency Rule)**」です。これまでのプロジェクトで、私たちは常にこのルールを意識してきました。

---

## ❓ ルールの定義

> ソースコードの依存性は、外側から内側へ向かわなければならない。内側の円にあるものは、外側の円にあるものについて何も知ってはならない。
> 
> 
> \--- Robert C. Martin (Clean Architecture)
> 

### 💡 簡単に言うと

「中心に近いもの（ビジネスルール）は、外側にあるもの（技術的詳細）のことを知ってはいけない」ということです。依存の矢印は、必ず「**詳細 → 抽象**」の方向を向きます。

### 🤔 なぜ重要か？

このルールが破られると、クリーンアーキテクチャの利点が失われます。

1. **変更の影響が波及する**:
もし内側（例：`UseCase`）が外側（例：特定のDBライブラリ `MongoDriver`）を直接知ってしまうと、DBライブラリを変更しただけで、ビジネスロジックである `UseCase` の修正が必要になってしまいます。
2. **ビジネスロジックが汚染される**:
内側のコードに、外側の技術的詳細（例：SQLクエリ文字列、HTMLタグ）が混入し、本来のビジネスルールが読み取りにくく、変更しにくくなります。
3. **テストが困難になる**:
内側のロジックをテストするために、外側の具体的なインフラ（DB、Webサーバーなど）を起動する必要が出てきてしまい、単体テストが非常に困難になります。
4. **再利用性が低下する**:
ビジネスロジックが特定の技術に依存していると、他の技術を使っている別のシステムでそのロジックを再利用できなくなります。

依存性のルールを守ることで、**ビジネスロジック（内側の円）を、頻繁に変更される技術的詳細（外側の円）から守る**ことができます。

---

## ✅ これまでの実践例（どこで使ったか）

私たちは、インターフェースとDI（依存性の注入）を使うことで、このルールを徹底しました。

### 📌 UseCaseとAdaptersの依存関係 (第1巡〜第5巡)

- **具体例**: `UpdateWorldModelUseCase`（`application/`）は、`StubSensorAdapter` や `MqttWorldModelPublisher`（`adapters/`）の存在を**全く知りません**でした。
- **実践**: `UseCase` は `application/boundaries.py` で定義された `SensorInterface` や `PlanningServiceAdapterInterface` という\*\*インターフェース（抽象）\*\*にのみ依存しました。具体的な `Adapter` クラス（詳細）は、`UseCase` ではなく、逆に `Adapter` クラスがインターフェースを実装する形で、抽象に依存していました。
依存性の矢印 `---->` は、常に外側から内側（境界）へ向かっています。
    
    ```
      Adapters (外側/詳細) -----> Boundaries (境界/抽象) <----- UseCase (内側/抽象)
      (implements)               (defines)                    (depends on)
    
    ```
    

### 📌 EntityとUseCaseの依存関係 (第1巡〜第5巡)

- **具体例**: `UpdateWorldModelUseCase`（`application/`）は、`WorldModel`（`domain/`）という **Entity** を直接利用していました。
- **実践**: これはルール通りです。`UseCase`（外側の円）が `Entity`（より内側の円）を知り、利用するのは問題ありません。依存の矢印は外側から内側へ向いています。
    
    ```
      UseCase (外側) -----> Entity (内側)
      (depends on)
    
    ```
    

### 📌 main.pyの役割 (第1巡〜第5巡)

- **具体例**: `main.py` は、`UseCase` クラスと具体的な `Adapter` クラスの両方をインポートし、インスタンス化して結合（DI）していました。
- **実践**: `main.py` は、アーキテクチャの一番外側の層（Frameworks & Drivers）に位置します。一番外側の層が、内側の全ての層を知り、依存関係を解決するのは、依存性のルールに違反しません。

---

## ❌ 間違った適用例（アンチパターン）

依存性のルールに違反すると、典型的な「密結合」なコードになります。

- **例1：UseCaseが具体的なAdapterをimport/インスタンス化する**
（SOLID原則(D)のアンチパターンと同じ例です）
    
    ```python
    # アンチパターン：DIP違反 ＝ 依存性のルール違反
    from adapters.stub_sensor import StubSensorAdapter # 👈 外側のクラスをインポート！
    
    class UpdateWorldModelUseCase:
        def __init__(self):
            # 内側のUseCaseが、外側の具体的な実装を知ってしまっている！
            self._sensor_adapter = StubSensorAdapter()
    
        async def handle(self):
            # 外側のクラスのメソッドを直接呼び出す
            image_data = await self._sensor_adapter.get_camera_image()
            # ...
    
    ```
    
    `UseCase`（内側）が `StubSensorAdapter`（外側）に依存してしまっています。依存の矢印が内側から外側へ向かっており、ルール違反です。
    
- **例2：EntityがUseCaseやAdapterを知っている**
    
    ```python
    # アンチパターン：Entityが外側を知る
    # from application.use_cases import SomeUseCase # 👈 NG! EntityはUseCaseを知らない
    # from adapters.repositories import SomeRepository # 👈 NG! EntityはAdapterを知らない
    
    class WorldModel:
        def save_myself(self):
             # NG! Entityが自分でリポジトリ(外側)を使って永続化しようとしている
             # repo = SomeRepository()
             # repo.save(self)
             pass
    
    ```
    
    `Entity`（最も内側の円）は、`UseCase` や `Adapters`（外側の円）の存在を知ってはいけません。永続化などの操作は、`UseCase` が `RepositoryInterface` を通じて行うべきです。
    

---

## 📝 まとめ

依存性のルール「**依存関係は常に外側から内側へ向かう**」は、クリーンアーキテクチャの根幹です。

このルールを守ることで、ソフトウェアの\*\*中心（ビジネスロジック）**を、不安定で変化しやすい**周辺（技術的詳細）\*\*から隔離し、保護することができます。

インターフェース（抽象）への依存とDIは、このルールを実践するための重要なテクニックです。

---

## ➡️ 次へ

次は、クリーンアーキテクチャの構造そのものである「**(2/10) レイヤー構造**」について復習しましょう。