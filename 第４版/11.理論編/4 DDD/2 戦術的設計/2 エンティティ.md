# 2. エンティティ

# 🏛️ 戦術的設計：エンティティ

DDD（ドメイン駆動設計）の戦術的設計における最も基本的なビルディングブロックの一つが「**エンティティ (Entity)**」です。これは、クリーンアーキテクチャ(CA)の最も内側の円「Entities」層で扱ってきたものと密接に関連しますが、DDDではその性質をより深く掘り下げます。

---

## ❓ エンティティとは？

> 属性（データ）によってではなく、連続性と同一性（ID）によって識別されるオブジェクト。その属性は時間とともに変化する可能性がある。
> 

### 💡 簡単に言うと

「名前（ID）で区別され、人生（ライフサイクル）を通じて状態が変化していく『**主役級**』のモノ」のことです。例えば、「人」は名前や住所が変わっても同じ人（IDで識別）ですし、「注文」はステータス（未発送→発送済み→完了）が変わっても同じ注文（注文IDで識別）です。

### 🤔 なぜ重要か？

ドメイン（ビジネス）における多くの重要な概念は、単なるデータの集まりではなく、時間とともに変化し、追跡される必要がある「モノ」として存在します。エンティティは、これらの概念をモデル化するための中心的な要素です。

1. **同一性の保証**:
システム内で特定の「モノ」を一意に識別し、追跡することを可能にします。IDがあることで、「あの顧客」「この注文」といった区別が明確になります。
2. **状態変化の表現**:
エンティティは可変（Mutable）であり、その属性を変更することで、ビジネスプロセスにおける状態の変化（例：注文ステータスの変更、在庫数の変動）をモデル化できます。
3. **ライフサイクルの管理**:
エンティティには「生成（作成）」から「変更」を経て、最終的に「削除（またはアーカイブ）」されるまでのライフサイクルがあります。このライフサイクルを管理することが、ドメインロジックの重要な部分となることがあります。
4. **ビジネスルールのカプセル化**:
エンティティは、自身のデータ（属性）だけでなく、そのデータを一貫性のある状態に保つための振る舞い（メソッド、ビジネスルール）も持つべきです。（例：`Order` エンティティが `addItem()` メソッドを持ち、追加時に合計金額を再計算するなど）

---

## ✅ これまでの実践例（どこで使ったか）

私たちはCAの実践の中で、暗黙的にDDDのエンティティの考え方を使っていました。

### 📌 ドメイン層のクラス (第1巡〜第5巡)

- **具体例**: `WorldModel` (認識サービス), `ParkingPlan` (経路計算サービス), `VehicleState` (制御サービス)。図書館システムの `Book`, `User` などもこれにあたります。
- **実践**:
    - **同一性**: これらのクラスは、特定の「状況報告書」「駐車計画」「車両状態」を表すオブジェクトとして扱われました。明示的なIDは持ちませんでしたが（今回はシンプルにするため省略）、例えば複数の `ParkingPlan` が存在した場合、それらはメモリ上のアドレス（暗黙的なID）やタイムスタンプで区別される、個別の「モノ」でした。
    - **状態変化**: `WorldModel` の `update_objects()` メソッドや、`ParkingPlan` の `add_command()` メソッドは、エンティティの状態が時間とともに変化することを表しています。`VehicleState` の `update_state()` も同様です。
    - **振る舞い**: これらのメソッドは、単なるセッターではなく、状態変更に伴うビジネスルール（例：タイムスタンプの更新）をカプセル化していました。

---

## ❌ 間違った適用例（アンチパターン）

エンティティの概念を誤解すると、ドメインモデルが貧弱になったり、不整合が起きやすくなったりします。

- **例1：貧血ドメインモデル (Anemic Domain Model)**
エンティティクラスが、データ（属性）のゲッター/セッターしか持たず、ビジネスルールや振る舞い（メソッド）を全く持たない状態。
    
    ```python
    # アンチパターン：貧血なエンティティ
    @dataclass
    class OrderEntity:
        order_id: int
        items: List[dict]
        total_price: float
        status: str
        # ビジネスロジックが全くない！
        # (例: addItem, calculateTotal, ship, cancel などのメソッドがない)
    
    # 別のクラス（UseCaseやService層）にロジックが漏れ出す
    class OrderService:
        def add_item_to_order(self, order: OrderEntity, item_data):
            # 本来 OrderEntity が持つべきロジックがここにある
            order.items.append(item_data)
            order.total_price += item_data['price'] * item_data['quantity']
            # ...
    
    ```
    
    これでは、`OrderEntity` は単なるデータ構造（DTOに近い）であり、注文に関するルール（合計金額の計算方法、ステータス遷移の条件など）がクラスの外（例：`OrderService`）に散らばってしまいます。データの整合性を保つのが難しくなり、コードの重複も発生しやすくなります。エンティティはデータと振る舞いを一緒に持つべきです。
    
- **例2：IDを持たないエンティティ**
本質的に「同一性」で区別されるべきものを、IDなしで扱ってしまう。
    
    ```python
    # アンチパターン？：IDのない顧客
    # (状況によるが、通常 Customer は ID で識別されるべき)
    @dataclass
    class Customer:
        name: str
        email: str
        # customer_id がない！
    
    # 同姓同名で同じメールアドレスの顧客を区別できない可能性がある
    # (例：システム統合時に問題が発生するなど)
    
    ```
    
    全てのエンティティが永続化IDを持つ必要はありませんが、「これは追跡可能な個別のモノか？」を自問し、必要であれば明確なID（UUID、DBのシーケンス、ドメイン固有の識別子など）を付与することが重要です。
    
- **例3：エンティティと値オブジェクトの混同**
（詳細は次の「値オブジェクト」で説明しますが）本来、属性だけで定義されるべきもの（例：住所）を、IDを持つエンティティとして扱ってしまう、あるいはその逆。

---

## 📝 まとめ

DDDにおけるエンティティは、単なるデータホルダではなく、「**同一性（ID）を持ち、ライフサイクルを通じて状態が変化し、自身のデータに関するビジネスルール（振る舞い）をカプセル化する**」オブジェクトです。

クリーンアーキテクチャの「Entities」層で作成したクラスも、この考え方に基づいて（あるいはさらに意識して）設計することで、よりドメインの概念を豊かに表現し、保守性の高いモデルを構築することができます。

---

## ➡️ 次へ

次は、エンティティと対比される重要な概念、「**値オブジェクト (Value Object)**」について見ていきましょう。