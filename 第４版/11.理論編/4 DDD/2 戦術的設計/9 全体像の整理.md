# 9. 全体像の整理

# 🏛️ 戦術的設計：全体像の整理

これまでに、DDD（ドメイン駆動設計）の戦術的設計における主要なビルディングブロック（構成要素）を一つずつ見てきました。

- **エンティティ (Entity)**: 同一性（ID）で区別されるモノ。
- **値オブジェクト (Value Object)**: 属性（値）だけで定義されるモノ、不変。
- **集約 (Aggregate)**: 一貫性を保つエンティティと値オブジェクトのまとまり、ルートを持つ。
- **リポジトリ (Repository)**: 集約の永続化を抽象化。
- **ドメインイベント (Domain Event)**: ドメイン内の重要な出来事。
- **ドメインサービス (Domain Service)**: 特定のオブジェクトに属さないドメイン操作。
- **ファクトリ (Factory)**: 複雑なオブジェクト生成をカプセル化。

このページでは、これらの要素が*一つの境界づけられたコンテキスト（Bounded Context）*の中で、どのように連携して豊かで堅牢なドメインモデルを形作るのか、その全体像を整理します。

---

## 🧩 モデルの中心：集約 (Aggregate)

戦術的設計の中心となるのは、多くの場合「**集約 (Aggregate)**」です。集約は、データの一貫性を守るための境界であり、ビジネスルールをカプセル化する主要な単位となります。

1. **構成**: 集約は、**集約ルート**（Entity）を必ず一つ持ち、必要に応じて他の**内部エンティティ**や**値オブジェクト**を含みます。
2. **操作**: 集約の状態を変更する操作は、必ず**集約ルート**のメソッドを通じて行われます。これにより、集約内の不変条件（Invariants）が常に守られます。
3. **アクセス**: 外部（例：UseCase）から集約内部のオブジェクト（内部エンティティや値オブジェクト）に直接アクセスすることは原則として禁止されます。アクセスは集約ルートを経由します。

<!-- end list -->

```
        External Actor (e.g., Use Case)
              |
              | 1. Request Operation
              v
     +------------------+
     | Aggregate Root   |  <-- Only entry point
     | (Entity)         |
     |------------------|
     | - Method()       | ----> 2. Executes business logic,
     |   - Validate()   |        maintains invariants,
     |   - ChangeState()|        operates on internal objects
     |                  | <---------------------+
     +--------▲---------+                       | 3. Modifies state
              | (contains / manages)            |
     +--------|-------------------------+       |
     | Internal Entities & Value Objects|       |
     | (State & supporting logic)       +-------+
     +----------------------------------+
              (Aggregate Boundary)

```

---

## 💾 永続化：リポジトリ (Repository)

集約をデータベースなどの永続化ストアに保存したり、そこから復元したりする責務を担うのが「**リポジトリ**」です。

1. **対象**: リポジトリは通常、**集約ルート**ごとに定義されます。
2. **役割**: `UseCase` などのクライアントに対して、あたかもメモリ上のコレクションのように集約を扱えるインターフェース（例: `findById`, `save`）を提供し、具体的な永続化技術（SQL、NoSQLなど）を隠蔽します。
3. **連携**: `UseCase` はリポジトリを使って集約を取得し、集約ルートのメソッドを呼び出してビジネスロキを実行し、変更された集約を再びリポジトリを使って保存します。

```
UseCase          Repo I/F       Repo Impl (Adapter)
      |              |                |
      |--findById--> |                |
      |              |----findById--->|----DB Query-->[DB]
      |              |                |<---Map Data----|
      |<--Aggregate--|<--Aggregate--- |
      |              |                |
      |--Agg.Method-> Agg. Root       |
      | (Logic)      | (Changes)      |
      |              |                |
      |---save-----> |                |
      |              |------save----->|----Persist--->[DB]
      |              |                |<---Result-----|
      |<---Result----|<---Result----- |

```

---

## 🏭 生成：ファクトリ (Factory) と コンストラクタ

新しい集約やエンティティ、値オブジェクトを生成する際には、「**ファクトリ**」またはクラスの**コンストラクタ**が使われます。

1. **単純な場合**: 値オブジェクトやシンプルなエンティティは、コンストラクタ（`__init__`）や静的ファクトリメソッドで生成されることが多いです。この際、自己検証ロジックを含めることが推奨されます（例：不正なメールアドレスは生成できない）。
2. **複雑な場合**: 集約のように、生成時に複数のオブジェクトを組み合わせたり、不変条件を満たす必要があったり、外部リソース（例：ID採番サービス）が必要な場合は、専用のファクトリクラスやドメインサービス（後述）に生成ロジックをカプセル化します。

---

## ⚙️ 複雑な操作：ドメインサービス (Domain Service)

特定のエンティティや値オブジェクトに自然に属さない、複数のオブジェクトにまたがるドメインロジックやプロセスは、「**ドメインサービス**」が担当します。

1. **役割**: 例えば、口座間の送金処理（2つの口座集約が関わる）、複雑な割引計算（注文集約と顧客エンティティ、商品情報が関わる）など。
2. **連携**: `UseCase` はドメインサービスを呼び出し、ドメインサービスは必要に応じてリポジトリから集約を取得し、それらのメソッドを呼び出したり、値オブジェクトを使って計算を行ったりします。ドメインサービスは通常ステートレスです。

<!-- end list -->

```
   Use Case --> Domain Service --> Repository --> Aggregate Root
      |              |                 ^              |
      |              |                 |              v
      |              +-----------------+--------> Method Call
      |                                (Aggregates)
      <---------------------------------------------- Result

```

---

## 📢 副作用の連鎖：ドメインイベント (Domain Event)

ある集約の状態が変化した結果として、別の処理（同じコンテキスト内の別の集約への影響、あるいは外部コンテキストへの通知）を引き起こしたい場合、「**ドメインイベント**」を使います。

1. **発行**: 集約ルートのメソッド内で、ビジネス上重要な出来事（例：注文確定）が発生した際に、ドメインイベント（例：`OrderPlaced` イベント）が発行されます。
2. **購読**: そのイベントに関心のある他のコンポーネント（例：イベントハンドラ、別のドメインサービス）がイベントを購読し、必要な副作用（例：配送集約の作成、通知メールの送信依頼）を実行します。これにより、発行元の集約は副作用を起こすコンポーネントについて知る必要がなくなり、疎結合が保たれます。

<!-- end list -->

```
   Aggregate Root -------+           Event Dispatcher
   (Method Execution)    |                ^      \
           |             | 1. Raise Event |       \ 2. Notify Subscribers
           v             v                |        v
   [ Domain Event ]      +----------------+    [ Event Handler 1 ] -> Side Effect A
                                               [ Event Handler 2 ] -> Side Effect B

```

---

## 🔗 全体の連携イメージ（UseCaseからの流れ）

一つの典型的な `UseCase` の実行フローは、これらのビルディングブロックを使って以下のように表現できます。

1. `UseCase` は、リポジトリから必要な集約を取得します。
2. `UseCase` は、集約ルートのメソッドを呼び出して、ビジネスロジックを実行します。
3. （もし必要なら）集約ルートのメソッドは、ドメインサービスを呼び出して複雑な計算を委譲します。
4. 集約ルートのメソッド内で状態が変更され、不変条件が維持されます。
5. （もし必要なら）集約ルートのメソッドは、ドメインイベントを発行します。
6. `UseCase` は、変更された集約をリポジトリを使って保存します。
7. （もしドメインイベントが発行されていたら）イベントディスパッチャがイベントハンドラを呼び出し、副作用が実行されます。

---

## 📝 まとめ

DDDの戦術的設計は、ドメインの複雑さを管理するための洗練されたツールキット（ビルディングブロック）を提供します。

- **集約**を中心に据え、データの一貫性を保証します。
- **リポジトリ**で永続化を抽象化します。
- **値オブジェクト**でドメイン概念を豊かに表現し、不変性と検証を保証します。
- **ドメインサービス**で、特定のオブジェクトに属さないプロセスを扱います。
- **ドメインイベント**で、関心を分離し、副作用を疎結合に扱います。
- **ファクトリ**で、複雑なオブジェクト生成をカプセル化します。

これらのパターンを適切に組み合わせることで、ドメイン知識をコードに明確に反映し、変更に強く、保守しやすいドメインモデルを構築することができます。

---

## ✅ DDD戦術的設計 完了

これで、DDD戦術的設計の主要なビルディングブロックとその連携についての解説が終わりました。