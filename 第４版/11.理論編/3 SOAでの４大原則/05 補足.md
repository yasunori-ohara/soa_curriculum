# 05 補足

## ❓ Q：SOAは１順しかやらず、また通信もMQTTのみでしたが、これらの４大原則はきちんと守られていたでしょうか？

---

はい、1巡だけでMQTTのみを使用した場合でも、SOAの4大原則は**かなりきちんと守られていた**と言えます。

## 各原則の達成度チェック

### 1. 🛡️ 境界と契約：達成度 ◎

- **守られていた点**: サービス間のやり取りは、MQTTのトピック (`autodrive/world_model`, `autodrive/plan`) とメッセージ形式（JSON）という明確な「**契約**」のみで行われました。各サービスは他のサービスの内部実装（UseCaseやRepository）を全く知りませんでした。これは完璧に実践できていました。

---

### 2. 🧩 自律性：達成度 ○〜◎

- **守られていた点**: MQTT（非同期Pub/Sub）を使ったことで、高い自律性を実現できました。認識サービスが停止しても、経路計算サービス（購読側）は自身のプロセスを継続できました（もちろん新しいデータは来ませんが）。各サービスが自身の状態（`InMemory...Repository`）を管理していた点も自律性を高めています。
- **少し甘い点 (発展)**: もし経路計算サービスが非常に重い計算をしていて、`world_model` の更新頻度についていけない場合、どう振る舞うべきか（古いデータで計算し続ける？ スキップする？）といった、より高度な自律的判断のロジックは今回実装していません。

---

### 3. 🔗 疎結合：達成度 ◎

- **守られていた点**: MQTT (Pub/Sub) を採用したことで、PublisherとSubscriberが互いを全く意識する必要がなく、時間的にも空間的にも非常に**疎結合**な状態を実現できました。アダプタの差し替えが容易だったのは、この疎結合性のおかげです。契約（トピックとメッセージ形式）が変わらない限り、互いに影響を与えません。

---

### 4. 📍 場所の透過性：達成度 △〜○

- **守られていた点**: ブローカーのアドレス (`localhost:1883`) を、UseCaseやAdapterのコアロジックにハードコーディングせず、`main.py` での設定値として外部から注入しました。これは場所の透過性を実現するための**第一歩**として正しいアプローチです。
- **完全ではない点**: 完全な場所の透過性を実現するには、サービスディスカバリ（サービスレジストリなど）の仕組みが必要です。今回は、まだ「`localhost`」という具体的な場所を `main.py` が知っている状態でした。

## まとめ

MQTTという非同期Pub/Sub方式を選んだこと、そしてクリーンアーキテクチャの原則（特にインターフェースとDI）を適用したことで、SOAの核心である**境界・契約・自律性・疎結合**は非常によく達成できていました。場所の透過性についても、基本的な第一歩は踏み出せています。

1巡だけでも、SOAの重要なエッセンスは十分に実践・学習できたと言えるでしょう。 🎉