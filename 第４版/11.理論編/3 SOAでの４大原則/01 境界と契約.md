# 01 境界と契約

# 🏛️ 境界と契約

SOA（サービス指向アーキテクチャ）を構築する上で、最も基本となるのが「**境界を明確にし、契約（インターフェース）で語れ (Explicit Boundaries & Contracts)**」という原則です。

---

## ❓ 原則の定義

> サービスは明確に定義された境界を持ち、外部とのやり取りは公開された契約（インターフェース）を通じてのみ行われるべきである。サービスの内部実装は隠蔽される。
> 

### 💡 簡単に言うと

サービスは独立した「国」のようなもの。どこまでが自分の領土（＝**境界**）かを明確にし、他の国（サービス）とは必ず公式な「外交ルート（＝**契約 / インターフェース**）」を通じてのみやり取りしましょう。国内事情（内部実装）を他国に漏らしてはいけません。

### 🤔 なぜ重要か？

この原則が守られないと、サービス間の依存関係が強くなりすぎ（密結合）、SOAの利点が失われます。

1. **変更の影響範囲の増大**:
あるサービスの内部実装（例：データベースのテーブル構造）を変更しただけで、それを直接利用していた他のサービスまで修正が必要になってしまいます。
2. **独立性の喪失**:
サービス同士が内部を知り合っていると、片方のサービスを修正・デプロイする際に、もう片方のサービスも同時に修正・デプロイしなければならなくなる可能性があります。
3. **理解・再利用の困難化**:
サービスの境界が曖昧だと、どこまでがそのサービスの責任範囲なのかが分かりにくくなります。また、内部実装に依存した連携は、他の場面での再利用を妨げます。

境界を明確にし、公開された契約（インターフェース）だけを頼りに連携することで、各サービスはその**内部実装を自由に変更**できるようになり、**独立して進化**していくことが可能になります。

---

## ✅ これまでの実践例（どこで使ったか）

私たちは、第4巡・第5巡の自動駐車システムで、この原則を実践してきました。

### 📌 ファイル/MQTTによる契約 (第4巡, 第5巡)

- **具体例**: 認識サービスと経路計算サービスは、`world_model.json`（第4巡）または MQTT の `/world_model` トピック（第5巡）を通じてのみ連携しました。
- **実践**:
    - **境界**: 認識サービスの責任は「`WorldModel` データを作成して公開すること」までであり、経路計算サービスの責任は「公開された `WorldModel` データを解釈して `ParkingPlan` を作成すること」から始まります。境界は明確です。
    - **契約**: 両サービス間の唯一の「契約」は、`world_model` データの中身（JSONスキーマ / Pythonの `WorldModel` Entity の構造）でした。認識サービスは、経路計算サービスが *どのように* そのデータを使うかを知りません。経路計算サービスは、認識サービスが *どのように* そのデータを作ったかを知りません。両者は合意されたデータ形式（契約）だけを頼りに連携しました。
    - **隠蔽**: 経路計算サービスは、認識サービスの `UseCase` や `Repository`、ましてやセンサーアダプタの実装について、一切知る必要がありませんでした。逆も同様です。

<!-- end list -->

```
 [認識サービス]          <-- 契約 (world_model データ形式) -->          [経路計算サービス]
   | (内部実装)                                                      | (内部実装)
   +-- UseCase                                                       +-- UseCase
   +-- Repository                                                    +-- Repository
   +-- Sensor Adapter                                                +-- ...
   (これらは隠蔽される)                                                (これらも隠蔽される)

```

### 📌 クリーンアーキテクチャの境界 (第1巡〜第5巡)

- **具体例**: サービス内部のクリーンアーキテクチャにおける `application/boundaries.py`。
- **実践**: `UseCase` が `Adapters` 層とやり取りする際に、インターフェース（契約）を定義し、具体的な実装（詳細）を隠蔽しました。これは、サービス内部における「境界と契約」の原則の適用例と見ることができます。

---

## ❌ 間違った適用例（アンチパターン）

この原則に違反すると、サービスが互いに深く依存し合ってしまいます。

- **例1：他のサービスのデータベースを直接参照する**
    
    ```
    # 経路計算サービス内 (アンチパターン)
    # import order_service_db_driver # 👈 NG! 他のサービスのDBに直接接続
    
    class CalculatePathUseCase:
        def handle(self):
            # 他のサービス(注文サービス)のDBテーブルを直接SQLで読み取る！
            # orders = order_service_db_driver.execute("SELECT * FROM recent_orders WHERE status='pending'")
            # ...
            pass
    
    ```
    
    経路計算サービスが、公開されたAPI（契約）ではなく、注文サービスの内部データベース構造（実装詳細）に直接依存してしまっています。もし注文サービスがデータベースのテーブル名やカラム名を変更したら、経路計算サービスも壊れてしまいます。境界が侵害されています。
    
- **例2：共有ライブラリにビジネスロジックを含めてしまう**
複数のサービスで共通して使うコード（例：データ構造の定義）を共有ライブラリにするのは良いプラクティスですが、そのライブラリに特定のサービスに属するべきビジネスロジックまで含めてしまうと問題になります。
    
    ```
    # shared_library/entities.py
    class Order:
        # ... 注文データ ...
    
        # NG! 本来は注文サービスに属するべきロジック
        # def apply_discount_for_premium_user(self, user_status):
        #     if user_status == 'premium':
        #         self.total *= 0.9
        #     # ...
        #     pass
    
    # payment_service/use_cases.py
    # from shared_library.entities import Order # 共有ライブラリを利用
    
    # class ProcessPaymentUseCase:
    #     def handle(self, order: Order):
    #         # 決済サービスは割引ロジックを知る必要はないはずなのに、
    #         # 共有ライブラリ経由で依存してしまっている
    #         # order.apply_discount_for_premium_user(...)
    #         # ... 決済処理 ...
    #         pass
    
    ```
    
    割引ロジックは「注文」ドメインの関心事であり、「注文サービス」の境界内にカプセル化されるべきです。共有ライブラリに入れることで、関係のない決済サービスまで割引ロジックに依存してしまい、境界が曖昧になっています。共有ライブラリに入れるのは、純粋なデータ構造（DTOやEntityの骨格）や、普遍的なユーティリティ関数に留めるべきです。
    

---

## 📝 まとめ

SOAの第一原則は、「**サービスは独立した存在であり、公開された契約（インターフェース）を通じてのみ対話する**」ということです。

サービスの境界を明確に定義し、その境界を越えるやり取りは、双方で合意された安定した契約（API仕様、メッセージ形式など）に基づいて行います。サービスの内部実装はブラックボックスとして扱い、それに依存しないようにします。

これにより、各サービスは独立して進化でき、システム全体として変更に強い構造を維持することができます。

---

## ➡️ 次へ

次は、SOAの4大原則の2番目、「**(2/4) サービスは自律的であれ**」について見ていきましょう。