# 02 O：オープン/クローズドの原則

# 🏛️ 理論編：SOLID原則（O）- オープン/クローズドの原則

SOLID原則の2番目は、「**O：オープン/クローズドの原則 (Open/Closed Principle)**」です。ソフトウェアの**柔軟性**と**保守性**を高める上で、非常に重要な考え方です。
以降、この原則を **OCP** と呼びます。

---

## ❓ 原則の定義

> 「ソフトウェアのエンティティ（クラス、モジュール、関数など）は、拡張に対して開いて（Open）おり、修正に対して閉じて（Closed）いなければならない。」
> 
> 
> \--- Bertrand Meyer (オリジナルの提唱)
> 
> \--- Robert C. Martin (現代的な解釈に貢献)
> 

### 💡 簡単に言うと

「機能を追加・変更したいときに、既存のコードをなるべく修正しなくても済むように設計しよう」ということです。新しい振る舞いは「追加」によって実現し、既存の動いているコードには「触らない」のが理想です。

### 🤔 なぜ重要か？

既存のコードを修正するには、常にリスクが伴います。

1. **バグ混入のリスク**:
修正した箇所や、その影響範囲に新たなバグ（デグレード）を生み出してしまう可能性があります。
2. **テストコストの増加**:
修正した箇所だけでなく、その影響範囲全体の再テストが必要になります。
3. **開発スピードの低下**:
既存コードの理解や、修正による影響調査に時間がかかります。

新しい機能や変更を「追加」だけで実現できれば、これらのリスクやコストを最小限に抑え、既存の安定したコードを守ることができます。

---

## ✅ これまでの実践例（どこで使ったか）

このOCPは、クリーンアーキテクチャ(CA)の「インターフェース（境界）」と「依存性の注入(DI)」によって、強力にサポートされていました。

### 📌 アダプタの差し替え (第5巡)

- **具体例**: 認識サービスで、出力アダプタを `FileWorldModelPublisher` から `MqttWorldModelPublisher` に変更しました。
- **なぜOCPか**: この変更を行う際、`UpdateWorldModelUseCase` のコードは**一切修正しませんでした**。`UseCase` は `PlanningServiceAdapterInterface` という「抽象（インターフェース）」に依存していました。新しい `MqttWorldModelPublisher` は、このインターフェースを実装する形で**追加**され、`main.py` で注入されるアダプタが差し替えられただけです。
`UseCase` は、新しい公開方法（MQTT）という「拡張」に対しては**開いて**おり、既存の実装（ファイル書き出し）の変更に対しては**閉じて**いたのです。
    
    ```
    UseCase -------> <I> PlanningServiceAdapterInterface <|------- FilePublisher (旧)
                                                       <|------- MqttPublisher (新/追加)
    
    ```
    

### 📌 データベースの変更 (第2巡 図書館システム)

- **具体例**: データ保存先をインメモリDBからMongoDBに変更しました。
- **なぜOCPか**: この時も、`BookRepositoryInterface` というインターフェースは変更せず、`MongoBookRepository` という新しい実装クラスを**追加**しました。`UseCase` は `BookRepositoryInterface` に依存していたため、修正は不要でした。データベースの種類という「拡張」に対して**開いて**おり、既存のインメモリ実装の変更に対しては**閉じて**いました。

### 📌 DI（依存性の注入）(第1巡〜第5巡)

- **具体例**: すべてのサービスの `main.py` で、`UseCase` に具体的なアダプタ（`StubSensorAdapter`, `MqttPublisher` など）を `__init__` 経由で渡していました。
- **なぜOCPか**: DIコンテナ（今回は `main.py`）が依存関係の解決（どの実装を使うか）を担当することで、`UseCase` は具体的な実装クラスを知る必要がなくなります。これにより、`UseCase` を修正することなく、`main.py` で注入するオブジェクトを変更するだけで、振る舞いを「拡張」できるようになります。

---

## ❌ 間違った適用例（アンチパターン）

オープン/クローズドの原則(OCP)に違反すると、変更のたびに既存コードの修正が必要になり、バグのリスクが高まります。

- **例1：条件分岐による機能追加**
新しい機能を追加するたびに、既存のコードに `if/else` や `switch` 文を追加していくパターンです。
    
    ```python
    # アンチパターン：条件分岐での拡張
    class ReportGenerator:
        def generate(self, report_type, data):
            if report_type == "CSV":
                # CSV生成ロジック
                print("Generating CSV report...")
                return self._generate_csv(data)
            elif report_type == "PDF":
                # PDF生成ロジック
                print("Generating PDF report...")
                return self._generate_pdf(data)
            # 新しいフォーマットを追加する場合、ここに elif を追加修正する必要がある
            # elif report_type == "JSON": <--- 修正が必要！
            #     print("Generating JSON report...")
            #     return self._generate_json(data)
            else:
                raise ValueError("Unsupported report type")
    
        def _generate_csv(self, data): pass
        def _generate_pdf(self, data): pass
        # def _generate_json(self, data): pass # <- メソッドも追加修正
    
    ```
    
    JSON形式のレポートを追加したい場合、`generate` メソッドと、`_generate_json` メソッドの両方を**修正**する必要があります。
    
    **改善策（OCP適用）**: Strategyパターン（または単純なインターフェース実装）を使う。
    
    > Strategyパターンとは？ 💡
    Strategy（戦略）パターンは、「アルゴリズム（戦略）をクラスとしてカプセル化し、それらを交換可能にする」デザインパターンです。
    今回の例では、「CSV生成」「PDF生成」「JSON生成」という各アルゴリズムを、共通のインターフェース（ReportStrategy）を持つ独立したクラスとして実装します。
    これにより、ReportGenerator は具体的な生成方法を知らなくても、渡された Strategy オブジェクトに処理を「委譲」するだけでよくなります。新しいフォーマットを追加したい場合は、新しい Strategy クラスを追加するだけで済むため、OCPを満たすことができます。
    > 
    
    ```python
    # OCP適用例：Strategyパターン
    from abc import ABC, abstractmethod
    
    class ReportStrategy(ABC): # 抽象インターフェース (戦略の共通ルール)
        @abstractmethod
        def generate(self, data): pass
    
    class CsvStrategy(ReportStrategy): # 具体的な戦略クラス (既存)
        def generate(self, data): print("Generating CSV..."); return ...
    
    class PdfStrategy(ReportStrategy): # 具体的な戦略クラス (既存)
        def generate(self, data): print("Generating PDF..."); return ...
    
    class JsonStrategy(ReportStrategy): # 👈 新しい戦略クラスを「追加」するだけ
        def generate(self, data): print("Generating JSON..."); return ...
    
    class ReportGenerator:
        def __init__(self, strategy: ReportStrategy): # DIで戦略を受け取る
            self._strategy = strategy
    
        def generate(self, data):
            # 既存の generate メソッドは修正不要！
            # 実際の処理は委譲された Strategy オブジェクトが行う
            return self._strategy.generate(data)
    
    # 利用側 (main.py など) で差し替える
    # generator = ReportGenerator(CsvStrategy())
    generator = ReportGenerator(JsonStrategy()) # 注入する戦略を変えるだけ
    generator.generate(some_data)
    
    ```
    
    新しい `JsonStrategy` クラスを**追加**するだけで、既存の `ReportGenerator` や他の Strategy クラスを**修正する必要がありません**。
    
- **例2：具象クラスへの直接依存**
インターフェース（抽象）ではなく、具体的な実装クラスに直接依存している場合です。
    
    ```python
    # アンチパターン：具象クラスへの依存
    class NotificationService:
        def __init__(self):
            # 具体的な EmailSender クラスに直接依存！
            self.sender = EmailSender()
    
        def notify_user(self, user, message):
            self.sender.send(user.email, message)
    
    class EmailSender:
        def send(self, email, message): print(f"Sending Email to {email}: {message}")
    
    # --- もしSMS通知を追加したい場合 ---
    # 1. SmsSender クラスを追加
    # 2. NotificationService を修正する必要がある！
    #    if user.prefers_sms:
    #        self.sms_sender = SmsSender() # <- 修正
    #        self.sms_sender.send(user.phone, message) # <- 修正
    #    else:
    #        self.sender.send(user.email, message)
    
    ```
    
    SMS通知を追加したい場合、`NotificationService` の `__init__` や `notify_user` メソッドを**修正**する必要があります。
    
    **改善策（OCP適用）**: 依存性逆転の原則(DIP)とDIを使う。
    
    ```python
    # OCP適用例：DIP + DI
    from abc import ABC, abstractmethod
    
    class NotificationSender(ABC): # 抽象インターフェース
        @abstractmethod
        def send(self, recipient, message): pass
    
    class EmailSender(NotificationSender): # 実装クラス (既存)
        def send(self, recipient, message): print(f"Sending Email to {recipient}: {message}")
    
    class SmsSender(NotificationSender): # 👈 新しい実装クラスを「追加」
        def send(self, recipient, message): print(f"Sending SMS to {recipient}: {message}")
    
    class NotificationService:
        def __init__(self, sender: NotificationSender): # 👈 抽象インターフェースに依存
            self.sender = sender
    
        def notify_user(self, user, message):
            # 既存の notify_user メソッドは修正不要！
            recipient = user.phone if isinstance(self.sender, SmsSender) else user.email # (簡易的な判定)
            self.sender.send(recipient, message)
    
    # 利用側 (main.py など) で差し替える
    # notifier = NotificationService(EmailSender())
    notifier = NotificationService(SmsSender()) # 注入する実装を変えるだけ
    notifier.notify_user(some_user, "Hello!")
    
    ```
    
    新しい `SmsSender` クラスを**追加**し、`main.py` で注入するオブジェクトを変更するだけで、`NotificationService` を**修正する必要がありません**。
    

---

## 📝 まとめ

オープン/クローズドの原則(OCP)は、「**変更に強いソフトウェア**」を作るための鍵となる原則です。

新しい機能や変更要求が来たときに、「よし、新しいクラス（や関数）を『追加』しよう」と考え、「既存のコードを『修正』するのは最後の手段だ」と思えるようになれば、この原則をうまく活用できている証拠です。

クリーンアーキテクチャにおける\*\*インターフェース（境界）**と**依存性の注入（DI）\*\*は、このOCPを実現するための強力な武器となります。

---

## ➡️ 次へ

次は、SOLID原則の3番目、「**L：リスコフの置換原則**」について見ていきましょう。