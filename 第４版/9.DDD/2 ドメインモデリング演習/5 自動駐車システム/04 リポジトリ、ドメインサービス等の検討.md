# 04 リポジトリ、ドメインサービス等の検討

# ステップ４：リポジトリ、ドメインサービス等の検討 💾⚙️

Step 3 で集約 (`VehicleControl`) と内部で使う値オブジェクトを洗練させました。このステップでは、この集約を**永続化**するための**リポジトリ (Repository)** を定義し、Step 3 で実装した計算ロジックを**ドメインサービス (Domain Service)** として切り出すべきか**再検討**します。

---

## 💾 1. リポジトリ (Repository) の定義と実装 - 制御状態の永続化

📝 **課題**: `VehicleControl` 集約は、車両の状態 (`current_state`) を保持しています。この状態は、システムの再起動後も復元される必要があるかもしれません（例えば、最後にどの計画を実行していたか、現在の物理的な状態など）。そのため、永続化の仕組みが必要です。

💡 **解決策**: **リポジトリ (`Repository`)** パターンを適用します。`VehicleControlRepositoryInterface` を定義し、具体的な実装（今回はインメモリ）を Adapters 層に隠蔽します。

**ファイル:** `control_context/application/boundaries.py` (追記)

```python
# control_context/application/boundaries.py
from abc import ABC, abstractmethod
# 👈 永続化対象の集約 (前のステップで定義済み)
from control_context.domain.aggregates import VehicleControl
from typing import Optional

# (他のインターフェース定義 ...)

# -----------------------------------------------------------------------------
# VehicleControl Repository Interface
# - DDD戦術的設計の Repository Interface
# - CAの Application 層 (境界定義)
# -----------------------------------------------------------------------------
class VehicleControlRepositoryInterface(ABC):
    """VehicleControl集約の永続化を抽象化するインターフェース"""
    @abstractmethod
    def find_by_vehicle_id(self, vehicle_id: str) -> Optional[VehicleControl]:
        """車両IDでVehicleControl集約を検索する"""
        raise NotImplementedError

    @abstractmethod
    def save(self, vehicle_control: VehicleControl):
        """VehicleControl集約を保存（新規作成または更新）する"""
        raise NotImplementedError

```

**ファイル:** `control_context/adapters/repositories.py` (新規作成または追記)

```python
# control_context/adapters/repositories.py
# 👈 インターフェースと集約をインポート
from control_context.application.boundaries import VehicleControlRepositoryInterface
from control_context.domain.aggregates import VehicleControl
from typing import Optional, Dict # Dictを追加
import copy

# (他のリポジトリ実装 ...)

# -----------------------------------------------------------------------------
# In-Memory VehicleControl Repository Implementation
# - DDD戦術的設計の Repository Implementation
# - CAの Adapters 層
# -----------------------------------------------------------------------------
class InMemoryVehicleControlRepository(VehicleControlRepositoryInterface):
    """VehicleControl集約をメモリ上の辞書で保持するリポジトリ実装"""
    def __init__(self):
        # vehicle_id をキーとする辞書
        self._controls: Dict[str, VehicleControl] = {}

    def find_by_vehicle_id(self, vehicle_id: str) -> Optional[VehicleControl]:
        print(f"[Adapter] InMemoryRepo: Finding VehicleControl for {vehicle_id}")
        control = self._controls.get(vehicle_id)
        # 状態を持つオブジェクトなのでコピーを返すのが安全
        return copy.deepcopy(control) if control else None

    def save(self, vehicle_control: VehicleControl):
        """VehicleControlの状態を保存する (存在すれば上書き)"""
        print(f"[Adapter] InMemoryRepo: Saving VehicleControl for {vehicle_control.vehicle_id} (State Time: {vehicle_control.current_state.timestamp})")
        # コピーを保存
        self._controls[vehicle_control.vehicle_id] = copy.deepcopy(vehicle_control)

```

✅ **このステップのポイント**:

- `VehicleControl` 集約の状態（`current_state` など）を永続化するための**リポジトリインターフェース**と**インメモリ実装**を定義しました。
- これにより、UseCase は具体的な永続化方法を知ることなく、システムの状態を保存・復元できるようになります。

---

## ⚙️ 2. ドメインサービス (Domain Service) の必要性再検討 - 制御ロジックの分離

📝 **課題**: Step 3 で実装した `VehicleControl` 集約の `calculate_actuator_commands` メソッド内には、計画コマンド (`ControlCommand`) と現在の車両状態 (`VehicleState`) から具体的なアクチュエータ指示 (`ActuatorCommand`) を計算する、**ドメイン固有の制御ロジック**が含まれています。このロジックは、PID制御やモデル予測制御など、非常に複雑になる可能性があります。これを集約メソッド内に保持し続けるべきでしょうか？

💡 **検討**:
制御ロジック（目標値追従アルゴリズムなど）は、`VehicleControl` 集約の主要な責務（状態管理と全体の調整）とは少し性質が異なります。これを分離することで、以下の利点が見込めます。

1. **集約の単純化**: `VehicleControl` 集約は、状態 (`current_state`) の管理と、どの制御ロジック（ドメインサービス）を呼び出すかの決定に集中できます。
2. **ロジックの再利用性**: 同じ制御アルゴリズム（例：ステアリングPID制御）が、自動駐車以外の機能（例：レーンキープ）でも使われる可能性があります。ドメインサービスとして切り出せば再利用が容易になります。
3. **独立したテスト**: 複雑な制御アルゴリズムだけを独立して、様々な入力 (`VehicleState`, 目標値) に対してテストすることが容易になります。

**選択肢**:

1. **ドメインサービス (`ControlLogicService` など)**:
制御計算ロジックをカプセル化するドメインサービスを作成する。`VehicleControl` 集約はこのサービスを呼び出して計算結果を得る。
    - **メリット**: 関心の分離、再利用性、テスト容易性の向上。
    - **デメリット**: わずかに設計が複雑になる（依存関係が増える）。
2. **集約メソッド内に保持 (Step 3 のまま)**:
制御ロジックが比較的単純で、他の場所で再利用される可能性が低い場合は、集約内に保持しても許容できる。
    - **メリット**: 設計がシンプル。
    - **デメリット**: 集約クラスが肥大化しやすく、ロジックの独立したテストがやや難しい。

**今回の判断**:
自動運転における制御ロジックは専門性が高く、独立してテスト・改善されるべき重要な要素です。そのため、今回は**ドメインサービスとして切り出す（選択肢1）** アプローチを採用します。

**ファイル:** `control_context/domain/services.py` (新規作成または追記)

```python
# control_context/domain/services.py
# 👈 計算に必要な値オブジェクトをインポート
from .value_objects import (
    VehicleState, ControlCommand,
    SteeringCommand, ThrottleBrakeCommand, SteeringAngle # SteeringAngleも追加
)
from typing import Tuple

# -----------------------------------------------------------------------------
# Control Calculation Domain Service
# - DDD戦術的設計の Domain Service
# - CAの Domain 層 (Aggregateから利用される)
# -----------------------------------------------------------------------------
class ControlCalculationService:
    """
    車両制御の計算ロジックを担当するドメインサービス (ステートレス)。
    - 計画コマンドと現在の車両状態から、アクチュエータ指示を計算する。
    - 複雑な制御アルゴリズム(PID等)をカプセル化する。
    - VehicleControl集約から利用される。
    """
    def calculate_commands(self,
                           current_state: VehicleState,
                           plan_command: ControlCommand,
                           # (必要であれば制御パラメータなども引数で受け取る)
                           # assist_strength: float
                           ) -> Tuple[SteeringCommand, ThrottleBrakeCommand]:
        """
        具体的なアクチュエータ指示を計算する。
        """
        print(f"[Domain Service] Calculating actuator commands...")
        print(f"  Current State: Speed={current_state.speed.meters_per_second:.1f} m/s, Steer={current_state.steering_angle.degrees:.1f} deg")
        print(f"  Plan Command: Action={plan_command.action}, Value={plan_command.value}, Duration={plan_command.duration}s")

        # --- ここに制御ロジックを実装 ---
        # (Step 3 の calculate_actuator_commands 内の計算ロジックをここに移動・洗練)

        steer_cmd = SteeringCommand.neutral()
        throttle_brake_cmd = ThrottleBrakeCommand.neutral()

        if plan_command.action == 'steer':
            try:
                target_angle = SteeringAngle(plan_command.value)
                # (発展: 現在の舵角 current_state.steering_angle と目標舵角 target_angle
                #  から、必要なステアリングトルクを計算するPID制御などを実装)
                steer_cmd = SteeringCommand(target_angle=target_angle) # 今回は単純に目標角度を指示
                print(f"[Domain Service] Steering command calculated: target={target_angle.degrees:.1f} deg")
            except ValueError as e:
                print(f"[Domain Service] Invalid steering value from plan: {e}. Requesting neutral.")

        elif plan_command.action == 'throttle':
            try:
                target_accel = plan_command.value # 仮に単位がm/s^2とする
                # (発展: 現在の速度 current_state.speed と目標加速度 target_accel
                #  から、必要なスロットル開度やブレーキ圧を計算する制御ロジックを実装)
                throttle_brake_cmd = ThrottleBrakeCommand(acceleration_mps2=target_accel) # 今回は単純に目標加速度を指示
                print(f"[Domain Service] Throttle/Brake command calculated: target={target_accel:.2f} m/s^2")
            except ValueError as e:
                print(f"[Domain Service] Invalid throttle/brake value from plan: {e}. Requesting neutral.")

        return steer_cmd, throttle_brake_cmd

```

**ファイル:** `control_context/domain/aggregates.py` (`VehicleControl` 集約を修正)

```python
# control_context/domain/aggregates.py
# (Imports...)
from .services import ControlCalculationService # 👈 ドメインサービスをインポート

@dataclass
class VehicleControl:
    vehicle_id: str
    current_state: VehicleState
    # (target_plan などは削除 or 必要なら保持)

    # (initialize, update_current_state メソッドは変更なし)
    @staticmethod
    def initialize(vehicle_id: str) -> 'VehicleControl': # 実装省略
        pass
    def update_current_state(self, new_state: VehicleState): # 実装省略
        pass

    def execute_plan_step(self,
                          plan_command: ControlCommand,
                          control_calculator: ControlCalculationService # 👈 ドメインサービスを受け取る
                          ) -> Tuple[SteeringCommand, ThrottleBrakeCommand]:
        """
        [集約の振る舞い] (修正)
        計画の1ステップ分のコマンドを受け取り、ドメインサービスを使って
        アクチュエータ指示を計算し、(必要なら内部状態を更新し)、指示を返す。
        """
        print(f"[Aggregate Logic] Executing plan step for {self.vehicle_id}...")

        # (ここに集約としての事前チェックや状態遷移ロジックが入る可能性)
        # 例: if self.status != ControlStatus.EXECUTING: raise ...

        # 1. 制御計算をドメインサービスに委譲 👈
        steer_cmd, throttle_brake_cmd = control_calculator.calculate_commands(
            self.current_state, plan_command #, self.assist_strength など設定値も渡せる
        )

        # (2. 必要なら、計算結果や計画の進捗などを集約の内部状態として更新する)
        # self.current_target_torque = steer_cmd.target_torque ... etc.

        print(f"[Aggregate Logic] Actuator commands determined.")
        # 3. 計算されたアクチュエータ指示を返す
        return steer_cmd, throttle_brake_cmd

    # --- ドメインイベント関連メソッド (参考) ---
    # ...

```

✅ **このステップのポイント**:

- 複雑な**制御計算ロジック**を**ドメインサービス (`ControlCalculationService`)** に分離しました。
- `VehicleControl` 集約は、そのドメインサービスを**利用する**形に修正され、自身の責務（状態管理、フロー調整）に集中できるようになりました。
- 計算ロジックが独立したことで、**テスト容易性**が向上しました。

---

## 📝 まとめ

このステップでは、`VehicleControl` 集約の永続化のための**リポジトリインターフェース**とその**インメモリ実装**を定義しました。

さらに、集約内にあった複雑な制御計算ロジックを**ドメインサービス (`ControlCalculationService`)** として切り出すことで、集約の責務を明確にし（SRP向上）、計算ロジックの独立性とテスト容易性を高める、という設計改善を行いました。

---

## ➡️ 次へ

これでドメインモデル、永続化、そして複雑な計算ロジックの分離ができました。最後のステップ「**(Step 5) モデルの一部をコード化 (UseCaseとMain)**」に進み、これらの部品を組み合わせてシステム（制御部分）を動作させてみましょう。