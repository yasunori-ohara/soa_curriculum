# 05 モデルの一部をコード化

# ステップ５：モデルの一部をコード化 (UseCaseとMain) ⚙️🚀

これまでのステップで定義・実装したドメインモデル（集約、値オブジェクト、ドメインサービス）とリポジトリを使って、いよいよシステムのコアロジックを実行する**UseCase**を実装し、それを[**main.py**](http://main.py/)から呼び出して実行してみましょう。

---

## ⚙️ 1. UseCase の実装 - システム実行フロー

📝 **課題**: 「センサーデータ（`LaneModel`, `VehicleState`）を受け取り、現在のLKAシステムの状態を取得し、ドメインロジック（逸脱判断、警告/介入決定）を実行し、更新されたシステム状態を保存し、最終的な出力（警告要求、操舵トルク要求）を返す」という一連の**アプリケーション固有のフロー**が必要です。

💡 **解決策**: このフローの責任を持つ「UseCase」を実装します。これはCA（クリーンアーキテクチャ）の UseCase と同じ役割です。UseCase はリポジトリインターフェースとドメインサービスに依存し、`LaneKeepingAssist` 集約を利用してロジックを実行します。

**ファイル:** `application/use_cases.py` (新規作成または追記)

```python
# application/use_cases.py
# 👈 境界、集約、値オブジェクト、サービスをインポート
from application.boundaries import LaneKeepingAssistRepositoryInterface
from domain.aggregates import LaneKeepingAssist
from domain.value_objects import LaneModel, VehicleState, WarningRequest, SteeringTorqueRequest, SystemStatus
from domain.services import LaneCalculationService
from typing import Tuple, Optional # 戻り値用

# (他のUseCaseがあればこのファイルに追加していく)

# -----------------------------------------------------------------------------
# Process LKA System Use Case
# - CAの Use Cases 層と同じ役割
# - アプリケーション固有のビジネスフローを担当
# - Domain Service, Repository Interface, Aggregate を利用する
# -----------------------------------------------------------------------------
class ProcessLKASystemUseCase:
    """
    LKAシステムのセンサー入力を処理し、状態を更新し、出力を決定するユースケース。
    (定期的に呼び出されることを想定)
    """
    def __init__(self,
                 lka_repository: LaneKeepingAssistRepositoryInterface, # 永続化の窓口
                 lane_calculator: LaneCalculationService): # 計算ロジックの専門家 (ドメイン層)
        # 必要な依存オブジェクトをコンストラクタで受け取る (DI)
        self._lka_repository = lka_repository
        self._lane_calculator = lane_calculator

    def handle(self, vehicle_id: str, lane_model: LaneModel, vehicle_state: VehicleState) \\
            -> Tuple[Optional[WarningRequest], Optional[SteeringTorqueRequest]]:
        """
        ユースケースを実行する。
        Args:
            vehicle_id: 対象車両のID
            lane_model: 最新の車線モデル (値オブジェクト)
            vehicle_state: 最新の車両状態 (値オブジェクト)
        Returns:
            決定された警告要求と操舵トルク要求 (値オブジェクトのタプル)、
            またはシステムが見つからない/非作動の場合は (None, None) など
        """
        print(f"[UseCase] Processing LKA cycle for vehicle {vehicle_id}")

        # --- トランザクション管理の開始 (概念) ---
        # (システム状態の読み込みと保存をアトミックに行う必要がある)
        try:
            # 1. リポジトリを使って集約(LaneKeepingAssist)を取得
            #    (もし存在しなければ、デフォルト状態で新規作成するロジックも必要かも)
            lka_system = self._lka_repository.find_by_vehicle_id(vehicle_id)
            if not lka_system:
                # ここでは単純化のためエラーとするが、実際には初期化処理などが必要
                print(f"[UseCase] LKA system for vehicle {vehicle_id} not found/initialized.")
                # raise ValueError(f"LKA system for vehicle {vehicle_id} not found.")
                # デモ用に、見つからなければ非アクティブなシステムを仮生成
                lka_system = LaneKeepingAssist(vehicle_id=vehicle_id, system_status=SystemStatus.INACTIVE)

            # (発展: 外部からのシステムON/OFF指示をここで処理するロジックも追加可能)
            # lka_system.activate() / deactivate() etc. based on external input

            # 2. 集約ルートのメソッドを呼び出してビジネスロジックを実行
            #    (ドメインサービス(lane_calculator)は集約メソッド内で利用される)
            #    警告要求と操舵トルク要求が集約から返される
            warning_req, torque_req = lka_system.update_and_decide(
                lane_model, vehicle_state, self._lane_calculator
            )

            # 3. 変更された(可能性のある)集約をリポジトリを使って保存
            #    (systemStatusが変わる場合や、内部状態を永続化する場合)
            self._lka_repository.save(lka_system)

            # --- トランザクションのコミット (概念) ---
            print(f"[UseCase] LKA cycle processed. Status: {lka_system.system_status.name}. Output: Warn={warning_req.level}, Torque={torque_req.torque_nm:.2f}Nm")

            # 4. 結果として警告・操舵要求を返す
            return warning_req, torque_req

        except Exception as e:
            # --- トランザクションのロールバック (概念) ---
            print(f"[UseCase] Error during LKA processing: {e}")
            # (エラー発生時はシステムをFAULT状態に遷移させるなどの処理が必要かも)
            # if lka_system:
            #     lka_system.set_fault_status() # 仮のメソッド
            #     self._lka_repository.save(lka_system)
            print("[UseCase] --- Transaction Rollback (Conceptual) ---")
            raise # エラーを上位に伝える

```

✅ **このステップのポイント**:

- UseCase は CA と同じく、**ビジネスフローの調整役**です。
- **リポジトリ**を使って `LaneKeepingAssist` 集約の状態を取得・保存します。
- **集約のメソッド (`update_and_decide`)** を呼び出して、ドメイン固有の判断ロジック（内部でドメインサービスを利用）を実行させます。
- UseCase は、集約やドメインサービスから返された結果（`WarningRequest`, `SteeringTorqueRequest`）を呼び出し元に返します。
- **トランザクション管理**（システム状態の読み込みと保存のアトミック性）の責務を持ちます。

---

## 🚀 2. 実行ファイル ([main.py](http://main.py/)) の作成 - 全体の組み立てと実行

📝 **課題**: 作成した UseCase を実行し、システム全体（今回はインメモリ）が動作することを確認する「起点」が必要です。センサーデータが継続的に入力される状況をシミュレートします。

💡 **解決策**: `main.py` で、具体的なリポジトリ実装とドメインサービスを生成し、それらを UseCase に注入（DI）して、UseCase を呼び出します。簡単なループでセンサー入力の変化を模倣します。

**ファイル:** `main.py` (プロジェクトルート、または `app/` など)

```python
# main.py
# 👈 実装、UseCase、ドメインオブジェクトなどをインポート
from adapters.repositories import InMemoryLKARepository
from application.use_cases import ProcessLKASystemUseCase
from domain.aggregates import LaneKeepingAssist
from domain.services import LaneCalculationService
from domain.value_objects import (
    LaneModel, VehicleState, LaneLine, SystemStatus,
    WarningRequest, SteeringTorqueRequest
)
from datetime import datetime, timedelta
import asyncio # 非同期処理のため (今回は簡易シミュレーション用)

# -----------------------------------------------------------------------------
# Main Application / Composition Root
# - CAの最も外側の層 (Frameworks & Drivers) と同じ役割
# - 依存関係の解決 (DI) とアプリケーションの起動を行う
# -----------------------------------------------------------------------------

async def simulate_driving():
    """ 運転状況をシミュレートし、LKA UseCase を定期的に呼び出す """
    print("--- LKA System Simulation ---")

    # --- 依存関係の解決 (Dependency Injection) ---
    print("\\n--- Wiring dependencies (DI) ---")
    lka_repo = InMemoryLKARepository()
    lane_calculator = LaneCalculationService() # ステートレスなのでそのまま生成
    process_lka_use_case = ProcessLKASystemUseCase(lka_repo, lane_calculator)
    print("--- Dependencies wired successfully ---")

    # --- 初期データ投入 (LKAシステムをアクティブ化) ---
    print("\\n--- Setting up initial LKA system state ---")
    vehicle_id = "vehicle-01"
    initial_system = LaneKeepingAssist(vehicle_id=vehicle_id)
    initial_system.activate(mode="ASSIST") # 最初から支援モードON
    lka_repo.save(initial_system)
    print(f"LKA system initialized for {vehicle_id} in {initial_system.system_status.name} mode.")

    # --- センサー入力のシミュレーションループ ---
    print("\\n--- Starting simulation loop (Press Ctrl+C to stop) ---")
    current_time = datetime.now()
    # (簡易的な車両状態のシミュレーション用変数)
    sim_offset = 0.1 # 最初は少し左寄り
    sim_steer = 0.0

    for i in range(10): # 10サイクル実行する例
        current_time += timedelta(milliseconds=100) # 100msごとに更新
        print(f"\\n--- Cycle {i+1} at {current_time.isoformat()} ---")

        # --- センサーデータの生成 (ダミー) ---
        # (実際には外部のセンサーフュージョンモジュールから来る)

        # 車線モデル (例: 直線で、認識は良好)
        lane = LaneModel(
            timestamp=current_time,
            left_lane_line=LaneLine(position_offset=1.8 + sim_offset, line_type="SOLID", confidence=0.9),
            right_lane_line=LaneLine(position_offset=-1.8 + sim_offset, line_type="SOLID", confidence=0.9)
        )

        # 車両状態 (例: 速度一定、ステアリングは前のサイクルの介入を反映)
        vehicle = VehicleState(
            timestamp=current_time,
            speed_mps=20.0, # 時速72km
            steering_angle_deg=sim_steer,
            yaw_rate_dps=0.0
        )
        print(f"[Simulation] Input: Offset(sim)={sim_offset:.2f}m, Steer(sim)={sim_steer:.1f}deg")
        print(f"[Simulation] Input: Lane Left={lane.left_lane_line.position_offset:.2f}, Right={lane.right_lane_line.position_offset:.2f}")

        # --- UseCaseの実行 ---
        try:
            warning, torque = process_lka_use_case.handle(vehicle_id, lane, vehicle)

            # --- 出力の表示 (本来はアクチュエータアダプタに渡す) ---
            print(f"[Simulation] Output: Warning={warning.level}/{warning.type}, Torque={torque.torque_nm:.2f} Nm")

            # --- 次のサイクルのための簡易シミュレーション更新 ---
            # 介入トルクに応じてステアリング角度が変わる (超簡易)
            sim_steer += torque.torque_nm * 5.0 # 係数は適当
            # ステアリング角度に応じて横ずれが変わる (超簡易)
            sim_offset += sim_steer * 0.01 # 係数は適当

        except Exception as e:
            print(f"Simulation cycle failed: {e}")
            # (エラー発生時の処理)
            break # ループ中断

        await asyncio.sleep(0.1) # 100ms待機 (シミュレーション用)

    print("\\n--- Simulation loop finished ---")

if __name__ == "__main__":
    # シミュレーションを実行
    asyncio.run(simulate_driving())

```

✅ **このステップのポイント**:

- `main.py` が依存関係を組み立て、`ProcessLKASystemUseCase` を呼び出しました。
- `simulate_driving` 関数内で、時間経過とともにセンサーデータ（`LaneModel`, `VehicleState`）が変化する様子を**シミュレート**しました。
- UseCase から返された警告要求と操舵トルク要求をコンソールに出力し、システムが入力に応じて反応する様子を確認しました（超簡易的なシミュレーションですが、介入によって `sim_offset` が中央に近づくはずです）。

---

## 📝 この演習のまとめ

この演習では、「車線逸脱防止支援システム」という少し技術的なドメインを題材に、DDDの戦術的パターンを適用しました。

1. **ユビキタス言語**: 「車線モデル」「車両状態」「逸脱状態」「システム状態」といった言葉を特定しました。
2. **集約**: システム全体の状態と振る舞いを管理する「`LaneKeepingAssist`」を集約として定義しました。
3. **値オブジェクト/Enum**: 入力データ、計算結果、内部状態、出力要求を、不変で自己検証可能なオブジェクトとしてモデル化しました。
4. **ドメインサービス**: 複雑な計算ロジック（相対位置計算、逸脱判定）を集約から分離し、独立してテスト可能な `LaneCalculationService` として実装しました。
5. **リポジトリ**: 集約の状態（システムステータスなど）の永続化を抽象化しました。
6. **UseCase**: ドメインモデル、ドメインサービス、リポジトリを利用して、センサー入力から警告/介入出力までのアプリケーションフローを実装しました。

特に、ドメインサービスによって**集約の責務を適切に保ちつつ、複雑なドメインロジックをドメイン層にカプセル化する**効果や、値オブジェクトによって**型安全性と不変性**を高める効果を体験できたかと思います。

---

## ✅ ドメインモデリング演習 (4/5) 完了！

これで、「車線逸脱防止支援システム」のモデリング演習は一区切りです。
次は、最後の題材「**(5/5) 自動駐車システム**」に進み、これまでの学習（第4・5巡）をDDDの視点で再評価してみましょうか？