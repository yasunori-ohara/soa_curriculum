# 03 口座間送金

# 🏛️ 演習３：口座間送金

## 🎯 この演習のゴール

- 複数の**集約 (Aggregate)** が関わるドメイン操作を、**ドメインサービス (Domain Service)** を使って実装する。
- ドメインサービスが、エンティティや値オブジェクトに属さないドメインロジックをカプセル化する役割を理解する。
- **集約**、**値オブジェクト**、**リポジトリ**とドメインサービスが連携する様子を実装する。
- **UseCase** がトランザクション管理（概念）とドメインサービスの利用を調整する役割を確認する。

---

## 📜 シナリオ

ある銀行口座から別の銀行口座へ、指定した金額を送金するシンプルなシナリオを実装します。送金は同一通貨間でのみ可能とし、送金元口座の残高が不足している場合は送金は失敗します。送金処理自体はアトミック（全体が成功するか失敗するかのどちらか）である必要があります。

---

## 🛠️ 実装ステップ

以下の手順で、各パターンを実装し、その役割と利点を確認していきます。

---

## 💎 ステップ1: 値オブジェクト (Value Object) の実装 - 金額と口座番号

📝 **課題**: 「金額」はマイナスになってはいけませんし、異なる通貨の加算はできません。「口座番号」も特定の形式を持つかもしれません。これらを単なる数値や文字列で扱うと、不正な値や操作が紛れ込む可能性があります。

💡 **解決策**: 「金額 (`Money`)」と「口座番号 (`AccountNumber`)」を**値オブジェクト (`Value Object`)** として定義し、不変性と自己検証ルールを適用します。

**ファイル:** `domain/value_objects.py`

```python
# domain/value_objects.py
from dataclasses import dataclass

# -----------------------------------------------------------------------------
# Money Value Object
# - DDD戦術的設計の Value Object
# - CAの Entities 層 (ドメインの核となるルールの一部)
# -----------------------------------------------------------------------------
@dataclass(frozen=True)
class Money:
    """金額を表す値オブジェクト (演習1, 2 と同様だが subtract を追加)"""
    amount: int
    currency: str

    def __post_init__(self):
        print(f"[VO Check] Validating Money: {self.amount} {self.currency}")
        if self.amount < 0: raise ValueError("Amount cannot be negative.")
        if len(self.currency) != 3: raise ValueError("Currency must be 3-letter code.")
        print("[VO Check] Money is valid.")

    def add(self, other: 'Money') -> 'Money':
        if self.currency != other.currency: raise ValueError("Cannot add different currencies.")
        new_amount = self.amount + other.amount
        print(f"[VO Logic] Adding Money: {self.amount} + {other.amount} = {new_amount} {self.currency}")
        return Money(new_amount, self.currency)

    def subtract(self, other: 'Money') -> 'Money':
        """金額を減算するメソッド"""
        if self.currency != other.currency: raise ValueError("Cannot subtract different currencies.")
        # ここでの残高チェックは、Moneyオブジェクト自体のルールではないため注意
        # (例: 0より小さくなる減算自体は許可するかもしれない)
        # 不足チェックは通常、集約(Account)の責務
        new_amount = self.amount - other.amount
        # if new_amount < 0: # もしMoney自体がマイナスを許容しないならここでチェック
        #     raise ValueError("Resulting amount cannot be negative.")
        print(f"[VO Logic] Subtracting Money: {self.amount} - {other.amount} = {new_amount} {self.currency}")
        return Money(new_amount, self.currency)

    # 比較演算子 (残高チェックで使う)
    def __lt__(self, other: 'Money'):
        if not isinstance(other, Money) or self.currency != other.currency:
            raise TypeError("Cannot compare different currencies or types.")
        return self.amount < other.amount
    # (必要であれば __le__, __gt__, __ge__, __eq__ も実装)
    def __eq__(self, other):
        return isinstance(other, Money) and self.amount == other.amount and self.currency == other.currency

# -----------------------------------------------------------------------------
# AccountNumber Value Object
# - DDD戦術的設計の Value Object
# - CAの Entities 層 (ドメインの核となるルールの一部)
# -----------------------------------------------------------------------------
@dataclass(frozen=True)
class AccountNumber:
    """口座番号を表す値オブジェクト"""
    value: str

    def __post_init__(self):
        # (例: 形式チェック - ここでは省略)
        print(f"[VO Check] Validating AccountNumber: {self.value}")
        if not self.value: # 簡単な存在チェック
             raise ValueError("Account number cannot be empty.")
        print("[VO Check] AccountNumber is valid.")

```

✅ **このステップのポイント**:

- `Money` と `AccountNumber` を値オブジェクトとして定義し、型安全性を高めました。
- `Money` には通貨チェック付きの `add`/`subtract` や比較メソッドを実装し、金額に関するドメインルールをカプセル化しました。

---

## 🧱 ステップ2: エンティティ (Entity) / 集約 (Aggregate) の実装 - 口座を定義する

📝 **課題**: 「銀行口座」は、口座番号や残高を持ち、IDによって一意に識別される必要があります。残高は入出金によって変化します。残高がマイナスにならない、というルール（不変条件）を守らなければなりません。

💡 **解決策**: 「口座 (`Account`)」を**エンティティ (`Entity`)** かつ**集約ルート (`Aggregate Root`)** として定義します。残高 (`balance`) は `Money` 値オブジェクトで保持し、入出金の振る舞い（メソッド）を集約内に実装して不変条件（残高はマイナスにならない）を保証します。

**ファイル:** `domain/aggregates.py`

```python
# domain/aggregates.py
from dataclasses import dataclass, field
from .value_objects import Money, AccountNumber # 作成した値オブジェクトをインポート
import uuid # ID生成用
# from typing import List # ドメインイベント用
# from .events import DomainEvent # ドメインイベントを使う場合

# -----------------------------------------------------------------------------
# Account Aggregate Root / Entity
# - DDD戦術的設計の Aggregate Root / Entity
# - CAの Entities 層
# -----------------------------------------------------------------------------
@dataclass
class Account:
    """
    銀行口座を表す集約ルート・エンティティ。
    - account_id というグローバルIDで識別される。
    - 口座番号(account_number)と残高(balance)は値オブジェクト。
    - 残高がマイナスにならない、という不変条件を維持する責務を持つ。
    """
    account_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    account_number: AccountNumber
    balance: Money
    # ... 他の口座属性 (例: owner_id, status) ...
    # _domain_events: List[DomainEvent] = field(default_factory=list, init=False, repr=False)

    def withdraw(self, amount: Money):
        """
        [集約の振る舞い] 口座から引き出す。残高不足チェックを行う。
        """
        print(f"[Aggregate Logic] Attempting to withdraw {amount.amount}{amount.currency} from {self.account_number.value} (Current Balance: {self.balance.amount})")
        # 不変条件：残高は引き出し額以上でなければならない
        if self.balance < amount:
            raise ValueError(f"Insufficient funds in account {self.account_number.value}. Balance: {self.balance.amount}, Required: {amount.amount}")

        # 値オブジェクトのメソッドを使って残高を更新 (不変なので新しいMoneyが返る)
        self.balance = self.balance.subtract(amount)
        print(f"[Aggregate Logic] Withdrawal successful. New balance: {self.balance.amount}")
        # event = FundsWithdrawnEvent(...)
        # self._domain_events.append(event)

    def deposit(self, amount: Money):
        """
        [集約の振る舞い] 口座に入金する。
        """
        print(f"[Aggregate Logic] Depositing {amount.amount}{amount.currency} to {self.account_number.value} (Current Balance: {self.balance.amount})")
        # 値オブジェクトのメソッドを使って残高を更新
        self.balance = self.balance.add(amount)
        print(f"[Aggregate Logic] Deposit successful. New balance: {self.balance.amount}")
        # event = FundsDepositedEvent(...)
        # self._domain_events.append(event)

    # --- ドメインイベント関連メソッド (参考) ---
    # def get_uncommitted_events(self) -> List[DomainEvent]: ...
    # def clear_uncommitted_events(self): ...

```

✅ **このステップのポイント**:

- `Account` は ID (`account_id`) を持つ**エンティティ**であり、口座の状態（特に残高）の一貫性を守る**集約ルート**です。
- `withdraw` メソッド内で残高チェックを行うことで、集約の**不変条件**（残高 \>= 0）を保証しています。
- 残高操作には `Money` 値オブジェクトのメソッドを利用し、コードの意図を明確にしています。

---

## 💾 ステップ3: リポジトリ (Repository) の実装 - 口座の永続化

📝 **課題**: `Account` 集約を永続化（保存・読み込み）する必要がありますが、`UseCase` や `Account` 自身がDB操作の詳細を知るべきではありません。

💡 **解決策**: **リポジトリ (`Repository`)** パターンを適用します。`AccountRepositoryInterface` を定義し、具体的な実装（今回はインメモリ）を `InMemoryAccountRepository` に隠蔽します。口座番号での検索も可能にします。

**ファイル:** `application/boundaries.py`

```python
# application/boundaries.py
from abc import ABC, abstractmethod
from domain.aggregates import Account # 永続化対象の集約
from domain.value_objects import AccountNumber # 検索で使う
from typing import Optional

# -----------------------------------------------------------------------------
# Account Repository Interface
# - DDD戦術的設計の Repository Interface
# - CAの Application 層 (境界定義)
# -----------------------------------------------------------------------------
class AccountRepositoryInterface(ABC):
    """Account集約の永続化を抽象化するインターフェース"""
    @abstractmethod
    def find_by_id(self, account_id: str) -> Optional[Account]:
        """IDでAccount集約を検索する"""
        raise NotImplementedError

    @abstractmethod
    def find_by_number(self, account_number: AccountNumber) -> Optional[Account]:
        """口座番号(値オブジェクト)でAccount集約を検索する"""
        raise NotImplementedError

    @abstractmethod
    def save(self, account: Account):
        """Account集約を保存（新規作成または更新）する"""
        raise NotImplementedError

```

**ファイル:** `adapters/repositories.py`

```python
# adapters/repositories.py
from application.boundaries import AccountRepositoryInterface
from domain.aggregates import Account
from domain.value_objects import AccountNumber # AccountNumber をインポート
from typing import Optional, Dict # Dict を追加
import copy

# -----------------------------------------------------------------------------
# In-Memory Account Repository Implementation
# - DDD戦術的設計の Repository Implementation
# - CAの Adapters 層
# -----------------------------------------------------------------------------
class InMemoryAccountRepository(AccountRepositoryInterface):
    """Account集約をメモリ上の辞書で保持するリポジトリ実装"""
    def __init__(self):
        self._accounts: Dict[str, Account] = {} # account_id をキーとする辞書

    def find_by_id(self, account_id: str) -> Optional[Account]:
        print(f"[Adapter] InMemoryRepo: Finding account by ID {account_id}")
        account = self._accounts.get(account_id)
        return copy.deepcopy(account) if account else None

    def find_by_number(self, account_number: AccountNumber) -> Optional[Account]:
        """口座番号(値オブジェクト)で検索"""
        print(f"[Adapter] InMemoryRepo: Finding account by Number {account_number.value}")
        for acc in self._accounts.values():
            # 値オブジェクト同士の比較
            if acc.account_number == account_number:
                return copy.deepcopy(acc)
        return None

    def save(self, account: Account):
        """Accountを保存する (存在すれば上書き)"""
        print(f"[Adapter] InMemoryRepo: Saving account {account.account_id} ({account.account_number.value}) Balance: {account.balance.amount}")
        self._accounts[account.account_id] = copy.deepcopy(account)

```

✅ **このステップのポイント**:

- CAと同様、リポジトリが永続化の詳細を隠蔽し、`UseCase` からの独立性を保ちます。
- 口座番号 (`AccountNumber` 値オブジェクト) で検索するメソッドを提供しました。

---

## ⚙️ ステップ4: ドメインサービス (Domain Service) の実装 - 口座間送金プロセス

📝 **課題**: 口座間送金は、送金元口座 (`from_account`) から引き出し、送金先口座 (`to_account`) に入金するという、**2つの `Account` 集約にまたがる操作**です。このロジックを `from_account` や `to_account` のどちらか一方のエンティティメソッドとして実装するのは不自然です（なぜなら、片方の口座がもう片方の口座の状態を変更することになるため）。また、`UseCase` にこのロジックを書くと、ドメイン固有の重要なプロセスがアプリケーション層に漏れ出してしまいます。

💡 **解決策**: このような、特定のエンティティに属さないがドメイン固有の重要な操作のために、「ドメインサービス (`Domain Service`)」を導入します。ドメインサービスは通常ステートレス（状態を持たない）で、関連するドメインオブジェクトを受け取り、それらを使ってドメインロジックを実行します。

**ファイル:** `domain/services.py`

```python
# domain/services.py
from .aggregates import Account # 操作対象の集約
from .value_objects import Money # 操作で使う値オブジェクト

# -----------------------------------------------------------------------------
# Transfer Domain Service
# - DDD戦術的設計の Domain Service
# - CAの Domain 層 (UseCaseから利用される)
# -----------------------------------------------------------------------------
class TransferService:
    """
    口座間送金プロセスを担当するドメインサービス (ステートレス)。
    - 複数の集約(Account)にまたがるドメインロジックをカプセル化する。
    - エンティティや値オブジェクトに自然に属さない振る舞いを担当する。
    """

    def transfer(self, from_account: Account, to_account: Account, amount: Money):
        """
        指定された金額を送金元口座から送金先口座へ移動する。
        - このメソッドは純粋なドメインロジックのみを実行し、永続化は行わない。
        - 必要な集約インスタンスは呼び出し元(UseCase)から渡される。
        Args:
            from_account: 送金元Account集約
            to_account: 送金先Account集約
            amount: 送金金額(Money値オブジェクト)
        Raises:
            ValueError: 残高不足の場合など (Account.withdrawから発生)
        """
        print(f"[Domain Service] Attempting transfer: {amount.amount}{amount.currency} from {from_account.account_number.value} to {to_account.account_number.value}")

        # --- ドメインロジックの実行 ---
        # 1. 送金元から引き出しを試みる (Account集約のメソッドを呼び出す)
        #    ここで残高不足なら ValueError が発生し、処理は中断される
        from_account.withdraw(amount)

        # 2. 引き出しが成功したら、送金先に入金する (Account集約のメソッドを呼び出す)
        to_account.deposit(amount)

        print(f"[Domain Service] Transfer logic completed successfully in memory.")
        # (ここで FundsTransferred ドメインイベントを発行しても良い)

```

✅ **このステップのポイント**:

- 「送金」という、複数の `Account` 集約にまたがるドメイン固有のプロセスを `TransferService` に**カプセル化**しました。
- ドメインサービスは、操作対象の集約を受け取り、それらの**エンティティが持つ振る舞い（`withdraw`, `deposit`）を組み合わせて**プロセスを実行します。
- ドメインサービスは**ステートレス**であり、**永続化には関与しない**ことに注意してください。

---

## ⚙️ ステップ5: UseCase の実装 - 送金フローとトランザクション管理

📝 **課題**: 「送金元口座番号、送金先口座番号、金額を受け取り、送金処理を実行し、結果を保存する」という**アプリケーションの要求**に応える必要があります。また、送金処理（引き出しと入金）は**全体として成功するか失敗するかのどちらか**でなければなりません（アトミック性）。

💡 **解決策**: このアプリケーション固有のフローとトランザクション管理の責任を持つのが「UseCase」です。UseCase はリポジトリインターフェースとドメインサービスに依存します。

**ファイル:** `application/use_cases.py`

```python
# application/use_cases.py
from application.boundaries import AccountRepositoryInterface
from domain.services import TransferService # 👈 ドメインサービスをインポート
from domain.value_objects import AccountNumber, Money # 値オブジェクトをインポート

# -----------------------------------------------------------------------------
# Transfer Funds Use Case
# - CAの Use Cases 層と同じ役割
# - アプリケーション固有のビジネスフローとトランザクション管理(概念)を担当
# - Domain Service や Repository Interface を利用する
# -----------------------------------------------------------------------------
class TransferFundsUseCase:
    """口座間送金を実行するユースケース"""
    def __init__(self,
                 account_repository: AccountRepositoryInterface, # 永続化の窓口
                 transfer_service: TransferService): # 送金ロジックの専門家 (ドメイン層)
        # 必要な依存オブジェクトをコンストラクタで受け取る (DI)
        self._account_repository = account_repository
        self._transfer_service = transfer_service

    def handle(self, from_account_number_str: str, to_account_number_str: str, amount_int: int, currency_str: str):
        """
        ユースケースを実行する。
        Args:
            from_account_number_str: 送金元口座番号(文字列)
            to_account_number_str: 送金先口座番号(文字列)
            amount_int: 送金金額(整数)
            currency_str: 通貨コード(文字列)
        Raises:
            ValueError: 入力不正、口座不存在、残高不足など
        """
        print(f"[UseCase] Starting fund transfer: {amount_int}{currency_str} from {from_account_number_str} to {to_account_number_str}")

        # 1. 入力文字列から値オブジェクトを生成 (形式検証)
        try:
            from_acc_num = AccountNumber(from_account_number_str)
            to_acc_num = AccountNumber(to_account_number_str)
            amount_to_transfer = Money(amount_int, currency_str)
            if from_acc_num == to_acc_num: # 自分自身への送金チェック
                raise ValueError("Cannot transfer to the same account.")
        except ValueError as e:
            print(f"[UseCase] Invalid input: {e}")
            raise

        # --- トランザクション管理の開始 (概念) ---
        # 実際のアプリケーションでは、ここでデータベースのトランザクションを開始したり、
        # Unit of Work パターンを使ったりする
        print("[UseCase] --- Transaction Start (Conceptual) ---")
        try:
            # 2. リポジトリを使って必要な集約(Account)を2つ取得
            print(f"[UseCase] Finding source account {from_acc_num.value}...")
            from_account = self._account_repository.find_by_number(from_acc_num)
            print(f"[UseCase] Finding destination account {to_acc_num.value}...")
            to_account = self._account_repository.find_by_number(to_acc_num)

            # 口座存在チェック
            if not from_account: raise ValueError(f"Source account {from_acc_num.value} not found.")
            if not to_account: raise ValueError(f"Destination account {to_acc_num.value} not found.")

            # 3. ドメインサービスに実際の送金処理(ドメインロジック)を委譲
            #    ドメインサービス内で残高チェック(withdraw)が行われ、失敗すれば例外が発生
            print("[UseCase] Calling TransferService to perform transfer logic...")
            self._transfer_service.transfer(from_account, to_account, amount_to_transfer)

            # 4. ドメインロジックが成功したら、変更された両方の集約をリポジトリを使って保存
            #    (これがアトミックに行われる必要がある)
            print(f"[UseCase] Saving source account {from_account.account_id}...")
            self._account_repository.save(from_account)
            print(f"[UseCase] Saving destination account {to_account.account_id}...")
            self._account_repository.save(to_account)

            # --- トランザクションのコミット (概念) ---
            print("[UseCase] --- Transaction Commit (Conceptual) ---")
            print("[UseCase] Fund transfer completed successfully.")

        except Exception as e: # ドメインルール違反(ValueError)や予期せぬエラーをキャッチ
            # --- トランザクションのロールバック (概念) ---
            print(f"[UseCase] Error during transfer: {e}")
            print("[UseCase] --- Transaction Rollback (Conceptual) ---")
            # (実際のロールバック処理が必要)
            raise # エラーを上位に伝える

```

✅ **このステップのポイント**:

- UseCase は、**ドメインサービス (`TransferService`)** と**リポジトリ (`AccountRepositoryInterface`)** をオーケストレーション（調整）して、アプリケーションの要求（口座間送金）を実現します。
- 複雑なドメインロジック（残高チェックを含む送金プロセス）はドメインサービスにカプセル化されているため、UseCase は比較的シンプルに保たれます。
- UseCase は、一連の操作が**アトミック**に行われるように**トランザクションを管理**する責務を持ちます（今回は概念的なコメントで表現）。

---

## 🚀 ステップ6: 実行ファイル ([main.py](http://main.py/)) の作成 - 全体の組み立て

最後に、これら全てを組み立てて実行する `main.py` を作成します。

**ファイル:** `main.py`

```python
# main.py
from adapters.repositories import InMemoryAccountRepository # 👈 具体的なリポジトリ実装
from domain.services import TransferService               # 👈 ドメインサービス
from application.use_cases import TransferFundsUseCase    # 👈 UseCase
from domain.aggregates import Account                     # 初期データ作成用
from domain.value_objects import AccountNumber, Money     # 初期データ作成用

# -----------------------------------------------------------------------------
# Main Application / Composition Root
# - CAの最も外側の層 (Frameworks & Drivers) と同じ役割
# - 依存関係の解決 (DI) とアプリケーションの起動を行う
# -----------------------------------------------------------------------------
if __name__ == "__main__":
    print("--- Fund Transfer Example ---")

    # --- 依存関係の解決 (Dependency Injection) ---
    print("\\n--- Wiring dependencies (DI) ---")
    account_repository = InMemoryAccountRepository()
    transfer_service = TransferService() # ドメインサービスは通常ステートレス
    transfer_funds_use_case = TransferFundsUseCase(account_repository, transfer_service)
    print("--- Dependencies wired successfully ---")

    # --- 初期データ投入 ---
    print("\\n--- Setting up initial accounts ---")
    try:
        acc_num1 = AccountNumber("ACC-001")
        acc_num2 = AccountNumber("ACC-002")
        account1 = Account(account_number=acc_num1, balance=Money(10000, "JPY"))
        account2 = Account(account_number=acc_num2, balance=Money(5000, "JPY"))
        account_repository.save(account1)
        account_repository.save(account2)
        print("Initial balances:")
        print(f"- {acc_num1.value}: {account1.balance.amount} {account1.balance.currency}")
        print(f"- {acc_num2.value}: {account2.balance.amount} {account2.balance.currency}")
    except ValueError as e:
        print(f"Error setting up initial data: {e}")
        exit()

    # --- UseCaseの実行 (成功例) ---
    print("\\n--- Executing UseCase (Success Case) ---")
    try:
        transfer_funds_use_case.handle(
            from_account_number_str="ACC-001",
            to_account_number_str="ACC-002",
            amount_int=3000,
            currency_str="JPY"
        )
    except Exception as e: print(f"Transfer failed: {e}")

    # --- UseCaseの実行 (失敗例: 残高不足) ---
    print("\\n--- Executing UseCase (Insufficient Funds) ---")
    try:
        transfer_funds_use_case.handle(
            from_account_number_str="ACC-001", # 残高は7000のはず
            to_account_number_str="ACC-002",
            amount_int=8000, # 👈 残高不足
            currency_str="JPY"
        )
    except Exception as e: print(f"Transfer failed as expected: {e}")

    # --- 最終結果の確認 ---
    print("\\n--- Verifying Final Balances ---")
    final_acc1 = account_repository.find_by_number(acc_num1)
    final_acc2 = account_repository.find_by_number(acc_num2)
    if final_acc1: print(f"- {acc_num1.value}: {final_acc1.balance.amount} {final_acc1.balance.currency}") # -> 7000 JPY
    if final_acc2: print(f"- {acc_num2.value}: {final_acc2.balance.amount} {final_acc2.balance.currency}") # -> 8000 JPY

```

✅ **このステップのポイント**:

- `main.py` が具体的な `InMemoryAccountRepository` と `TransferService` を生成し、`TransferFundsUseCase` に注入しました。
- UseCase を呼び出し、成功例と失敗例（残高不足）を実行して動作を確認しました。

---

## 📝 この演習のまとめ

この演習では、「口座間送金」シナリオを通じて、特に**ドメインサービス**の役割と使い方を実践しました。

- **集約 (`Account`)**: 各口座の状態と基本的な振る舞い（入出金、残高チェック）をカプセル化しました。
- **値オブジェクト (`Money`, `AccountNumber`)**: 金額と口座番号を型安全に扱いました。
- **ドメインサービス (`TransferService`)**: 複数の集約にまたがるドメイン固有のプロセス（送金）を実装しました。
- **リポジトリ (`AccountRepository`)**: 集約の永続化を抽象化しました。
- **UseCase (`TransferFundsUseCase`)**: ドメインサービスとリポジトリを利用してアプリケーションの要求に応え、トランザクション（概念）を管理しました。

ドメインサービスを導入することで、特定のエンティティに属さないが重要なビジネスロジックを**ドメイン層**に明確に位置づけ、UseCase がアプリケーションフローの調整に集中できるようになることが確認できたかと思います。

---

## ➡️ 次へ

次は、最後の演習「**(演習4) 在庫引き当て**」に進み、ドメインイベントを使って異なる関心事（注文と在庫）を疎結合に連携させる方法を見ていきましょう。