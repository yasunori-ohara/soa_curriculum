# 04 在庫引き当て

# 🏛️ 演習４：在庫引き当て（ドメインイベント活用）

## 🎯 この演習のゴール

- **ドメインイベント (Domain Event)** を使って、異なる関心事（注文と在庫）を**疎結合**に連携させる方法を実装する。
- **集約 (Aggregate)** を使って、在庫数の一貫性（マイナス在庫不可）を保証する。
- イベントハンドラ（またはそれに類する仕組み）が、ドメインイベントをトリガーとして**UseCase**を呼び出す流れを理解する。
- **リポジトリ (Repository)** を使って、在庫データの永続化を抽象化する。

---

## 📜 シナリオ

（別のコンテキストである）注文サービスから「注文が確定した (`OrderConfirmedEvent`)」というイベントを受け取った際に、該当する商品の在庫数を注文分だけ減らす（引き当てる）シナリオを実装します。在庫数が不足している場合は、引き当ては失敗し、エラー（または別のイベント発行）となります。

---

## 🛠️ 実装ステップ

以下の手順で、在庫管理という新しい（シンプルな）境界づけられたコンテキストを想定し、ドメインイベントに対応する形で各パターンを実装していきます。

---

## 📢 ステップ1: ドメインイベント (Domain Event) の定義 - 「出来事」を表現する

📝 **課題**: 「注文が確定した」という出来事は、「注文」コンテキストで発生しますが、「在庫」コンテキストもその事実を知り、自身の状態（在庫数）を更新する必要があります。しかし、注文コンテキストが在庫コンテキストの実装を直接知って呼び出すのは密結合になります。

💡 **解決策**: 「注文が確定した」という出来事を、**ドメインイベント (`Domain Event`)** として定義します。これは、過去に起こった事実を表す不変のオブジェクトです。在庫コンテキストは、このイベントが発生したことを（何らかの仕組み、今回はシミュレーションで）受け取り、それに応じた処理を行います。

**ファイル:** `inventory_context/domain/events.py` (※新しいコンテキストを想定)

```python
# inventory_context/domain/events.py
from dataclasses import dataclass, field
from datetime import datetime
from typing import List # OrderItem用

# (演習1のOrderItem定義をここに持ってくるか、共有ライブラリにする想定)
@dataclass(frozen=True)
class OrderItemData: # イベントに含めるデータ用 (値オブジェクトに近い)
    product_id: str
    quantity: int

# -----------------------------------------------------------------------------
# Order Confirmed Event (Input Contract)
# - DDD戦術的設計の Domain Event (他のコンテキストから来る Integration Event)
# - このコンテキストにとっては「入力データ」の契約にあたる
# -----------------------------------------------------------------------------
@dataclass(frozen=True) # イベントは不変
class OrderConfirmedEvent:
    """
    (注文コンテキストから発行される想定の)注文確定イベント。
    在庫コンテキストが購読し、在庫引き当てのトリガーとする。
    """
    order_id: str
    items: List[OrderItemData] # 引き当てに必要な商品IDと数量のリスト
    occurred_on: datetime = field(default_factory=datetime.now)

# (参考: 在庫引き当て成功/失敗を示すイベントも定義可能)
# @dataclass(frozen=True)
# class InventoryAllocatedEvent(DomainEvent):
#     order_id: str
#     product_id: str
# @dataclass(frozen=True)
# class AllocationFailedEvent(DomainEvent):
#     order_id: str
#     product_id: str
#     reason: str

```

✅ **このステップのポイント**:

- `OrderConfirmedEvent` は、「注文が確定した」という**過去の事実**を表します。
- イベントには、副作用（在庫引き当て）を実行するために**必要な最小限の情報**（商品IDと数量）を含めます。
- このイベント定義は、注文コンテキストと在庫コンテキストの間の**契約**として機能します。

---

## 🧱 ステップ2: エンティティ (Entity) / 集約 (Aggregate) の実装 - 在庫商品を定義する

📝 **課題**: 各商品の在庫数は、ID（商品ID）で識別され、在庫の引き当てや補充によって変化します。在庫数がマイナスになることは許されません（不変条件）。

💡 **解決策**: 「在庫商品 (`InventoryItem`)」を**エンティティ (`Entity`)** かつ**集約ルート (`Aggregate Root`)** として定義します。在庫数 (`stock_level`) を属性として持ち、在庫引き当て (`decrease_stock`) の振る舞い（メソッド）に不変条件（在庫数 \>= 0）のチェックを実装します。

**ファイル:** `inventory_context/domain/aggregates.py`

```python
# inventory_context/domain/aggregates.py
from dataclasses import dataclass, field
# from typing import List # ドメインイベント用
# from .events import DomainEvent # ドメインイベントを使う場合

# -----------------------------------------------------------------------------
# InventoryItem Aggregate Root / Entity
# - DDD戦術的設計の Aggregate Root / Entity
# - CAの Entities 層
# -----------------------------------------------------------------------------
@dataclass
class InventoryItem:
    """
    在庫商品を表す集約ルート・エンティティ。
    - product_id (外部システムと共通のIDなど) で識別される。
    - 在庫数(stock_level)の一貫性(マイナス不可)を維持する責務を持つ。
    """
    product_id: str # 商品を識別するID (ここでは単純な文字列)
    stock_level: int

    # _domain_events: List[DomainEvent] = field(default_factory=list, init=False, repr=False)

    def __post_init__(self):
        """生成時の検証"""
        if self.stock_level < 0:
            raise ValueError("Stock level cannot be negative at creation.")

    def decrease_stock(self, quantity_to_decrease: int):
        """
        [集約の振る舞い] 在庫数を減らす (引き当て)。
        - 不変条件(在庫 >= 0)をチェックする。
        """
        print(f"[Aggregate Logic] Attempting to decrease stock for {self.product_id} by {quantity_to_decrease} (Current: {self.stock_level})")
        if quantity_to_decrease <= 0:
            raise ValueError("Quantity to decrease must be positive.")

        # 不変条件: 在庫数は 0 未満になってはならない
        if self.stock_level < quantity_to_decrease:
            raise ValueError(f"Insufficient stock for product {self.product_id}. Available: {self.stock_level}, Required: {quantity_to_decrease}")
            # (ここで AllocationFailedEvent を発行しても良い)

        self.stock_level -= quantity_to_decrease
        print(f"[Aggregate Logic] Stock decreased successfully. New level: {self.stock_level}")
        # (ここで InventoryAllocatedEvent を発行しても良い)

    def increase_stock(self, quantity_to_increase: int):
        """
        [集約の振る舞い] 在庫数を増やす (補充など)。
        """
        print(f"[Aggregate Logic] Increasing stock for {self.product_id} by {quantity_to_increase}")
        if quantity_to_increase <= 0:
            raise ValueError("Quantity to increase must be positive.")
        self.stock_level += quantity_to_increase
        print(f"[Aggregate Logic] Stock increased successfully. New level: {self.stock_level}")

    # --- ドメインイベント関連メソッド (参考) ---
    # def get_uncommitted_events(self) -> List[DomainEvent]: ...
    # def clear_uncommitted_events(self): ...

```

✅ **このステップのポイント**:

- `InventoryItem` は `product_id` で識別される**エンティティ**であり、在庫数の一貫性を守る**集約ルート**です。
- `decrease_stock` メソッド内で在庫不足チェックを行うことで、集約の**不変条件**（在庫数 \>= 0）を保証しています。

---

## 💾 ステップ3: リポジトリ (Repository) の実装 - 在庫の永続化

📝 **課題**: `InventoryItem` 集約を永続化（保存・読み込み）する必要がありますが、その方法の詳細を `UseCase` や `InventoryItem` 自身が知るべきではありません。

💡 **解決策**: **リポジトリ (`Repository`)** パターンを適用します。`InventoryRepositoryInterface` を定義し、具体的な実装（今回はインメモリ）を `InMemoryInventoryRepository` に隠蔽します。商品ID (`product_id`) で検索できるようにします。

**ファイル:** `inventory_context/application/boundaries.py`

```python
# inventory_context/application/boundaries.py
from abc import ABC, abstractmethod
from inventory_context.domain.aggregates import InventoryItem # 永続化対象の集約
from typing import Optional

# -----------------------------------------------------------------------------
# Inventory Repository Interface
# - DDD戦術的設計の Repository Interface
# - CAの Application 層 (境界定義)
# -----------------------------------------------------------------------------
class InventoryRepositoryInterface(ABC):
    """InventoryItem集約の永続化を抽象化するインターフェース"""
    @abstractmethod
    def find_by_product_id(self, product_id: str) -> Optional[InventoryItem]:
        """商品IDでInventoryItem集約を検索する"""
        raise NotImplementedError

    @abstractmethod
    def save(self, inventory_item: InventoryItem):
        """InventoryItem集約を保存（新規作成または更新）する"""
        raise NotImplementedError

```

**ファイル:** `inventory_context/adapters/repositories.py`

```python
# inventory_context/adapters/repositories.py
from inventory_context.application.boundaries import InventoryRepositoryInterface
from inventory_context.domain.aggregates import InventoryItem
from typing import Optional, Dict # Dict を追加
import copy

# -----------------------------------------------------------------------------
# In-Memory Inventory Repository Implementation
# - DDD戦術的設計の Repository Implementation
# - CAの Adapters 層
# -----------------------------------------------------------------------------
class InMemoryInventoryRepository(InventoryRepositoryInterface):
    """InventoryItem集約をメモリ上の辞書で保持するリポジトリ実装"""
    def __init__(self):
        # product_id をキーとする辞書
        self._items: Dict[str, InventoryItem] = {}

    def find_by_product_id(self, product_id: str) -> Optional[InventoryItem]:
        print(f"[Adapter] InMemoryRepo: Finding inventory item by Product ID {product_id}")
        item = self._items.get(product_id)
        return copy.deepcopy(item) if item else None

    def save(self, inventory_item: InventoryItem):
        """InventoryItemを保存する (存在すれば上書き)"""
        print(f"[Adapter] InMemoryRepo: Saving inventory item {inventory_item.product_id} with stock {inventory_item.stock_level}")
        self._items[inventory_item.product_id] = copy.deepcopy(inventory_item)

```

✅ **このステップのポイント**:

- リポジトリが永続化の詳細を隠蔽し、`UseCase` からの独立性を保ちます。
- 商品ID (`product_id`) で在庫アイテムを検索するメソッドを提供しました。

---

## ⚙️ ステップ4: UseCase の実装 - 在庫引き当てフロー

📝 **課題**: `OrderConfirmedEvent` を受け取った際に、「イベント内の各商品について、在庫集約を取得し、在庫数を減らし、結果を保存する」という**アプリケーション固有のフロー**が必要です。

💡 **解決策**: このフローの責任を持つ「UseCase」を実装します。この UseCase は、イベントデータ（商品IDと数量）を受け取り、リポジトリインターフェースを利用して在庫集約を操作します。

**ファイル:** `inventory_context/application/use_cases.py`

```python
# inventory_context/application/use_cases.py
from inventory_context.application.boundaries import InventoryRepositoryInterface
from inventory_context.domain.events import OrderItemData # イベント内のデータ構造
from typing import List

# -----------------------------------------------------------------------------
# Allocate Inventory Use Case
# - CAの Use Cases 層と同じ役割
# - アプリケーション固有のビジネスフローを担当
# - Domain Event データを受け取り、Aggregate を操作する
# -----------------------------------------------------------------------------
class AllocateInventoryUseCase:
    """注文に基づいて在庫を引き当てるユースケース"""
    def __init__(self, inventory_repository: InventoryRepositoryInterface): # 必要な依存(Repo I/F)を注入
        self._inventory_repository = inventory_repository

    def handle(self, order_id: str, items_to_allocate: List[OrderItemData]):
        """
        ユースケースを実行する。
        Args:
            order_id: 対象の注文ID (ログやエラー通知用)
            items_to_allocate: 引き当てる商品とその数量のリスト
        Raises:
            ValueError: 在庫が見つからない、在庫不足の場合など
        """
        print(f"[UseCase] Starting inventory allocation for order {order_id}")

        processed_items = [] # 正常に処理できたアイテムを追跡 (補償トランザクション用)
        try:
            # --- トランザクション管理の開始 (概念) ---
            # 複数の在庫アイテムを更新するため、アトミック性が重要
            print("[UseCase] --- Transaction Start (Conceptual) ---")

            for item_data in items_to_allocate:
                product_id = item_data.product_id
                quantity = item_data.quantity
                print(f"[UseCase] Processing item {product_id}, quantity {quantity}")

                # 1. リポジトリを使って集約(InventoryItem)を取得
                inventory_item = self._inventory_repository.find_by_product_id(product_id)
                if not inventory_item:
                    raise ValueError(f"Inventory item {product_id} not found.")

                # 2. 集約ルートのメソッドを呼び出してビジネスロジック(在庫引き当て)を実行
                #    (ここで在庫不足なら ValueError が発生)
                inventory_item.decrease_stock(quantity)

                # 3. 変更された集約をリポジトリを使って保存
                #    (トランザクション内で全ての変更を記録していくイメージ)
                self._inventory_repository.save(inventory_item)
                processed_items.append((product_id, quantity)) # 成功した操作を記録

            # --- トランザクションのコミット (概念) ---
            print("[UseCase] --- Transaction Commit (Conceptual) ---")
            print(f"[UseCase] Inventory allocation for order {order_id} completed successfully.")

        except ValueError as e: # 在庫不足などのドメインルール違反
            # --- トランザクションのロールバック (概念) ---
            print(f"[UseCase] Allocation failed due to domain rule violation: {e}")
            print("[UseCase] --- Transaction Rollback (Conceptual) ---")
            # (※本来は、processed_items を使って補償トランザクション
            #    (引き当てた在庫を元に戻す処理) を行う必要があるが、ここでは省略)
            raise

        except Exception as e: # 予期せぬエラー
            print(f"[UseCase] An unexpected error occurred: {e}")
            print("[UseCase] --- Transaction Rollback (Conceptual) ---")
            # (同様に補償トランザクションが必要な場合がある)
            raise

```

✅ **このステップのポイント**:

- UseCase は、入力（イベントデータ）を受け取り、**リポジトリ**を使って**集約**を操作し、結果を保存するという、アプリケーションフローを調整します。
- 在庫引き当てのビジネスルール（マイナス在庫不可）は**集約 (`InventoryItem`)** にカプセル化されているため、UseCase はそのルールを直接実装する必要はありません。
- 複数の集約（異なる在庫商品）を更新する可能性があるため、**トランザクション管理**（今回は概念のみ）が重要になります。失敗した場合の**補償トランザクション**（元に戻す処理）も考慮が必要です。

---

## 🚀 ステップ5: 実行ファイル ([main.py](http://main.py/)) の作成 - イベント受信のシミュレーションと実行

📝 **課題**: UseCase を実行するためには、本来なら外部（注文コンテキストやメッセージキュー）から `OrderConfirmedEvent` を受信する仕組み（**イベントリスナー**や**メッセージコンシューマ**）が必要です。今回はその部分をシミュレートし、`main.py` で UseCase を直接呼び出します。

💡 **解決策**: `main.py` で依存関係を組み立て、`OrderConfirmedEvent` に相当するデータを作成し、`AllocateInventoryUseCase` を呼び出して実行します。

**ファイル:** `inventory_context/main.py`

```python
# inventory_context/main.py
from adapters.repositories import InMemoryInventoryRepository   # 👈 具体的なリポジトリ実装
from application.use_cases import AllocateInventoryUseCase    # 👈 UseCase
from domain.aggregates import InventoryItem                 # 初期データ作成用
from domain.events import OrderItemData                     # イベントデータ用

# -----------------------------------------------------------------------------
# Main Application / Composition Root / Event Listener Simulation
# - CAの最も外側の層 (Frameworks & Drivers) と同じ役割
# - 依存関係の解決 (DI) と、イベント受信を模したUseCase起動を行う
# -----------------------------------------------------------------------------
if __name__ == "__main__":
    print("--- Inventory Allocation Example (Event Driven) ---")

    # --- 依存関係の解決 (Dependency Injection) ---
    print("\\n--- Wiring dependencies (DI) ---")
    inventory_repository = InMemoryInventoryRepository()
    allocate_inventory_use_case = AllocateInventoryUseCase(inventory_repository)
    print("--- Dependencies wired successfully ---")

    # --- 初期在庫データ投入 ---
    print("\\n--- Setting up initial inventory ---")
    item1 = InventoryItem(product_id="prod-001", stock_level=10)
    item2 = InventoryItem(product_id="prod-002", stock_level=5)
    inventory_repository.save(item1)
    inventory_repository.save(item2)
    print("Initial stock levels:")
    print(f"- {item1.product_id}: {item1.stock_level}")
    print(f"- {item2.product_id}: {item2.stock_level}")

    # --- イベント受信 & UseCase実行 (シミュレーション1: 成功例) ---
    print("\\n--- Simulating OrderConfirmedEvent (Success Case) ---")
    # (本来はメッセージキューなどから受信するイベントデータ)
    order_id_1 = "order-abc"
    items_in_order_1 = [
        OrderItemData(product_id="prod-001", quantity=3),
        OrderItemData(product_id="prod-002", quantity=2),
    ]
    try:
        # イベントを受け取り、UseCaseを呼び出すイメージ
        allocate_inventory_use_case.handle(order_id_1, items_in_order_1)
    except Exception as e:
        print(f"Allocation failed for order {order_id_1}: {e}")

    # --- イベント受信 & UseCase実行 (シミュレーション2: 在庫不足) ---
    print("\\n--- Simulating OrderConfirmedEvent (Insufficient Stock) ---")
    order_id_2 = "order-def"
    items_in_order_2 = [
        OrderItemData(product_id="prod-001", quantity=5), # 残り7個のはず -> OK
        OrderItemData(product_id="prod-002", quantity=4), # 残り3個のはず -> NG!
    ]
    try:
        allocate_inventory_use_case.handle(order_id_2, items_in_order_2)
    except Exception as e:
        # 在庫不足のValueErrorがUseCaseから伝播してくるはず
        print(f"Allocation failed for order {order_id_2} as expected: {e}")

    # --- 最終結果の確認 ---
    print("\\n--- Verifying Final Stock Levels ---")
    final_item1 = inventory_repository.find_by_product_id("prod-001")
    final_item2 = inventory_repository.find_by_product_id("prod-002")
    # 成功したorder-abcの引き当て分だけが反映されているはず
    if final_item1: print(f"- {final_item1.product_id}: {final_item1.stock_level}") # -> 7 (10 - 3)
    if final_item2: print(f"- {final_item2.product_id}: {final_item2.stock_level}") # -> 3 (5 - 2)

```

✅ **このステップのポイント**:

- `main.py` が依存関係を組み立て、イベント受信を模して `AllocateInventoryUseCase` を呼び出しました。
- UseCase 内で在庫不足 (`ValueError`) が発生した場合、それが適切に `main.py` まで伝播し、キャッチされることを確認しました。

---

## 📝 この演習のまとめ

この演習では、「在庫引き当て」シナリオを通じて、**ドメインイベント**をトリガーとする処理の実装を実践しました。

- **ドメインイベント (`OrderConfirmedEvent`)**: 異なる関心事（注文と在庫）の間を**疎結合**に繋ぐ「**契約**」として機能しました。在庫コンテキストは、注文コンテキストの実装を知る必要がありません。
- **集約 (`InventoryItem`)**: 在庫数の一貫性（マイナス在庫不可）という**不変条件**を、`decrease_stock` メソッド内で保証しました。
- **リポジトリ (`InventoryRepository`)**: 在庫集約の永続化を抽象化しました。
- **UseCase (`AllocateInventoryUseCase`)**: イベントデータを受け取り、リポジトリと集約を利用して在庫引き当ての**アプリケーションフロー**を実行しました。トランザクション管理の重要性（今回は概念のみ）も示唆されました。

ドメインイベントを活用することで、システムの異なる部分（コンテキストやサービス）が、互いに直接依存することなく、**イベント（出来事）を通じて連携できるようになります。これにより、システムの柔軟性**と**拡張性**が向上します。

---

## ✅ 第6巡 実践編 完了！

これで、DDDの戦術的設計パターンを活用する4つの演習が完了しました。
これらの演習を通じて、`Entity`, `Value Object`, `Aggregate`, `Repository`, `Factory`, `Domain Service`, `Domain Event` といったビルディングブロックが、それぞれどのような役割を持ち、どのように連携してドメインの複雑さをコードに表現するのか、実践的な感覚を掴むことができたかと思います。