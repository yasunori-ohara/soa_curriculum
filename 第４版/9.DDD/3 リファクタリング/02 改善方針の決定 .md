# 02 改善方針の決定

# ステップ２：改善方針の決定 🗺️

Step 1 で、第2巡の図書館システム（想定）のコードをDDDの視点から分析し、いくつかの課題（値オブジェクトの不在、エンティティの振る舞い不足、集約境界の曖昧さなど）を洗い出しました。

このステップでは、これらの課題に対する具体的な*改善方針（リファクタリング計画）*を決定します。

---

## 💎 方針1：値オブジェクト (Value Object) の導入

- **課題**: `ISBN`, 貸出期間 (`borrow_date`, `due_date`), `User.name` などが、単なる基本型 (`str`, `datetime`) で表現されており、ドメイン固有のルール（`形式`, `不変性`, `関連ロジック`）がカプセル化されていない。
- **方針**:
    1. `ISBN` 値オブジェクトを作成する。コンストラクタで形式検証（例：桁数）を行う。
    2. `LoanPeriod` 値オブジェクトを作成する。`start_date` と `end_date` を持ち、生成時に `end_date > start_date` を保証する。貸出期間（例：2週間）を計算するメソッドも持たせる。
    3. `UserName` 値オブジェクトを作成する（例：空でないことを保証）。
    4. (`Book` の `Title`, `Author` も同様に値オブジェクト化を検討するが、まずは上記3つを優先）。
- **期待効果**: コードの表現力向上、不正データの防止、関連ロジックのカプセル化。

---

### 🧱 方針2：エンティティ (Entity) / 集約 (Aggregate) の責務明確化

- **課題**: `Book` エンティティが自身の貸出状態 (`is_borrowed`) に関する振る舞い（貸出可能かチェック、状態変更）を持っていない可能性がある。`Loan` エンティティも同様に、状態管理が外部（UseCase）で行われている可能性がある。
- **方針**:
    1. **`Book` 集約**:
        - `is_borrowed` 属性（またはより詳細な `BookStatus` Enum/VO）を内部状態として持つ。
        - `borrow()` メソッドを追加する。内部で貸出可能か（例：`status == AVAILABLE`）をチェックし、可能なら状態を `BORROWED` に変更する。貸出不可なら例外を送出する。
        - `return_book()` メソッドを追加する。状態を `AVAILABLE` に戻す。
    2. **`Loan` 集約**:
        - `LoanStatus` Enum/VO（例：`ACTIVE`, `COMPLETED`）を内部状態として持つ。
        - `complete()` メソッド（または `mark_as_returned()`）を追加する。状態を `COMPLETED` に変更する。
        - `LoanPeriod` 値オブジェクトを利用するように変更する。
    3. **`User` 集約**:
        - 今回はシンプルにするため、`User` 集約自体のリファクタリングは最小限とし、主にID参照として扱う（ただし `UserName` VO は導入）。
- **期待効果**: エンティティ/集約が自身の状態と振る舞いに責任を持つようになり、ドメインルールがカプセル化される（貧血ドメインモデルの解消）。UseCase のコードがシンプルになる。

---

### 🧩 方針3：集約境界の確定と連携方法

- **課題**: `Book`, `User`, `Loan` の関係性と、それらにまたがるルール（例：「貸出中の本は貸し出せない」「利用者はN冊まで」）の扱い。
- **方針**:
    1. `Book`, `User`, `Loan` をそれぞれ**独立した集約**として扱うことを確定する。
    2. `Loan` 集約は、`Book` と `User` を**ID** (`book_id`, `user_id`) で参照する。
    3. 「貸出中の本は貸し出せない」ルールは、`Book` 集約の `borrow()` メソッド内で状態チェックすることで保証する。
    4. 「利用者は最大N冊まで」ルールは、今回はシンプルに **`BorrowBookUseCase`** が `LoanRepository` の `count_active_loans_by_user_id` (新規追加) のようなメソッドを使ってチェックする、という**アプリケーション層の責務**とする（より複雑な場合は `User` 集約やドメインサービスを検討）。
- **期待効果**: 各集約の独立性が保たれ、責務が明確になる。集約をまたぐルールをどこで扱うかの判断基準を学ぶ。

---

### 💾 方針4：リポジトリ (Repository) の調整

- **課題**: リポジトリインターフェースと実装が、上記の変更（値オブジェクト導入、集約境界確定）に対応している必要がある。
- **方針**:
    1. 各リポジトリ (`BookRepository`, `UserRepository`, `LoanRepository`) が対応する集約ルートのみを扱うことを再確認する。
    2. 検索メソッドなどで値オブジェクト (`ISBN`, `UserID` など) を使えるようにインターフェースと実装を調整する。
    3. 方針3-4で必要となった `LoanRepositoryInterface.count_active_loans_by_user_id()` のようなメソッドを追加する。
- **期待効果**: 永続化層がドメインモデルの変更に追従し、抽象化が維持される。

---

### 🗣️ 方針5：ユビキタス言語の見直し

- **課題**: コード内の名前がドメインの言葉と一致していない可能性がある。
- **方針**: リファクタリングを進める中で、クラス名、メソッド名、変数名などが、図書館ドメインの自然な言葉（ユビキタス言語）を反映しているか常に意識し、必要であればリネームする（例：`is_borrowed` -\> `status: BookStatus`, `borrow()` メソッドの追加など）。
- **期待効果**: コードの可読性が向上し、ドメインエキスパート（今回は想像上の）とのコミュニケーションが円滑になる土台ができる。

---

## 📝 リファクタリング計画まとめ

1. **値オブジェクト導入**: `ISBN`, `LoanPeriod`, `UserName` を作成。
2. **集約の責務強化**: `Book` に `borrow`/`return_book`、`Loan` に `complete` メソッドを追加。状態管理を内部化。
3. **集約境界確定**: `Book`, `User`, `Loan` を独立集約とし、ID参照。最大貸出数チェックはUseCase責務に。
4. **リポジトリ調整**: インターフェースと実装を上記変更に合わせる。検索メソッド追加。
5. **命名見直し**: ユビキタス言語を意識したリネーム。

---

## ➡️ 次へ

改善方針が固まりました。次のステップ「**(Step 3) リファクタリングの実装：値オブジェクトの導入**」で、実際にコードの修正を始めていきましょう。