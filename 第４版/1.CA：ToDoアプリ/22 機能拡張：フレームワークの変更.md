# 22 機能拡張：フレームワークの変更

# 🔄 Webフレームワークの差し替え：Flask → FastAPI

## 🧭 この章の目的

この章では、Web UI を構築するフレームワークを **Flask から FastAPI に差し替える**例を通じて、クリーンアーキテクチャの「技術独立性の強さ」を確認します。

ここで注目したいのは：

* ビジネスロジック（UseCase）
* 表示ロジックの整形（Presenter）
* データ保存（Repository）

…といった内側の層は、一切変更しなくてもよいということです。

![クリーンアーキテクチャ](../クリーンアーキテクチャ.png)

---

## 🔁 なぜフレームワークの差し替えが「簡単」なのか？

> 💡 クリーンアーキテクチャでは、フレームワークは「最外層の詳細」に過ぎません。

* `View` は最外層（Frameworks & Drivers）にあるため、外部技術そのもの（FlaskでもFastAPIでもOK）を自由に差し替えられます。
* `View` が依存してよいのは **Controller と ViewModel だけ**。
* `UseCase` や `Presenter` は Web フレームワークに依存していません。
* つまり Flask版の `WebView` を FastAPI版に置き換えても、**UseCase / Presenter / Repository / Entity は1行も変更不要**です。

これは、将来「別のWebフレームワークに移行したい」「APIサーバーと別フロントにしたい」といった要求にも応えやすい構造になっている、という意味です。

---

## 📂 ファイルの配置

FastAPI版のViewは、他のView（CLI版 / GUI版 / Flask版）と同じ並びに追加します。

```text
├─ interface_adapters/
│   ├─ presenters/
│   │   └─ todo_presenter.py
│   ├─ controllers/
│   │   └─ todo_controller.py
│   └─ views/
│       ├─ view_console.py        # CLI版 View
│       ├─ view_gui.py            # GUI版 View (tkinter)
│       ├─ view_web.py            # Web版 View (Flask)
│       ├─ view_fastapi.py        # Web版 View (FastAPI) ← この章で追加
│       └─ templates/
│           └─ index.html         # FastAPI用のテンプレート（Jinja2）
```

ポイントは、**どのViewも Controller と ViewModel にだけ依存する**という対称性です。
アプリの中心である `core/` や `infrastructure/` には一切触れていません。

---

## ✅ FastAPI版 View の実装例

下記は Flask版 `WebView` と同じ責務を FastAPI で実現したものです。
違いはフレームワーク（＝HTTPサーバーの詳細）だけです。

```python
# --------------------------------------------------------------------
# File: interface_adapters/views/view_fastapi.py
# Layer: Interface Adapters（View - Web版 / FastAPI）
#
# 責務：
#   - HTTP経由でユーザー入力を受け取り（フォーム送信）、
#     Controllerに「TODOを追加して」と依頼する。
#   - Presenterが更新したViewModelの内容をHTMLとして返す。
#
# 依存：
#   - <I> TodoController（ユーザー操作の伝達先）
#   - <DS> TodoViewModel（表示用の状態を保持）
#
# 同心円図での位置：
#   - Frameworks & Drivers（最外層）
#   - FastAPIなどのフレームワーク依存コードはここに閉じ込める。
#
# 備考：
#   - FastAPIは非同期I/Oに対応しているので、ハンドラはasyncで書ける。
#   - それでも「何をするか」はConsoleView/GuiViewとまったく同じ。
# --------------------------------------------------------------------

from fastapi import FastAPI, Request, Form
from fastapi.responses import HTMLResponse
from fastapi.templating import Jinja2Templates

from interface_adapters.controllers.todo_controller import TodoController
from core.usecase.boundary.dto import TodoViewModel


class FastApiView:
    """
    FastAPI版のView。
    - HTTPリクエストを受けてControllerに処理を依頼し、
      Presenterが更新したViewModelの内容をHTMLとして返す。
    - Webサーバー（FastAPI+uvicorn）の起動も担当する。
    """

    def __init__(self, controller: TodoController, view_model: TodoViewModel):
        """
        [依存関係]
        - controller: フォーム入力をUseCaseまで橋渡しする仲介役
        - view_model: Presenterが更新し続ける表示用データ
        """
        self._controller = controller
        self._view_model = view_model

        # FastAPIアプリ本体
        self.app = FastAPI()

        # Jinja2テンプレートの場所
        # 例: interface_adapters/views/templates/index.html
        self.templates = Jinja2Templates(directory="interface_adapters/views/templates")

        # ルーティングの設定
        self._setup_routes()

    def _setup_routes(self):
        """
        "/" エンドポイントにGETとPOSTをまとめる。
        - GET  : 現在の画面を表示
        - POST : 入力されたタイトルをControllerに渡してUseCaseを実行
        """

        @self.app.get("/", response_class=HTMLResponse)
        async def get_form(request: Request):
            # 現在のViewModelの状態をテンプレートに流し込む
            return self.templates.TemplateResponse(
                "index.html",
                {
                    "request": request,
                    "display": self._view_model.display_text,
                },
            )

        @self.app.post("/", response_class=HTMLResponse)
        async def post_form(request: Request, title: str = Form(...)):
            # ユーザー入力（title）をControllerへ渡す
            self._controller.add_todo(title)

            # PresenterがViewModelを更新している前提で、その最新状態を返す
            return self.templates.TemplateResponse(
                "index.html",
                {
                    "request": request,
                    "display": self._view_model.display_text,
                },
            )

    def run(self):
        """
        FastAPIアプリケーションを起動する。
        uvicornを使ってローカル開発用サーバーを立ち上げる。
        """
        import uvicorn
        uvicorn.run(self.app, host="127.0.0.1", port=8000, reload=True)
```

### テンプレート例：`interface_adapters/views/templates/index.html`

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <title>TODOアプリ（FastAPI版）</title>
    <style>
        body {
            font-family: sans-serif;
            line-height: 1.5;
            max-width: 480px;
        }
        form {
            margin-bottom: 1rem;
        }
        .msg {
            color: green;
            white-space: pre-wrap;
        }
        small {
            color: #777;
        }
    </style>
</head>
<body>
    <h1>TODO追加</h1>

    <form method="POST">
        <input
            type="text"
            name="title"
            placeholder="TODOのタイトル"
            required
            style="padding:0.5rem; width:70%;"
        />
        <button type="submit" style="padding:0.5rem 1rem;">追加</button>
    </form>

    <p class="msg">{{ display }}</p>

    <hr/>
    <small>
        この画面はFastAPI版のViewです。  
        ビジネスロジック（UseCase）や永続化（Repository）には一切触れていません。
    </small>
</body>
</html>
```

---

## 🛡 このクラスの鉄則

> 技術は変わる、責務は変えない。

* Viewは「表示」と「入力の橋渡し」だけを行う
* Webフレームワーク（Flask / FastAPI / Django / …）はView層に閉じ込める
* Controller・UseCase・Presenter・Repositoryには、一切変更を伝播させない

これができていれば、フレームワーク選定の自由度は圧倒的に高くなります。

---

## 🔧 `main.py` での差し替え例（FastAPI版）

`main.py` は、アプリ全体の部品を組み立てる場所（コンポジションルート）です。
ConsoleView・GuiView・Flask版WebViewと同様に、FastAPI版も同じ流れで組み立てられます。

```python
# main.py (FastAPI版で動かしたい場合の例)

from core.usecase.boundary.dto import TodoViewModel
from core.usecase.interactor.create_todo import TodoUseCase
from interface_adapters.presenters.todo_presenter import TodoPresenter
from interface_adapters.controllers.todo_controller import TodoController
from interface_adapters.views.view_fastapi import FastApiView
from infrastructure.repositories.in_memory_todo_repository import InMemoryTodoRepository


def main():
    # ViewModel（PresenterとViewで共有される表示状態）
    view_model = TodoViewModel()

    # Repository（Todoを保存。今回はインメモリ実装）
    repository = InMemoryTodoRepository()

    # Presenter（UseCaseの結果をViewModel向けメッセージに整形する）
    presenter = TodoPresenter(view_model)

    # UseCase（ビジネスロジック本体。「TODOを追加する」など）
    use_case = TodoUseCase(presenter, repository)

    # Controller（ユーザー入力をUseCaseに橋渡しする）
    controller = TodoController(use_case)

    # FastAPI版 View（HTTP経由でControllerとViewModelをつなぐ）
    web_view = FastApiView(controller, view_model)

    # Webサーバーを起動する
    web_view.run()


if __name__ == "__main__":
    main()
```

ここでもやはり：

* `core/` の中身は一切変更していません
* PresenterもRepositoryもそのまま
* 差し替えているのは **Viewの具体的なフレームワーク実装だけ** です

---

## まとめ

* Flask版の `WebView` も、FastAPI版の `FastApiView` も、**責務は同じ**

  * HTTPリクエストを受けて Controller を呼び
  * Presenterが詰めた ViewModel の内容を HTML に埋め込んで返す

* つまり「どのフレームワークを使うか」は、**最外層の都合**でしかない
  → アプリの本質（ビジネスルール、ユースケース、永続化）の都合ではない

* これが「フレームワークにアプリを従わせるのではなく、アプリがフレームワークを利用する」という考え方です。

