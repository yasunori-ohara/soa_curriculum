# 04 認識サービスの変更 (サーバー側)

# ステップ２：認識サービスの変更 (サーバー側)

ステップ1で定義したOpenAPIの「契約書」に基づき、最初のサービスである「認識サービス」を改修します。

## 🎯 課題

認識サービスの現在の役割は、MQTTブローカーにWorldModelをPublish（送信）することです。
今回の課題は、このMQTT Publisherとしての機能を削除し、代わりに **REST APIサーバーとして機能させる**ことです。

具体的には、経路計算サービスから `GET /world_model` というHTTPリクエストを受け取ったら、現在のWorldModelをJSON形式でレスポンス（返信）できるように変更します。

## 🔧 実装方針

このHTTP APIサーバーを実装するために、PythonのモダンなWebフレームワークである **FastAPI** を導入します。FastAPIは、OpenAPI仕様とPydantic（データバリデーションライブラリ）に完全準拠しており、最小限のコードで高性能なAPIサーバーを構築できます。

クリーンアーキテクチャの観点では、以下の変更を行います。

1. MQTT Publisher Adapterを削除します。
2. HTTP API (FastAPI) を担当する新しい **Controller (Adapter層)** を実装します。
3. `main.py` を、MQTTブローカーに接続する処理から、FastAPIサーバーを起動する処理に変更します。

## 📁 ファイル構成（変更点）

`recognition_service/` 配下の構成が以下のように変更されます。

```
recognition_service/
├── adapter/
│   ├── __init__.py
│   ├── dto.py          # (新規) Pydanticモデル (DTO) を定義
│   └── rest_api.py     # (新規) FastAPIコントローラー
├── domain/
│   └── ... (変更なし)
├── usecase/
│   └── get_world_model.py # (変更なし)
└── main.py             # (修正) FastAPIサーバーを起動

```

## 📜 コード実装 (Pydanticモデル)

FastAPIはPydanticモデルを使ってデータの型定義、バリデーション、JSONシリアライズを行います。これはOpenAPIの `schemas` と 1:1 で対応します。

`recognition_service/adapter/dto.py`

```python
# CA: Infrastructure (Adapter)
# 処理内容: OpenAPIの 'schemas' に基づき、Pydanticモデルを定義する。
# これらはAPIのレスポンスモデル(DTO)として、また型ヒントとして使用される。
from pydantic import BaseModel, Field
from typing import List
from datetime import datetime

# --- OpenAPI 'schemas' に対応するPydanticモデル ---

class Point(BaseModel):
    x: float
    y: float

class Pose(BaseModel):
    x: float
    y: float
    theta: float

class Obstacle(BaseModel):
    id: int
    polygon: List[Point]

class ParkingSpot(BaseModel):
    id: int
    is_occupied: bool
    polygon: List[Point]

class WorldModel(BaseModel):
    """
    APIレスポンスとして返すWorldModelのスキーマ。
    FastAPIはこれを自動的にJSONに変換する。
    """
    timestamp: datetime
    obstacles: List[Obstacle]
    parking_spots: List[ParkingSpot]
    vehicle_pose: Pose

    # PydanticモデルがPythonのオブジェクト(例: Domainモデル)から
    # データを読み込めるようにするための設定
    class Config:
        from_attributes = True

```

## 📜 コード実装 (FastAPIコントローラー)

これがAPIのエンドポイントを定義する、新しいAdapter（Controller層）です。

`recognition_service/adapter/rest_api.py`

```python
# CA: Interface (Adapter)
# 処理内容: FastAPIを使用して '/world_model' エンドポイントを実装するコントローラー。

from fastapi import FastAPI
# (仮) 本来はdomainモデルを使うが、ここでは簡略化のためUseCaseがDTOを返すと仮定
# 実際にはここで domain -> dto の変換を行う
from .dto import WorldModel
# (仮) UseCaseのインポートパス
from usecase.get_world_model import GetWorldModelUseCase

# CA: Infrastructure (Adapter)
# 処理内容: FastAPIアプリケーションのインスタンスを作成
app = FastAPI(
    title="Recognition Service API",
    description="Provides the current World Model.",
    version="1.0.0"
)

# CA: Interface (Adapter) - Controller
# 処理内容: HTTP GETリクエスト '/world_model' に対応するエンドポイントを定義。
# response_model=WorldModel は、戻り値がWorldModelスキーマに従うことを保証し、
# 自動でJSONにシリアライズし、OpenAPIドキュメントにも反映する。
@app.get("/world_model", response_model=WorldModel)
def get_world_model_endpoint():
    """
    現在のWorldModelを取得します。
    """
    # 1. CA: Application (UseCase)
    # 処理内容: ビジネスロジック(UseCase)のインスタンスを作成。
    # 本来はリポジトリ等をDI(依存性注入)するが、ここでは簡略化。
    use_case = GetWorldModelUseCase()

    # 2. CA: Application (UseCase)
    # 処理内容: ユースケースを実行し、結果(WorldModel)を取得する。
    # (注意) 本来UseCaseはDomainモデルを返す。
    # ここでは簡略化のため、UseCaseがPydanticのDTOモデルを返すと仮定する。
    # 厳密には、このAdapter層でDomainモデルをDTO(WorldModel)に変換する。
    world_model_data = use_case.handle()

    # 3. CA: Interface (Adapter) - Presenter
    # 処理内容: UseCaseから受け取ったデータを返す。
    # FastAPIが自動的に Pydantic モデルを JSON レスポンスに変換する (Presenterの役割)。
    return world_model_data

```

## 📜 コード実装 ([main.py](http://main.py/))

最後に、MQTTのロジックを削除し、Uvicorn（ASGIサーバー）でFastAPIアプリを起動するよう `main.py` を修正します。

`recognition_service/main.py`

```python
# CA: Main / Infrastructure
# 処理内容: アプリケーションのエントリーポイント。
# MQTTクライアントの代わりに、Uvicorn ASGIサーバーを起動してFastAPIアプリをホストする。

import uvicorn
# CA: Infrastructure (Adapter)
# 処理内容: adapter/rest_api.py で定義したFastAPIアプリのインスタンスをインポート
from adapter.rest_api import app

if __name__ == "__main__":
    print("Starting Recognition Service (REST API Server)...")

    # CA: Infrastructure
    # 処理内容: Uvicornサーバーを起動する。
    # "adapter.rest_api:app" : 'adapter.rest_api.py' ファイル内の 'app' という名前のFastAPIインスタンスを指定
    # host="0.0.0.0" : 全てのネットワークインターフェースで待ち受ける
    # port=8001      : 認識サービスはポート8001番で実行する
    # reload=True    : (開発用) コード変更時にサーバーを自動リロードする
    uvicorn.run("adapter.rest_api:app", host="0.0.0.0", port=8001, reload=True)

    # --- 第5巡のMQTT関連コードは全て削除 ---
    # client = MqttClient(...)
    # ... (削除) ...
    # while True: ... (削除) ...

```

## 💡 ポイント

注目すべきは、**UseCase (usecase/get_world_model.py) のコードには一切変更を加えていない**点です。（UseCaseが返すデータがドメインモデルであると仮定すれば、dto.pyへの変換処理がrest\_api.pyに追加されるだけです）。

これは、クリーンアーキテクチャの大きな利点です。
外部とのI/O（入出力）の方法がMQTT（非同期）からREST（同期）へと根本的に変わったにもかかわらず、システムの核となるビジネスロジックは影響を受けずに済みました。変更はAdapter層とMain（インフラ層）に限定されています。