# 10 補足3：なぜ今回はDockerを使わなかったか？

# 補足3：なぜ今回はDockerを使わなかったか？

第5巡（MQTT）ではDocker (docker-compose) を使用して全サービスを起動しましたが、今回の第6巡（REST）では各サービスをターミナルで個別に起動しました。この違いには明確な理由があります。

## 📦 必須の「外部ミドルウェア」の有無

最大の理由は、**第6巡のアーキテクチャには、必須の外部ミドルウェア（ブローカーなど）が存在しない**ためです。

### 第5巡（MQTT）の場合

第5巡のシステムは、3つのPythonサービスに加えて、**Mosquitto (MQTTブローカー)** という独立した第4のコンポーネントが不可欠でした。

この構成では、`docker-compose` を使うことで、以下の大きなメリットがありました。

1. Mosquittoブローカーの起動と管理を自動化できる。
2. 3つのPythonサービスとMosquittoブローカー間のネットワーク接続を簡潔に定義できる。
3. `docker-compose up` という単一のコマンドで、4つのコンポーネント全てを同時に起動できる。

## 🖥️ 第6巡（REST）の場合

一方、今回の第6巡のシステムは、3つのPythonサービス（FastAPIサーバー x2, クライアント x1）のみで完結しています。

サービス間の通信は、HTTPリクエストによって直接行われます（例：`http://localhost:8001` へアクセス）。Mosquittoのような**仲介役となるミドルウェアは不要**です。

このため、3つのターミナルを開いて `python main.py` を実行するだけで、システム全体を起動・動作させることができました。

## 🎓 学習上の理由

あえてDockerを使わなかったことには、学習上のメリットもあります。

今回の同期モデルでは、「ターミナル3（制御）がリクエストを発行 → ターミナル2（計画）がそれを受け付け、ターミナル1（認識）を呼び出し → ターミナル1が応答 → ターミナル2が応答 → ターミナル3が応答を受け取る」という、**処理の連鎖と待機（ブロッキング）**が明確に発生します。

もし `docker-compose` を使うと、3つのサービスのログが1つのターミナルに混在して出力されるため、この同期的な処理の連鎖が視覚的に追いにくくなります。

今回は、各サービスのログを個別のターミナルで見ることで、どのサービスがいつリクエストを受け取り、いつ待機し、いつ応答を返したかを明確に観察できるようにするため、あえてDockerを使用しませんでした。

### 補足：現実の開発では

もちろん、今回の第6巡の構成であっても、現実のプロジェクト開発では `docker-compose` を使うのが一般的です。その目的は、開発者間や本番環境との間でPythonのバージョンやライブラリ依存関係を統一する「環境のコンテナ化」や、`docker-compose up` ひとつで全サービスを起動できる「利便性の向上」にあります。