# 06 車両制御サービスの変更 (クライアント側)

# ステップ４：車両制御サービスの変更 (クライアント側)

ステップ3で、経路計算サービスが「サーバー」兼「クライアント」になりました。
最後のステップとして、「車両制御サービス」を改修します。このサービスは純粋な「クライアント」として機能します。

## 🎯 課題

車両制御サービスは、第5巡（MQTT）ではParkingPlanをSubscribe（受信）して実行していました。
今回の課題は、このMQTT Subscriberとしての機能を削除し、代わりに **REST クライアントとして機能させる**ことです。

具体的には、経路計算サービス ( `http://localhost:8002` ) に `GET /parking_plan` を自らリクエストし、取得したParkingPlanを実行するように変更します。

## 🔧 実装方針

経路計算サービスと同様に、HTTPクライアントライブラリ **requests** を導入します。
このサービスは外部からのリクエストを受け付ける必要がないため、FastAPI（サーバー機能）は不要です。

クリーンアーキテクチャの観点では、以下の変更を行います。

1. MQTT Subscriber Adapterを削除します。
2. 経路計算サービスAPIを呼び出すための新しい **Infrastructure (Adapter)** として `PlanningClient` を実装します。
3. UseCase (`ExecutePlanUseCase`) を修正します。MQTTメッセージを待つ（イベント駆動）のではなく、`PlanningClient` を使って自ら計画を同期的に取得（プル型）するように変更します。
4. `main.py` を修正します。MQTTの待機ループから、例えば「定期的に計画を取得しにいく」といった同期的な実行ループに変更します。

## 📁 ファイル構成（変更点）

`control_service/` 配下の構成が以下のように変更されます。

```
control_service/
├── adapter/
│   ├── __init__.py
│   ├── dto.py            # (新規) Pydanticモデル (DTO) を定義
│   └── planning_client.py  # (新規) 経路計算サービスAPIクライアント
├── domain/
│   └── ... (変更なし)
├── usecase/
│   └── execute_plan.py    # (修正) データ取得方法を変更
└── main.py                # (修正) 同期実行ループに変更

```

## 📜 コード実装 (Pydanticモデル)

まず、経路計算サービスから受信するParkingPlanのスキーマを `dto.py` として定義します。

`control_service/adapter/dto.py`

```python
# CA: Infrastructure (Adapter)
# 処理内容: OpenAPIの 'schemas' に基づき、Pydanticモデルを定義する。
# 経路計算サービスから受信する ParkingPlan のスキーマ。
from pydantic import BaseModel
from typing import List
from uuid import UUID

class Pose(BaseModel):
    x: float
    y: float
    theta: float

class ParkingPlan(BaseModel):
    plan_id: UUID
    status: str
    path: List[Pose]

    class Config:
        from_attributes = True

```

## 📜 コード実装 (クライアント側 - Planning Client Adapter)

次に、経路計算サービス ( `port:8002` ) の `GET /parking_plan` を呼び出すためのAdapterを実装します。

`control_service/adapter/planning_client.py`

```python
# CA: Infrastructure (Adapter)
# 処理内容: 経路計算サービス(Planning Service)APIへのHTTPクライアント。
# requestsライブラリを使い、同期的にParkingPlanを取得する。

import requests
from requests.exceptions import RequestException
from adapter.dto import ParkingPlan # DTOをインポート
from typing import Optional

# 経路計算サービスのベースURL
PLANNING_SERVICE_URL = "<http://localhost:8002>"

class PlanningClient:
    """
    経路計算サービス(Planning Service)のREST APIクライアント
    """
    def fetch_parking_plan(self) -> Optional[ParkingPlan]:
        """
        経路計算サービスからGET /parking_planを呼び出し、
        計算済みの駐車計画を取得する。
        """
        try:
            # CA: Infrastructure
            # 処理内容: 同期HTTP GETリクエストを実行。
            # 経路計算サービスは内部で認識サービスを呼ぶため、
            # タイムアウトは長め(例: 10秒)に設定する。
            response = requests.get(
                f"{PLANNING_SERVICE_URL}/parking_plan",
                timeout=10.0
            )

            # CA: Infrastructure
            # 処理内容: HTTPステータスコードが200番台以外なら例外を発生
            response.raise_for_status()

            # CA: Infrastructure (Adapter) - Data Mapper
            # 処理内容: 成功した場合、JSONレスポンスをParkingPlan DTOにパースして返す
            return ParkingPlan.model_validate(response.json())

        except RequestException as e:
            # CA: Infrastructure
            # 処理内容: 接続エラー、タイムアウト、HTTPエラー(503等)
            print(f"Error fetching ParkingPlan: {e}")
            return None

```

## 📜 コード実装 (UseCaseの修正)

UseCaseを修正し、MQTTのコールバックで起動されるのではなく、自ら `PlanningClient` を使って計画を取得するように変更します。

`control_service/usecase/execute_plan.py`

```python
# CA: Application (UseCase)
# 処理内容: 駐車計画を取得し、車両制御を実行するロジック。
# MQTTからのイベント駆動ではなく、
# 自らクライアント(pull)を使ってデータを取得するように変更。

# CA: Infrastructure (Adapter)
# 処理内容: インフラ層のアダプタ(クライアント)をインポート
from adapter.planning_client import PlanningClient
from adapter.dto import ParkingPlan # (仮) DomainモデルとDTOが同一と仮定
from typing import Optional

class ExecutePlanUseCase:
    """
    駐車計画を取得し、実行するユースケース
    """

    # CA: Application (UseCase)
    # 処理内容: DI(依存性注入)により、呼び出し元(main)からクライアントを受け取る
    def __init__(self, planning_client: PlanningClient):
        self.planning_client = planning_client

    def handle(self):
        """
        ユースケースの実行
        """
        # 1. CA: Infrastructure (Adapter)
        # 処理内容: アダプタ経由で経路計算サービスを「同期的に」呼び出す。
        # この呼び出しが完了する(計画が返るかエラーになる)まで、処理は待機する。
        print("Fetching ParkingPlan from Planning Service...")
        plan: Optional[ParkingPlan] = self.planning_client.fetch_parking_plan()

        if plan is None:
            print("Failed to get ParkingPlan. Vehicle remains idle.")
            return

        # 2. CA: Application (UseCase) / Domain
        # 処理内容: 取得した計画(plan)に基づいて車両制御を実行する(ダミー)
        print(f"Executing ParkingPlan (ID: {plan.plan_id})...")
        for i, pose in enumerate(plan.path):
            print(f"  Moving to step {i+1}: (x={pose.x}, y={pose.y}, theta={pose.theta})")
            # (ここに実際の車両制御コマンドが入る)

        print(f"ParkingPlan (ID: {plan.plan_id}) execution complete.")

```

## 📜 コード実装 ([main.py](http://main.py/))

最後に `main.py` です。
MQTTブローカーに接続して待ち受ける（非同期）代わりに、一定間隔（例：5秒ごと）でUseCaseを呼び出す（同期）ループ処理に変更します。

`control_service/main.py`

```python
# CA: Main / Infrastructure
# 処理内容: アプリケーションのエントリーポイント。
# サーバー機能は持たず、クライアントとして定期的にUseCaseを実行する。

import time
from adapter.planning_client import PlanningClient
from usecase.execute_plan import ExecutePlanUseCase

# 実行間隔 (秒)
EXECUTION_INTERVAL_SECONDS = 5

def main_loop():
    """
    メインの実行ループ。
    定期的に経路計算サービスに計画を問い合わせ、実行する。
    """
    print("Starting Control Service (REST Client)...")

    # --- 依存性の注入 (DI) ---
    # 1. CA: Infrastructure (Adapter)
    # 処理内容: 経路計算サービスクライアントのインスタンスを作成
    client = PlanningClient()

    # 2. CA: Application (UseCase)
    # 処理内容: UseCaseにクライアントを注入してインスタンスを作成
    use_case = ExecutePlanUseCase(planning_client=client)
    # ---------------------------

    try:
        while True:
            # 3. CA: Application (UseCase)
            # 処理内容: ユースケースを実行
            # このhandle()の中で、planning_serviceへの同期HTTP呼び出しが発生する
            use_case.handle()

            # CA: Infrastructure
            # 処理内容: 指定した間隔だけ待機する
            print(f"Waiting for {EXECUTION_INTERVAL_SECONDS} seconds before next cycle...")
            time.sleep(EXECUTION_INTERVAL_SECONDS)

    except KeyboardInterrupt:
        print("Stopping Control Service...")

if __name__ == "__main__":
    main_loop()

    # --- 第5巡のMQTT関連コードは全て削除 ---
    # client = MqttClient(...)
    # client.on_message = on_message_callback ... (削除) ...
    # client.loop_forever() ... (削除) ...

```

## 💡 ポイント

この変更により、車両制御サービスは「計画がMQTTで送られてくるのを待つ」という受動的なコンポーネントから、「自ら定期的に計画を問い合わせにいく」という能動的なコンポーネントに変わりました。

`use_case.handle()` が呼ばれると、その内部で経路計算サービスへの同期呼び出しが発生し、結果が返るまで（経路計算サービスが認識サービスを呼び出し、計算を終えるまで）処理がブロックされます。システム全体の動作が、同期的・直列的になったことが分かります。