# 01 シンプルな注文

# 🏛️ 演習１：シンプルな注文

## 🎯 この演習のゴール

- DDDの基本的なパターン（値オブジェクト, エンティティ, 集約, ファクトリ, リポジトリ）を実装し、それらが連携する様子を理解する。
- 各パターンが「なぜ」必要なのか、使わない場合に比べてどのような利点があるのかを学ぶ。
- これらのパターンが、私たちが学んできたクリーンアーキテクチャ(CA)の構造（特に `domain/`, `application/`, `adapters/`）の中でどのように位置づけられるかを確認する。

---

## 📜 シナリオ

顧客が商品をカートに入れ、注文を作成するシンプルなシナリオを実装します。注文には最低1つの注文明細が必要です。注文が作成されると、合計金額が自動的に計算され、ステータスは「PENDING」になります。

---

## 🛠️ 実装ステップ

以下の手順で、各パターンを実装し、その役割と利点を確認していきます。

---

## 💎 ステップ1: 値オブジェクト (Value Object) の実装 - 「値」を豊かに表現する

📝 **課題**: 注文には「金額」という概念が登場します。これを単なる数値 (`int`) と文字列 (`str` for currency) で扱うこともできますが、それだと「1000円 + 5ドル」のような不正な計算ができてしまったり、マイナス金額のようなありえない値が紛れ込んだりする可能性があります。

💡 **解決策**: 「金額」というドメイン（ビジネス）の概念を、専用のクラス「値オブジェクト (`Value Object`)」として定義します。値オブジェクトは、「値そのもの」が重要で、IDを持たず、通常は不変（変更不可）です。生成時にルール（マイナス不可、通貨は3文字など）を強制し、安全な操作（通貨が同じ場合のみ加算可能など）を提供します。

**ファイル:** `domain/value_objects.py`

```python
# domain/value_objects.py
from dataclasses import dataclass

# -----------------------------------------------------------------------------
# Money Value Object
# - DDD戦術的設計の Value Object
# - CAの Entities 層 (ドメインの核となるルールの一部)
# -----------------------------------------------------------------------------
@dataclass(frozen=True) # 不変 (Immutable) を保証
class Money:
    """
    金額を表す値オブジェクト。
    - frozen=True: インスタンス作成後に属性を変更できないようにする。
    - IDを持たず、amountとcurrencyという「値」だけで定義される。
    """
    amount: int
    currency: str # 例: "JPY", "USD"

    def __post_init__(self):
        """
        インスタンス生成直後に呼ばれるメソッド。
        自己検証 (Self-validation) ロジックをここに書く。
        """
        print(f"[VO Check] Validating Money: {self.amount} {self.currency}")
        if self.amount < 0:
            # 不正な値でオブジェクトが生成されるのを防ぐ
            raise ValueError("Amount cannot be negative.")
        if len(self.currency) != 3:
            # 通貨コードは3文字というルールを強制
            raise ValueError("Currency must be 3-letter code.")
        print("[VO Check] Money is valid.")

    def add(self, other: 'Money') -> 'Money':
        """
        金額を加算するメソッド。
        - 通貨が異なる場合はエラーとする (ドメインルール)。
        - 結果として新しいMoneyインスタンスを返す (不変性を維持)。
        """
        if self.currency != other.currency:
            raise ValueError("Cannot add different currencies.")
        # 新しいインスタンスを生成して返す
        new_amount = self.amount + other.amount
        print(f"[VO Logic] Adding Money: {self.amount} + {other.amount} = {new_amount} {self.currency}")
        return Money(new_amount, self.currency)

    # (必要であれば subtract, multiply などのメソッドも追加)

```

✅ **このステップのポイント**:

- `Money` クラスを作ることで、「金額」というビジネス概念がコード上で明確になりました (Primitive Obsessionの回避)。
- `frozen=True` と `add` が新しいインスタンスを返すことで、意図しない値の変更を防ぎます (不変性)。
- `__post_init__` でのチェックにより、常に「正しい」金額オブジェクトしか存在しない状態を作れます (自己検証)。

---

## 🧱 ステップ2: エンティティ (Entity) と 集約 (Aggregate) の実装 - 一貫性を保つまとまりを作る

📝 **課題**: 注文 (`Order`) は、複数の注文明細 (`OrderItem`) を持ちます。注文の合計金額は、常に明細の合計と一致していなければなりません。また、「どの注文か」を区別するためにIDが必要です。これらをバラバラに扱うと、合計金額の計算漏れや、どの明細がどの注文に属するかの管理が複雑になります。

💡 **解決策**:

1. **エンティティ (`Entity`)**: 注文 (`Order`) や注文明細 (`OrderItem`) のように、IDで区別され、状態が変化するものをエンティティとして定義します。
2. **集約 (`Aggregate`)**: データの整合性を保つべきエンティティと値オブジェクト（今回は `Order` と `OrderItem`、`Money`）を一つの「まとまり（集約）」として扱います。集約には必ず代表者（**集約ルート**、今回は `Order`）が存在し、外部からのアクセスや変更は必ずこのルートを通じて行います。これにより、集約内部のルール（合計金額の一致など）を一貫して守ることができます。

**ファイル:** `domain/aggregates.py`

```python
# domain/aggregates.py
from dataclasses import dataclass, field
from typing import List, Dict, Optional # List, Dict を追加
from .value_objects import Money # 作成した値オブジェクトをインポート
import uuid # ID生成用

@dataclass
class OrderItem:
    """
    注文明細を表すエンティティ（集約内部）。
    - 集約ルート(Order)によってライフサイクルが管理される。
    - item_id は Order 内で一意であればよい（ローカルID）。
    - UnitPrice は Money 値オブジェクト。
    """
    item_id: str
    product_id: str
    quantity: int # (本来は Quantity 値オブジェクトにするのが望ましい)
    unit_price: Money

    def calculate_item_total(self) -> Money:
        """明細ごとの合計金額を計算するメソッド"""
        print(f"[Entity Logic] Calculating item total for {self.item_id}")
        # Moneyオブジェクトのamountとcurrencyを使って計算
        return Money(self.unit_price.amount * self.quantity, self.unit_price.currency)

# -----------------------------------------------------------------------------
# Order Aggregate Root
# - DDD戦術的設計の Aggregate Root / Entity
# - CAの Entities 層
# -----------------------------------------------------------------------------
@dataclass
class Order:
    """
    注文全体を表す集約ルート・エンティティ。
    - order_id というグローバルIDで識別される (Entityの特徴)。
    - 注文明細(items)や合計金額(total_price)など、
      一貫性を保つべきデータと振る舞いをカプセル化する (Aggregateの特徴)。
    """
    order_id: str = field(default_factory=lambda: str(uuid.uuid4())) # IDを自動生成
    customer_id: str
    items: Dict[str, OrderItem] = field(default_factory=dict) # 明細を辞書で保持 (item_id -> OrderItem)
    total_price: Money = field(init=False) # 合計金額 (計算結果を保持)
    status: str = "PENDING" # 初期ステータス

    def __post_init__(self):
        """インスタンス生成後に合計金額を初期計算"""
        self._recalculate_total()

    def add_item(self, product_id: str, quantity: int, unit_price: Money):
        """
        [集約の振る舞い] 注文明細を追加し、合計を更新する。
        - 外部から items 辞書を直接操作させず、このメソッド経由で行う (カプセル化)。
        - これにより、合計金額との一貫性（不変条件）を保証する。
        """
        print(f"[Aggregate Logic] Adding item {product_id} to order {self.order_id}")
        if quantity <= 0:
            raise ValueError("Quantity must be positive.")
        # (製品が存在するか、価格が正しいか等のチェックは省略)

        item_id = f"item_{len(self.items) + 1}"
        new_item = OrderItem(item_id, product_id, quantity, unit_price)
        self.items[item_id] = new_item

        # 状態変更後に、関連する状態(合計金額)も更新する
        self._recalculate_total()
        print(f"[Aggregate Logic] Item added. New total: {self.total_price.amount} {self.total_price.currency}")

    def change_item_quantity(self, item_id: str, new_quantity: int):
        """
        [集約の振る舞い] 既存明細の数量を変更し、合計を更新する。
        - これも集約ルート経由で行うことで一貫性を保つ。
        """
        print(f"[Aggregate Logic] Changing quantity for item {item_id} in order {self.order_id}")
        if new_quantity <= 0:
            raise ValueError("Quantity must be positive.")
        if item_id not in self.items:
            raise ValueError(f"Item {item_id} not found in order.")

        self.items[item_id].quantity = new_quantity
        self._recalculate_total()
        print(f"[Aggregate Logic] Quantity changed. New total: {self.total_price.amount} {self.total_price.currency}")

    def _recalculate_total(self):
        """
        [内部ロジック] 合計金額を集約内部で再計算するプライベートメソッド。
        - 集約の不変条件（合計金額は常に明細合計と一致）を維持する責務を持つ。
        """
        print(f"[Aggregate Logic] Recalculating total for order {self.order_id}")
        if not self.items:
            self.total_price = Money(0, "JPY") # 通貨は仮
            return

        currency = next(iter(self.items.values())).unit_price.currency
        total_amount = 0
        for item in self.items.values():
            if item.unit_price.currency != currency:
                raise ValueError("Cannot mix currencies in a single order.") # 不変条件
            item_total = item.calculate_item_total()
            total_amount += item_total.amount

        self.total_price = Money(total_amount, currency)

    # ... (confirm_order など他のメソッドは省略) ...

```

✅ **このステップのポイント**:

- `Order` と `OrderItem` を一つの「注文集約」としてまとめることで、`total_price` の**一貫性**が保証されやすくなりました。
- 変更操作 (`add_item`, `change_item_quantity`) を集約ルート (`Order`) のメソッドに集約することで、ルール（不変条件）のチェック漏れを防ぎます (カプセル化)。
- `Order` は `order_id` で識別される**エンティティ**です。

---

## 🏭 ステップ3: ファクトリ (Factory) の実装 - 複雑な生成を専門家に任せる

📝 **課題**: 新しい `Order` 集約を作るには、顧客IDだけでなく、最初の注文明細リスト（最低1つ）が必要です。さらに、明細ごとの価格（`Money` オブジェクト）の生成や、初期の合計金額計算も伴います。この生成ロジックを `UseCase` など、オブジェクトを利用する側に書くと、コードが複雑になり、同じロジックが重複する可能性があります。

💡 **解決策**: 複雑なオブジェクト生成の「専門家」として、「ファクトリ (`Factory`)」を導入します。ファクトリは、必要な情報を受け取り、ルールに従ってオブジェクト（今回は `Order` 集約）を正しく生成する責任を持ちます。

**ファイル:** `domain/factories.py`

```python
# domain/factories.py
from .aggregates import Order, OrderItem
from .value_objects import Money
from typing import List, Dict # List, Dict を追加

# -----------------------------------------------------------------------------
# Order Factory
# - DDD戦術的設計の Factory
# - CAの Domain 層 (または Application 層に置く場合もある)
# -----------------------------------------------------------------------------
class OrderFactory:
    """
    Order集約の生成ロジックをカプセル化するファクトリ。
    - UseCaseなどのクライアントから複雑な初期化手順を隠蔽する。
    - 生成時に満たすべき不変条件（最低1アイテム）を保証する。
    """
    def create_new_order(self, customer_id: str, item_data_list: List[Dict]) -> Order:
        """
        新しい注文集約を生成する。
        Args:
            customer_id: 顧客ID
            item_data_list: 注文明細データのリスト (辞書のリスト)
                           例: [{'product_id': 'p1', 'quantity': 2, 'unit_price': 100, 'currency': 'JPY'}, ...]
        Returns:
            生成されたOrder集約インスタンス
        Raises:
            ValueError: アイテムリストが空の場合やデータが不正な場合
        """
        print("[Factory] Creating new order...")
        if not item_data_list:
            # 生成時の不変条件チェック
            raise ValueError("Order must have at least one item to be created.")

        # 1. 集約ルート(Order)のインスタンスを生成
        #    (order_id は Order のコンストラクタ内で自動生成される)
        #    この時点では items は空で、total_price は初期値(0円)のはず
        order = Order(customer_id=customer_id)
        print(f"[Factory] Initial Order object created with ID: {order.order_id}")

        # 2. 渡されたデータからOrderItemを作成し、集約に追加
        #    (この処理が複雑なのでFactoryにまとめる価値がある)
        for item_data in item_data_list:
            # 値オブジェクト(Money)の生成もここで行う
            try:
                unit_price = Money(amount=item_data['unit_price'], currency=item_data['currency'])
            except KeyError as e:
                raise ValueError(f"Missing key in item data: {e}")
            except ValueError as e: # Moneyの検証エラー
                raise ValueError(f"Invalid money data in item: {e}")

            # 集約ルートのメソッド(add_item)経由で明細を追加する
            # これにより、Order内部の不変条件(_recalculate_total)が維持される
            print(f"[Factory] Adding item {item_data['product_id']} via Order.add_item...")
            order.add_item(
                product_id=item_data['product_id'],
                quantity=item_data['quantity'],
                unit_price=unit_price
            )

        # 3. 完全に初期化され、不変条件を満たした集約インスタンスを返す
        #    (この時点で total_price も正しく計算されているはず)
        print(f"[Factory] New order {order.order_id} created successfully with total {order.total_price.amount}.")
        return order

```

✅ **このステップのポイント**:

- `Order` の複雑な生成手順（`Money` の生成、`add_item` のループ呼び出し、最低1アイテムの保証）が `OrderFactory` に**カプセル化**されました。
- `UseCase` は、このファクトリを使うだけで、正しい状態の `Order` 集約を簡単に生成できるようになります。

---

## 💾 ステップ4: リポジトリ (Repository) の実装 - 永続化の隠蔽

📝 **課題**: 作成した `Order` 集約を、データベースやファイルなどの永続化ストレージに保存したり、後でIDを指定して読み込んだりする必要があります。しかし、`UseCase` やドメインモデル（`Order` など）が、具体的なデータベース操作（SQLの発行など）を知ってしまうと、データベースの種類を変更したり、テストしたりするのが困難になります（CAのデータベース独立性の原則違反）。

💡 **解決策**: 「リポジトリ (`Repository`)」パターンを適用します。リポジトリは、ドメインモデル（特に集約）の永続化に関する**インターフェース**（窓口）を定義し、その具体的な**実装**（DBアクセスなど）を隠蔽します。`UseCase` はインターフェースだけを利用します。

**ファイル:** `application/boundaries.py`

```python
# application/boundaries.py
from abc import ABC, abstractmethod
from domain.aggregates import Order # 永続化対象の集約
from typing import Optional

# -----------------------------------------------------------------------------
# Order Repository Interface
# - DDD戦術的設計の Repository Interface
# - CAの Application 層 (境界定義)
# -----------------------------------------------------------------------------
class OrderRepositoryInterface(ABC):
    """
    Order集約の永続化を抽象化するインターフェース。
    あたかもメモリ上のコレクションのように振る舞うメソッドを提供する。
    """
    @abstractmethod
    def find_by_id(self, order_id: str) -> Optional[Order]:
        """IDでOrder集約を検索する"""
        raise NotImplementedError

    @abstractmethod
    def save(self, order: Order):
        """Order集約を保存（新規作成または更新）する"""
        raise NotImplementedError

    # (必要であれば delete, find_by_customer などのメソッドも追加)

```

**ファイル:** `adapters/repositories.py`

```python
# adapters/repositories.py
from application.boundaries import OrderRepositoryInterface
from domain.aggregates import Order
from typing import Optional, Dict # Dict を追加
import copy # オブジェクトのコピー用

# -----------------------------------------------------------------------------
# In-Memory Order Repository Implementation
# - DDD戦術的設計の Repository Implementation
# - CAの Adapters 層
# -----------------------------------------------------------------------------
class InMemoryOrderRepository(OrderRepositoryInterface):
    """
    Order集約をメモリ上の辞書で保持するリポジトリ実装。
    (テスト用やシンプルなアプリケーション向け)
    """
    def __init__(self):
        self._orders: Dict[str, Order] = {} # order_id をキーとする辞書

    def find_by_id(self, order_id: str) -> Optional[Order]:
        print(f"[Adapter] InMemoryRepo: Finding order {order_id}")
        order = self._orders.get(order_id)
        # 取得時にコピーを返すのがより安全な場合もあるが、今回は参照を返す
        return copy.deepcopy(order) if order else None

    def save(self, order: Order):
        """Orderを保存する (存在すれば上書き)"""
        print(f"[Adapter] InMemoryRepo: Saving order {order.order_id}")
        # 保存時にもコピーを保存することで、外部での変更の影響を切る
        self._orders[order.order_id] = copy.deepcopy(order)

```

✅ **このステップのポイント**:

- `OrderRepositoryInterface` が、「IDで検索」「保存」という**抽象的な操作**を定義しました。
- `InMemoryOrderRepository` が、その操作を**具体的な方法**（今回はメモリ上の辞書）で実装し、その詳細を隠蔽しました。
- `UseCase` は `OrderRepositoryInterface` だけに依存すればよくなり、データがメモリにあるのかDBにあるのかを気にする必要がなくなりました。

---

## ⚙️ ステップ5: UseCase の実装 - ビジネスフローの実現

📝 **課題**: シナリオ「顧客IDと商品リストを受け取り、新しい注文を作成し、保存する」という一連の**ビジネスフロー**を実行する部品が必要です。このフローには、注文の生成（ファクトリ利用）と保存（リポジトリ利用）が含まれますが、それらの具体的な実装方法からは独立しているべきです。

💡 **解決策**: このビジネスフローの責任を持つのが「UseCase」です。これはCAで学んだ UseCase と**同じ概念**です。UseCase はドメインオブジェクト（集約、値オブジェクト）、ファクトリ、リポジトリ（インターフェース）を利用して、特定のアプリケーションの要求を実現します。

**ファイル:** `application/use_cases.py`

```python
# application/use_cases.py
from application.boundaries import OrderRepositoryInterface
from domain.factories import OrderFactory
from typing import List, Dict # List, Dict を追加

# -----------------------------------------------------------------------------
# Create Order Use Case
# - CAの Use Cases 層と同じ役割
# - アプリケーション固有のビジネスフローを担当
# - ドメインオブジェクト(Factory, Repo I/F)を利用する
# -----------------------------------------------------------------------------
class CreateOrderUseCase:
    """注文を作成するユースケース"""
    def __init__(self,
                 order_factory: OrderFactory, # 注文生成の専門家 (ドメイン層)
                 order_repository: OrderRepositoryInterface): # 注文永続化の窓口 (境界)
        # 依存オブジェクトをコンストラクタで受け取る (DI)
        self._order_factory = order_factory
        self._order_repository = order_repository

    def handle(self, customer_id: str, item_data_list: List[Dict]) -> str:
        """
        ユースケースを実行する。
        Args:
            customer_id: 顧客ID
            item_data_list: 注文明細データのリスト
        Returns:
            生成された注文のID
        """
        print("[UseCase] Starting to create order...")
        try:
            # 1. ファクトリを使ってドメインオブジェクト(Order集約)を生成する
            #    (UseCaseは複雑な生成手順を知らない)
            print("[UseCase] Calling OrderFactory to create order...")
            new_order = self._order_factory.create_new_order(customer_id, item_data_list)

            # 2. リポジトリインターフェースを使って集約を保存する
            #    (UseCaseは具体的な保存方法を知らない)
            print(f"[UseCase] Calling Repository to save order {new_order.order_id}...")
            self._order_repository.save(new_order)

            # (もし必要なら、ここでドメインイベントを発行・ディスパッチする処理が入る)

            print(f"[UseCase] New order created successfully: {new_order.order_id}")
            # 3. 結果として注文IDを返す (例)
            return new_order.order_id

        except ValueError as e: # Factoryや集約メソッドからのドメインルール違反をキャッチ
            print(f"[UseCase] Failed to create order due to domain rule violation: {e}")
            raise # エラーを上位に伝播させるのが一般的

        except Exception as e: # 予期せぬエラー (DB接続エラーなどもここに該当しうる)
            print(f"[UseCase] An unexpected error occurred: {e}")
            raise

```

✅ **このステップのポイント**:

- `CreateOrderUseCase` は、CAの UseCase と**同じ役割**を果たします。アプリケーションの特定の機能（注文作成）のフローを制御します。
- `UseCase` は、DDDのビルディングブロック（`OrderFactory`, `OrderRepositoryInterface`）を利用しますが、それらの**具体的な実装**には依存しません（DI経由で受け取るため）。
- 複雑なドメインルール（金額計算、一貫性維持、生成ルール）は `Entity`, `Aggregate`, `Value Object`, `Factory` にカプセル化されているため、UseCase は**ビジネスフローの調整**に集中できます。

---

## 🚀 ステップ6: 実行ファイル ([main.py](http://main.py/)) の作成 - 全体の組み立て

📝 **課題**: これまで作成した各部品（`UseCase`, `Factory`, `Repository`の実装）は、まだバラバラの状態です。アプリケーションとして動作させるためには、これらの部品を**組み立て**、`UseCase` に必要な具体的な実装（依存オブジェクト）を\*\*提供（注入）\*\*し、実行を開始する「起点」が必要です。

💡 **解決策**: この組み立てと起動の役割を担うのが `main.py`（またはアプリケーションのエントリーポイント）です。これはCAで学んだ `main.py` の役割（**Composition Root** や **DIコンテナ**の役割）と**同じ**です。`main.py` は、どの具体的な実装クラスを使うかを決定し、それらをインスタンス化して `UseCase` に渡します。

**ファイル:** `main.py` (プロジェクトルート、または `app/` など)

```python
# main.py
from domain.factories import OrderFactory
from adapters.repositories import InMemoryOrderRepository # 👈 具体的なリポジトリ実装
from application.use_cases import CreateOrderUseCase    # 👈 UseCase

# -----------------------------------------------------------------------------
# Main Application / Composition Root
# - CAの最も外側の層 (Frameworks & Drivers) と同じ役割
# - 依存関係の解決 (DI) とアプリケーションの起動を行う
# -----------------------------------------------------------------------------
if __name__ == "__main__":
    print("--- Simple Order Creation Example ---")

    # --- 依存関係の解決 (Dependency Injection) ---
    print("\\n--- Wiring dependencies (DI) ---")
    # 1. 具体的なリポジトリ実装をインスタンス化
    order_repository = InMemoryOrderRepository()
    # 2. ファクトリをインスタンス化 (今回は依存なし)
    order_factory = OrderFactory()
    # 3. UseCaseに必要な具体的な依存オブジェクトを注入してインスタンス化
    #    CreateOrderUseCase は OrderFactory と OrderRepositoryInterface を要求していたので、
    #    OrderFactory と InMemoryOrderRepository のインスタンスを渡す。
    create_order_use_case = CreateOrderUseCase(order_factory, order_repository)
    print("--- Dependencies wired successfully ---")

    # --- UseCaseの実行 ---
    print("\\n--- Executing UseCase ---")
    # (本来はWebリクエストやCLI引数などから入力データが来る)
    customer_id = "cust-123"
    items_to_order = [
        {'product_id': 'prod-001', 'quantity': 2, 'unit_price': 1000, 'currency': 'JPY'},
        {'product_id': 'prod-002', 'quantity': 1, 'unit_price': 2500, 'currency': 'JPY'},
    ]

    try:
        # UseCaseのhandleメソッドを呼び出す
        new_order_id = create_order_use_case.handle(customer_id, items_to_order)

        # --- 結果の確認 (リポジトリから取得して検証) ---
        print("\\n--- Verifying Created Order via Repository ---")
        created_order = order_repository.find_by_id(new_order_id)
        if created_order:
            print(f"Order ID: {created_order.order_id}")
            print(f"Customer ID: {created_order.customer_id}")
            print(f"Status: {created_order.status}") # -> PENDING
            print(f"Total Price: {created_order.total_price.amount} {created_order.total_price.currency}") # -> 4500 JPY
            print(f"Number of Items: {len(created_order.items)}") # -> 2
        else:
            print("Order not found in repository.")

    except ValueError as e:
        print(f"Operation failed: {e}")
    except Exception as e:
        print(f"An unexpected error occurred: {e}")

```

✅ **このステップのポイント**:

- `main.py` は、CAの `main.py` と**同じ役割**を果たします。アプリケーション全体の依存関係を把握し、それらを組み立てます（Composition Root）。
- `UseCase` や他の部品は、自身が依存するオブジェクトが具体的にどのクラスなのかを知る必要がありません。`main.py` がそれを決定し、注入します（Dependency Injection）。

---

## 📝 この演習のまとめ

この演習では、「シンプルな注文」シナリオを通じて、DDDの戦術的設計パターンがどのように連携するかを、各ステップで「なぜ」そのパターンが必要なのかを考えながら実践しました。

- **値オブジェクト (`Money`)**: 「値」を安全に、豊かに表現しました。
- **集約 (`Order`, `OrderItem`)**: データの一貫性を保つ「まとまり」を作り、ビジネスルールをカプセル化しました。
- **ファクトリ (`OrderFactory`)**: 複雑な「生成」の責務を分離しました。
- **リポジトリ (`OrderRepository`)**: 「永続化」の責務を分離し、抽象化しました。
- **UseCase (`CreateOrderUseCase`)**: CAと同様に、ビジネスフローを調整する役割を担いました。
- [**main.py**](http://main.py/): CAと同様に、全体の依存関係を組み立てる役割を担いました。

これらのパターンを組み合わせることで、ドメインのルールがコードに明確に反映され、変更に強く、テストしやすい設計が実現できることを確認できたかと思います。

---

## ➡️ 次へ

次は、「**(演習2) ユーザープロファイル更新**」に進み、エンティティ、値オブジェクト、リポジトリの連携と、値オブジェクトによる自己検証の効果をさらに詳しく見ていきましょう。