# 02 ユーザープロファイル更新

# 🏛️ 演習２：ユーザープロファイル更新

## 🎯 この演習のゴール

- **エンティティ (Entity)** と **値オブジェクト (Value Object)** を適切に使い分け、ドメイン概念を表現する。
- 値オブジェクトの**自己検証**機能を利用して、ドメインモデルの堅牢性を高める。
- **リポジトリ (Repository)** を介してエンティティの永続化を抽象化する。
- これらのパターンがクリーンアーキテクチャのフォルダ構造の中で連携する様子を実装する。

---

## 📜 シナリオ

ユーザーが自身のメールアドレスを変更するシンプルなシナリオを実装します。メールアドレスには特定の形式（例：`@`が含まれる）が必要です。また、変更後のメールアドレスが既に他のユーザーに使われていないかチェックします。

---

## 🛠️ 実装ステップ

以下の手順で、各パターンを実装し、その役割と利点を確認していきます。

---

## 💎 ステップ1: 値オブジェクト (Value Object) の実装 - 「メールアドレス」という概念を定義する

📝 **課題**: メールアドレスは単なる文字列ですが、特定の形式を持つというビジネスルールがあります。これを単なる `str` で扱うと、不正な形式のメールアドレスがシステム内に紛れ込む可能性があります。また、メールアドレスの形式チェックロジックが、コードのあちこちに散らばるかもしれません。

💡 **解決策**: 「メールアドレス」という概念を、専用の**値オブジェクト (`Value Object`)** として定義します。値オブジェクトは不変（Immutable）とし、生成時に形式チェックを行うことで、常に「正しい形式の」メールアドレスオブジェクトしか存在しない状態を作ります。

**ファイル:** `domain/value_objects.py`

```python
# domain/value_objects.py
from dataclasses import dataclass
import re # メール形式チェック用の正規表現ライブラリ

# -----------------------------------------------------------------------------
# EmailAddress Value Object
# - DDD戦術的設計の Value Object
# - CAの Entities 層 (ドメインの核となるルールの一部)
# -----------------------------------------------------------------------------
@dataclass(frozen=True) # 不変 (Immutable) を保証
class EmailAddress:
    """
    メールアドレスを表す値オブジェクト。
    - frozen=True: インスタンス作成後に属性を変更できない。
    - IDを持たず、value(メールアドレス文字列)という「値」だけで定義される。
    - 生成時に形式の妥当性を検証する (自己検証)。
    """
    value: str

    def __post_init__(self):
        """
        インスタンス生成直後に呼ばれるメソッドで、自己検証を行う。
        """
        print(f"[VO Check] Validating EmailAddress: {self.value}")
        # 簡単なメール形式チェック (正規表現は必要に応じて調整)
        if not re.match(r"[^@]+@[^@]+\\.[^@]+", self.value):
            # 不正な形式の場合はオブジェクト生成を失敗させる
            raise ValueError(f"Invalid email format: {self.value}")
        print("[VO Check] EmailAddress is valid.")

    # 値オブジェクトは通常、振る舞い（メソッド）をあまり持たないが、
    # 例えばドメイン部分を取得するようなヘルパーメソッドは有用な場合がある
    def get_domain(self) -> str:
        return self.value.split('@')[1]

```

✅ **このステップのポイント**:

- `EmailAddress` クラスにより、「メールアドレス」というビジネス概念がコード上で型として表現されました。
- `frozen=True` で**不変性**を保証し、意図しない変更を防ぎます。
- `__post_init__` での**自己検証**により、常に正しい形式のメールアドレスしか扱わない安全な設計を実現しました。

---

## 🧱 ステップ2: エンティティ (Entity) / 集約 (Aggregate) の実装 - 「ユーザー」を定義する

📝 **課題**: 「ユーザー」は、名前やメールアドレスといった属性を持ちますが、これらの属性が変わっても（例：改名、メール変更）、同一のユーザーとして識別される必要があります（IDが必要）。また、メールアドレスを変更するという振る舞い（ビジネスロジック）も持ちます。

💡 **解決策**: 「ユーザー (`User`)」を**エンティティ (`Entity`)** として定義します。今回はシンプルにするため、`User` エンティティ自体が集約ルートでもあると考えます。メールアドレスは、先ほど定義した `EmailAddress` 値オブジェクトとして保持します。

**ファイル:** `domain/aggregates.py`

```python
# domain/aggregates.py
from dataclasses import dataclass, field
from .value_objects import EmailAddress # 作成した値オブジェクトをインポート
import uuid # ID生成用
from typing import List # ドメインイベント用 (今回の演習では使わないが参考)
# from .events import DomainEvent # ドメインイベントを使う場合

# -----------------------------------------------------------------------------
# User Aggregate Root / Entity
# - DDD戦術的設計の Aggregate Root / Entity
# - CAの Entities 層
# -----------------------------------------------------------------------------
@dataclass
class User:
    """
    ユーザーを表す集約ルート・エンティティ。
    - user_id というグローバルIDで識別される (Entityの特徴)。
    - メールアドレス(email)は EmailAddress 値オブジェクトとして保持する。
    - 状態変更(メールアドレス変更)のためのメソッドを持つ。
    """
    user_id: str = field(default_factory=lambda: str(uuid.uuid4())) # IDを自動生成
    name: str
    email: EmailAddress # 👈 値オブジェクトを利用
    # ... 他のユーザー属性 (例: password_hash, created_at など) ...

    # _domain_events: List[DomainEvent] = field(default_factory=list, init=False, repr=False) # イベント用

    def change_email(self, new_email: EmailAddress):
        """
        [エンティティの振る舞い] メールアドレスを変更する。
        - 新しいメールアドレスも EmailAddress 型で受け取ることで、
          不正な形式のアドレスが設定されるのを防ぐ。
        """
        print(f"[Entity Logic] Attempting to change email for user {self.user_id} to {new_email.value}")
        # (例: 変更履歴の記録や、変更通知イベントの発行などもここに追加可能)
        if self.email == new_email:
            # 値オブジェクト同士の比較は、属性値(value)の比較となる (dataclassの機能)
            print("[Entity Logic] New email is the same as the current one. No change.")
            return # 同じ場合は何もしない

        self.email = new_email
        print(f"[Entity Logic] User {self.user_id} email successfully changed to {new_email.value}")
        # event = UserEmailChangedEvent(user_id=self.user_id, new_email=new_email.value)
        # self._domain_events.append(event)

    # ... 他のユーザーに関するビジネスルール (例: パスワード変更メソッドなど) ...

    # --- ドメインイベント関連メソッド (参考) ---
    # def get_uncommitted_events(self) -> List[DomainEvent]:
    #     return self._domain_events[:]
    # def clear_uncommitted_events(self):
    #     self._domain_events.clear()

```

✅ **このステップのポイント**:

- `User` は `user_id` で識別される**エンティティ**です。
- メールアドレスを `EmailAddress` **値オブジェクト**で保持することで、`User` オブジェクトが常に有効なメールアドレスを持つことを保証し、`change_email` メソッドの引数も型安全になります。
- メールアドレス変更という**振る舞い**を `User` エンティティ自身が持つことで、関連するロジック（重複チェックを除く）がカプセル化されます。

---

## 💾 ステップ3: リポジトリ (Repository) の実装 - ユーザーの永続化

📝 **課題**: 生成・変更した `User` エンティティを永続化（保存・読み込み）する必要がありますが、その方法（DB、ファイルなど）の詳細を `UseCase` や `User` エンティティが知るべきではありません。

💡 **解決策**: 「リポジトリ (`Repository`)」パターンを適用します。`UserRepositoryInterface` を定義し、具体的な永続化ロジック（今回はインメモリ）を `InMemoryUserRepository` に隠蔽します。

**ファイル:** `application/boundaries.py`

```python
# application/boundaries.py
from abc import ABC, abstractmethod
from domain.aggregates import User # 永続化対象の集約
from domain.value_objects import EmailAddress # 検索で使う
from typing import Optional

# -----------------------------------------------------------------------------
# User Repository Interface
# - DDD戦術的設計の Repository Interface
# - CAの Application 層 (境界定義)
# -----------------------------------------------------------------------------
class UserRepositoryInterface(ABC):
    """User集約の永続化を抽象化するインターフェース"""
    @abstractmethod
    def find_by_id(self, user_id: str) -> Optional[User]:
        """IDでUser集約を検索する"""
        raise NotImplementedError

    @abstractmethod
    def find_by_email(self, email: EmailAddress) -> Optional[User]:
        """メールアドレス(値オブジェクト)でUser集約を検索する"""
        raise NotImplementedError

    @abstractmethod
    def save(self, user: User):
        """User集約を保存（新規作成または更新）する"""
        raise NotImplementedError

    # (必要であれば delete などのメソッドも追加)

```

**ファイル:** `adapters/repositories.py`

```python
# adapters/repositories.py
from application.boundaries import UserRepositoryInterface
from domain.aggregates import User
from domain.value_objects import EmailAddress # EmailAddress をインポート
from typing import Optional, Dict # Dict を追加
import copy

# -----------------------------------------------------------------------------
# In-Memory User Repository Implementation
# - DDD戦術的設計の Repository Implementation
# - CAの Adapters 層
# -----------------------------------------------------------------------------
class InMemoryUserRepository(UserRepositoryInterface):
    """
    User集約をメモリ上の辞書で保持するリポジトリ実装。
    """
    def __init__(self):
        self._users: Dict[str, User] = {} # user_id をキーとする辞書

    def find_by_id(self, user_id: str) -> Optional[User]:
        print(f"[Adapter] InMemoryRepo: Finding user by ID {user_id}")
        user = self._users.get(user_id)
        return copy.deepcopy(user) if user else None

    def find_by_email(self, email: EmailAddress) -> Optional[User]:
        """メールアドレス(値オブジェクト)でユーザーを検索する"""
        print(f"[Adapter] InMemoryRepo: Finding user by email {email.value}")
        for user in self._users.values():
            # 値オブジェクト同士の比較 (EmailAddressインスタンス同士を比較)
            if user.email == email:
                return copy.deepcopy(user)
        return None

    def save(self, user: User):
        """Userを保存する (存在すれば上書き)"""
        print(f"[Adapter] InMemoryRepo: Saving user {user.user_id} with email {user.email.value}")
        self._users[user.user_id] = copy.deepcopy(user)

```

✅ **このステップのポイント**:

- `UserRepositoryInterface` が永続化操作を抽象化しました。
- `InMemoryUserRepository` が具体的な実装を提供し、`UseCase` から詳細を隠蔽しました。
- `find_by_email` メソッドのように、**値オブジェクトを検索条件として**利用できることを示しました。

---

## ⚙️ ステップ4: UseCase の実装 - メールアドレス変更フロー

📝 **課題**: 「ユーザーIDと新しいメールアドレス文字列を受け取り、ユーザーを特定し、メールアドレスが使用中でなければ変更し、保存する」という一連の**ビジネスフロー**が必要です。

💡 **解決策**: このフローの責任を持つ「UseCase」を実装します。UseCase はリポジトリインターフェースに依存し、ドメインオブジェクト（`User`, `EmailAddress`）を利用してロジックを実行します。

**ファイル:** `application/use_cases.py`

```python
# application/use_cases.py
from application.boundaries import UserRepositoryInterface
from domain.value_objects import EmailAddress # UseCaseも値オブジェクトを使う

# -----------------------------------------------------------------------------
# Change User Email Use Case
# - CAの Use Cases 層と同じ役割
# - アプリケーション固有のビジネスフローを担当
# -----------------------------------------------------------------------------
class ChangeUserEmailUseCase:
    """ユーザーのメールアドレスを変更するユースケース"""
    def __init__(self, user_repository: UserRepositoryInterface): # 必要な依存(Repo I/F)を注入
        self._user_repository = user_repository

    def handle(self, user_id: str, new_email_str: str):
        """
        ユースケースを実行する。
        Args:
            user_id: 対象ユーザーのID
            new_email_str: 新しいメールアドレス（文字列）
        Raises:
            ValueError: ユーザーが見つからない、メール形式不正、メール使用中など
        """
        print(f"[UseCase] Attempting to change email for user {user_id} to {new_email_str}")

        # 1. 入力文字列から値オブジェクトを生成
        #    (ここで不正な形式は ValueError となる)
        try:
            print("[UseCase] Creating EmailAddress value object from input string...")
            new_email = EmailAddress(new_email_str)
        except ValueError as e:
            print(f"[UseCase] Invalid email format provided: {e}")
            raise # エラーを呼び出し元に伝える

        # 2. リポジトリを使って集約(User)を取得
        print(f"[UseCase] Finding user {user_id} via repository...")
        user = self._user_repository.find_by_id(user_id)
        if not user:
            print(f"[UseCase] User {user_id} not found.")
            raise ValueError(f"User {user_id} not found.")

        # 3. メールアドレスの重複チェック (アプリケーションレベルのルール)
        #    (※ より複雑な場合は Domain Service に切り出すことも検討)
        print(f"[UseCase] Checking if email {new_email.value} is already in use...")
        existing_user = self._user_repository.find_by_email(new_email)
        if existing_user and existing_user.user_id != user_id:
            print(f"[UseCase] Email {new_email.value} is already used by another user ({existing_user.user_id}).")
            raise ValueError(f"Email {new_email.value} is already in use.")

        # 4. 集約ルート(User)のメソッドを呼び出してビジネスロジック(状態変更)を実行
        print(f"[UseCase] Calling User.change_email method...")
        user.change_email(new_email) # エンティティに変更を依頼

        # 5. リポジトリを使って変更された集約を保存
        print(f"[UseCase] Saving updated user {user_id} via repository...")
        self._user_repository.save(user)

        print(f"[UseCase] User {user_id} email successfully changed.")
        # (必要なら、ここで完了通知などの副作用を行う)

```

✅ **このステップのポイント**:

- UseCase は CA と同じく、**ビジネスフローの調整役**です。
- **値オブジェクト (`EmailAddress`) を早期に生成**することで、以降の処理（重複チェック、エンティティメソッド呼び出し）では常に妥当な形式のメールアドレスを扱えるようになり、コードが安全かつシンプルになります。
- 重複チェックのような、複数の集約（他のユーザー）の状態を参照する必要があるロジックは、UseCase（またはDomain Service）が担当します。

---

## 🚀 ステップ5: 実行ファイル ([main.py](http://main.py/)) の作成 - 全体の組み立て

最後に、これら全てを組み立てて実行する `main.py` を作成します。これも CA の `main.py` と同じ役割です。

**ファイル:** `main.py`

```python
# main.py
from adapters.repositories import InMemoryUserRepository # 👈 具体的なリポジトリ実装
from application.use_cases import ChangeUserEmailUseCase # 👈 UseCase
from domain.aggregates import User                      # 初期データ作成用
from domain.value_objects import EmailAddress             # 初期データ作成用

# -----------------------------------------------------------------------------
# Main Application / Composition Root
# - CAの最も外側の層 (Frameworks & Drivers) と同じ役割
# - 依存関係の解決 (DI) とアプリケーションの起動を行う
# -----------------------------------------------------------------------------
if __name__ == "__main__":
    print("--- User Profile Update Example ---")

    # --- 依存関係の解決 (Dependency Injection) ---
    print("\\n--- Wiring dependencies (DI) ---")
    user_repository = InMemoryUserRepository()
    change_email_use_case = ChangeUserEmailUseCase(user_repository)
    print("--- Dependencies wired successfully ---")

    # --- 初期データ投入 ---
    print("\\n--- Setting up initial data ---")
    try:
        initial_email = EmailAddress("initial@example.com")
        user = User(name="Test User", email=initial_email)
        user_repository.save(user)
        user_id = user.user_id
        print(f"Initial user created - ID: {user_id}, Email: {initial_email.value}")

        # 別のユーザーも作成 (重複チェック用)
        other_email = EmailAddress("other@example.com")
        other_user = User(name="Other User", email=other_email)
        user_repository.save(other_user)
        print(f"Another user created - ID: {other_user.user_id}, Email: {other_email.value}")

    except ValueError as e:
        print(f"Error setting up initial data: {e}")
        exit()

    # --- UseCaseの実行 (成功例) ---
    print("\\n--- Executing UseCase (Success Case) ---")
    try:
        new_email_str = "new.address@example.com"
        change_email_use_case.handle(user_id, new_email_str)
    except ValueError as e:
        print(f"Operation failed: {e}")

    # --- UseCaseの実行 (失敗例: 形式不正) ---
    print("\\n--- Executing UseCase (Invalid Format) ---")
    try:
        change_email_use_case.handle(user_id, "invalid-email-format")
    except ValueError as e:
        print(f"Operation failed as expected: {e}") # -> Invalid email format...

    # --- UseCaseの実行 (失敗例: 重複) ---
    print("\\n--- Executing UseCase (Email Already Used) ---")
    try:
        # 他のユーザーが使っているメールアドレスに変更しようとする
        change_email_use_case.handle(user_id, "other@example.com")
    except ValueError as e:
        print(f"Operation failed as expected: {e}") # -> Email other@example.com is already in use.

    # --- 最終結果の確認 ---
    print("\\n--- Verifying Final State ---")
    final_user = user_repository.find_by_id(user_id)
    if final_user:
        print(f"User {user_id}'s final email: {final_user.email.value}") # -> new.address@example.com

```

✅ **このステップのポイント**:

- `main.py` が具体的な `InMemoryUserRepository` を生成し、`ChangeUserEmailUseCase` に注入しました。
- UseCase を呼び出し、成功例と失敗例（形式不正、重複）を実行して動作を確認しました。

---

## 📝 この演習のまとめ

この演習では、「ユーザープロファイル更新」シナリオを通じて、以下の点を実践しました。

- **値オブジェクト (`EmailAddress`)**: メールアドレスという概念を型として定義し、**自己検証**によって不正なデータがドメインモデルに入るのを防ぎました。
- **エンティティ (`User`)**: ユーザーの同一性を保ちつつ、状態変更（メールアドレス変更）の**振る舞い**をカプセル化しました。値オブジェクトを利用することで、エンティティ内のデータの一貫性も高まりました。
- **リポジトリ (`UserRepository`)**: ユーザーの永続化を抽象化し、UseCase を具体的な保存方法から隔離しました。

値オブジェクトを導入することで、単なる文字列 (`str`) よりもはるかに多くの**ドメインルール**（形式、不変性）をコードに直接埋め込むことができ、システム全体の堅牢性が向上することが確認できたかと思います。

---

## ➡️ 次へ

次は、「**(演習3) 口座間送金**」に進み、複数の集約が関わる操作で「ドメインサービス」がどのように役立つかを見ていきましょう。