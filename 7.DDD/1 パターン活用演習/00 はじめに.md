# 00 はじめに

# 🏛️ DDDパターン活用演習

これまでの6つの巡で、私たちはクリーンアーキテクチャ(CA)とサービス指向アーキテクチャ(SOA)を実践的に学んできました。これらはソフトウェアの「構造」を整え、変更に強くテストしやすいシステムを作るための強力な土台です。

しかし、ソフトウェアの本当の価値は、それが扱う「**ビジネスの問題領域（ドメイン）**」をどれだけうまく表現できているかにあります。この第7巡では、**ドメイン駆動設計（Domain-Driven Design - DDD）**の考え方、特にドメインモデルを豊かに表現するための**具体的な設計パターン（戦術的設計）**に焦点を当て、実践的な演習を行います。

---

## 🎯 この巡のゴール

- ドメイン（ビジネス）の概念をコードに落とし込むための、DDDの基本的な設計パターン（特に **エンティティ** と **値オブジェクト**）を実装できるようになる。
- これらのパターンが、**集約**, **リポジトリ**, **ドメインサービス**, **ドメインイベント** といった他のパターンとどのように連携し、ドメインのルールや一貫性をコードで表現するのかを実践を通じて理解する。
- クリーンアーキテクチャの構造の中で、これらのDDDパターンがどのように位置づけられるかを確認する。

---

## 🧭 なぜ小さなシナリオ？

### 小さなシナリオに焦点を当てる理由

第1〜6巡では、一つのアプリケーションを段階的に構築しました。しかし、DDDの戦術的パターンは、特定のドメイン概念（例：「注文」とは何か、「お金」をどう扱うか）をどうモデル化するかという、より**ミクロな設計技術**です。
そのため、この第7巡では、システム全体を構築するのではなく、**小さな、独立したシナリオ（連携例）**に焦点を当てます。これにより、各パターンの使い方そのものに集中して学習できます。

---

## 🧱 今回登場する主なDDDパターン（予習）

演習に入る前に、今回特に重要となる2つの基本的なパターン、「エンティティ」と「値オブジェクト」について、少し詳しく見ておきましょう。これらはドメインモデルの「モノ」を表現する基本的な方法です。

### 1. エンティティ (Entity)

- **💡 簡単に言うと**: 「名前（ID）で区別され、人生（ライフサイクル）を通じて状態が変化していく『主役級』のモノ」。
- **特徴**:
    - **同一性 (Identity)**: 他の属性（例：名前や住所）が変わっても、IDが変わらなければ同じモノとして識別されます（例：顧客ID、注文ID）。
    - **可変性 (Mutable)**: 時間とともに状態（属性）が変化する可能性があります（例：注文のステータスが変わる）。
    - **ライフサイクル**: 生成され、使われ、場合によっては削除される、という明確なライフサイクルを持ちます。
- **例**: 顧客 (Customer), 注文 (Order), 商品 (Product - 在庫管理の文脈など)

### 2. 値オブジェクト (Value Object)

- **💡 簡単に言うと**: 「それ自体が『何であるか』よりも、『どんな値を持っているか』だけが重要なモノ」。
- **特徴**:
    - **同一性を持たない**: IDで区別しません。属性の値がすべて同じなら、同じモノとみなされます（例：100円玉はどれも同じ「100円」）。
    - **不変性 (Immutable)**: 一度作成したら、その値（属性）は変更しません。値を変えたい場合は、新しいオブジェクトを作成します。これにより、意図しない副作用を防ぎます。
    - **属性で定義**: そのオブジェクトが何であるかは、持つ属性（値）によって完全に決まります。
    - **自己検証**: しばしば、生成時に自身の値が妥当か（例：メールアドレスの形式が正しいか）をチェックするロジックを持ちます。
- **例**: 金額 (Money), 住所 (Address), 色 (Color), 日付範囲 (DateRange), メールアドレス (EmailAddress)

**なぜ使い分ける？** 🤔
すべてのものをエンティティ（ID付き、可変）として扱うと、システムが不必要に複雑になります。「値」として扱えるものは値オブジェクト（IDなし、不変）としてモデル化することで、設計がシンプルになり、コードの安全性も向上します。

---

## 📖 この巡の進め方

以下の**4つのシナリオ**を、それぞれ独立した演習課題として取り組みます。各演習で、上記のエンティティや値オブジェクト、そしてそれらと連携する他のパターン（集約、リポジトリなど）を実装していきます。

1. **演習1：シンプルな注文**: `Aggregate`, `Entity`, `Value Object`, `Factory`, `Repository` の連携
2. **演習2：ユーザープロファイル更新**: `Entity`, `Value Object`, `Repository` の連携と自己検証
3. **演習3：口座間送金**: `Aggregate`, `Value Object`, `Repository`, `Domain Service` の連携
4. **演習4：在庫引き当て**: `Domain Event`, `Aggregate`, `Repository` の連携（イベント駆動）

各演習では、指定されたシナリオに基づき、関連するビルディングブロックを `domain/`, `application/`, `adapters/` のディレクトリ構造に実装し、簡単な `main.py` で動作確認を行います。

---

## ❓ Q&A：CAのエンティティとDDDのエンティティ

**Q: クリーンアーキテクチャ(CA)で学んだ「エンティティ」と、DDDの「エンティティ」は同じものですか？**

**A:** 完全に同じではありませんが、**非常によく似ています**。

- **共通点**: どちらもソフトウェアの中心となる**ビジネスルール**や**ドメイン概念**を表し、**外部の技術的詳細から独立**しているべき、という考え方は共通です。
- **違い（DDDの方がより厳密）**:
    - **DDDのエンティティ**:
        - *同一性（ID）**による区別を強調します。
        - **ライフサイクル**を持つことを意識します。
        - **値オブジェクト**と明確に区別されます。
    - **CAのエンティティ**:
        - アーキテクチャの**最も内側の層**にあるものを指し、「アプリケーション非依存のビジネスルールとデータ構造」という、より**広い意味**で使われることがあります。
        - DDDで言う**値オブジェクト**も、CAの文脈ではEntities層に含まれることがあります。
        - 主眼は「**依存性のルール**」を守ることにあります。

**まとめ**: CAの「Entities」層の多くはDDDの「エンティティ」に該当しますが、DDDはそれをさらに「エンティティ」と「値オブジェクト」に分類し、それぞれの性質（同一性、不変性など）をより厳密に定義することで、ドメインモデルを豊かに表現しようとします。

---

## ➡️ 次へ

それでは、最初の演習「**(演習1) シンプルな注文**」から始めましょう。