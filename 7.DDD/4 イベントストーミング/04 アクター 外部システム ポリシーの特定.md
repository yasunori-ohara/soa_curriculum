# 04 アクター/外部システム/ポリシーの特定

## ステップ４：アクター/外部システム/ポリシーの特定 🧑‍💻🔗💡

Step 3 でコマンド、イベント、集約、Read Modelの関係性を見ました。このステップでは、プロセスに関与する**アクター (Actor)** をより明確にし、連携する可能性のある**外部システム (External System)**、そしてイベントによって自動的に引き起こされる**ルール (ポリシー - Policy)** を特定します。

---

## 🧑‍💻 1. アクター (Actor) の再確認

`{会議室を予約する}` コマンドを実行するのは誰でしょうか？

- **(利用者 / 予約者 / User / Employee)**: これが主要なアクターですね。会議室を使いたい本人です。

将来的な機能を考えると、他のアクターも関わる可能性があります。

- **(管理者 / Admin)**: 会議室の登録・削除、特定の予約の強制キャンセルなどを行うアクター。
- **(システム)**: 例えば、定期的な予約を自動生成する場合など、システム自体がアクターとなることもあります。

今回は、`(利用者)` がコマンドを実行するシンプルなケースに焦点を当てます。

---

## 🔗 2. 外部システム (External System) の特定

会議室予約プロセスは、他のシステムと連携する可能性があるでしょうか？

- **<カレンダーシステム (Calendar System)>**: 予約が確定したら、利用者のカレンダーに予定を自動的に追加するかもしれません。
- **<通知システム (Notification System)>**: 予約完了時や、予約が近づいた時にリマインダーを送信するかもしれません (メール、チャットなど)。
- **<認証システム (Authentication System)>**: 予約を行う利用者が誰であるかを確認するために連携する可能性があります (コマンド実行前)。

今回は、`[会議室が予約された]` イベントの**後**に連携する可能性のある `<<カレンダーシステム>>` と `<<通知システム>>` を意識しておきましょう。

---

## 💡 3. ポリシー (Policy) の特定

**ポリシー**とは、「**もし[イベント]が発生したら、[コマンド]を実行する（または[外部システム]を呼び出す）**」という形式で表現される、システム内の自動的な反応ルールです。イベント駆動アーキテクチャの重要な要素です。

`[会議室が予約された]` イベントが発生した**結果として**、システムが自動的に行うべきことは何でしょうか？

- **ポリシー候補 1**: `もし[会議室が予約された]ら -> {予約者のカレンダーに予定を追加する}` (これは `<<カレンダーシステム>>` との連携につながります)
- **ポリシー候補 2**: `もし[会議室が予約された]ら -> {予約者に確認通知を送る}` (これは `<<通知システム>>` との連携につながります)
- **ポリシー候補 3**: `もし[会議室が予約された]ら -> {会議室の空き状況表示を更新する}` (これは内部的なRead Modelの更新かもしれません)

これらのポリシーは、`[会議室が予約された]` イベントを受け取る**イベントハンドラ**によって実装されることが多いです。

---

### 🗺️ 全体の流れに要素を追加

これまでのステップで見えてきた要素を組み合わせ、プロセス全体の流れを更新します。

```
1. (利用者) が {会議室を予約する} コマンドを RoomID, UserID, TimeRange 付きで開始する。
   * (任意: <<認証システム>> による認証)

2. システムは {{会議室情報}} と {{既存予約情報}} を参照して予約可能かチェックする。

3. チェックが通れば：
   a. システムは <Reservation> 集約を生成する。
   b. システムは <Reservation> をリポジトリ経由で保存する。
   c. <Reservation> が [会議室が予約された] イベントを発行する。

4. ポリシーが [会議室が予約された] イベントに反応する：
   a. ポリシーが {予約者に通知を送る} を実行 -> <<通知システム>>。
   b. ポリシーが {カレンダーに予定追加} を実行 -> <<カレンダーシステム>>。
   c. ポリシーが {空き状況表示更新} を実行 -> {{空き状況Read Model}} を更新。

```

1. `(利用者)` が `{会議室を予約する}` コマンド（必要な情報付き）を実行する (認証が必要な場合あり)。
2. システムは `{{会議室情報}}` や `{{既存予約情報}}` を参照して予約可能かチェックする。
3. 可能であれば、新しい `<Reservation>` 集約を生成し、保存する。
4. その結果として `[会議室が予約された]` イベントが発生する。
5. このイベントをトリガーとして、複数の**ポリシー**（自動ルール）が実行される。
    - 予約者に通知を送る（`<<通知システム>>` と連携）。
    - 予約者のカレンダーに予定を追加する（`<<カレンダーシステム>>` と連携）。
    - （内部的に）空き状況表示用のデータ（Read Model）を更新する。

---

## 📝 まとめ

このステップでは、会議室予約プロセスに関わる**アクター**（利用者）、連携する可能性のある**外部システム**（カレンダー、通知）、そしてドメインイベントによって引き起こされる**ポリシー**（副作用）を特定しました。

イベントストーミングを通じて、単に中心的なフローだけでなく、その前後の認証や、発生後の副作用といった、プロセス全体の繋がりや関係性を明らかにすることができます。

---

## ➡️ 次へ

これで、会議室予約プロセスの基本的なイベントストーミング（簡易版）が一通り完了しました。
最後のステップとして、「**(Step 5) モデルへの反映と考察**」に進み、このイベントストーミングの結果がDDDのモデル（特に集約、ドメインイベント、UseCase）の設計にどのように役立つかを考えてみましょう。