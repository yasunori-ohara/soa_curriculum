# 02 集約の発見と境界設定

# ステップ２：集約の発見と境界設定 🧱

Step 1 で洗い出したユビiquitous 言語（候補）をもとに、このドメインにおける**集約 (Aggregate)** を見つけ出し、その境界を定義します。集約は、データの一貫性を保つための「まとまり」です。

## 🤔 集約とは？（復習）

- 関連するエンティティと値オブジェクトの**まとまり**。
- データ変更における**一貫性**の単位。
- 外部からのアクセスは**集約ルート (Aggregate Root)** を通じてのみ行う。

**ポイント**: 「一緒に変更されるべきもの」「常に整合性が取れていないといけないもの」をグループ化し、そのグループの代表者（ルート）を決めます。

---

## 💬 候補の検討

Step 1 で挙げた主な名詞候補を見てみましょう。

- **記事 (Article)**
- **著者 / ユーザー (Author / User)**
- **コメント (Comment)**
- **公開状態 (PublishStatus)**
- **タイトル (Title)**
- **本文 (Body)**

これらのうち、IDを持ち、ライフサイクルを持つ**エンティティ**として、集約ルートになりそうなものはどれでしょうか？

1. **記事 (Article)**:
    - `ArticleID` で識別される。
    - 属性（タイトル、本文、著者、状態など）を持つ。
    - 状態（下書き→公開済み、更新）が変化する。
    - ➡️ **集約ルート**の有力候補です。システムの中核ですね。
2. **コメント (Comment)**:
    - `CommentID` で識別される。
    - 属性（本文、投稿者名、投稿日時など）を持つ。
    - 状態（投稿済み、(将来的に)承認済み/削除済みなど）が変化する。
    - ➡️ **集約ルート**の候補です。記事とは独立したライフサイクルを持つ可能性があります。
3. **著者 / ユーザー (Author / User)**:
    - `UserID` で識別される。
    - ブログシステムにおいては、記事の作成者として参照されますが、ユーザー情報の管理（登録、パスワード変更など）はこのシステムの主目的ではない可能性が高いです。
    - ➡️ **別のコンテキスト**（ユーザー管理コンテキスト）の集約ルートと考えられます。このブログコンテキストでは、主に **ID (`UserID`)** で参照するだけでよさそうです。
4. **公開状態 (PublishStatus)**, **タイトル (Title)**, **本文 (Body)**:
    - これらは通常、IDで識別される独立したモノではなく、「記事」や「コメント」の**属性**や**状態**を表します。
    - ➡️ **値オブジェクト**またはエンティティの属性の候補です。

---

## 💬 集約の境界：「記事」と「コメント」の関係は？

ここで重要な設計判断があります。「コメント」は「記事」の一部として、`Article` 集約に含めるべきでしょうか？

- **含める場合 (案1)**:
    - `Article` 集約ルートが `List<Comment>` を持つ。
    - メリット: 記事とそのコメントを一体として扱える。
    - デメリット:
        - コメントが非常に多い記事（例：1000件）の場合、記事を読み込む/保存するたびに全コメントも処理する必要があり、パフォーマンスが悪化する。
        - コメントの追加・削除・編集といった操作が、`Article` 集約ルートを経由する必要があり、不自然になる（コメント自身のライフサイクル管理がしにくい）。
        - コメントの承認プロセスなどを追加する場合、`Article` 集約の責務が肥大化する。
- **含めない場合 (案2 - 推奨)**:
    - `Article` と `Comment` を**別々の集約**として定義する。
    - `Comment` 集約は、どの記事に属するかを示すために `ArticleID` を**参照**として持つ。
    - メリット:
        - 各集約が小さく、責務が明確になる。
        - 記事の読み込み/保存と、コメントの読み込み/保存を独立して行える（パフォーマンス向上）。
        - コメントのライフサイクル（投稿、承認、削除など）を `Comment` 集約内で完結できる。
    - デメリット: 記事に紐づくコメント一覧を取得する場合、`CommentRepository` に `findByArticleId` のようなメソッドが必要になる（これは一般的なクエリ操作であり問題ない）。

今回は、将来的な拡張性やパフォーマンスを考慮し、**案2（`Article` と `Comment` を別々の集約とする）** を採用するのが良いでしょう。

---

## 💬 集約の決定（案）

以上の検討から、このブログシステム（コア機能）では、主要な集約として以下の2つを定義します。

1. **`Article` 集約**:
    - **ルート**: `Article` (Entity)
    - **内部**: `Title` (VO?), `Body` (VO?), `AuthorID` (参照ID), `PublishStatus` (VO/Enum), `PublishedAt` (VO?) など。
    - **責務**: 記事の内容、公開状態、メタデータ（著者、日時など）の一貫性を管理する。
2. **`Comment` 集約**:
    - **ルート**: `Comment` (Entity)
    - **内部**: `ArticleID` (参照ID), `CommenterName` (VO?), `Body` (VO?), `PostedAt` (VO?) など。
    - **責務**: コメントの内容とメタデータ（投稿者、日時など）の一貫性を管理する。（将来的には承認状態なども）

```
+---------------------------+       +----------------------------+
|     Article Aggregate     |       |     Comment Aggregate      |
| +-----------------------+ |       | +------------------------+ |
| | Article (Root Entity) | |       | | Comment (Root Entity)  | |
| | - articleId           | |       | | - commentId            | |
| | - title (VO?)         | |       | | - articleId (Ref)      | |<-+
| | - body (VO?)          | |       | | - commenterName (VO?)  | |  | (Belongs to)
| | - authorId (Ref)      | |       | | - body (VO?)           | |  |
| | - status (VO/Enum)    | |       | | - postedAt (VO?)       | |  |
| | - publishedAt (VO?)   | |       | +------------------------+ |  |
| |                       | |       +----------------------------+  |
| | + publish()           | |                                       |
| | + changeBody()        | |                                       |
| +-----------------------+ |---------------------------------------+
+---------------------------+

```

---

### 境界と不変条件

- **`Article` 集約**:
    - タイトルや本文の文字数制限（もしあれば）。
    - `status` が `PUBLISHED` の場合のみ `publishedAt` が設定される。
    - 一度公開したら著者は変更できない、など。
- **`Comment` 集約**:
    - 本文の文字数制限（もしあれば）。
    - `articleId` は必須。

---

## 📝 まとめ

このステップでは、ユビiquitous 言語から主要な概念を抽出し、**一貫性を保つべきまとまり**と、それぞれの**ライフサイクル**を考慮して、**`Article`** と **`Comment`** という2つの集約を特定しました。

記事とコメントを別の集約にすることで、それぞれの責務が明確になり、パフォーマンスや拡張性の面でも有利になる可能性が高いという設計判断を行いました。

---

## ➡️ 次へ

次は、これらの集約の内部で使われる「**(Step 3) 値オブジェクトとエンティティの洗練**」に進み、`Title`, `Body`, `PublishStatus` などを具体的に設計していきましょう。