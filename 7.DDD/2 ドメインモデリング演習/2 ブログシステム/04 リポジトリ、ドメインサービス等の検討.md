# 04 リポジトリ、ドメインサービス等の検討

# ステップ４：リポジトリ、ドメインサービス等の検討 💾⚙️

Step 3 で集約 (`Article`, `Comment`) と値オブジェクトを洗練させました。このステップでは、これらのドメインモデルを**永続化**するための**リポジトリ (Repository)** を定義し、また、特定の集約に属さないドメインロジックを担う**ドメインサービス (Domain Service)** の必要性を検討します。

---

## 💾 1. リポジトリ (Repository) の定義と実装 - 永続化の抽象化

📝 **課題**: 作成・変更した `Article` や `Comment` 集約を、永続化ストレージ（データベースなど）に保存したり、後で検索したりする必要があります。しかし、ドメインモデルや UseCase が、具体的な保存方法を知るべきではありません。

💡 **解決策**: 各集約ルート (`Article`, `Comment`) に対して**リポジトリ (`Repository`)** パターンを適用します。永続化操作の**インターフェース**を定義し、具体的な実装を **Adapters 層**に隠蔽します。

**ファイル:** `application/boundaries.py` (追記)

```python
# application/boundaries.py
from abc import ABC, abstractmethod
from domain.aggregates import Article, Comment # 👈 永続化対象の集約
from typing import Optional, List # Listを追加

# (他のインターフェース定義 ... )

# -----------------------------------------------------------------------------
# Article Repository Interface
# - DDD戦術的設計の Repository Interface
# - CAの Application 層 (境界定義)
# -----------------------------------------------------------------------------
class ArticleRepositoryInterface(ABC):
    """Article集約の永続化を抽象化するインターフェース"""
    @abstractmethod
    def find_by_id(self, article_id: str) -> Optional[Article]:
        """IDでArticle集約を検索する"""
        raise NotImplementedError

    @abstractmethod
    def save(self, article: Article):
        """Article集約を保存する"""
        raise NotImplementedError

    @abstractmethod
    def find_published_articles(self) -> List[Article]:
        """公開済みの記事一覧を取得する (例)"""
        raise NotImplementedError

# -----------------------------------------------------------------------------
# Comment Repository Interface
# - DDD戦術的設計の Repository Interface
# - CAの Application 層 (境界定義)
# -----------------------------------------------------------------------------
class CommentRepositoryInterface(ABC):
    """Comment集約の永続化を抽象化するインターフェース"""
    @abstractmethod
    def find_by_id(self, comment_id: str) -> Optional[Comment]:
        """IDでComment集約を検索する"""
        raise NotImplementedError

    @abstractmethod
    def save(self, comment: Comment):
        """Comment集約を保存する"""
        raise NotImplementedError

    @abstractmethod
    def find_by_article_id(self, article_id: str) -> List[Comment]:
        """特定の記事に紐づくコメント一覧を取得する"""
        raise NotImplementedError

```

**ファイル:** `adapters/repositories.py` (追記)

```python
# adapters/repositories.py
from application.boundaries import ArticleRepositoryInterface, CommentRepositoryInterface # 👈 インポート
from domain.aggregates import Article, Comment
from domain.value_objects import PublishStatus # Article検索用
from typing import Optional, List, Dict # Dictを追加
import copy

# (他のリポジトリ実装 ...)

# -----------------------------------------------------------------------------
# In-Memory Article Repository Implementation
# - DDD戦術的設計の Repository Implementation
# - CAの Adapters 層
# -----------------------------------------------------------------------------
class InMemoryArticleRepository(ArticleRepositoryInterface):
    """Article集約をメモリ上の辞書で保持するリポジトリ実装"""
    def __init__(self):
        self._articles: Dict[str, Article] = {} # article_id をキー

    def find_by_id(self, article_id: str) -> Optional[Article]:
        print(f"[Adapter] InMemoryRepo: Finding article {article_id}")
        article = self._articles.get(article_id)
        return copy.deepcopy(article) if article else None

    def save(self, article: Article):
        print(f"[Adapter] InMemoryRepo: Saving article {article.article_id} ('{article.title.value}')")
        self._articles[article.article_id] = copy.deepcopy(article)

    def find_published_articles(self) -> List[Article]:
        print("[Adapter] InMemoryRepo: Finding all published articles")
        published = [
            copy.deepcopy(article) for article in self._articles.values()
            if article.status == PublishStatus.PUBLISHED
        ]
        # (通常は公開日時でソートするなどする)
        return published

# -----------------------------------------------------------------------------
# In-Memory Comment Repository Implementation
# - DDD戦術的設計の Repository Implementation
# - CAの Adapters 層
# -----------------------------------------------------------------------------
class InMemoryCommentRepository(CommentRepositoryInterface):
    """Comment集約をメモリ上の辞書で保持するリポジトリ実装"""
    def __init__(self):
        self._comments: Dict[str, Comment] = {} # comment_id をキー

    def find_by_id(self, comment_id: str) -> Optional[Comment]:
        print(f"[Adapter] InMemoryRepo: Finding comment {comment_id}")
        comment = self._comments.get(comment_id)
        return copy.deepcopy(comment) if comment else None

    def save(self, comment: Comment):
        print(f"[Adapter] InMemoryRepo: Saving comment {comment.comment_id} for article {comment.article_id}")
        self._comments[comment.comment_id] = copy.deepcopy(comment)

    def find_by_article_id(self, article_id: str) -> List[Comment]:
        """特定記事のコメントを検索"""
        print(f"[Adapter] InMemoryRepo: Finding comments for article {article_id}")
        article_comments = [
            copy.deepcopy(comment) for comment in self._comments.values()
            if comment.article_id == article_id
        ]
        # (通常は投稿日時でソートするなどする)
        return article_comments

```

✅ **このステップのポイント**:

- 各集約ルート (`Article`, `Comment`) に対して、**リポジトリインターフェース**を定義しました。
- 具体的な実装（今回はインメモリ）を **Adapters 層**に隠蔽しました。
- UseCase が必要とするであろう検索メソッド（`find_published_articles`, `find_by_article_id`）をインターフェースに追加しました。

---

## ⚙️ 2. ドメインサービス (Domain Service) の必要性検討

📝 **課題**: このブログシステムにおいて、特定のエンティティや値オブジェクトに自然に属さない、ドメイン固有の重要な操作はあるでしょうか？

💡 **検討**:
現在のシンプルなシナリオ（記事作成・公開・閲覧、コメント投稿）の範囲では、必須となるドメインサービスは**見当たりません**。

- **記事の公開**: `Article` 集約の `publish()` メソッドで完結します。
- **コメントの投稿**: 新しい `Comment` 集約を作成し、リポジトリに保存するだけで済みそうです（これは UseCase の責務）。
- **記事とコメントの関連付け**: `Comment` が `articleId` を持つことで実現されており、特別なサービスは不要です。

**将来的な可能性**:
もし、以下のような複雑な機能が追加された場合、ドメインサービスの導入を検討するかもしれません。

- **スパムコメントの判定**: コメントの内容や投稿者情報など、複数の要素を分析してスパムかどうかを判定する複雑なロジックは、`SpamDetectionService` として切り出すかもしれません。
- **関連記事の推薦**: 記事の内容やタグ、ユーザーの閲覧履歴などに基づいて関連記事を推薦するアルゴリズムは、`RecommendationService` としてドメイン層に置くのが適切かもしれません。

**今回の判断**:
現時点では、ドメインサービスは**不要**と判断します。ロジックは主に集約（`Article`, `Comment`）と UseCase でカバーできると考えられます。

✅ **このステップのポイント**:

- ドメインサービスは、必要になった場合に導入するものであり、**最初から無理に作る必要はありません**。
- ロジックが特定の集約の責務として自然に表現できる場合は、エンティティのメソッドとして実装するのが基本です。

---

## 📝 まとめ

このステップでは、ドメインモデル（集約）を永続化するための**リポジトリインターフェース**とその**インメモリ実装**を定義しました。これにより、UseCase は具体的な永続化方法を知ることなく、集約を保存・取得できるようになります。

また、**ドメインサービス**の必要性を検討し、現在のシンプルなスコープでは不要であると判断しました。

---

## ➡️ 次へ

これでドメインモデルと永続化の準備が整いました。最後のステップ「**(Step 5) モデルの一部をコード化 (UseCaseとMain)**」に進み、これらの部品を組み合わせて「記事を公開する」「コメントを投稿する」といった UseCase を実装してみましょう。