# 03 値オブジェクトとエンティティの洗練

# ステップ３：値オブジェクトとエンティティの洗練 ✨

Step 2 で主要な集約 (`VehicleControl`) と、各コンテキストの役割を再定義しました。このステップでは、**車両制御コンテキスト**に焦点を当て、その内部で使われる**値オブジェクト (Value Object)** を具体的に設計し、`VehicleControl` エンティティ（集約ルート）の定義をより洗練させていきます。

## 🤔 値オブジェクトとは？（復習）

- *属性（値）*だけで定義される（IDを持たない）。
- 通常は**不変 (Immutable)**。
- **自己検証**ロジックを持つことができる。

---

## 💎 1. 値オブジェクト (Value Object) の設計 (制御コンテキスト)

Step 1 で洗い出した候補の中から、車両制御コンテキストで重要となる値オブジェクトを具体化します。

### a) `VehicleState` (車両状態)

📝 **課題**: 車両の物理状態（速度、舵角など）は、制御の入力となる重要な情報ですが、それぞれの値には物理的な制約（例：速度はマイナスもありうるが、極端な値は取らない、舵角には限界がある）があります。これらを単純な `float` で扱うと、不正な値が紛れ込む可能性があります。

💡 **解決策**: `VehicleState` を**値オブジェクト**として定義します。内部の各属性（速度、舵角など）も、可能であれば専用の値オブジェクト（例：`Speed`, `SteeringAngle`）として定義し、不変性と検証ルールを適用します。

**ファイル:** `control_context/domain/value_objects.py` (新規作成または追記)

```python
# control_context/domain/value_objects.py
from dataclasses import dataclass, field
from datetime import datetime
import math # 角度正規化用

# -----------------------------------------------------------------------------
# Speed Value Object
# - DDD戦術的設計の Value Object
# - CAの Entities 層
# -----------------------------------------------------------------------------
@dataclass(frozen=True)
class Speed:
    """速度を表す値オブジェクト [m/s]"""
    meters_per_second: float

    # (例: 極端な値でないかの検証を __post_init__ に追加可能)

# -----------------------------------------------------------------------------
# SteeringAngle Value Object
# - DDD戦術的設計の Value Object
# - CAの Entities 層
# -----------------------------------------------------------------------------
@dataclass(frozen=True)
class SteeringAngle:
    """ステアリング角度を表す値オブジェクト [degrees]"""
    degrees: float
    MAX_ANGLE = 540.0 # 仮の最大舵角

    def __post_init__(self):
        # 角度を -MAX_ANGLE ～ +MAX_ANGLE の範囲に正規化する例
        # (実際には単純なクリップやエラーの方が適切かもしれない)
        # normalized_degrees = max(-self.MAX_ANGLE, min(self.MAX_ANGLE, self.degrees))
        # # Use object.__setattr__ because the dataclass is frozen
        # object.__setattr__(self, 'degrees', normalized_degrees)
        if abs(self.degrees) > self.MAX_ANGLE:
            raise ValueError(f"Steering angle {self.degrees} exceeds limit (+/- {self.MAX_ANGLE})")
        print(f"[VO Check] SteeringAngle {self.degrees} deg is valid.")

# -----------------------------------------------------------------------------
# VehicleState Value Object
# - DDD戦術的設計の Value Object
# - CAの Entities 層 (VehicleControl集約の内部状態の一部)
# -----------------------------------------------------------------------------
@dataclass(frozen=True)
class VehicleState:
    """特定の瞬間の車両状態を表す値オブジェクト"""
    timestamp: datetime
    speed: Speed             # 👈 Speed 値オブジェクトを使用
    steering_angle: SteeringAngle # 👈 SteeringAngle 値オブジェクトを使用
    # yaw_rate: YawRate # ヨーレートもVO化可能
    # position: Position # 位置情報もVO化可能

```

### b) `ActuatorCommand` (アクチュエータ指示)

📝 **課題**: ステアリングやスロットル/ブレーキへの指示も、物理的な制約（最大トルク、最大加速度など）を持つ値です。

💡 **解決策**: `SteeringCommand` や `ThrottleBrakeCommand` といった、各アクチュエータへの指示を**値オブジェクト**として定義します。生成時に妥当な範囲内にあるかを検証します。

**ファイル:** `control_context/domain/value_objects.py` (追記)

```python
# control_context/domain/value_objects.py
# (Speed, SteeringAngle, VehicleState definitions...)

# -----------------------------------------------------------------------------
# SteeringCommand Value Object (Output)
# - DDD戦術的設計の Value Object
# - CAの Entities 層 (UseCaseが出力するデータ型の一部)
# -----------------------------------------------------------------------------
@dataclass(frozen=True)
class SteeringCommand:
    """ステアリングへの指示を表す値オブジェクト"""
    target_angle: SteeringAngle # 👈 目標角度をVOで指定
    # または target_torque: Torque # トルクで指示する場合

    # (必要であれば、指示のタイプや優先度なども含める)

    @staticmethod
    def neutral() -> 'SteeringCommand':
        return SteeringCommand(target_angle=SteeringAngle(0.0))

# -----------------------------------------------------------------------------
# ThrottleBrakeCommand Value Object (Output)
# - DDD戦術的設計の Value Object
# - CAの Entities 層 (UseCaseが出力するデータ型の一部)
# -----------------------------------------------------------------------------
@dataclass(frozen=True)
class ThrottleBrakeCommand:
    """スロットル/ブレーキへの指示を表す値オブジェクト"""
    # 例: 加速度 [m/s^2] で指示 (-はブレーキ)
    acceleration_mps2: float
    MAX_ACCEL = 2.0  # 仮の最大加速度
    MAX_BRAKE = -5.0 # 仮の最大ブレーキ加速度

    def __post_init__(self):
        if not (self.MAX_BRAKE <= self.acceleration_mps2 <= self.MAX_ACCEL):
            raise ValueError(f"Acceleration {self.acceleration_mps2} out of range [{self.MAX_BRAKE}, {self.MAX_ACCEL}]")
        print(f"[VO Check] ThrottleBrakeCommand {self.acceleration_mps2} m/s^2 is valid.")

    @staticmethod
    def neutral() -> 'ThrottleBrakeCommand':
        return ThrottleBrakeCommand(acceleration_mps2=0.0)

# (参考: 第4/5巡の ControlCommand は ParkingPlan の一部であり、
#  この ActuatorCommand とは少し役割が異なる。
#  ParkingPlan.ControlCommand -> 指示内容 (What)
#  ActuatorCommand -> HWへの具体的な指示 (How) )

```

### c) `ParkingPlan` と `ControlCommand` (入力契約)

📝 **課題**: 制御コンテキストは、経路計算コンテキストから `ParkingPlan` を受け取ります。このデータ構造も明確に定義する必要があります。

💡 **解決策**: `ParkingPlan` とその中の `ControlCommand` を、制御コンテキスト側でも（受け取る側の**契約**として）値オブジェクトとして定義します。これらは経路計算コンテキストが出力するものと同じ構造である必要があります（本来は共有ライブラリや Protobuf などで定義を共有）。

**ファイル:** `control_context/domain/value_objects.py` (追記 - 経路計算コンテキストの定義を流用)

```python
# control_context/domain/value_objects.py
# (Other definitions...)
from typing import List # Listを追加

# --- 経路計算コンテキストとの「契約」として定義されるValue Object ---
# (※本来は共通ライブラリやスキーマで定義・共有される)

# -----------------------------------------------------------------------------
# ControlCommand from Plan (Input Contract)
# - DDD戦術的設計の Value Object
# - CAの Entities 層 (UseCaseへの入力データ型の一部)
# -----------------------------------------------------------------------------
@dataclass(frozen=True)
class ControlCommand:
    """経路計算サービスから受け取る個別の制御命令"""
    action: str  # (例: 'steer', 'throttle')
    value: float # (例: 30.0 [度], -0.5 [m/s^2]) - 単位に注意
    duration: float # (例: 1.5 [秒])

# -----------------------------------------------------------------------------
# ParkingPlan Value Object (Input Contract)
# - DDD戦術的設計の Value Object (or DTO)
# - CAの Entities 層 (UseCaseへの入力データ型)
# -----------------------------------------------------------------------------
@dataclass(frozen=True)
class ParkingPlan:
    """経路計算サービスから受け取る「駐車計画」"""
    timestamp: datetime
    commands: List[ControlCommand] = field(default_factory=list)

```

✅ **このステップのポイント**:

- 車両制御に関わる重要な概念（`VehicleState`, `SteeringAngle`, `Speed`, `SteeringCommand`, `ThrottleBrakeCommand`）を**値オブジェクト**として定義し、型安全性、不変性、自己検証の利点を導入しました。
- 入力となる `ParkingPlan` と `ControlCommand` も値オブジェクトとして定義し、入力データの契約を明確にしました。

---

## 🧱 2. エンティティ (`VehicleControl`) の洗練

作成した値オブジェクトを使って、`VehicleControl` 集約（エンティティ）の定義を更新します。内部状態として `VehicleState` を持ち、`ParkingPlan` を解釈して `ActuatorCommand` を生成するメソッドを定義します。

**ファイル:** `control_context/domain/aggregates.py` (修正・追記)

```python
# control_context/domain/aggregates.py
from dataclasses import dataclass, field
# 👈 作成した値オブジェクトをインポート
from .value_objects import (
    VehicleState, Speed, SteeringAngle,
    ParkingPlan, ControlCommand,
    SteeringCommand, ThrottleBrakeCommand
)
from datetime import datetime
from typing import Optional, Tuple, List # Tuple, List を追加
import uuid
# from .events import DomainEvent # ドメインイベント用

# -----------------------------------------------------------------------------
# VehicleControl Aggregate Root / Entity
# - DDD戦術的設計の Aggregate Root / Entity
# - CAの Entities 層
# -----------------------------------------------------------------------------
@dataclass
class VehicleControl:
    """
    車両の制御状態と振る舞いを管理する集約ルート・エンティティ。
    - vehicleId で識別される。
    - 現在の車両状態(current_state)を保持・更新する。
    - 駐車計画(ParkingPlan)を解釈し、アクチュエータ指示を生成する。
    - 制御に関する不変条件（速度制限、舵角制限など）を維持する。
    """
    vehicle_id: str
    current_state: VehicleState # 👈 最新の車両状態をVOで保持
    # target_plan: Optional[ParkingPlan] = None # 実行中の計画を保持する場合
    # current_command_index: int = 0          # 計画のどこまで実行したか

    # _domain_events: List[DomainEvent] = field(default_factory=list, init=False, repr=False)

    @staticmethod
    def initialize(vehicle_id: str) -> 'VehicleControl':
         """初期状態の VehicleControl を生成するファクトリメソッド (例)"""
         print(f"[Factory] Initializing VehicleControl for {vehicle_id}")
         # 停止状態から開始
         initial_state = VehicleState(
             timestamp=datetime.now(),
             speed=Speed(0.0),
             steering_angle=SteeringAngle(0.0)
         )
         return VehicleControl(vehicle_id=vehicle_id, current_state=initial_state)

    def update_current_state(self, new_state: VehicleState):
        """センサー等からの最新の車両状態で内部状態を更新"""
        # (タイムスタンプの比較など、状態更新の妥当性チェックを行う)
        if new_state.timestamp <= self.current_state.timestamp:
            print("[Aggregate Logic] Ignoring older or same timestamp state update.")
            return
        print(f"[Aggregate Logic] Updating current vehicle state for {self.vehicle_id} at {new_state.timestamp.isoformat()}")
        self.current_state = new_state
        # (StateUpdated イベントを発行しても良い)

    def calculate_actuator_commands(self, plan_command: ControlCommand) -> Tuple[SteeringCommand, ThrottleBrakeCommand]:
        """
        [集約の振る舞い]
        受け取った計画コマンド(ControlCommand)と現在の車両状態(current_state)
        に基づいて、具体的なアクチュエータ指示(ActuatorCommand)を計算する。
        (このロジックが制御ドメインの核心)
        """
        print(f"[Aggregate Logic] Calculating actuator commands based on plan: {plan_command.action}={plan_command.value}")

        # --- ここに制御ロジックを実装 ---
        # (例: PID制御、モデル予測制御など)
        # 今回は非常にシンプルな変換ロジック (ダミー)

        steer_cmd = SteeringCommand.neutral()
        throttle_brake_cmd = ThrottleBrakeCommand.neutral()

        if plan_command.action == 'steer':
            try:
                # 計画の指示値(度)を目標舵角VOに変換 (ここで範囲チェックも行われる)
                target_angle = SteeringAngle(plan_command.value)
                steer_cmd = SteeringCommand(target_angle=target_angle)
                print(f"[Aggregate Logic] Steering command calculated: target={target_angle.degrees} deg")
            except ValueError as e:
                print(f"[Aggregate Logic] Invalid steering value from plan: {e}. Keeping neutral.")
                # (エラー処理 or Fault状態への遷移)

        elif plan_command.action == 'throttle':
            try:
                # 計画の指示値(m/s^2 ?)を目標加速度VOに変換 (範囲チェック含む)
                target_accel = plan_command.value # 仮に単位がm/s^2とする
                throttle_brake_cmd = ThrottleBrakeCommand(acceleration_mps2=target_accel)
                print(f"[Aggregate Logic] Throttle/Brake command calculated: target={target_accel} m/s^2")
            except ValueError as e:
                print(f"[Aggregate Logic] Invalid throttle/brake value from plan: {e}. Keeping neutral.")
                # (エラー処理 or Fault状態への遷移)

        # (発展: 現在の速度や舵角に基づいて、目標値への追従制御を行うロジックを追加)
        # (発展: 安全ルール(最大速度超過など)に基づく介入ロジックもここに追加)

        return steer_cmd, throttle_brake_cmd

    # --- ドメインイベント関連メソッド (参考) ---
    # def get_uncommitted_events(self) -> List[DomainEvent]: ...
    # def clear_uncommitted_events(self): ...

```

✅ **このステップのポイント**:

- `VehicleControl` 集約が、**値オブジェクト** (`VehicleState`, `SteeringAngle` など) を使って自身の状態を管理し、入出力データを扱うようになりました。
- 主要な振る舞いとして `update_current_state`（状態更新）と `calculate_actuator_commands`（制御指示計算）を定義しました。
- `calculate_actuator_commands` 内で、入力 (`ControlCommand`) と出力 (`SteeringCommand`, `ThrottleBrakeCommand`) にも値オブジェクトを利用し、生成時の検証ルール（範囲チェックなど）を活用しています。これにより、集約が不正な指示値を生成するのを防ぎます。

---

## 📝 まとめ

このステップでは、車両制御コンテキストにおける重要な概念を**値オブジェクト**として具体的に設計し、それらを使って中心となる\*\*`VehicleControl` 集約（エンティティ）\*\*の定義を洗練させました。

値オブジェクトを積極的に導入することで、

- コードの**表現力**（物理単位など）と**型安全性**が向上し、
- **不変性**と**自己検証**によって不正な状態や指示を防ぎ、
- 集約が自身の主要な責務（状態管理と制御ロジックの実行）に集中できるようになりました。

---

## ➡️ 次へ

次は、このドメインモデル（集約）を永続化するための「**(Step 4) リポジトリ、ドメインサービス等の検討**」に進みます。制御ロジックの一部をドメインサービスに切り出すことも再度検討します。