# 05 モデルの一部をコード化

# ステップ５：モデルの一部をコード化 (UseCaseとMain) ⚙️🚀

これまでのステップで定義・実装したドメインモデル（`VehicleControl`集約、値オブジェクト、`ControlCalculationService`ドメインサービス）とリポジトリを使って、いよいよシステムのコアとなる**UseCase**を実装し、それを[**main.py**](http://main.py/)から呼び出して、計画実行のシミュレーションを行ってみましょう。

---

## ⚙️ 1. 境界インターフェース (Boundary) の追加 - アクチュエータ

📝 **課題**: `VehicleControl` 集約（またはそれを呼び出す UseCase）は、計算された `ActuatorCommand`（ステアリング指示、スロットル指示）を実際のハードウェア（アクチュエータ）に送信する必要があります。しかし、UseCase やドメインモデルが具体的なハードウェア制御方法（CAN通信など）を知るべきではありません。

💡 **解決策**: ハードウェアへの出力を抽象化する**インターフェース (`ActuatorInterface`)** を `application/boundaries.py` に定義します。

**ファイル:** `control_context/application/boundaries.py` (追記)

```python
# control_context/application/boundaries.py
from abc import ABC, abstractmethod
# (Repository interfaces...)
from control_context.domain.aggregates import VehicleControl
from typing import Optional
# 👈 制御指示のValue Objectをインポート
from control_context.domain.value_objects import SteeringCommand, ThrottleBrakeCommand

# (VehicleControlRepositoryInterface definition...)

# -----------------------------------------------------------------------------
# Actuator Interface (Output Boundary)
# - DDD戦術的設計の Interface (Port)
# - CAの Application 層 (境界定義)
# -----------------------------------------------------------------------------
class ActuatorInterface(ABC):
    """車両アクチュエータ(ステアリング、スロットル/ブレーキ)への指示を抽象化するインターフェース"""
    @abstractmethod
    async def send_steering_command(self, command: SteeringCommand):
        """ステアリングへの指示を送信する (非同期)"""
        raise NotImplementedError

    @abstractmethod
    async def send_throttle_brake_command(self, command: ThrottleBrakeCommand):
        """スロットル/ブレーキへの指示を送信する (非同期)"""
        raise NotImplementedError

# (UseCase Input Boundary definition...)
class ExecuteParkingStepInputBoundary(ABC): # UseCase I/F名も具体的に
    @abstractmethod
    async def handle(self, vehicle_id: str, current_vehicle_state: 'VehicleState', plan_command: 'ControlCommand'):
        raise NotImplementedError # 戻り値はvoid (コマンドなので)

```

---

## ⚙️ 2. アダプタ (Adapter) の実装 - スタブアクチュエータ

📝 **課題**: `ActuatorInterface` の具体的な実装が必要です。実際のハードウェア制御は複雑ですが、シミュレーションやテストのためには簡単な代替物（スタブ）が必要です。

💡 **解決策**: `ActuatorInterface` を実装する `StubActuatorAdapter` を `adapters` フォルダに作成します。これは受け取ったコマンドをコンソールに出力するだけの簡単な実装です。

**ファイル:** `control_context/adapters/stub_actuator.py` (新規作成または追記)

```python
# control_context/adapters/stub_actuator.py
from control_context.application.boundaries import ActuatorInterface
from control_context.domain.value_objects import SteeringCommand, ThrottleBrakeCommand
import asyncio

# -----------------------------------------------------------------------------
# Stub Actuator Adapter Implementation
# - DDD戦術的設計の Adapter Implementation
# - CAの Adapters 層
# -----------------------------------------------------------------------------
class StubActuatorAdapter(ActuatorInterface):
    """
    アクチュエータハードウェアのダミー（スタブ）。
    受け取ったコマンドをコンソールに出力する。
    """
    async def send_steering_command(self, command: SteeringCommand):
        """ステアリング指示をコンソールに出力 (シミュレーション)"""
        print(f"[Adapter] StubActuator: -> STEER Target Angle = {command.target_angle.degrees:.1f} deg")
        await asyncio.sleep(0.01) # わずかなI/O時間をシミュレート

    async def send_throttle_brake_command(self, command: ThrottleBrakeCommand):
        """スロットル/ブレーキ指示をコンソールに出力 (シミュレーション)"""
        print(f"[Adapter] StubActuator: -> THROTTLE/BRAKE Target Accel = {command.acceleration_mps2:.2f} m/s^2")
        await asyncio.sleep(0.01) # わずかなI/O時間をシミュレート

```

---

## ⚙️ 3. UseCase の実装 - 計画実行ステップフロー

📝 **課題**: 「現在の車両状態と、駐車計画の次のステップ（`ControlCommand`）を受け取り、`VehicleControl` 集約を使って適切なアクチュエータ指示を計算し、アクチュエータインターフェース経由で指示を送信し、車両状態を更新して保存する」という**アプリケーション固有のフロー**が必要です。

💡 **解決策**: このフローの責任を持つ「UseCase」を実装します。リポジトリ、ドメインサービス（集約経由で利用）、アクチュエータインターフェースに依存します。

**ファイル:** `control_context/application/use_cases.py` (新規作成または追記)

```python
# control_context/application/use_cases.py
from control_context.application.boundaries import ( # 👈 必要な境界をインポート
    VehicleControlRepositoryInterface,
    ActuatorInterface,
    ExecuteParkingStepInputBoundary # UseCase自身のI/F
)
from control_context.domain.aggregates import VehicleControl
from control_context.domain.value_objects import VehicleState, ControlCommand # 入力VO
from control_context.domain.services import ControlCalculationService # 👈 ドメインサービス
from typing import Tuple, Optional

# -----------------------------------------------------------------------------
# Execute Parking Step Use Case
# - CAの Use Cases 層と同じ役割
# - 駐車計画の1ステップを実行するフローを担当
# -----------------------------------------------------------------------------
class ExecuteParkingStepUseCase(ExecuteParkingStepInputBoundary):
    """駐車計画の1ステップを実行するユースケース"""
    def __init__(self,
                 vehicle_control_repo: VehicleControlRepositoryInterface, # 永続化の窓口
                 control_calculator: ControlCalculationService,        # 計算ロジック (DI)
                 actuator_interface: ActuatorInterface):               # 出力の窓口 (DI)
        self._vehicle_control_repo = vehicle_control_repo
        self._control_calculator = control_calculator # ドメインサービスを保持
        self._actuator_interface = actuator_interface

    async def handle(self, vehicle_id: str, current_vehicle_state: VehicleState, plan_command: ControlCommand):
        """
        ユースケースを実行する。
        Args:
            vehicle_id: 対象車両のID
            current_vehicle_state: 最新の車両状態 (センサー等からの入力)
            plan_command: 実行する計画コマンド (ParkingPlanから取得)
        Raises:
            ValueError: システムが見つからない場合など
            Exception: アクチュエータへの送信失敗など
        """
        print(f"[UseCase] Executing parking step for vehicle {vehicle_id}...")
        print(f"  Input State: Speed={current_vehicle_state.speed.meters_per_second:.1f}, Steer={current_vehicle_state.steering_angle.degrees:.1f}")
        print(f"  Plan Command: Action={plan_command.action}, Value={plan_command.value}")

        # --- トランザクション管理の開始 (概念) ---
        try:
            # 1. リポジトリを使って集約(VehicleControl)を取得
            vehicle_control = self._vehicle_control_repo.find_by_vehicle_id(vehicle_id)
            if not vehicle_control:
                raise ValueError(f"VehicleControl aggregate for {vehicle_id} not found.")

            # 2. 最新の車両状態で集約内部の状態を更新
            #    (これはセンサーデータに基づき毎回行う)
            vehicle_control.update_current_state(current_vehicle_state)

            # 3. 集約ルートのメソッドを呼び出してアクチュエータ指示を計算
            #    (集約は内部でドメインサービス(control_calculator)を利用)
            steer_cmd, throttle_brake_cmd = vehicle_control.execute_plan_step(
                plan_command, self._control_calculator
            )

            # --- ここでトランザクションを区切ることも可能 ---
            # (状態更新とコマンド送信を別トランザクションにするなど)

            # 4. アクチュエータインターフェース経由で指示を送信 (副作用)
            print("[UseCase] Sending commands to actuators...")
            await self._actuator_interface.send_steering_command(steer_cmd)
            await self._actuator_interface.send_throttle_brake_command(throttle_brake_cmd)

            # 5. (もし必要なら) 更新された集約をリポジトリを使って保存
            #    (状態更新が永続化必要ならここで行う)
            # self._vehicle_control_repo.save(vehicle_control)
            # 今回はInMemoryRepoなのでupdate_current_stateだけでメモリ上は更新されるが、
            # DBを使う場合は明示的なsaveが必要。
            print(f"[UseCase] (Skipping save in this example, state updated in memory for aggregate {vehicle_id})")

            # --- トランザクションのコミット (概念) ---
            print("[UseCase] Parking step execution successful.")

        except ValueError as e: # ドメインルール違反など
             print(f"[UseCase] Domain rule violation during execution: {e}")
             # --- トランザクションのロールバック (概念) ---
             raise
        except Exception as e: # 予期せぬエラー (アクチュエータ通信失敗など)
            print(f"[UseCase] Error during parking step execution: {e}")
            # --- トランザクションのロールバック (概念) ---
            raise

```

✅ **このステップのポイント**:

- UseCase は CA と同じく、**ビジネスフローの調整役**です。
- **リポジトリ**を使って `VehicleControl` 集約を取得（し、必要なら保存）。
- **集約のメソッド**を呼び出してドメインロジック（制御指示計算）を実行させます（集約は内部でドメインサービスを利用）。
- **アクチュエータインターフェース**を通じて、計算された指示を外部（ハードウェア）に送信します。

---

## 🚀 4. 実行ファイル ([main.py](http://main.py/)) の作成 - 全体の組み立てとシミュレーション実行

📝 **課題**: 作成した UseCase を実行し、システム全体（制御部分）が動作することを確認する「起点」が必要です。駐車計画 (`ParkingPlan`) が存在し、車両状態 (`VehicleState`) が変化する状況をシミュレートします。

💡 **解決策**: `main.py` で、具体的なリポジトリ実装、ドメインサービス、スタブアダプタを生成し、それらを UseCase に注入（DI）して、計画のコマンドを順番に UseCase に渡して実行します。

**ファイル:** `control_context/main.py`

```python
# control_context/main.py
# 👈 実装、UseCase、ドメインオブジェクトなどをインポート
from adapters.repositories import InMemoryVehicleControlRepository
from adapters.stub_actuator import StubActuatorAdapter
from application.use_cases import ExecuteParkingStepUseCase
from domain.aggregates import VehicleControl
from domain.services import ControlCalculationService
from domain.value_objects import ( # 必要なVOをインポート
    ParkingPlan, ControlCommand, VehicleState, Speed, SteeringAngle
)
from datetime import datetime, timedelta
import asyncio

# -----------------------------------------------------------------------------
# Main Application / Composition Root
# - CAの最も外側の層 (Frameworks & Drivers) と同じ役割
# - 依存関係の解決 (DI) とアプリケーションの起動を行う
# -----------------------------------------------------------------------------

async def execute_parking_simulation(use_case: ExecuteParkingStepUseCase, repo: InMemoryVehicleControlRepository, vehicle_id: str, plan: ParkingPlan):
    """駐車計画を指定されたUseCaseで実行するシミュレーション関数"""
    print(f"\\n--- Executing Parking Plan ({len(plan.commands)} steps) ---")

    # 実行前の車両状態を取得 (あるいは初期化)
    vehicle_control = repo.find_by_vehicle_id(vehicle_id)
    if not vehicle_control:
         print(f"Error: VehicleControl for {vehicle_id} not found.")
         return
    current_state = vehicle_control.current_state # 初期状態

    # 計画のコマンドを順番に実行
    for i, command in enumerate(plan.commands):
        print(f"\\n--- Step {i+1}: Executing Command {command.action}={command.value} for {command.duration}s ---")

        # --- センサーからの車両状態入力 (シミュレーション) ---
        # (本来はここで実際のセンサー値を取得する)
        # 今回は、前のステップの制御結果を反映した「仮の」状態を使う (超簡易)
        # 時間経過も考慮
        current_time = current_state.timestamp + timedelta(seconds=command.duration / 2.0) # コマンド中間の時間を仮定
        # (速度や舵角も前のコマンド結果から簡易的に更新)
        simulated_state = VehicleState(
             timestamp=current_time,
             speed=current_state.speed, # 速度は簡単のため変化しないとする
             steering_angle=current_state.steering_angle # 舵角も簡単のため変化しないとする
        )
        print(f"[Simulation] Input State: Speed={simulated_state.speed.meters_per_second:.1f}, Steer={simulated_state.steering_angle.degrees:.1f}")

        # --- UseCaseの実行 ---
        try:
            await use_case.handle(vehicle_id, simulated_state, command)

            # --- UseCase実行後の状態を取得 (シミュレーション用) ---
            # (実際には次のセンサー入力で更新される)
            updated_control = repo.find_by_vehicle_id(vehicle_id) # 保存された最新状態を取得
            if updated_control:
                 current_state = updated_control.current_state # 次のステップの入力状態とする
                 print(f"[Simulation] State potentially updated in Repo (for next step).")

            # コマンドの実行時間待機 (シミュレーション)
            print(f"[Simulation] Waiting for command duration: {command.duration}s...")
            await asyncio.sleep(command.duration)

        except Exception as e:
            print(f"Execution failed at step {i+1}: {e}")
            break # エラー発生時は中断

    print("\\n--- Parking Plan Execution Finished ---")

if __name__ == "__main__":
    print("--- Automated Parking Control Example ---")

    # --- 依存関係の解決 (Dependency Injection) ---
    print("\\n--- Wiring dependencies (DI) ---")
    vehicle_control_repo = InMemoryVehicleControlRepository()
    control_calculator = ControlCalculationService()
    actuator_adapter = StubActuatorAdapter()
    execute_step_use_case = ExecuteParkingStepUseCase(
        vehicle_control_repo, control_calculator, actuator_adapter
    )
    print("--- Dependencies wired successfully ---")

    # --- 初期データ投入 (VehicleControl集約の初期化) ---
    print("\\n--- Setting up initial vehicle state ---")
    vehicle_id = "parking-car-01"
    initial_control = VehicleControl.initialize(vehicle_id)
    vehicle_control_repo.save(initial_control)
    print(f"VehicleControl initialized for {vehicle_id}. Initial state: Speed={initial_control.current_state.speed.meters_per_second}, Steer={initial_control.current_state.steering_angle.degrees}")

    # --- 駐車計画データの準備 (ダミー) ---
    # (本来は経路計算サービス(Planning Context)から受け取る)
    print("\\n--- Preparing dummy Parking Plan ---")
    plan_ts = datetime.now()
    dummy_plan = ParkingPlan(
        timestamp=plan_ts,
        commands=[
            ControlCommand(action='steer', value=-30.0, duration=1.5), # 左に切る
            ControlCommand(action='throttle', value=-0.8, duration=3.0),# バック(加速度指定)
            ControlCommand(action='steer', value=0.0, duration=1.0),  # まっすぐに戻す
            ControlCommand(action='throttle', value=-0.2, duration=2.0),# ゆっくりバック
            ControlCommand(action='throttle', value=0.0, duration=0.5), # 停止 (加速度0)
        ]
    )
    print(f"Plan created with {len(dummy_plan.commands)} steps.")

    # --- シミュレーションの実行 ---
    # asyncio.run()を使って非同期関数を実行
    asyncio.run(execute_parking_simulation(execute_step_use_case, vehicle_control_repo, vehicle_id, dummy_plan))

    # --- 最終結果の確認 ---
    print("\\n--- Verifying Final State ---")
    final_control = vehicle_control_repo.find_by_vehicle_id(vehicle_id)
    if final_control:
        final_state = final_control.current_state
        print(f"Vehicle {vehicle_id}'s final state (@{final_state.timestamp.isoformat()}):")
        # (注意: このシミュレーションではStateの更新は簡易的なので、
        #  最終状態が物理的に正確かは保証されない)
        print(f"  Speed: {final_state.speed.meters_per_second:.1f} m/s")
        print(f"  Steering Angle: {final_state.steering_angle.degrees:.1f} deg")

```

✅ **このステップのポイント**:

- `main.py` が依存関係を組み立て、`ExecuteParkingStepUseCase` を呼び出しました。
- `execute_parking_simulation` 関数内で、ダミーの駐車計画 (`ParkingPlan`) を用意し、そのコマンドを**ループ**で一つずつ UseCase に渡して実行する**シミュレーション**を行いました。
- 各ステップで UseCase がアクチュエータアダプタ (`StubActuatorAdapter`) を呼び出し、コンソールに制御指示が出力されることを確認しました。
- 車両状態 (`VehicleState`) の更新を簡易的にシミュレートし、次のステップの入力としています（より現実に近づけるには物理シミュレータが必要）。

---

## 📝 この演習のまとめ

この演習では、「自動駐車システム」のドメイン（特に制御部分）を題材に、第4・5巡での実装を DDD の視点から再評価・洗練しました。

1. **コンテキストと集約**: 「認識」「経路計算」「制御」というコンテキスト分割の妥当性を確認し、「制御」コンテキストの中心に `VehicleControl` 集約を置きました。`WorldModel` や `ParkingPlan` はコンテキスト間の契約（値オブジェクト/DTO）と位置づけました。
2. **値オブジェクト**: `VehicleState`, `Speed`, `SteeringAngle`, `ActuatorCommand` などを値オブジェクトとして定義し、型安全性と不変性を高めました。
3. **ドメインサービス**: 複雑な制御計算ロジックを `ControlCalculationService` に分離し、集約 (`VehicleControl`) の責務を明確化しました。
4. **リポジトリ**: `VehicleControl` 集約の永続化を抽象化しました。
5. **UseCase**: ドメインモデル、ドメインサービス、リポジトリ、アクチュエータインターフェースを利用して、計画実行のステップを処理するフローを実装しました。

第4・5巡のクリーンアーキテクチャ/SOAの実装にDDDの戦術的パターンを適用することで、ドメインのルールや構造がコードにより明確に表現され、各部品の責務がさらに洗練されることを体験できたかと思います。

---

## ✅ ドメインモデリング演習 (5/5) 完了！

これで、5つの題材すべてに対するドメインモデリング演習が一区切りとなります。お疲れ様でした！
これらの演習を通じて、DDDの考え方（特に戦術パターン）を様々なドメインに適用する感覚を掴むことができたのではないでしょうか。