# 05 モデルの一部をコード化

# ステップ５：モデルの一部をコード化 (UseCaseとMain) ⚙️🚀

これまでのステップで定義・実装したドメインモデル（集約、値オブジェクト）とリポジトリを使って、いよいよ「商品をカートに入れる」「カートから注文を作成する」という具体的な**UseCase**を実装し、それを[**main.py**](http://main.py/)から呼び出して実行してみましょう。

---

## ⚙️ 1. UseCase の実装 - ビジネスフローの実現

📝 **課題**:

1. 「顧客ID、追加したい書籍のISBN、数量」を受け取り、該当顧客のカートを取得（なければ新規作成）し、商品をカートに追加（または数量更新）して保存するフローが必要です。
2. 「顧客ID」を受け取り、該当顧客のカートを取得し、カートの内容に基づいて新しい注文を作成し、保存する（そしてカートを空にする）フローが必要です。

💡 **解決策**: これらのアプリケーション固有のフローの責任を持つ「UseCase」を実装します。UseCase はリポジトリインターフェースやファクトリ（必要な場合）に依存し、ドメインオブジェクトを利用してロジックを実行します。

**ファイル:** `application/use_cases.py` (新規作成または追記)

```python
# application/use_cases.py
from application.boundaries import BookRepositoryInterface, ShoppingCartRepositoryInterface, OrderRepositoryInterface
from domain.aggregates import ShoppingCart, Order # 利用・生成する集約
from domain.value_objects import ISBN, Quantity # 値オブジェクトを利用
from domain.factories import OrderFactory # Order生成用 (演習1のものを流用・拡張想定)
from typing import Optional, List, Dict # 型ヒント用

# (BookRepositoryInterface, OrderRepositoryInterface, OrderFactory の定義は
#  それぞれのコンテキストや演習1にあると仮定)

# -----------------------------------------------------------------------------
# Add Item To Cart Use Case
# - CAの Use Cases 層と同じ役割
# - カートに商品を追加するフローを担当
# -----------------------------------------------------------------------------
class AddItemToCartUseCase:
    """商品をカートに追加するユースケース"""
    def __init__(self,
                 cart_repository: ShoppingCartRepositoryInterface,
                 # (任意) book_repository: BookRepositoryInterface # 商品存在確認用
                 ):
        self._cart_repository = cart_repository
        # self._book_repository = book_repository # 商品チェックする場合

    def handle(self, customer_id: str, isbn_str: str, quantity_int: int):
        """
        ユースケースを実行する。
        Args:
            customer_id: 顧客ID
            isbn_str: 追加する書籍のISBN(文字列)
            quantity_int: 追加する数量(整数)
        Raises:
            ValueError: 入力不正、商品不存在(実装する場合)など
        """
        print(f"[UseCase] Attempting to add item {isbn_str} (qty: {quantity_int}) to cart for customer {customer_id}")

        # 1. 入力から値オブジェクトを生成 (形式検証)
        try:
            isbn = ISBN(isbn_str)
            quantity = Quantity(quantity_int)
        except ValueError as e:
            print(f"[UseCase] Invalid input: {e}")
            raise

        # (任意: 商品(Book)が存在するか、価格はいくらか等をBookRepositoryで確認する処理)
        # book = self._book_repository.find_by_isbn(isbn)
        # if not book: raise ValueError(f"Book with ISBN {isbn_str} not found.")
        # price = book.price # 価格情報を取得する場合

        # --- トランザクション管理の開始 (概念) ---
        try:
            # 2. リポジトリを使って集約(ShoppingCart)を取得、なければ新規作成
            cart = self._cart_repository.find_by_customer_id(customer_id)
            if not cart:
                print(f"[UseCase] Cart not found for customer {customer_id}, creating a new one.")
                cart = ShoppingCart(customer_id=customer_id) # 新規カート作成

            # 3. 集約ルート(ShoppingCart)のメソッドを呼び出して商品を追加/更新
            cart.add_item(isbn, quantity)

            # 4. 変更された集約をリポジトリを使って保存
            self._cart_repository.save(cart)

            # --- トランザクションのコミット (概念) ---
            print(f"[UseCase] Item added/updated in cart successfully for customer {customer_id}.")

        except Exception as e:
            # --- トランザクションのロールバック (概念) ---
            print(f"[UseCase] Failed to add item to cart: {e}")
            raise # エラーを上位に伝える

# -----------------------------------------------------------------------------
# Place Order Use Case
# - CAの Use Cases 層と同じ役割
# - カートから注文を作成するフローを担当
# -----------------------------------------------------------------------------
class PlaceOrderUseCase:
    """カートの内容から注文を作成するユースケース"""
    def __init__(self,
                 cart_repository: ShoppingCartRepositoryInterface,
                 order_factory: OrderFactory, # 注文生成用 (演習1のものを流用)
                 order_repository: OrderRepositoryInterface, # 注文保存用 (演習1のものを流用)
                 book_repository: BookRepositoryInterface # 注文時の価格取得用
                 ):
        self._cart_repository = cart_repository
        self._order_factory = order_factory
        self._order_repository = order_repository
        self._book_repository = book_repository # 注文作成時に最新の価格を参照する

    def handle(self, customer_id: str) -> Optional[str]:
        """
        ユースケースを実行する。
        Args:
            customer_id: 注文する顧客のID
        Returns:
            成功した場合は生成された注文ID、失敗した場合はNone
        Raises:
            ValueError: カートが空の場合など
        """
        print(f"[UseCase] Attempting to place order for customer {customer_id}")

        # --- トランザクション管理の開始 (概念) ---
        try:
            # 1. 顧客のカートを取得
            cart = self._cart_repository.find_by_customer_id(customer_id)
            if not cart or not cart.items:
                raise ValueError("Cannot place order: Shopping cart is empty.")

            # 2. カート内のアイテム情報から、注文明細データリストを作成
            #    (この際、最新の価格をBookRepositoryから取得する)
            item_data_list = []
            print("[UseCase] Fetching current prices for cart items...")
            for isbn, cart_item in cart.items.items():
                book = self._book_repository.find_by_isbn(isbn) # カタログから書籍情報取得
                if not book:
                    raise ValueError(f"Book with ISBN {isbn.value} not found in catalog during order placement.")

                # 注文明細データを作成 (ファクトリへの入力形式)
                item_data_list.append({
                    'product_id': isbn.value, # ファクトリが文字列を期待している場合
                    'quantity': cart_item.quantity.value,
                    'unit_price': book.price.amount, # 最新の価格を使用
                    'currency': book.price.currency
                })
                print(f" - Item: {isbn.value}, Qty: {cart_item.quantity.value}, Price: {book.price.amount}")

            # 3. OrderFactory を使って新しい Order 集約を生成
            #    (最低1アイテムのチェックなどはFactory内で行われる)
            print("[UseCase] Calling OrderFactory to create a new order...")
            new_order = self._order_factory.create_new_order(customer_id, item_data_list)

            # 4. 生成された Order 集約を OrderRepository を使って保存
            print(f"[UseCase] Saving the new order {new_order.order_id}...")
            self._order_repository.save(new_order)

            # 5. (任意) 注文が成功したらカートを空にする
            #    (カート集約のメソッドを使う)
            # cart.clear_items()
            # self._cart_repository.save(cart) # 変更を保存
            print(f"[UseCase] (Optional: Clearing cart {cart.cart_id})")

            # --- トランザクションのコミット (概念) ---
            print(f"[UseCase] Order {new_order.order_id} placed successfully.")
            return new_order.order_id

        except Exception as e:
            # --- トランザクションのロールバック (概念) ---
            print(f"[UseCase] Failed to place order: {e}")
            # (エラーハンドリング)
            raise

```

✅ **このステップのポイント**:

- 各 UseCase は CA と同じく、**ビジネスフローの調整役**です。
- `AddItemToCartUseCase` は `ShoppingCartRepository` を使って `ShoppingCart` 集約を操作します。
- `PlaceOrderUseCase` は複数のリポジトリ (`ShoppingCartRepository`, `OrderRepository`, `BookRepository`) とファクトリ (`OrderFactory`) を利用して、カートから注文への変換と永続化という、より複雑なフローを実現します。**異なるコンテキスト（カート、注文、カタログ）の情報を組み合わせて**処理を行っています。
- 最新価格の取得など、コンテキストをまたぐ情報の参照が必要な場合があります（ただし、コンテキスト間の直接的な書き込みは避けるべきです）。

---

## 🚀 2. 実行ファイル ([main.py](http://main.py/)) の作成 - 全体の組み立てと実行

📝 **課題**: 作成した UseCase を実行し、システム全体（今回はインメモリ）が動作することを確認する「起点」が必要です。

💡 **解決策**: `main.py` で、具体的なリポジトリ実装やファクトリを生成し、それらを UseCase に注入（DI）して、UseCase を呼び出します。

**ファイル:** `main.py` (プロジェクトルート、または `app/` など)

```python
# main.py
# (各アダプタ、ユースケース、ドメインオブジェクトのインポート)
from adapters.repositories import ( # 👈 実装
    InMemoryBookRepository,
    InMemoryCartRepository,
    InMemoryOrderRepository
)
from application.use_cases import AddItemToCartUseCase, PlaceOrderUseCase # 👈 UseCase
from domain.aggregates import Book, ShoppingCart, Order # 初期データ用/確認用
from domain.value_objects import ISBN, Money, Title, Body, Quantity # 初期データ用
from domain.factories import OrderFactory # OrderFactory (演習1のもの)

# -----------------------------------------------------------------------------
# Main Application / Composition Root
# -----------------------------------------------------------------------------
if __name__ == "__main__":
    print("--- Online Bookstore Example ---")

    # --- 依存関係の解決 (Dependency Injection) ---
    print("\\n--- Wiring dependencies (DI) ---")
    book_repo = InMemoryBookRepository()
    cart_repo = InMemoryCartRepository()
    order_repo = InMemoryOrderRepository() # 演習1と同じリポジトリインスタンスを流用
    order_factory = OrderFactory()      # 演習1と同じファクトリインスタンスを流用

    add_item_to_cart_use_case = AddItemToCartUseCase(cart_repo) # BookRepoは省略
    place_order_use_case = PlaceOrderUseCase(cart_repo, order_factory, order_repo, book_repo)
    print("--- Dependencies wired successfully ---")

    # --- 初期データ投入 (書籍カタログ) ---
    print("\\n--- Setting up initial data (Books) ---")
    try:
        book1_isbn = ISBN("978-4-7981-5763-7") # 例: Clean Architecture ISBN
        book1 = Book(isbn=book1_isbn, title=Title("Clean Architecture"), price=Money(3000, "JPY"), description=Body("..."))
        book_repo.save(book1)
        print(f"Book '{book1.title.value}' added to catalog.")

        book2_isbn = ISBN("978-4-87311-993-9") # 例: DDD ISBN
        book2 = Book(isbn=book2_isbn, title=Title("Domain-Driven Design"), price=Money(4000, "JPY"), description=Body("..."))
        book_repo.save(book2)
        print(f"Book '{book2.title.value}' added to catalog.")
    except ValueError as e:
        print(f"Error setting up book data: {e}")
        exit()

    # --- UseCase実行1: カートに商品を追加 ---
    print("\\n--- Executing UseCase: Add Item to Cart ---")
    customer_id = "cust-001"
    try:
        # 1冊目追加
        add_item_to_cart_use_case.handle(customer_id, "978-4-7981-5763-7", 1)
        # 2冊目追加
        add_item_to_cart_use_case.handle(customer_id, "978-4-87311-993-9", 2)
        # 1冊目をもう1つ追加 (数量更新)
        add_item_to_cart_use_case.handle(customer_id, "978-4-7981-5763-7", 1)
    except Exception as e:
        print(f"Failed to add item: {e}")

    # --- カートの状態確認 ---
    print("\\n--- Verifying Cart State ---")
    cart = cart_repo.find_by_customer_id(customer_id)
    if cart:
        print(f"Cart {cart.cart_id} for customer {customer_id} contains {len(cart.items)} unique items:")
        for isbn, item in cart.items.items():
            print(f" - ISBN: {isbn.value}, Quantity: {item.quantity.value}")
            # -> ISBN: 978-4-7981-5763-7, Quantity: 2
            # -> ISBN: 978-4-87311-993-9, Quantity: 2
    else:
        print("Cart not found.")

    # --- UseCase実行2: カートから注文を作成 ---
    print("\\n--- Executing UseCase: Place Order from Cart ---")
    new_order_id = None
    try:
        new_order_id = place_order_use_case.handle(customer_id)
    except Exception as e:
        print(f"Failed to place order: {e}")

    # --- 注文の状態確認 ---
    print("\\n--- Verifying Created Order ---")
    if new_order_id:
        created_order = order_repo.find_by_id(new_order_id)
        if created_order:
            print(f"Order ID: {created_order.order_id}")
            print(f"Customer ID: {created_order.customer_id}")
            print(f"Status: {created_order.status}") # -> PENDING
            print(f"Total Price: {created_order.total_price.amount} {created_order.total_price.currency}") # -> (3000*2 + 4000*2) = 14000 JPY
            print(f"Number of Items: {len(created_order.items)}") # -> 2
            # for item_id, item in created_order.items.items():
            #     print(f" - Item {item_id}: ISBN={item.isbn.value}, Qty={item.quantity.value}, UnitPrice={item.unit_price.amount}")
        else:
            print("Order not found.")
    else:
        print("Order placement failed.")

    # --- (任意) カートが空になったか確認 ---
    # final_cart = cart_repo.find_by_customer_id(customer_id)
    # if final_cart: print(f"Cart items after order: {len(final_cart.items)}") # -> 0 (もしクリア処理を実装した場合)

```

✅ **このステップのポイント**:

- `main.py` が複数のリポジトリ実装 (`InMemoryBookRepository`, `InMemoryCartRepository`, `InMemoryOrderRepository`) とファクトリを生成し、各 UseCase に適切に注入しました。
- UseCase を順番に呼び出し、「カートに追加」→「注文作成」という一連のフローを実行し、各ステップでの状態（カートの中身、作成された注文）を確認しました。
- `PlaceOrderUseCase` が異なるコンテキスト（カタログ、カート、注文）のリポジトリを利用して処理を実現する様子を示しました。

---

## 📝 この演習のまとめ

この演習では、「オンライン書店」のコア機能（カート追加、注文作成）を通じて、DDDの戦術的パターンを適用しました。

1. **コンテキストの意識**: 「書籍」という概念がコンテキスト（カタログ、カート、注文）によって関心事が異なることを認識し、それぞれのコンテキストで必要なモデル（`Book`集約、`CartItem`値オブジェクト、`OrderItem`エンティティ）を設計しました。
2. **値オブジェクト (`ISBN`, `Money`, `Quantity`, `CartItem`)**: ドメインの基本的な構成要素を型安全に、不変なオブジェクトとして定義しました。
3. **集約 (`Book`, `ShoppingCart`, `Order`)**: それぞれのコンテキストにおける一貫性の単位を定義し、ビジネスルールをカプセル化しました。
4. **リポジトリ**: 各集約の永続化を抽象化しました。
5. **UseCase**: アプリケーションの要求（カート操作、注文作成）を実現するフローを、ドメインオブジェクトとリポジトリを利用して実装しました。特に `PlaceOrderUseCase` では、複数のコンテキスト（リポジトリ経由）の情報を組み合わせて処理を行いました。

複数のコンテキストが関わる場合でも、各コンテキスト内のモデル（集約）は自身の責務に集中し、UseCase がそれらを協調させてアプリケーションの機能を実現するという、より実践的な設計パターンを体験できたかと思います。

---

## ✅ ドメインモデリング演習 (3/5) 完了！

これで、「オンライン書店」のモデリング演習は一区切りです。
次は、4つ目の題材「**(4/5) 車線逸脱防止支援システム (LDW/LKA)**」に進み、少し技術寄りのドメインをモデル化してみましょうか？