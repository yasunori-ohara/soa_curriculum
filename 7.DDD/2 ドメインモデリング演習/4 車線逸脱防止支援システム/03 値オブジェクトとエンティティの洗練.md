# 03 値オブジェクトとエンティティの洗練

# ステップ３：値オブジェクトとエンティティの洗練 ✨

Step 2 で中心となる `LaneKeepingAssist` 集約の輪郭を捉えました。このステップでは、この集約が扱う**入力**、**内部状態**、**出力**に関する重要な概念を**値オブジェクト (Value Object)** として具体的に設計し、それらを使って `LaneKeepingAssist` エンティティ（集約ルート）の定義をより洗練させていきます。

## 🤔 値オブジェクトとは？（復習）

- *属性（値）*だけで定義される（IDを持たない）。
- 通常は**不変 (Immutable)**。
- **自己検証**ロジックを持つことができる。

---

## 💎 1. 値オブジェクト (Value Object) の設計

Step 1 で洗い出した候補の中から、値オブジェクトとして定義するものを具体化します。これらはドメインの「測定値」「状態」「要求」などを表現します。

### a) 入力データ (`LaneModel`, `VehicleState`)

📝 **課題**: センサーからの車線情報や車両の物理状態は、特定の瞬間の「スナップショット」です。これらのデータ構造が明確に定義されていないと、`LaneKeepingAssist` 集約が不安定な入力に依存することになります。

💡 **解決策**: `LaneModel` と `VehicleState` を**値オブジェクト**として定義します。不変とし、必要であれば生成時に値の妥当性（例：速度がマイナスでないか）をチェックします。

**ファイル:** `domain/value_objects.py` (新規作成または追記)

```python
# domain/value_objects.py
from dataclasses import dataclass, field
from enum import Enum, auto
from datetime import datetime # Timestamp用

# -----------------------------------------------------------------------------
# LaneLine Value Object (LaneModelの一部)
# - DDD戦術的設計の Value Object
# - CAの Entities 層
# -----------------------------------------------------------------------------
@dataclass(frozen=True)
class LaneLine:
    """単一の車線（白線）を表す値オブジェクト"""
    position_offset: float # 車両中心からの横方向オフセット [m]
    line_type: str # 例: "SOLID", "DASHED", "NONE"
    confidence: float # 認識の信頼度 [0.0 - 1.0]

# -----------------------------------------------------------------------------
# LaneModel Value Object (Input)
# - DDD戦術的設計の Value Object
# - CAの Entities 層
# -----------------------------------------------------------------------------
@dataclass(frozen=True)
class LaneModel:
    """認識された車線モデル全体を表す値オブジェクト"""
    timestamp: datetime
    left_lane_line: LaneLine
    right_lane_line: LaneLine
    # (将来的に: road_curvature, upcoming_lane_change など)

# -----------------------------------------------------------------------------
# VehicleState Value Object (Input)
# - DDD戦術的設計の Value Object
# - CAの Entities 層
# -----------------------------------------------------------------------------
@dataclass(frozen=True)
class VehicleState:
    """車両の物理状態を表す値オブジェクト"""
    timestamp: datetime
    speed_mps: float # 速度 [m/s]
    steering_angle_deg: float # ステアリング角度 [deg]
    yaw_rate_dps: float # ヨーレート [deg/s]
    # (将来的に: turn_signal_status など)

    def __post_init__(self):
        # 簡単な妥当性チェック
        if self.speed_mps < 0:
            raise ValueError("Speed cannot be negative.")

```

### b) 計算結果 / 内部状態 (`LaneRelativePosition`, `DepartureState`, `SystemStatus`)

📝 **課題**: 車線内の相対位置、逸脱状態、システム全体の動作状態も、明確な定義が必要です。特に状態は、限られた値しか取らないべきです。

💡 **解決策**: `LaneRelativePosition` を**値オブジェクト**、`DepartureState` と `SystemStatus` を*Enum（値オブジェクトの一種）*として定義します。

**ファイル:** `domain/value_objects.py` (追記)

```python
# domain/value_objects.py
# (LaneModel, VehicleState definitions...)

# -----------------------------------------------------------------------------
# LaneRelativePosition Value Object (Calculated)
# - DDD戦術的設計の Value Object
# - CAの Entities 層
# -----------------------------------------------------------------------------
@dataclass(frozen=True)
class LaneRelativePosition:
    """車線に対する車両の相対位置を表す値オブジェクト"""
    timestamp: datetime
    lateral_offset_m: float # 車線中央からの横ずれ [m] (例: 左が+, 右が-)
    heading_angle_deg: float # 車線に対する相対角度 [deg] (例: 左向き+, 右向き-)
    # (将来的に: distance_to_left_line, distance_to_right_line など)

# -----------------------------------------------------------------------------
# DepartureState Enum (Calculated State)
# - DDD戦術的設計の Value Object (Enum表現)
# - CAの Entities 層
# -----------------------------------------------------------------------------
class DepartureState(Enum):
    """車両の車線逸脱状態を表す列挙型"""
    IN_LANE = auto()        # 車線内にいる
    DRIFTING_LEFT = auto()  # 左に逸脱しそう
    DRIFTING_RIGHT = auto() # 右に逸脱しそう
    DEPARTED_LEFT = auto()  # 左に逸脱した
    DEPARTED_RIGHT = auto() # 右に逸脱した
    UNCERTAIN = auto()      # 不明 (例: 車線未認識)

# -----------------------------------------------------------------------------
# SystemStatus Enum (Aggregate State)
# - DDD戦術的設計の Value Object (Enum表現)
# - CAの Entities 層 (LaneKeepingAssist集約の内部状態)
# -----------------------------------------------------------------------------
class SystemStatus(Enum):
    """LKAシステムの動作状態を表す列挙型"""
    INACTIVE = auto()           # 非作動 (OFF)
    ACTIVE_WARNING_ONLY = auto() # 作動中 (警告のみ LDW)
    ACTIVE_ASSISTING = auto()    # 作動中 (操舵支援あり LKA)
    SUPPRESSED = auto()         # 一時停止 (例: ウィンカー操作中)
    FAULT = auto()              # 故障

```

### c) 出力要求 (`WarningRequest`, `SteeringTorqueRequest`)

📝 **課題**: システムが外部（警告装置、ステアリングアクチュエータ）に要求する内容も明確に定義する必要があります。

💡 **解決策**: `WarningRequest` と `SteeringTorqueRequest` を**値オブジェクト**として定義します。これらは、特定の要求とそのパラメータ（強さ、種類など）をカプセル化します。

**ファイル:** `domain/value_objects.py` (追記)

```python
# domain/value_objects.py
# (Other definitions...)

# -----------------------------------------------------------------------------
# WarningRequest Value Object (Output)
# - DDD戦術的設計の Value Object
# - CAの Entities 層 (UseCaseが出力するデータ型)
# -----------------------------------------------------------------------------
@dataclass(frozen=True)
class WarningRequest:
    """ドライバーへの警告要求を表す値オブジェクト"""
    level: str # 例: "LOW", "HIGH", "NONE"
    type: str # 例: "AUDIBLE", "HAPTIC", "VISUAL", "NONE"

    # ファクトリメソッドで定型的な要求を生成できるようにしても良い
    @staticmethod
    def no_warning() -> 'WarningRequest':
        return WarningRequest(level="NONE", type="NONE")

# -----------------------------------------------------------------------------
# SteeringTorqueRequest Value Object (Output)
# - DDD戦術的設計の Value Object
# - CAの Entities 層 (UseCaseが出力するデータ型)
# -----------------------------------------------------------------------------
@dataclass(frozen=True)
class SteeringTorqueRequest:
    """ステアリングへの操舵トルク要求を表す値オブジェクト"""
    torque_nm: float # 要求トルク [Nm] (例: 右向き+, 左向き-)
    # (将来的に: fade_in_time, duration など)

    @staticmethod
    def no_torque() -> 'SteeringTorqueRequest':
        return SteeringTorqueRequest(torque_nm=0.0)

```

✅ **このステップのポイント**:

- システムが扱う入力、計算結果、内部状態、出力を、それぞれ意味のある**値オブジェクト**または**Enum**として定義しました。
- これにより、`LaneKeepingAssist` 集約が扱うデータの**型が明確**になり、**不変性**や**自己検証**の恩恵を受けられるようになりました。

---

## 🧱 2. エンティティ (`LaneKeepingAssist`) の洗練

作成した値オブジェクトとEnumを使って、`LaneKeepingAssist` 集約（エンティティ）の定義を更新します。内部状態として `SystemStatus` を持ち、入力値オブジェクトを受け取って判断し、出力値オブジェクトを返すメソッドを定義します。

**ファイル:** `domain/aggregates.py` (修正・追記)

```python
# domain/aggregates.py
from dataclasses import dataclass, field
# 👈 作成した値オブジェクトとEnumをインポート
from .value_objects import (
    LaneModel, VehicleState, LaneRelativePosition, DepartureState, SystemStatus,
    WarningRequest, SteeringTorqueRequest
)
from datetime import datetime
from typing import Tuple # 戻り値用

# (他の集約定義があれば...)

# -----------------------------------------------------------------------------
# LaneKeepingAssist Aggregate Root / Entity
# - DDD戦術的設計の Aggregate Root / Entity
# - CAの Entities 層
# -----------------------------------------------------------------------------
@dataclass
class LaneKeepingAssist:
    """
    車線逸脱防止支援システムを表す集約ルート・エンティティ。
    - vehicleId で識別される想定 (車に紐づく)。
    - システム状態(systemStatus)を管理し、入力に基づいて判断を行い、
      警告や操舵トルクの要求を出力する責務を持つ。
    """
    vehicle_id: str # (またはシステム固有ID)
    system_status: SystemStatus = SystemStatus.INACTIVE # 👈 内部状態としてEnumを使用
    # --- 設定値 (例) ---
    warning_threshold_m: float = 0.3 # 逸脱警告を開始する閾値 [m]
    assist_threshold_m: float = 0.4 # 操舵支援を開始する閾値 [m]
    assist_strength_factor: float = 1.0 # 操舵支援の強さ係数

    # --- 計算された内部状態 (一時的な保持用、永続化しないかも) ---
    _last_lane_model: Optional[LaneModel] = field(default=None, init=False, repr=False)
    _last_vehicle_state: Optional[VehicleState] = field(default=None, init=False, repr=False)
    _current_relative_pos: Optional[LaneRelativePosition] = field(default=None, init=False, repr=False)
    _current_departure_state: DepartureState = field(default=DepartureState.UNCERTAIN, init=False, repr=False)

    def activate(self, mode: str = "ASSIST"):
        """システムを作動させる (例: LDWモード or LKAモード)"""
        print(f"[Aggregate Logic] Activating LKA system for {self.vehicle_id} in mode: {mode}")
        if self.system_status == SystemStatus.FAULT:
            print("[Aggregate Logic] Cannot activate due to FAULT status.")
            return
        if mode == "ASSIST":
            self.system_status = SystemStatus.ACTIVE_ASSISTING
        else: # "WARNING_ONLY" or default
            self.system_status = SystemStatus.ACTIVE_WARNING_ONLY
        print(f"[Aggregate Logic] System status changed to: {self.system_status.name}")

    def deactivate(self):
        """システムを非作動にする"""
        print(f"[Aggregate Logic] Deactivating LKA system for {self.vehicle_id}")
        self.system_status = SystemStatus.INACTIVE
        # 内部状態もリセット
        self._current_departure_state = DepartureState.UNCERTAIN
        print(f"[Aggregate Logic] System status changed to: {self.system_status.name}")

    def suppress_by_driver(self):
         """ドライバー操作により一時停止する (例: ウィンカー点灯時)"""
         if self.system_status in [SystemStatus.ACTIVE_WARNING_ONLY, SystemStatus.ACTIVE_ASSISTING]:
             print(f"[Aggregate Logic] Suppressing LKA system for {self.vehicle_id} due to driver input.")
             self.system_status = SystemStatus.SUPPRESSED
             print(f"[Aggregate Logic] System status changed to: {self.system_status.name}")

    def resume_from_suppress(self):
         """一時停止から復帰する (例: ウィンカー消灯時)"""
         if self.system_status == SystemStatus.SUPPRESSED:
             print(f"[Aggregate Logic] Resuming LKA system for {self.vehicle_id}.")
             # 元の状態(ASSIST or WARNING_ONLY)に戻すロジックが必要だが、ここではASSISTに固定
             self.system_status = SystemStatus.ACTIVE_ASSISTING
             print(f"[Aggregate Logic] System status changed to: {self.system_status.name}")

    def update_and_decide(self, lane_model: LaneModel, vehicle_state: VehicleState) \\
            -> Tuple[WarningRequest, SteeringTorqueRequest]:
        """
        [集約の主要な振る舞い]
        センサー情報(LaneModel, VehicleState)を受け取り、
        内部状態を更新し、警告と操舵トルクの要求を決定して返す。
        """
        print(f"[Aggregate Logic] Updating state for {self.vehicle_id}...")
        self._last_lane_model = lane_model
        self._last_vehicle_state = vehicle_state

        # 1. 内部状態の計算 (これらはDomain Serviceに切り出すことも可能)
        self._current_relative_pos = self._calculate_relative_position(lane_model, vehicle_state)
        self._current_departure_state = self._judge_departure_state(self._current_relative_pos)
        print(f"[Aggregate Logic] Calculated RelativePos: {self._current_relative_pos.lateral_offset_m:.2f}m, DepartureState: {self._current_departure_state.name}")

        # 2. 現在のシステム状態に基づいて出力を決定
        warning_req = WarningRequest.no_warning()
        torque_req = SteeringTorqueRequest.no_torque()

        if self.system_status == SystemStatus.ACTIVE_WARNING_ONLY or \\
           self.system_status == SystemStatus.ACTIVE_ASSISTING:

            # 逸脱しそうな場合に警告
            if self._current_departure_state in [DepartureState.DRIFTING_LEFT, DepartureState.DRIFTING_RIGHT]:
                 # (逸脱方向や度合いに応じて警告レベルを変えるロジック)
                 warning_req = WarningRequest(level="LOW", type="HAPTIC")
                 print("[Aggregate Logic] Decision: LOW HAPTIC Warning requested.")

            # 操舵支援モードの場合、さらに逸脱した場合に介入
            if self.system_status == SystemStatus.ACTIVE_ASSISTING:
                 if abs(self._current_relative_pos.lateral_offset_m) >= self.assist_threshold_m:
                     # (逸脱方向と度合い、速度などに応じてトルクを計算するロジック)
                     required_torque = -1.0 * self._current_relative_pos.lateral_offset_m * self.assist_strength_factor # 簡易計算
                     torque_req = SteeringTorqueRequest(torque_nm=required_torque)
                     print(f"[Aggregate Logic] Decision: Steering Torque requested: {torque_req.torque_nm:.2f} Nm.")
                     # 介入中は警告レベルを上げるなど
                     if warning_req.level == "LOW": warning_req = WarningRequest(level="HIGH", type="HAPTIC")

        elif self.system_status == SystemStatus.SUPPRESSED:
            print("[Aggregate Logic] System suppressed. No warning/assist.")
        elif self.system_status == SystemStatus.INACTIVE:
            print("[Aggregate Logic] System inactive. No warning/assist.")
        # (FAULT状態の処理も必要)

        return warning_req, torque_req

    def _calculate_relative_position(self, lane: LaneModel, vehicle: VehicleState) -> LaneRelativePosition:
        """(内部ロジック) 車線モデルと車両状態から相対位置を計算"""
        # --- ここに複雑な計算ロジックが入る ---
        # 例: 左右の白線情報と車両速度、ヨーレートから横ずれと角度を推定
        # (今回はダミー計算)
        calculated_offset = (lane.left_lane_line.position_offset + lane.right_lane_line.position_offset) / 2
        calculated_angle = vehicle.steering_angle_deg * 0.1 # 仮
        return LaneRelativePosition(
            timestamp=vehicle.timestamp,
            lateral_offset_m=calculated_offset,
            heading_angle_deg=calculated_angle
        )

    def _judge_departure_state(self, rel_pos: LaneRelativePosition) -> DepartureState:
        """(内部ロジック) 相対位置から逸脱状態を判定"""
        # --- ここに判定ロジックが入る ---
        offset = abs(rel_pos.lateral_offset_m)
        if offset < self.warning_threshold_m:
            return DepartureState.IN_LANE
        elif offset < self.assist_threshold_m: # 警告閾値以上、介入閾値未満
            if rel_pos.lateral_offset_m > 0: return DepartureState.DRIFTING_LEFT
            else: return DepartureState.DRIFTING_RIGHT
        else: # 介入閾値以上
            if rel_pos.lateral_offset_m > 0: return DepartureState.DEPARTED_LEFT
            else: return DepartureState.DEPARTED_RIGHT
        # (車線認識不可の場合のUNCERTAIN判定も必要)

```

✅ **このステップのポイント**:

- `LaneKeepingAssist` 集約（エンティティ）が、**値オブジェクト**と**Enum**を使って内部状態 (`system_status`) や入力 (`LaneModel`, `VehicleState`)、出力 (`WarningRequest`, `SteeringTorqueRequest`) を明確な型で扱えるようになりました。
- システムの状態遷移（`activate`, `deactivate`, `suppress` など）と、主要な判断ロジック (`update_and_decide`) を**集約の振る舞い**としてカプセル化しました。
- 複雑な計算ロジック (`_calculate_relative_position`, `_judge_departure_state`) はプライベートメソッドとして分離しましたが、これらがさらに複雑化する場合は**ドメインサービス**に切り出す候補となります。

---

## 📝 まとめ

このステップでは、車線逸脱防止支援システムのドメインにおける様々な概念（センサー入力、内部状態、計算結果、出力要求）を**値オブジェクト**や**Enum**として具体的に設計し、それらを使って中心となる`LaneKeepingAssist` 集約（エンティティ）の定義を洗練させました。

値オブジェクトとEnumを活用することで、

- コードの**表現力**と**型安全性**が向上し、
- **不変性**や**自己検証**によって堅牢性が高まり、
- 集約が自身の状態と振る舞いを**明確にカプセル化**できるようになりました。

---

## ➡️ 次へ

次は、このドメインモデル（集約）を永続化し、利用するための「**(Step 4) リポジトリ、ドメインサービス等の検討**」に進みます。（今回はドメインサービスに切り出す候補も出てきましたね）