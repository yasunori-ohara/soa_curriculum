# 04 リポジトリ、ドメインサービス等の検討

# ステップ４：リポジトリ、ドメインサービス等の検討 💾⚙️

Step 3 で集約 (`LaneKeepingAssist`) と内部で使う値オブジェクトを洗練させました。このステップでは、この集約を**永続化**するための**リポジトリ (Repository)** を定義し、Step 3 で見えた複雑な計算ロジックを**ドメインサービス (Domain Service)** として切り出すことを検討します。

---

## 💾 1. リポジトリ (Repository) の定義と実装 - システム状態の永続化

📝 **課題**: `LaneKeepingAssist` 集約は、現在の `SystemStatus` や設定値といった状態を持っています。これらの状態は、車両の電源がオフになっても（あるいはシステムが再起動しても）保持される必要があるかもしれません（例：ユーザーが設定したON/OFF状態など）。そのため、永続化の仕組みが必要です。

💡 **解決策**: **リポジトリ (`Repository`)** パターンを適用します。`LaneKeepingAssistRepositoryInterface` を定義し、具体的な実装（今回はインメモリ）を Adapters 層に隠蔽します。

**ファイル:** `application/boundaries.py` (追記)

```python
# application/boundaries.py
from abc import ABC, abstractmethod
# 👈 永続化対象の集約 (前のステップで定義済み)
from domain.aggregates import LaneKeepingAssist
from typing import Optional

# (他のインターフェース定義 ...)

# -----------------------------------------------------------------------------
# LaneKeepingAssist Repository Interface
# - DDD戦術的設計の Repository Interface
# - CAの Application 層 (境界定義)
# -----------------------------------------------------------------------------
class LaneKeepingAssistRepositoryInterface(ABC):
    """LaneKeepingAssist集約の永続化を抽象化するインターフェース"""
    @abstractmethod
    def find_by_vehicle_id(self, vehicle_id: str) -> Optional[LaneKeepingAssist]:
        """車両IDでLaneKeepingAssist集約を検索する"""
        raise NotImplementedError

    @abstractmethod
    def save(self, lka_system: LaneKeepingAssist):
        """LaneKeepingAssist集約を保存（新規作成または更新）する"""
        raise NotImplementedError

```

**ファイル:** `adapters/repositories.py` (追記)

```python
# adapters/repositories.py
# 👈 インターフェースと集約をインポート
from application.boundaries import LaneKeepingAssistRepositoryInterface
from domain.aggregates import LaneKeepingAssist
from typing import Optional, Dict # Dictを追加
import copy

# (他のリポジトリ実装 ...)

# -----------------------------------------------------------------------------
# In-Memory LaneKeepingAssist Repository Implementation
# - DDD戦術的設計の Repository Implementation
# - CAの Adapters 層
# -----------------------------------------------------------------------------
class InMemoryLKARepository(LaneKeepingAssistRepositoryInterface):
    """LaneKeepingAssist集約をメモリ上の辞書で保持するリポジトリ実装"""
    def __init__(self):
        # vehicle_id をキーとする辞書
        self._systems: Dict[str, LaneKeepingAssist] = {}

    def find_by_vehicle_id(self, vehicle_id: str) -> Optional[LaneKeepingAssist]:
        print(f"[Adapter] InMemoryRepo: Finding LKA system for vehicle {vehicle_id}")
        system = self._systems.get(vehicle_id)
        # 状態を持つオブジェクトなのでコピーを返すのが安全
        return copy.deepcopy(system) if system else None

    def save(self, lka_system: LaneKeepingAssist):
        """LKAシステムの状態を保存する (存在すれば上書き)"""
        print(f"[Adapter] InMemoryRepo: Saving LKA system for vehicle {lka_system.vehicle_id} (Status: {lka_system.system_status.name})")
        # コピーを保存
        self._systems[lka_system.vehicle_id] = copy.deepcopy(lka_system)

```

✅ **このステップのポイント**:

- `LaneKeepingAssist` 集約の状態（特に `SystemStatus` や設定値）を永続化するための**リポジトリインターフェース**と**インメモリ実装**を定義しました。
- これにより、UseCase は具体的な永続化方法を知ることなく、システムの状態を保存・復元できるようになります。

---

## ⚙️ 2. ドメインサービス (Domain Service) の導入検討 - 計算ロジックの分離

📝 **課題**: Step 3 で実装した `LaneKeepingAssist` 集約の `update_and_decide` メソッド内には、`_calculate_relative_position` と `_judge_departure_state` という、ドメイン固有の**複雑な計算ロジック**が含まれていました。これらは `LaneKeepingAssist` 集約の主要な責務（状態管理と判断のオーケストレーション）とは少し性質が異なり、集約クラスを肥大化させる可能性があります。また、これらの計算ロジックだけを独立してテストすることも難しくなります。

💡 **解決策**: これらの計算ロジックを、独立した**ドメインサービス (`Domain Service`)** として切り出すことを検討します。ドメインサービスはステートレスで、入力（`LaneModel`, `VehicleState` など）を受け取り、計算結果（`LaneRelativePosition`, `DepartureState`）を返す責務を持ちます。`LaneKeepingAssist` 集約は、このドメインサービスを利用するように変更します。

**ファイル:** `domain/services.py` (新規作成または追記)

```python
# domain/services.py
# 👈 計算に必要な値オブジェクトをインポート
from .value_objects import LaneModel, VehicleState, LaneRelativePosition, DepartureState
# (しきい値などをサービス内で持つ場合は集約から渡す必要がある)
# from .aggregates import LaneKeepingAssist # 設定値参照用 (別案)

# -----------------------------------------------------------------------------
# Lane Calculation Domain Service
# - DDD戦術的設計の Domain Service
# - CAの Domain 層 (Aggregateから利用される)
# -----------------------------------------------------------------------------
class LaneCalculationService:
    """
    車線情報と車両状態に基づいて、相対位置や逸脱状態を計算するドメインサービス。
    - ステートレス。
    - 複雑な計算ロジックをカプセル化する。
    - LaneKeepingAssist集約から利用される。
    """
    def calculate_relative_position(self, lane: LaneModel, vehicle: VehicleState) -> LaneRelativePosition:
        """車線モデルと車両状態から相対位置を計算"""
        print("[Domain Service] Calculating relative position...")
        # --- ここに複雑な計算ロジックが入る ---
        # (Step 3 の _calculate_relative_position の内容をここに移動)
        calculated_offset = (lane.left_lane_line.position_offset + lane.right_lane_line.position_offset) / 2
        calculated_angle = vehicle.steering_angle_deg * 0.1 # 仮
        result = LaneRelativePosition(
            timestamp=vehicle.timestamp,
            lateral_offset_m=calculated_offset,
            heading_angle_deg=calculated_angle
        )
        print(f"[Domain Service] Relative position calculated: offset={result.lateral_offset_m:.2f}m")
        return result

    def judge_departure_state(self, rel_pos: LaneRelativePosition,
                              warning_threshold: float, assist_threshold: float) -> DepartureState:
        """相対位置から逸脱状態を判定"""
        # (判定に必要な閾値は引数で受け取るように変更)
        print(f"[Domain Service] Judging departure state based on offset {rel_pos.lateral_offset_m:.2f}m (Warn:{warning_threshold}, Assist:{assist_threshold})")

        # --- ここに判定ロジックが入る ---
        # (Step 3 の _judge_departure_state の内容をここに移動)
        offset = abs(rel_pos.lateral_offset_m)
        state = DepartureState.UNCERTAIN # デフォルト

        # (車線認識の信頼度なども考慮すべきだが省略)
        if offset < warning_threshold:
            state = DepartureState.IN_LANE
        elif offset < assist_threshold:
            state = DepartureState.DRIFTING_LEFT if rel_pos.lateral_offset_m > 0 else DepartureState.DRIFTING_RIGHT
        else:
            state = DepartureState.DEPARTED_LEFT if rel_pos.lateral_offset_m > 0 else DepartureState.DEPARTED_RIGHT

        print(f"[Domain Service] Departure state judged: {state.name}")
        return state

```

**ファイル:** `domain/aggregates.py` (`LaneKeepingAssist` 集約を修正)

```python
# domain/aggregates.py
# (Imports...)
from .services import LaneCalculationService # 👈 ドメインサービスをインポート

@dataclass
class LaneKeepingAssist:
    vehicle_id: str
    system_status: SystemStatus = SystemStatus.INACTIVE
    warning_threshold_m: float = 0.3
    assist_threshold_m: float = 0.4
    assist_strength_factor: float = 1.0

    # --- 計算結果を保持するフィールドは残す ---
    _last_lane_model: Optional[LaneModel] = field(default=None, init=False, repr=False)
    _last_vehicle_state: Optional[VehicleState] = field(default=None, init=False, repr=False)
    _current_relative_pos: Optional[LaneRelativePosition] = field(default=None, init=False, repr=False)
    _current_departure_state: DepartureState = field(default=DepartureState.UNCERTAIN, init=False, repr=False)

    # (activate, deactivate, suppress, resume メソッドは変更なし)
    def activate(self, mode: str = "ASSIST"): # 実装省略
        pass
    def deactivate(self): # 実装省略
        pass
    def suppress_by_driver(self): # 実装省略
        pass
    def resume_from_suppress(self): # 実装省略
        pass

    def update_and_decide(self, lane_model: LaneModel, vehicle_state: VehicleState,
                          lane_calculator: LaneCalculationService) # 👈 ドメインサービスを受け取る
            -> Tuple[WarningRequest, SteeringTorqueRequest]:
        """
        [集約の主要な振る舞い] (修正)
        センサー情報を受け取り、ドメインサービスを使って計算し、
        内部状態を更新し、警告と操舵トルクの要求を決定して返す。
        """
        print(f"[Aggregate Logic] Updating state for {self.vehicle_id} using Domain Service...")
        self._last_lane_model = lane_model
        self._last_vehicle_state = vehicle_state

        # 1. 内部状態の計算をドメインサービスに委譲 👈
        self._current_relative_pos = lane_calculator.calculate_relative_position(lane_model, vehicle_state)
        self._current_departure_state = lane_calculator.judge_departure_state(
            self._current_relative_pos, self.warning_threshold_m, self.assist_threshold_m
        )
        # (ログは委譲先で行われる)

        # 2. 現在のシステム状態に基づいて出力を決定 (このロジックは集約に残す)
        warning_req = WarningRequest.no_warning()
        torque_req = SteeringTorqueRequest.no_torque()

        if self.system_status == SystemStatus.ACTIVE_WARNING_ONLY or \\
           self.system_status == SystemStatus.ACTIVE_ASSISTING:

            if self._current_departure_state in [DepartureState.DRIFTING_LEFT, DepartureState.DRIFTING_RIGHT]:
                 warning_req = WarningRequest(level="LOW", type="HAPTIC")
                 print("[Aggregate Logic] Decision: LOW HAPTIC Warning requested.")

            if self.system_status == SystemStatus.ACTIVE_ASSISTING:
                 # 介入判断 (閾値との比較は集約の責任)
                 if abs(self._current_relative_pos.lateral_offset_m) >= self.assist_threshold_m:
                     # トルク計算 (これもDomain Serviceに切り出せる可能性あり)
                     required_torque = -1.0 * self._current_relative_pos.lateral_offset_m * self.assist_strength_factor
                     torque_req = SteeringTorqueRequest(torque_nm=required_torque)
                     print(f"[Aggregate Logic] Decision: Steering Torque requested: {torque_req.torque_nm:.2f} Nm.")
                     if warning_req.level == "LOW": warning_req = WarningRequest(level="HIGH", type="HAPTIC")

        # (elif self.system_status == SystemStatus.SUPPRESSED: ... etc. )

        return warning_req, torque_req

    # --- プライベートメソッドだった計算ロジックは削除 ---
    # def _calculate_relative_position(...): ... ❌削除
    # def _judge_departure_state(...): ... ❌削除

```

✅ **このステップのポイント**:

- 複雑な計算ロジック（相対位置計算、逸脱判定）を**ドメインサービス (`LaneCalculationService`)** に分離しました。
- `LaneKeepingAssist` 集約は、そのドメインサービスを**利用する**形に修正され、自身の主要な責務（状態管理、判断のオーケストレーション）に集中できるようになり、**クラスがスリム化**しました（SRPの向上）。
- 分離された計算ロジックは、`LaneCalculationService` として**独立してテスト**することが可能になりました。
- ドメインサービスを呼び出す際に、必要な情報（閾値など）を集約が引数として渡しています。

---

## 📝 まとめ

このステップでは、`LaneKeepingAssist` 集約の永続化のための**リポジトリインターフェース**とその**インメモリ実装**を定義しました。

さらに、集約内にあった複雑な計算ロジックを**ドメインサービス (`LaneCalculationService`)** として切り出すことで、集約の**単一責任の原則(SRP)を高め、計算ロジックの独立したテスト**を可能にする、という設計改善を行いました。

---

## ➡️ 次へ

これでドメインモデルと永続化、そして計算ロジックの分離ができました。最後のステップ「**(Step 5) モデルの一部をコード化 (UseCaseとMain)**」に進み、これらの部品を組み合わせてシステムを動作させてみましょう。