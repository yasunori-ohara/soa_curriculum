# 05 モデルの一部をコード化

# ステップ５：モデルの一部をコード化 (UseCaseとMain) ⚙️🚀

これまでのステップで定義・実装したドメインモデル（集約、値オブジェクト）とリポジトリを使って、いよいよ「会議室を予約する」という具体的な**UseCase**を実装し、それを[**main.py**](http://main.py/)から呼び出して実行してみましょう。

---

## ⚙️ 1. UseCase の実装 - 予約フローの実現

📝 **課題**: 「利用者ID、予約したい会議室ID、開始日時、終了日時」を受け取り、①会議室が存在するか、②その時間帯が会議室の予約可能ルールに合致するか、③その時間帯に既に他の予約がないかを確認し、問題なければ新しい予約を作成して保存する、という一連の**アプリケーション固有のフロー**が必要です。

💡 **解決策**: このフローの責任を持つ「UseCase」を実装します。これはCA（クリーンアーキテクチャ）の UseCase と同じ役割です。UseCase はリポジトリインターフェースに依存し、ドメインオブジェクト（`MeetingRoom`, `Reservation`, `TimeRange`）を利用してロジックを実行します。

**ファイル:** `application/use_cases.py` (新規作成または追記)

```python
# application/use_cases.py
from application.boundaries import MeetingRoomRepositoryInterface, ReservationRepositoryInterface
from domain.value_objects import TimeRange # 値オブジェクトを利用
from domain.aggregates import Reservation # 生成する集約
from datetime import datetime
from typing import Optional # 戻り値用

# (他のUseCaseがあればこのファイルに追加していく)

# -----------------------------------------------------------------------------
# Book Meeting Room Use Case
# - CAの Use Cases 層と同じ役割
# - アプリケーション固有のビジネスフローを担当
# - Repository Interface や Domain Objects を利用する
# -----------------------------------------------------------------------------
class BookMeetingRoomUseCase:
    """会議室を予約するユースケース"""
    def __init__(self,
                 meeting_room_repo: MeetingRoomRepositoryInterface, # 会議室永続化の窓口
                 reservation_repo: ReservationRepositoryInterface): # 予約永続化の窓口
        # 必要な依存オブジェクト(インターフェース)をコンストラクタで受け取る (DI)
        self._meeting_room_repo = meeting_room_repo
        self._reservation_repo = reservation_repo

    def handle(self, user_id: str, room_id: str, start_dt: datetime, end_dt: datetime) -> Optional[str]:
        """
        ユースケースを実行する。
        Args:
            user_id: 予約者のID
            room_id: 予約する会議室のID
            start_dt: 予約開始日時
            end_dt: 予約終了日時
        Returns:
            成功した場合は生成された予約ID、失敗した場合はNone (または例外送出)
        """
        print(f"[UseCase] Attempting to book room {room_id} for user {user_id} from {start_dt} to {end_dt}")

        # 1. 入力から値オブジェクトを生成 (形式・前後関係検証)
        try:
            requested_range = TimeRange(start_datetime=start_dt, end_datetime=end_dt)
        except ValueError as e:
            print(f"[UseCase] Invalid time range provided: {e}")
            return None # または raise

        # --- トランザクション管理の開始 (概念) ---
        print("[UseCase] --- Transaction Start (Conceptual) ---")
        try:
            # 2. 会議室集約を取得し、存在と予約可能ルールをチェック
            print(f"[UseCase] Finding meeting room {room_id}...")
            meeting_room = self._meeting_room_repo.find_by_id(room_id)
            if not meeting_room:
                print(f"[UseCase] Meeting room {room_id} not found.")
                raise ValueError(f"Meeting room {room_id} not found.")

            # MeetingRoom集約のメソッドで予約可能ルールをチェック
            if not meeting_room.can_book(requested_range):
                print(f"[UseCase] Room {room_id} cannot be booked for the requested time range based on room rules.")
                raise ValueError("Requested time range is not bookable for this room.")

            # 3. 重複予約チェック (リポジトリを利用)
            print(f"[UseCase] Checking for overlapping reservations...")
            overlapping_reservations = self._reservation_repo.find_by_room_and_time(room_id, requested_range)
            if overlapping_reservations:
                print(f"[UseCase] Found {len(overlapping_reservations)} overlapping reservations.")
                raise ValueError("The requested time slot is already booked.")

            # 4. 新しい予約(Reservation)集約を生成
            #    (今回はシンプルな生成なのでFactoryは使わないが、使っても良い)
            print("[UseCase] Creating new reservation...")
            new_reservation = Reservation(
                room_id=room_id,
                user_id=user_id,
                time_range=requested_range
                # reservation_id は Reservation クラス内で自動生成
            )

            # 5. 生成した予約集約をリポジトリを使って保存
            print(f"[UseCase] Saving new reservation {new_reservation.reservation_id}...")
            self._reservation_repo.save(new_reservation)

            # --- トランザクションのコミット (概念) ---
            print("[UseCase] --- Transaction Commit (Conceptual) ---")
            print(f"[UseCase] Room {room_id} booked successfully. Reservation ID: {new_reservation.reservation_id}")

            # 成功した場合は予約IDを返す
            return new_reservation.reservation_id

        except Exception as e:
            # --- トランザクションのロールバック (概念) ---
            print(f"[UseCase] Error during booking: {e}")
            print("[UseCase] --- Transaction Rollback (Conceptual) ---")
            # (エラーをログに記録するなど)
            # raise # エラーを上位に伝えるか、Noneを返すかなどの設計判断
            return None

```

✅ **このステップのポイント**:

- UseCase は CA と同じく、**ビジネスフローの調整役**です。
- **リポジトリ**を使って必要な集約（`MeetingRoom`, `Reservation`）を取得・保存します。
- ドメインオブジェクト（`MeetingRoom.can_book`, `TimeRange`）を利用してドメインルール（予約可能時間、重複チェック）を検証します。
- 新しい `Reservation` 集約を生成し、保存します。
- **トランザクション管理**（今回は概念のみ）の責務を持ちます。

---

## 🚀 2. 実行ファイル ([main.py](http://main.py/)) の作成 - 全体の組み立てと実行

📝 **課題**: 作成した UseCase を実行し、システム全体（今回はインメモリですが）が動作することを確認する「起点」が必要です。

💡 **解決策**: `main.py` で、具体的なリポジトリ実装を生成し、それらを UseCase に注入（DI）して、UseCase を呼び出します。

**ファイル:** `main.py` (プロジェクトルート、または `app/` など)

```python
# main.py
from adapters.repositories import InMemoryMeetingRoomRepository, InMemoryReservationRepository # 👈 実装
from application.use_cases import BookMeetingRoomUseCase # 👈 UseCase
from domain.aggregates import MeetingRoom # 初期データ用
from datetime import datetime, timedelta # 初期データ・テスト用

# -----------------------------------------------------------------------------
# Main Application / Composition Root
# - CAの最も外側の層 (Frameworks & Drivers) と同じ役割
# - 依存関係の解決 (DI) とアプリケーションの起動を行う
# -----------------------------------------------------------------------------
if __name__ == "__main__":
    print("--- Conference Room Booking Example ---")

    # --- 依存関係の解決 (Dependency Injection) ---
    print("\\n--- Wiring dependencies (DI) ---")
    meeting_room_repo = InMemoryMeetingRoomRepository()
    reservation_repo = InMemoryReservationRepository()
    book_meeting_room_use_case = BookMeetingRoomUseCase(meeting_room_repo, reservation_repo)
    print("--- Dependencies wired successfully ---")

    # --- 初期データ投入 ---
    print("\\n--- Setting up initial data (Meeting Rooms) ---")
    room1 = MeetingRoom(name="Room A", capacity=10)
    room2 = MeetingRoom(name="Room B", capacity=5)
    meeting_room_repo.save(room1)
    meeting_room_repo.save(room2)
    room1_id = room1.room_id
    room2_id = room2.room_id
    print(f"Room A created with ID: {room1_id}")
    print(f"Room B created with ID: {room2_id}")

    # --- UseCaseの実行 (成功例) ---
    print("\\n--- Executing UseCase (Success Case) ---")
    user_id = "user-001"
    start_time_1 = datetime(2025, 10, 23, 10, 0, 0) # 10:00
    end_time_1 = start_time_1 + timedelta(hours=1) # 11:00

    reservation_id_1 = book_meeting_room_use_case.handle(user_id, room1_id, start_time_1, end_time_1)
    if reservation_id_1:
        print(f"Booking successful! Reservation ID: {reservation_id_1}")
    else:
        print("Booking failed.")

    # --- UseCaseの実行 (失敗例: 重複) ---
    print("\\n--- Executing UseCase (Overlapping Booking Attempt) ---")
    start_time_2 = datetime(2025, 10, 23, 10, 30, 0) # 10:30 (最初の予約と重複)
    end_time_2 = start_time_2 + timedelta(hours=1) # 11:30

    reservation_id_2 = book_meeting_room_use_case.handle(user_id, room1_id, start_time_2, end_time_2)
    if reservation_id_2:
        print(f"Booking successful! Reservation ID: {reservation_id_2}")
    else:
        print("Booking failed as expected (Overlapping).")

    # --- UseCaseの実行 (失敗例: 時間外) ---
    print("\\n--- Executing UseCase (Outside Operating Hours) ---")
    start_time_3 = datetime(2025, 10, 23, 8, 0, 0) # 8:00 (早すぎる)
    end_time_3 = start_time_3 + timedelta(hours=1) # 9:00

    reservation_id_3 = book_meeting_room_use_case.handle(user_id, room1_id, start_time_3, end_time_3)
    if reservation_id_3:
        print(f"Booking successful! Reservation ID: {reservation_id_3}")
    else:
        print("Booking failed as expected (Outside hours).")

    # --- 最終結果の確認 (リポジトリから取得) ---
    print("\\n--- Verifying Final State ---")
    # room1 の 10:00-11:00 の予約が1件だけ存在することを確認
    verify_range = TimeRange(start_time_1, end_time_1)
    final_reservations = reservation_repo.find_by_room_and_time(room1_id, verify_range)
    print(f"Reservations found for Room A between 10:00-11:00: {len(final_reservations)}") # -> 1
    if final_reservations:
        print(f" - Reservation ID: {final_reservations[0].reservation_id}")

```

✅ **このステップのポイント**:

- `main.py` が依存関係を組み立て、`BookMeetingRoomUseCase` を呼び出して動作を確認しました。
- UseCase がドメインルール（予約可能時間、重複）を正しくチェックし、成功・失敗ケースを処理できることを確認しました。

---

## 📝 この演習のまとめ

この演習では、「会議室予約」というドメインを題材に、DDDの戦術的パターンを適用するプロセスを体験しました。

1. **ユビキタス言語**: 「会議室」「予約」「予約時間帯」といった言葉を特定しました。
2. **集約**: 「`MeetingRoom`」と「`Reservation`」を一貫性の単位として定義しました。
3. **値オブジェクト**: 「`TimeRange`」を定義し、時間帯に関するルールと振る舞いをカプセル化しました。
4. **リポジトリ**: 集約の永続化を抽象化しました。
5. **UseCase**: ドメインモデルとリポジトリを利用して、予約作成のビジネスフローを実装しました（重複チェック含む）。

これらのパターンを組み合わせることで、ドメインのルールがコードに明確に反映され、変更に強く、テストしやすい設計の基礎が築けることを確認できたかと思います。