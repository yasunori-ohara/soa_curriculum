# 04 リポジトリ、ドメインサービス等の検討

# ステップ４：リポジトリ、ドメインサービス等の検討 💾⚙️

Step 3 で集約 (`MeetingRoom`, `Reservation`) と値オブジェクト (`TimeRange`) を洗練させました。このステップでは、これらのドメインモデルを**永続化**するための**リポジトリ (Repository)** を定義し、また、特定の集約に属さないドメインロジック（もしあれば）を担う**ドメインサービス (Domain Service)** の必要性を検討します。

---

## 💾 1. リポジトリ (Repository) の定義と実装 - 永続化の抽象化

📝 **課題**: 作成・変更した `MeetingRoom` や `Reservation` 集約を、メモリ外（データベース、ファイルなど）に保存したり、後で検索したりする必要があります。しかし、ドメインモデル（集約）や UseCase が、具体的な保存方法（SQL、DBドライバAPIなど）を知るべきではありません（CAの原則）。

💡 **解決策**: 各集約ルートに対して**リポジトリ (`Repository`)** パターンを適用します。永続化操作の**インターフェース**を定義し、具体的な実装を **Adapters 層**に隠蔽します。

**ファイル:** `application/boundaries.py` (追記)

```python
# application/boundaries.py
from abc import ABC, abstractmethod
from domain.aggregates import MeetingRoom, Reservation # 永続化対象の集約
from domain.value_objects import TimeRange # 検索で使う可能性
from typing import Optional, List # Listを追加

# -----------------------------------------------------------------------------
# MeetingRoom Repository Interface
# - DDD戦術的設計の Repository Interface
# - CAの Application 層 (境界定義)
# -----------------------------------------------------------------------------
class MeetingRoomRepositoryInterface(ABC):
    """MeetingRoom集約の永続化を抽象化するインターフェース"""
    @abstractmethod
    def find_by_id(self, room_id: str) -> Optional[MeetingRoom]:
        """IDでMeetingRoom集約を検索する"""
        raise NotImplementedError

    @abstractmethod
    def save(self, meeting_room: MeetingRoom):
        """MeetingRoom集約を保存する"""
        raise NotImplementedError

    @abstractmethod
    def find_all(self) -> List[MeetingRoom]:
        """全てのMeetingRoomを取得する (例)"""
        raise NotImplementedError

# -----------------------------------------------------------------------------
# Reservation Repository Interface
# - DDD戦術的設計の Repository Interface
# - CAの Application 層 (境界定義)
# -----------------------------------------------------------------------------
class ReservationRepositoryInterface(ABC):
    """Reservation集約の永続化を抽象化するインターフェース"""
    @abstractmethod
    def find_by_id(self, reservation_id: str) -> Optional[Reservation]:
        """IDでReservation集約を検索する"""
        raise NotImplementedError

    @abstractmethod
    def save(self, reservation: Reservation):
        """Reservation集約を保存する"""
        raise NotImplementedError

    @abstractmethod
    def find_by_room_and_time(self, room_id: str, time_range: TimeRange) -> List[Reservation]:
        """指定した会議室と時間帯に重複する予約を検索する (重複チェック用)"""
        raise NotImplementedError

    # (必要であれば find_by_user などのメソッドも追加)

```

**ファイル:** `adapters/repositories.py` (新規作成または追記)

```python
# adapters/repositories.py
from application.boundaries import MeetingRoomRepositoryInterface, ReservationRepositoryInterface
from domain.aggregates import MeetingRoom, Reservation
from domain.value_objects import TimeRange
from typing import Optional, List, Dict # Dictを追加
import copy

# -----------------------------------------------------------------------------
# In-Memory MeetingRoom Repository Implementation
# - DDD戦術的設計の Repository Implementation
# - CAの Adapters 層
# -----------------------------------------------------------------------------
class InMemoryMeetingRoomRepository(MeetingRoomRepositoryInterface):
    """MeetingRoom集約をメモリ上の辞書で保持するリポジトリ実装"""
    def __init__(self):
        self._rooms: Dict[str, MeetingRoom] = {} # room_id をキーとする辞書

    def find_by_id(self, room_id: str) -> Optional[MeetingRoom]:
        print(f"[Adapter] InMemoryRepo: Finding room {room_id}")
        room = self._rooms.get(room_id)
        return copy.deepcopy(room) if room else None

    def save(self, meeting_room: MeetingRoom):
        print(f"[Adapter] InMemoryRepo: Saving room {meeting_room.room_id} ({meeting_room.name})")
        self._rooms[meeting_room.room_id] = copy.deepcopy(meeting_room)

    def find_all(self) -> List[MeetingRoom]:
        print("[Adapter] InMemoryRepo: Finding all rooms")
        return list(self._rooms.values()) # コピーを返すのが望ましいが簡略化

# -----------------------------------------------------------------------------
# In-Memory Reservation Repository Implementation
# - DDD戦術的設計の Repository Implementation
# - CAの Adapters 層
# -----------------------------------------------------------------------------
class InMemoryReservationRepository(ReservationRepositoryInterface):
    """Reservation集約をメモリ上の辞書で保持するリポジトリ実装"""
    def __init__(self):
        self._reservations: Dict[str, Reservation] = {} # reservation_id をキー

    def find_by_id(self, reservation_id: str) -> Optional[Reservation]:
        print(f"[Adapter] InMemoryRepo: Finding reservation {reservation_id}")
        res = self._reservations.get(reservation_id)
        return copy.deepcopy(res) if res else None

    def save(self, reservation: Reservation):
        print(f"[Adapter] InMemoryRepo: Saving reservation {reservation.reservation_id} for room {reservation.room_id}")
        self._reservations[reservation.reservation_id] = copy.deepcopy(reservation)

    def find_by_room_and_time(self, room_id: str, time_range: TimeRange) -> List[Reservation]:
        """指定会議室・時間帯の重複予約を検索 (メモリ実装)"""
        print(f"[Adapter] InMemoryRepo: Finding overlapping reservations for room {room_id} at {time_range.start_datetime}-{time_range.end_datetime}")
        overlapping = []
        for res in self._reservations.values():
            # ステータスがキャンセル済みでなく、部屋が一致し、時間帯が重複するか
            if res.status != "CANCELLED" and \\
               res.room_id == room_id and \\
               res.time_range.overlaps_with(time_range):
                overlapping.append(copy.deepcopy(res))
        print(f"[Adapter] InMemoryRepo: Found {len(overlapping)} overlapping reservations.")
        return overlapping

```

✅ **このステップのポイント**:

- 各集約ルート (`MeetingRoom`, `Reservation`) に対して、永続化を抽象化する**リポジトリインターフェース**を定義しました。
- 具体的な実装（今回はインメモリ）を **Adapters 層**に隠蔽しました。
- `ReservationRepository` には、重複予約チェックのために特定の部屋と時間帯で予約を検索するメソッド (`find_by_room_and_time`) を追加しました。これは UseCase が利用します。

---

## ⚙️ 2. ドメインサービス (Domain Service) の必要性検討

📝 **課題**: ステップ2で議論した「重複予約チェック」ロジックは、単一の集約（`MeetingRoom` または `Reservation`）の責務とするのは不自然でした。これはドメインサービスが担当すべきでしょうか？

💡 **検討**:
「指定された会議室の、指定された時間帯に、既に予約が存在しないか確認する」という操作は、複数の `Reservation` 集約（の状態）を参照する必要があります。これは、個々の `Reservation` 集約が持つべき知識を超えています。

**選択肢**:

1. **ドメインサービス (`BookingPolicyService` など)**:
重複チェックロジックをカプセル化するドメインサービスを作成する。UseCase はこのサービスを呼び出して予約可否を判断する。
    - **メリット**: ドメイン固有の重要なルール（予約ポリシー）がドメイン層に明示的に表現される。
    - **デメリット**: 少し設計が複雑になる。
2. **UseCase が調整する**:
UseCase が `ReservationRepository` の `find_by_room_and_time` メソッドを呼び出し、結果が空でなければ予約不可と判断する。
    - **メリット**: 設計がシンプル。
    - **デメリット**: 重複チェックというドメインルールが UseCase（アプリケーション層）に少し漏れ出す形になる。

**今回の判断**:
今回は比較的シンプルなドメインであり、重複チェックのロジックも「リポジトリで検索して結果を見る」だけで実現できるため、**UseCase が調整する（選択肢2）** アプローチを採用します。より複雑な予約ルール（例：役職による優先度、部署ごとの利用制限など）が出てきた場合には、ドメインサービスの導入を検討するのが良いでしょう。

✅ **このステップのポイント**:

- ドメインサービスは、「特定の集約に属さないドメインロジック」のためのパターンですが、**常に必要とは限りません**。
- UseCase がリポジトリなどを利用して調整することで十分に実現できる場合は、無理にドメインサービスを導入しなくても良い場合があります。今回は重複チェックを UseCase の責務と判断しました。

---

## 📝 まとめ

このステップでは、ドメインモデル（集約）を永続化するための**リポジトリインターフェース**とその**インメモリ実装**を定義しました。これにより、UseCase は具体的な永続化方法を知ることなく、集約を保存・取得できるようになります。

また、**ドメインサービス**の必要性を検討し、今回の「重複予約チェック」については UseCase がリポジトリを使って実現する、という設計判断を行いました。

---

## ➡️ 次へ

これでドメインモデルと永続化の準備が整いました。いよいよ最後のステップ「**(Step 5) モデルの一部をコード化 (UseCaseとMain)**」に進み、これらの部品を組み合わせて「会議室を予約する」という UseCase を実装してみましょう。