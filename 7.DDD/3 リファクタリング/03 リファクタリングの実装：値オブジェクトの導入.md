# 03 リファクタリングの実装：値オブジェクトの導入

# ステップ３：リファクタリングの実装：値オブジェクトの導入 💎

Step 2 で決定した改善方針に基づき、実際にコードのリファクタリングを開始します。最初のステップとして、課題となっていた**値オブジェクト (Value Object)** を導入します。

## 🤔 なぜ値オブジェクトから？

値オブジェクトはドメインモデルの基礎となる部品であり、他の部品（エンティティ、リポジトリ）のインターフェースや実装にも影響を与えます。先に値オブジェクトを定義することで、その後のリファクタリングがスムーズに進みます。

---

### 💎 1. `ISBN` 値オブジェクトの作成

📝 **課題**: ISBNが単なる文字列 (`str`) で扱われており、形式チェックがされていない。

💡 **改善**: `ISBN` 値オブジェクトを作成し、不変性と形式検証ルールをカプセル化します。

**ファイル:** `domain/value_objects.py` (新規作成または追記)

```python
# domain/value_objects.py
from dataclasses import dataclass

# -----------------------------------------------------------------------------
# ISBN Value Object
# - DDD戦術的設計の Value Object
# - CAの Entities 層 (ドメインの核となるルールの一部)
# -----------------------------------------------------------------------------
@dataclass(frozen=True) # 不変 (Immutable) を保証
class ISBN:
    """ISBNコードを表す値オブジェクト"""
    value: str

    def __post_init__(self):
        """ISBN形式を検証 (簡易版 - ISBN-13桁のみ想定)"""
        print(f"[VO Check] Validating ISBN: {self.value}")
        # ハイフンを除去して数字のみにする
        cleaned_value = self.value.replace("-", "")
        # 長さチェックと数値チェック
        if not (cleaned_value.isdigit() and len(cleaned_value) == 13):
            raise ValueError(f"Invalid ISBN format: {self.value}. Should be 13 digits (hyphens optional).")
        # (チェックデジット検証を追加すると、より堅牢になる)
        print("[VO Check] ISBN is valid.")

    def format_with_hyphens(self) -> str:
        """ハイフン付き形式で返すメソッド (例)"""
        # (実際のISBNフォーマットルールに従う必要がある)
        return self.value # ここでは単純に元の値を返す

```

✅ **効果**: これ以降、コード内で `ISBN` 型を使う箇所では、常に正しい形式（13桁数字）であることが保証されます。`Book` エンティティの `isbn` 属性の型も `str` から `ISBN` に変更します（次のステップで実施）。

---

### 💎 2. `LoanPeriod` 値オブジェクトの作成

📝 **課題**: 貸出期間が `borrow_date` と `due_date` という2つの `datetime` 属性で表現されており、関連するルール（終了日は開始日より後、期間計算）がカプセル化されていない。

💡 **改善**: `LoanPeriod` 値オブジェクトを作成し、開始日・終了日を保持し、不変性とルール（終了日 \> 開始日）、期間計算ロジックをカプセル化します。

**ファイル:** `domain/value_objects.py` (追記)

```python
# domain/value_objects.py
# (ISBN definition...)
from datetime import date, timedelta # dateとtimedeltaを使用

# -----------------------------------------------------------------------------
# LoanPeriod Value Object
# - DDD戦術的設計の Value Object
# - CAの Entities 層
# -----------------------------------------------------------------------------
@dataclass(frozen=True)
class LoanPeriod:
    """貸出期間を表す値オブジェクト"""
    start_date: date
    end_date: date
    # (例: デフォルトの貸出期間をクラス変数として定義)
    DEFAULT_LOAN_DAYS = 14

    def __post_init__(self):
        """自己検証：終了日は開始日より後でなければならない"""
        print(f"[VO Check] Validating LoanPeriod: {self.start_date} to {self.end_date}")
        if self.start_date >= self.end_date:
            raise ValueError("End date must be after start date.")
        print("[VO Check] LoanPeriod is valid.")

    def get_duration_days(self) -> int:
        """貸出期間の日数を計算する"""
        return (self.end_date - self.start_date).days

    @staticmethod
    def create_default(start_date: date) -> 'LoanPeriod':
        """開始日からデフォルト期間(例:2週間)の貸出期間を生成するファクトリメソッド"""
        end_date = start_date + timedelta(days=LoanPeriod.DEFAULT_LOAN_DAYS)
        print(f"[VO Factory] Creating default LoanPeriod starting {start_date}")
        return LoanPeriod(start_date=start_date, end_date=end_date)

    def is_overdue(self, current_date: date) -> bool:
        """指定された日付時点で延滞しているか"""
        return current_date > self.end_date

```

✅ **効果**: `Loan` エンティティは、2つの `datetime` の代わりに `LoanPeriod` オブジェクトを一つ持つだけで済みます。期間の妥当性は `LoanPeriod` が保証し、期間計算や延滞チェックのロジックも `LoanPeriod` 内に集約されます。

---

### 💎 3. `UserName` 値オブジェクトの作成

📝 **課題**: 利用者名 (`User.name`) が単なる `str` で、空文字列などが許容されている可能性がある。

💡 **改善**: `UserName` 値オブジェクトを作成し、空でないことを保証します（文字数制限なども追加可能）。

**ファイル:** `domain/value_objects.py` (追記)

```python
# domain/value_objects.py
# (ISBN, LoanPeriod definitions...)

# -----------------------------------------------------------------------------
# UserName Value Object
# - DDD戦術的設計の Value Object
# - CAの Entities 層
# -----------------------------------------------------------------------------
@dataclass(frozen=True)
class UserName:
    """利用者名を表す値オブジェクト"""
    value: str
    MAX_LENGTH = 100 # 例: 最大文字数

    def __post_init__(self):
        print(f"[VO Check] Validating UserName: '{self.value}'")
        if not self.value:
            raise ValueError("User name cannot be empty.")
        if len(self.value) > self.MAX_LENGTH:
            raise ValueError(f"User name cannot exceed {self.MAX_LENGTH} characters.")
        print("[VO Check] UserName is valid.")

```

✅ **効果**: `User` エンティティの `name` 属性の型を `UserName` に変更することで（次のステップで実施）、`User` オブジェクトが常に空でない（かつ長すぎない）名前を持つことが保証されます。

---

### 🧱 次のステップへの影響

このステップで定義した値オブジェクト (`ISBN`, `LoanPeriod`, `UserName`) は、次のステップで**エンティティ** (`Book`, `Loan`, `User`) の属性の型として使用されます。これにより、エンティティクラス自体のコードがよりシンプルになり、ドメインの概念がコード上でより明確に表現されるようになります。

---

## 📝 まとめ

このステップでは、図書館システムのドメインにおける重要な概念（ISBN、貸出期間、利用者名）を、単なる基本型ではなく**値オブジェクト**として定義しました。

各値オブジェクトに**不変性**と**自己検証**のルールを適用することで、

- コードの**表現力**を高め（`str` ではなく `ISBN` 型）、
- **不正なデータ**がドメインモデルに混入するのを防ぎ、
- 関連する**ドメインルールやロジック**（形式チェック、期間計算など）をカプセル化する
ことができました。

これは、ドメインモデル全体の**堅牢性**と**保守性**を高めるための重要な第一歩です。

---

## ➡️ 次へ

次は、作成した値オブジェクトを使って、「**(Step 4) リファクタリングの実装：エンティティ/集約の責務明確化**」に進み、`Book` や `Loan` エンティティの振る舞いを改善していきましょう。