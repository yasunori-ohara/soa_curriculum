## 🖼️ 道具を探す

監視用HDDレコーダーという具体的な題材を使って、これまで学んだ戦術的設計の道具（値オブジェクト、集約、リポジトリ）をどのように見つけ出し、適用していくか、思考訓練を始めましょう。


この仕様からは、まず`解像度`や`録画セグメント`といった**値オブジェクト**を定義します。次に、一貫性を保つべきまとまりとして、個々のカメラ設定を管理する**`Camera`集約**と、録画データの保存や上書きという最も複雑なルールを管理する**`Storage`集約**という2つの主要な集約を設計するのが良いアプローチです。

***

### 道具1：値オブジェクト - 仕様書の「言葉」に意味とルールを与える

まず、仕様書に出てくる「言葉」の中から、単なる文字列や数値ではなく、特定のルールや意味を持つものを探し出し、**値オブジェクト**として定義していきます。

* **`CameraId`**:
    カメラを識別するためのID。「1〜16の整数」というルールを持ちます。ただの`int`ではなく、`CameraId(1)`のように型として定義します。

* **`Resolution` (解像度)**, **`FrameRate` (記録枚数)**:
    「低・中・高」や「30, 20, ... fps」のように、**選択肢が限定**されています。これらをEnumや専用のクラスにすることで、`Resolution('超高画質')`のような不正な値を設定できなくします。

* **`RecordingType`**:
    録画の種類を区別するための型。「通常」「アラーム」「緊急」の3種類が考えられます。

* **`ProtectedStorage` (保護領域)**:
    「全体の10%」といった割合と、実際の容量（ギガバイト）を計算するロジックをカプセル化できます。

* **`RecordingSegment` (録画セグメント)**:
    これは非常に重要な、少しリッチな値オブジェクト（または集約内のエンティティ）です。録画データの断片であり、以下の情報を持ちます。
    * `start_time`, `end_time`
    * `camera_id`
    * `recording_type`
    * `is_protected` (保護されているかどうかのフラグ)

---
### 道具2：集約 - 「一貫性」の責任者を決める

次に、仕様書の中核となるビジネスルール、特に「**何かを変更したら、こちらも必ず変更されなければならない**」という一貫性が求められる箇所を探し、**集約**の境界を定義します。

#### 集約候補1：`Camera`集約



* **集約ルート**: `Camera`
* **責務**: **一台のカメラに関する設定の一貫性**を保つ。
* **内包するもの**: `CameraId`, `Resolution`, `FrameRate`, `TimerSchedule`オブジェクトなど。
* **振る舞い (メソッド)**:
    * `change_settings(resolution, frame_rate)`: 解像度と記録枚数の組み合わせに制限がある場合、このメソッド内でルールをチェックします。
    * `update_schedule(schedule)`: タイマースケジュールを更新します。

`Camera`ごとに設定が独立しているため、これは自然な集約の単位です。

#### 集約候補2：`Storage`集約



これがこのシステムで最も重要で、最も複雑なルールを持つ集約です。

* **集約ルート**: `Storage`
* **責務**: **HDD全体の録画セグメントを管理し、ループ録画と保護領域のルールを強制する**。
* **内包するもの**: `List<RecordingSegment>`（すべての録画セグメントのリスト）、`ProtectedStorage`（保護領域の設定）。
* **振る舞い (メソッド)**:
    * `add_segment(segment: RecordingSegment)`:
        このメソッドが、**通常録画とアラーム録画**で使われるメインの入り口です。内部で以下の複雑なロジックをすべて実行します。
        1. HDDの空き容量をチェックする。
        2. 空き容量がなければ、**保護されていない (`is_protected == False`) 最も古いセグメント**を見つけ出す。
        3. その古いセグメントを削除（上書き）し、新しいセグメントを追加する。
    * `add_emergency_segment(segment: RecordingSegment)`:
        **緊急アラーム録画**で使われる専用の入り口です。
        1. 保護領域の空き容量をチェックする。
        2. 空きがあれば、セグメントを`is_protected = True`として追加する。
        3. 空きがなければ、例外（`ProtectedStorageFullError`）を発生させ、録画失敗を通知する。
    * `find_segments_by_time(...)`, `find_alarm_segments()`:
        再生・検索機能のために、管理しているセグメントのリストから必要なものを探し出して返す。

この`Storage`集約を設計することで、**ループ録画という最も複雑なロジック**が、このクラスの中に完全にカプセル化されます。
`RecordingUseCase`のような利用者は、ループ録画の仕組みを一切知る必要がなく、ただ「この録画セグメントを追加してくれ」と`Storage`集約にお願いするだけで済むのです。