## 第1章：集約 (Aggregate) の専門家である

リポジトリが単なるデータアクセスの仕組みと一線を画す最初のポイントは、リポジトリが扱う対象が、単なる「データ」ではなく「集約 (Aggregate)」であるという点です。

### 👎 やってはいけない実装：UseCaseが「組み立て職人」になる

リポジトリが集約の概念を知らない場合、`Book`と`Review`のデータを別々に返し、UseCaseがそれらを組み立てる責任を負うことになります。

```python
#
# 良くない例：リポジトリがバラバラの部品を返す
#
class NaiveBookRepository:
    def find_book_data(self, book_id: str) -> dict:
        # booksテーブルからBookの基本情報を取得
        # 例: {'id': 'b-123', 'title': 'DDD入門'}
        pass

    def find_reviews_data(self, book_id: str) -> list[dict]:
        # reviewsテーブルから、その本に関連するレビューをすべて取得
        # 例: [{'user_id': 'u-1', 'rating': 5}, {'user_id': 'u-2', 'rating': 4}]
        pass

# UseCaseの責任が非常に重くなる
class SomeUseCase:
    def execute(self, book_id: str):
        # 1. バラバラの部品（データ）をリポジトリから受け取る
        book_data = self._book_repo.find_book_data(book_id)
        reviews_data = self._book_repo.find_reviews_data(book_id)

        # 2. UseCaseが、部品を元にオブジェクトを組み立てる責任を持つ
        #    この「組み立て方」の知識がUseCaseに漏れ出してしまっている
        review_objects = [Review(**data) for data in reviews_data]
        
        book = Book(
            id=book_data['id'],
            title=book_data['title'],
            reviews=review_objects # 手動でセット
        )
        book._recalculate_average_rating() # 平均点の計算もUseCaseが呼び出す必要がある？
        
        # ...
```

この実装では、`Book`集約を正しく組み立てるための知識（`reviews`をセットして、平均点を再計算する、など）がUseCaseに漏れ出しています。もし`Book`の構造が変われば、このUseCaseも修正が必要になり、非常に脆い設計です。

### 👍 あるべき姿：リポジトリが「組み立ての専門家」

DDDのリポジトリは、**集約を復元するために必要なすべての処理**を内部にカプセル化し、常に完全な状態の集約オブジェクトを返します。

```python
#
# 良い例：リポジトリが集約の専門家
#
class IBookRepository(ABC):
    # 戻り値は、Reviewもすべて内包した完全なBook集約オブジェクト
    @abstractmethod
    def find_by_id(self, book_id: str) -> Book:
        pass

    @abstractmethod
    def save(self, book: Book):
        pass

# リポジトリの実装（インフラ層）
class PostgresBookRepository(IBookRepository):
    def find_by_id(self, book_id: str) -> Book:
        # --- 組み立ての複雑な処理は、すべてリポジトリ内部で行う ---
        # 1. booksテーブルとreviewsテーブルをJOINしてデータを取得
        # 2. 取得したデータを元にReviewオブジェクトのリストを作成
        # 3. 最後にBookオブジェクトを生成し、Reviewのリストを渡す
        # 4. 完全に組み立てられたBookオブジェクトを返す
        # ---
        pass

# UseCaseは組み立て方を一切知らない
class LendBookUseCase:
    def execute(self, book_id: str):
        # 1. リポジトリから、完全に組み立て済みのBook集約を受け取る
        #    このbookは、Reviewリストも平均評価点もすべて正しい状態
        book = self._book_repo.find_by_id(book_id)

        # 2. UseCaseは安心して集約の振る舞いを呼び出すだけ
        book.lend() # 例
        
        # 3. 変更があった集約を丸ごとリポジトリに渡す
        self._book_repo.save(book)
```

この設計では、UseCaseは「`Book`と`Review`が別々のテーブルに保存されている」といったデータベースの都合を一切知る必要がありません。UseCaseにとって、`Book`は常に`Review`と一体の、一つのオブジェクトとして見えています。

リポジトリが「集約の専門家」であることにより、UseCaseはデータベースから来たデータが**不完全であったり、不正であったりする可能性を一切考慮する必要がなくなります**。リポジトリは、ビジネスルールを満たした**完全な集約オブジェクトを届けること**を契約として保証してくれるのです。

### プラモデルの組み立てに例える 🤖

  * **良くないリポジトリ**: ロボット本体の部品が入った箱と、武器セットの部品が入った箱を**別々に**渡してきます。「あとは君が説明書を読んで、武器を本体に正しく取り付けてくれたまえ」というスタンスです。

  * **良いリポジトリ**: 専門家がロボット本体も武器もすべて完璧に組み立て、**完成品のロボット**を渡してくれます。あなたはそれを手に取って、すぐにポーズを取らせて（メソッドを呼び出して）遊ぶことができます。

リポジトリが「集約の組み立て専門家」として振る舞うことで、UseCaseは永続化の複雑さから解放され、本来のビジネスロジックの指揮という仕事に集中できるのです。

