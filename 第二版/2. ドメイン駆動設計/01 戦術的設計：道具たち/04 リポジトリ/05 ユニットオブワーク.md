### 発展テーマ：「Unit of Work」とは？

これは、**複数のリポジトリをまたがる変更を、一つのトランザクションとしてまとめる**ためのパターンです。

#### 🤔 どんな問題を解決するのか？

`LendBookUseCase`を思い出してください。このユースケースでは、2つの集約（`Book`と`Member`）の状態が変更されます。

```python
class LendBookUseCase:
    def execute(self, book_id: str, member_id: str):
        # ...
        book.lend()
        member.note_borrowed()
        
        # 2回もsaveを呼ばないといけない…
        self._book_repo.save(book)
        self._member_repo.save(member)
```

この実装には、少し懸念があります。
もし、`book_repo.save()`が成功した直後に、`member_repo.save()`でエラーが発生したらどうなるでしょうか？本の状態だけが「貸出中」になり、会員の貸出冊数が増えない、という**データの不整合**が発生してしまいます。

#### ✨ Unit of Workによる解決

Unit of Workは、この問題を解決する「**変更記録係**」です。

1.  UseCaseは、変更があったオブジェクト（`book`や`member`）を、直接`save`する代わりに、Unit of Workに「このオブジェクトが変更されたよ」と**登録**します。
2.  UseCaseの処理がすべて正常に完了したら、最後に一度だけUnit of Workに「**記録した変更をすべて確定してください (`commit`)**」と命令します。

Unit of Workは、この`commit`命令を受けて初めて、データベースへの書き込みを**一つのトランザクション**の中で行います。

```python
class LendBookUseCase:
    def execute(self, book_id: str, member_id: str):
        # uowはUnit of Workのインスタンス
        book = self._book_repo.find_by_id(book_id)
        member = self._member_repo.find_by_id(member_id)

        book.lend()
        member.note_borrowed()

        # 変更を直接保存せず、Unit of Workに登録するだけ
        self._uow.register_dirty(book)
        self._uow.register_dirty(member)

        # 最後に一度だけコミット
        self._uow.commit()
```

このパターンは必須ではありませんが、知っておくと、より洗練されたトランザクション管理が可能になります。
