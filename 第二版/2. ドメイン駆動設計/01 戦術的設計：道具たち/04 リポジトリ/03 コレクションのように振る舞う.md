## 第2章：コレクションのように振る舞う

リポジトリがもたらす2つ目の大きな効果は、その名の通り「**リポジトリ（貯蔵庫、保管庫）**」として、まるでメモリ上にあるリストや辞書（コレクション）のように振る舞う点です。

これにより、UseCaseなどの利用者は、**背後にあるデータベースの存在を完全に忘れて**、ビジネスロジックに集中できます。

### 👎 データベースの言葉で話すコード

もしリポジトリという抽象化がない場合、UseCaseはデータベースの「言葉」（SQLなど）を話さなければなりません。

```python
#
# 良くない例：UseCaseがデータベースの都合を知っている
#
class SomeUseCase:
    def execute(self, book_id: str):
        # ...
        
        # UseCaseがSQLの知識を持ってしまっている
        update_sql = "UPDATE books SET status = %s WHERE id = %s"
        db_connection.execute(update_sql, ('LOANED', book_id))
        
        # ...
```

このコードは、`UPDATE`というSQLの命令を知らないと読めません。また、将来データベースをSQL系からNoSQL系に変更した場合、このUseCaseのコードも修正が必要になってしまいます。

### 👍 コレクションの言葉で話すコード

リポジトリは、これらのデータベース言語をすべて翻訳し、**シンプルで普遍的なコレクション操作**の言葉だけを利用者に提供します。

| コレクション操作 | リポジトリのメソッド例 | 意味 |
| :--- | :--- | :--- |
| `my_list.append(item)` | `repository.add(item)` | 新しいものを追加する |
| `item = my_dict['key']` | `item = repository.get('key')` | IDを指定して一つ取得する |
| `my_list.remove(item)` | `repository.remove(item)` | それを削除する |

このインターフェースを使うと、UseCaseは劇的にシンプルになります。

```python
#
# 良い例：UseCaseはコレクションを操作する感覚でコードを書ける
#
class IBookRepository(ABC):
    @abstractmethod
    def get(self, book_id: str) -> Book: # 辞書からキーで値を取得する感覚
        pass

    @abstractmethod
    def save(self, book: Book): # リストや辞書に最新の状態を保存する感覚
        pass

class LendBookUseCase:
    def execute(self, book_id: str):
        # 1. コレクションからBookを取得する
        book = self._book_repo.get(book_id)

        # 2. メモリ上のオブジェクトを操作する
        book.lend()
        
        # 3. 変更したオブジェクトをコレクションに戻す（保存する）
        self._book_repo.save(book)
```

このUseCaseのコードには、`UPDATE`や`SELECT`といったデータベース言語は一切登場しません。まるでメモリ上の辞書からオブジェクトを取り出し、変更し、また戻す、という感覚でコードが書かれています。

### 魔法の本棚に例える 📚

リポジトリは、あなたの部屋にある\*\*「魔法の本棚」\*\*のようなものです。

  * **見た目**: 普通の本棚です。本を取り出したり（`get`）、戻したり（`save`）できます。
  * **魔法の仕組み**: あなたが知らないうちに、この本棚は地下にある巨大な図書館（データベース）と繋がっています。
      * あなたが本棚から本（`Book`集約）を取り出すと、司書（リポジトリの実装）が光の速さで地下の書庫からそれを持ってきてくれます。
      * あなたが本を本棚に戻すと、司書がそれをまた書庫の正しい場所へしまいに行ってくれます。

あなた（UseCase）は、地下の図書館の存在や、司書の複雑な仕事ぶりを**一切意識する必要がありません**。ただ、目の前のシンプルな本棚だけを見ていればよいのです。

この\*\*「永続化の仕組みを知らなくてよい（Persistence Ignorance）」**という状態を実現することが、リポジトリの大きな役割です。これにより、ドメインロジックとインフラストラクチャが綺麗に分離され、特に**テスト\*\*（本物のデータベースの代わりに、テスト用の偽の本棚（インメモリ実装）を簡単に用意できる）が非常にやりやすくなります。