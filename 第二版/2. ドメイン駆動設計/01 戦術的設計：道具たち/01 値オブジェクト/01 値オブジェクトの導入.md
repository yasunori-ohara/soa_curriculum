## 値オブジェクト（Value Object）を深く理解する

値オブジェクトを一言で表すなら、「ドメイン（業務）における『値』の概念を、独自の型として表現したもの」です。

`String`や`Integer`といったプログラミング言語が提供する汎用的な型（プリミティブ型）の代わりに、私たちが開発しているシステム固有の「意味」と「ルール」を持った型を定義します。

### なぜ、わざわざ独自の型を作るのか？

`String`のままでもシステムは動くのに、なぜ手間をかけて`Isbn`や`UserName`といったクラスを作るのでしょうか？それには、コードをより安全で、分かりやすくするための3つの大きな理由（特性）があります。

#### 特性1：自己充足的である（ルールを内包する）

値オブジェクトは、その値が「何であるか」だけでなく、「どうあるべきか」というルール（制約）を自分自身で知っています。

**例：`UserName`（利用者の名前）**

もし、図書館システムのルールに「利用者の名前は2文字以上20文字以内」というものがあったとします。

**❌ 良くない例：プリミティブ型を使う**

```typescript
class User {
  public name: string; // ただの文字列

  constructor(name: string) {
    // Userクラスが名前のルールを知っている
    if (name.length < 2 || name.length > 20) {
      throw new Error("名前は2文字以上20文字以内です。");
    }
    this.name = name;
  }
}

// このUserを使う様々な場所で、同じような文字数チェックが必要になるかもしれない…
```

この場合、`User`クラスが名前の文字数ルールを知ってしまっています。もし他の場所でも`UserName`を扱う必要が出てきたら、その都度同じバリデーションコードを書くことになりかねません。

**✅ 良い例：値オブジェクトを使う**

```typescript
class UserName {
  public readonly value: string;

  constructor(value: string) {
    // UserName自身が、自分のルールを知っている！
    if (value.length < 2 || value.length > 20) {
      throw new Error("名前は2文字以上20文字以内です。");
    }
    this.value = value;
  }
}

class User {
  public name: UserName; // UserName型として持つ

  constructor(name: UserName) {
    this.name = name;
  }
}

// 使い方
// const tooShortName = new UserName("a"); // ここでエラーになる！
const validName = new UserName("山田 太郎");
const user = new User(validName);
```

`UserName`という型を作ったことで、「名前に関するルール」はすべて`UserName`クラスの中に閉じ込められました。これにより、`new UserName(...)`が成功した時点で、そのインスタンスは**必ず有効な名前である**ことが保証されます。

#### 特性2：不変である（Immutable）

一度作成したら、**中の値を絶対に変更できません**。もし変更したい場合は、新しいインスタンスを作成します。

**例：`Money`（お金）**
自動販売機の例で考えてみましょう。「100円」という値オブジェクトがあるとします。

```typescript
class Money {
  public readonly amount: number;
  public readonly currency: string;

  constructor(amount: number, currency: string) {
    this.amount = amount;
    this.currency = currency;
  }

  // お金を追加する場合…
  public add(other: Money): Money {
    if (this.currency !== other.currency) {
      throw new Error("通貨単位が異なります。");
    }
    // 自分自身の値は変えずに、新しいインスタンスを返す！
    return new Money(this.amount + other.amount, this.currency);
  }
}

// 使い方
const price1 = new Money(100, "JPY");
const price2 = new Money(50, "JPY");

const totalPrice = price1.add(price2); // 新しいMoneyオブジェクトが返る

console.log(price1.amount); // 100 (元の値は変わっていない！)
console.log(totalPrice.amount); // 150
```

もし`price1`の値が直接`150`に変わってしまったら、予期せぬバグの原因になります。不変であることにより、値オブジェクトは安心して関数に渡したり、複数の場所で使い回したりできるのです。

#### 特性3：値で比較される（等価性）

値オブジェクトは、中身の値が同じであれば「同じもの」として扱われます。IDで区別されるエンティティ（`User`や`Book`）とは対照的です。

**例：2つの100円玉**
あなたの財布に入っている100円玉と、私の財布に入っている100円玉は、製造年が違っても「100円」という価値においては全く同じです。交換しても何も問題ありません。これが値オブジェクトの考え方です。

```typescript
class Money {
  // ... (さっきと同じ) ...

  public equals(other: Money): boolean {
    return this.amount === other.amount && this.currency === other.currency;
  }
}

const coin1 = new Money(100, "JPY");
const coin2 = new Money(100, "JPY");
const coin3 = new Money(500, "JPY");

console.log(coin1.equals(coin2)); // true
console.log(coin1.equals(coin3)); // false
```

`coin1`と`coin2`は別のインスタンスですが、値が同じなので`equals`の結果は`true`になります。

### まとめ：値オブジェクト導入のメリット

値オブジェクトを導入することで、あなたのコードは以下の恩恵を受けられます。

  * **① 表現力が高まる**
      * `name: string` よりも `name: UserName` の方が、コードを読むだけで「これはただの文字列ではなく、利用者名という概念だ」と理解できます。
  * **② コードが安全になる**
      * コンストラクタでルールを強制するため、不正な値を持ったオブジェクトはそもそも存在できなくなります。
      * 不変であるため、意図せず値が書き換えられる心配がなく、安心して使えます。
  * **③ ロジックがまとまる**
      * 値に関するロジック（バリデーション、計算、比較など）がそのクラスに集約されるため、コードの重複が減り、保守性が向上します。

まずは、これまで`String`や`Integer`で扱っていたものの中に、「これはドメインの特別な意味を持つ値ではないか？」と考えられるものがないか探してみてください。`ISBN`、`氏名`、`本のタイトル`、`貸出日`、`金額`など、値オブジェクトにできる候補はたくさん見つかるはずです。

この「値」の概念をしっかりオブジェクトに落とし込むことが、豊かなドメイン層を築くための重要な第一歩となります。