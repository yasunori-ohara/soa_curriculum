## 値オブジェクトの生成：ファクトリについて

値オブジェクトを生成する際の「ファクトリ」について、その必要性や具体的なパターンをもう少し掘り下げて解説します。

-----

### 🤔 なぜコンストラクタだけでは不十分なのか？

通常、オブジェクトは `new MyClass(...)` のようにコンストラクタを使って生成します。しかし、生成プロセスが少しでも複雑になると、コンストラクタだけではいくつかの問題が出てきます。

1.  **名前が一つしかない**: コンストラクタの名前はクラス名と決まっています。そのため、「文字列から作る」「数値から作る」といった、**異なる材料からの作り方を名前で表現できません**。
2.  **ロジックで肥大化しやすい**: バリデーション、パース（解析）、計算などのロジックを全てコンストラクタに詰め込むと、クラスの本来の責務（＝何であるか）と、生成の責務（＝どうやって作るか）が混在し、見通しが悪くなります。
3.  **柔軟性に欠ける**: コンストラクタは必ずそのクラスの新しいインスタンスを返す必要があります。例えば、特定の条件でキャッシュ済みのインスタンスを返したり、サブクラスのインスタンスを返したりといった柔軟な制御ができません。

**ファクトリ**は、この「オブジェクトをどうやって作るか」という生成の責務をクラスから分離し、これらの問題を解決するためのデザインパターンです。

-----

### ✨ ファクトリがもたらす3つのメリット

1.  **意図の明確化 (Self-documenting)**
    ファクトリメソッドには、**生成方法が明確にわかる名前**を付けることができます。

    ```typescript
    // どちらが分かりやすいかは一目瞭然
    const period = new DatePeriod("2025-10-12/P7D"); // ISO 8601形式？ 推測が必要
    const period = DatePeriod.fromStartAndDays(startDate, 7); // 開始日と日数から作るんだな！
    ```

2.  **生成ロジックのカプセル化 (Encapsulation)**
    複雑な生成ロジックをファクトリに閉じ込めることで、**利用側はその複雑さを意識する必要がなくなります**。コンストラクタは、渡された値をプロパティに設定するだけのシンプルな役割に専念できます。

3.  **柔軟性の向上 (Flexibility)**
    将来的に、生成方法が変更されても（例えば、キャッシュを使うように変更するなど）、ファクトリの内部を修正するだけで済み、**利用側のコードには一切影響を与えません**。

-----

### 🛠️ 主なファクトリの2つのパターン

#### パターン1：静的ファクトリメソッド (Static Factory Method)

**最も手軽で、値オブジェクトでよく使われるパターンです。** クラス自身の静的メソッドとしてファクトリを実装します。

**例：`DateRange` 値オブジェクト**
「開始日」と「終了日」を持つ `DateRange` を考えます。「開始日と日数」や「月の初めから終わりまで」といった様々な作り方を提供したい場合に非常に有効です。

```typescript
class DateRange {
  public readonly start: Date;
  public readonly end: Date;

  // コンストラクタは単純な代入に徹する（privateにしておくのが一般的）
  private constructor(start: Date, end: Date) {
    if (start > end) {
      throw new Error("終了日は開始日以降である必要があります。");
    }
    this.start = start;
    this.end = end;
  }

  // ファクトリ1：開始日と終了日から生成
  public static fromStartToEnd(start: Date, end: Date): DateRange {
    return new DateRange(start, end);
  }

  // ファクトリ2：開始日と日数から生成
  public static fromStartAndDays(start: Date, days: number): DateRange {
    const end = new Date(start);
    end.setDate(start.getDate() + (days - 1));
    return new DateRange(start, end);
  }

  // ファクトリ3：指定された月の範囲で生成
  public static forMonth(year: number, month: number): DateRange {
    const start = new Date(year, month - 1, 1);
    const end = new Date(year, month, 0); // 月の最終日を取得するテクニック
    return new DateRange(start, end);
  }
}

// 利用者は、意図に合ったファクトリメソッドを呼び出すだけ
const weeklyReportRange = DateRange.fromStartAndDays(new Date(), 7);
const octoberSalesRange = DateRange.forMonth(2025, 10);
```

#### パターン2：ファクトリクラス (Factory Class)

生成ロジックが**さらに複雑**で、他のサービス（リポジトリなど）に依存するような場合は、ファクトリの責務を完全に別のクラスに分離します。

これは値オブジェクト単体よりも、複数のエンティティを組み合わせて集約（Aggregate）を生成する際によく使われますが、考え方として知っておくと役立ちます。

**例：`LoanFactory`（貸出集約のファクトリ）**

```typescript
// 生成の専門家
class LoanFactory {
  private readonly bookRepository: IBookRepository;

  constructor(bookRepository: IBookRepository) {
    this.bookRepository = bookRepository;
  }

  // 本の在庫チェックなど、外部への依存を伴う生成処理
  public create(bookId: string, userId: string): Loan {
    const book = this.bookRepository.findById(bookId);
    if (!book.isAvailable()) {
      throw new Error("この本は貸出できません。");
    }
    // Loanの生成ロジック...
    return new Loan(generateId(), book.id, userId, new Date());
  }
}
```

まずは、手軽で強力な**静的ファクトリメソッド**のパターンを覚えておけば、ほとんどの値オブジェクトの生成シーンでコードを綺麗に保つことができるでしょう。

## 🤔 いまのところ ファクトリクラス  は、そんなものがある、という感じで大丈夫ですか？

はい、もちろんです。「そんなものがある」というくらいの理解で全く問題ありません。

DDDの学習においては、一度に全てを完璧に理解しようとするよりも、使う頻度が高い重要なパターンから確実に身につけていくのが効果的です。

---
## 使い分けのイメージ

現時点では、以下のようなざっくりとした使い分けのイメージを持っておけば十分です。

* **静的ファクトリメソッド**
    * **9割以上はこれでOK。**
    * 値オブジェクトのように、**それ自身の情報だけで完結して作れる**場合に使います。

* **ファクトリクラス**
    * **出番は少なめ。**
    * 集約（Aggregate）のように、**作るのに外部の情報（リポジトリなど）が必要になる**複雑なケースで使います。

---
## 包丁とフードプロセッサー

道具に例えるなら、こんな関係です。

* **静的ファactリーメソッド**は「**包丁**」です。
    * ほとんどの調理（オブジェクト生成）はこれでこなせます。まずは使い方をマスターすべき、基本的で万能な道具です。

* **ファクトリクラス**は「**フードプロセッサー**」です。
    * たくさんの材料を一度に、複雑な手順で下ごしらえする（依存関係の多いオブジェクトを生成する）ときに非常にパワフルです。
    * しかし、毎日使うものではありません。必要になったときに「あ、こういう便利な道具があったな」と思い出せれば大丈夫です。

今はまず「包丁」である静的ファクトリメソッドを使いこなすことに集中し、「生成時にリポジトリなど外部の情報が必要になったら、あのクラスの出番だな」と思い出せるくらいで、学習のステップとしては完璧です。
