## 値オブジェクトの深掘り

## 🤔 全ての値をオブジェクトにすることになりますか？そうでない場合は、その線引きはどこで決まりますか？

いいえ、**全ての値をオブジェクトにするわけではありません。**

それは非常に良い質問で、多くの開発者が最初に悩むポイントです。その線引きは、**「その値に、ビジネス上の意味やルールが存在するかどうか」**で決まります。

一言で言うなら、**ただのデータ（情報）なのか、意味を持つ概念（知識）なのか**を見極めることが重要です。

---

### 線引きの判断基準

ある値を値オブジェクトにすべきかどうかは、以下の観点で判断します。

#### 1. 制約やルールがあるか？ (最重要)
これが最も分かりやすい基準です。その値にフォーマット、文字数、範囲などの**ビジネス上のルール**があるなら、値オブジェクトの強力な候補です。

* **作るべき例:**
    * `メールアドレス`: 「@が含まれている」「ドメインがある」といった形式ルールがある。
    * `数量`: 「0以上でなければならない」というルールがある。
    * `パスワード`: 「8文字以上で、大文字・小文字・数字を含む」などの複雑なルールがある。
* **作らなくて良い例:**
    * `備考欄のテキスト`: 基本的に自由入力で、特定のビジネスルールがない。
    * `データベースのID`: 自動採番される一意な識別子で、それ自体にビジネスルールはない。

#### 2. 関連する振る舞い（計算など）があるか？
その値を使った特有の計算や操作が頻繁に行われる場合、それらのロジックをまとめる場所として値オブジェクトは最適です。

* **作るべき例:**
    * `金額 (Money)`: 足し算、引き算、税率計算などの振る舞いを持つ。
    * `貸出期間 (LoanPeriod)`: 「期間の日数を計算する」「延滞しているか判定する」といった振る舞いを持つ。
* **作らなくて良い例:**
    * `本のタイトル`: タイトル自体に計算などの振る舞いはない。（もし「禁則処理をする」などの振る舞いがあれば、作る候補になります）

#### 3. 単位や文脈を明確にする必要があるか？
単なる数値だと、それが何を表しているのか分かりにくくなる場合があります。型で単位や文脈を保証したい場合に有効です。

* **作るべき例:**
    * `重さ (Weight)`: `100`という数値だけではkgなのかgなのか不明。`new Weight(100, "kg")`のように単位を強制できる。
    * `パーセンテージ (Percentage)`: `15`という数値が「15%」を意味することを明確にする。`0.15`で持つのか`15`で持つのかといった内部表現も隠蔽できる。
* **作らなくて良い例:**
    * `ループカウンタ`: `for (let i = 0; ...)` の `i` のような、文脈が限定的で一時的な変数。

---

### まとめ：迷ったら「コスト 対 効果」で判断

以下の表は、判断の目安です。

| 値オブジェクトにするのがオススメ 👍 | プリミティブ型のままでも良いかも 🤔 |
| :--- | :--- |
| **ルール**が明確にある（メールアドレス、パスワード） | ルールが特にない（自由入力のメモ、備考） |
| **計算ロジック**が伴う（金額、期間） | 単純なデータ表示にしか使わない |
| **単位**を間違えると問題になる（重さ、長さ、温度） | 単位がなく、意味が明白（個数、回数） |
| ビジネスの**専門用語**である（商品コード、注文番号） | プログラミング上の都合で使う一時的な値 |

**やりすぎは禁物です。** ルールも振る舞いもない単純な値をすべてオブジェクトにすると、コードが冗長になり、かえって生産性が落ちてしまいます。

**「この値オブジェクトを作ることで、コードはより安全に、より分かりやすくなるか？」**という費用対効果を常に意識することが、適切な線引きのコツです。まずは、アプリケーションの核となる重要な概念（お金、Eメール、IDなど）から値オブジェクト化を試していくのが良いでしょう。

## 🤔 値オブジェクトの決め方

**「発見しながら育てていく」反復的（イテレーティブ）なプロセス**と考える方が自然です。

「最初にすべてを完璧に洗い出して設計図を完成させる」というのは、ウォーターフォール開発に近い考え方ですが、DDDはもっとアジャイルで柔軟なアプローチを取ります。

---

### 理想的なアプローチ：発見と進化のプロセス

実際の開発では、以下のような流れで進めるのが一般的です。

#### 1. ドメインの言葉（ユビキタス言語）から始める
まず、開発者とドメインの専門家（図書館の例なら司書さんなど）が会話し、業務で使われる重要な言葉をリストアップします。
* 「本」「ISBN」「貸出」「返却予定日」「利用者」など。

この段階で、「ISBN」や「貸出期間」のように、明らかに**ルールや振る舞いを持つ概念**がいくつか見つかるでしょう。これらは値オブジェクトの**初期候補**になります。

---

#### 2. 実装しながら発見し、導入する
次に、具体的な機能（ユースケース）、例えば「本を貸し出す」処理を実装し始めます。

この実装の過程で、プリミティブ型（`string`や`int`）を扱っているときに、次のような**「問い」**を自分自身に投げかけます。

* 「この`string`型の`isbn`、本当にただの文字列でいいんだっけ？あ、13桁の数字っていうルールがあったな…」
    * → **よし、`Isbn`値オブジェクトを作ろう！**
* 「この`loanDate`と`returnDate`、いつもセットで使って期間計算してるな。延滞チェックのロジックも必要だ…」
    * → **よし、`LoanPeriod`値オブジェクトを作ろう！**
* 「この`string`型の`title`は…？今のところ文字数制限くらいで、特別な計算はないな…」
    * → **よし、一旦`string`のままでいこう。**

このように、**必要性を感じたその瞬間**に値オブジェクトを導入していくのが、無駄のない効率的なやり方です。

---

#### 3. リファクタリングで育てる
最初は`string`で済ませていた値でも、開発が進むにつれて新しいルールが追加されることがあります。

例えば、最初はただの文字列だった「本のタイトル」に、「禁則文字を含んではいけない」というルールが後から追加されたとします。そのルールをチェックするコードが複数の場所に書かれ始めたら、それは**「値オブジェクトに昇格させる」絶好のタイミング**です。

`string`だった`title`を`BookTitle`という値オブジェクトにリファクタリングし、禁則文字チェックのロジックをその中に閉じ込めるのです。

---

### まとめ

| ❌ アンチパターン（硬直的な考え方） | ✅ DDDの考え方（柔軟なプロセス） |
| :--- | :--- |
| 1. 最初に**すべての値**を洗い出す | 1. 最初に**主要なドメイン用語**を把握する |
| 2. どれを値オブジェクトにするか**完璧に**決める | 2. 実装中に**必要性**を感じたら導入する |
| 3. その設計図通りに**一気に**実装する | 3. 後からでも**リファクタリング**で育てていく |

**結論として、値オブジェクトの特定は、設計の最初に行う一度きりの作業ではありません。** ドメインへの理解が深まるにつれて、モデル（値オブジェクトやエンティティ）も洗練されていく、**継続的な活動**なのです。

## 🤔 値オブジェクトのし忘れなどはどうやって防止しますか？

その危険性はあります。そして、それはリファクタリングにおける非常に重要なポイントです。

もし、ある日突然システム内の `Book` クラスの `isbn` を `string` 型から `Isbn` 型に書き換えてしまうと、まさにご指摘の通り、**古いコードは動かなくなり、データの不整合が起きる可能性があります。**

-----

### 安全に進めるためのリファクタリング手順

そうならないために、**一度にすべてを変えるのではなく、段階的かつ安全に移行する**のが定石です。これは「古い橋の隣に新しい橋をかけ、交通を少しずつ移してから古い橋を壊す」イメージです。

具体的な手順は以下のようになります。

#### ステップ1：値オブジェクトを「導入」する

まず、新しい `Isbn` クラスを作成します。しかし、この段階ではまだ `Book` クラスの `isbn` プロパティ（`string`型）は**削除しません。**

```typescript
// 1. 新しい値オブジェクトを定義する
class Isbn {
  public readonly value: string;
  constructor(value: string) {
    // バリデーションルール
    if (!/^\d{13}$/.test(value)) {
      throw new Error("ISBNの形式が正しくありません。");
    }
    this.value = value;
  }
}

// 2. Bookクラスはまだ古いまま
class Book {
  public id: string;
  public title: string;
  public isbn: string; // まだ string 型
}
```

-----

#### ステップ2：両方の型を「共存」させる

次に、`Book` クラスを修正し、古い型（`string`）と新しい型（`Isbn`）の両方にアクセスできるようにします。これにより、古いコードを壊さずに、新しいコードから値オブジェクトを使い始めることができます。

```typescript
class Book {
  public id: string;
  public title: string;
  private _isbn: string; // 古い値をプライベートにする

  constructor(id: string, title: string, isbn: string) {
    this.id = id;
    this.title = title;
    this._isbn = isbn;
  }

  // 新しいコード向けのゲッター（値オブジェクトを返す）
  public getIsbn(): Isbn {
    return new Isbn(this._isbn);
  }

  // 古いコード向けのゲッター（後方互換性のため）
  public getIsbnAsString(): string {
    return this._isbn;
  }
}
```

**ポイント：** `Book` のコンストラクタはまだ文字列を受け取りますが、内部で `Isbn` 型を生成して返すメソッドを用意します。

-----

#### ステップ3：利用箇所を少しずつ「移行」する

システム全体で、古い `getIsbnAsString()` を使っている箇所を、一つずつ新しい `getIsbn()` を使うように書き換えていきます。

**Before:**
`const isbnValue = book.getIsbnAsString();`

**After:**
`const isbnObject = book.getIsbn();`
`const isbnValue = isbnObject.value;`

この作業は一度に行う必要はありません。機能ごと、ファイルごとなど、少しずつ進めることができます。すべてのコードが新しい `getIsbn()` を使うようになったことを確認します。

-----

#### ステップ4：古い型を「削除」する

すべての利用箇所が新しい `getIsbn()` メソッドに移行し終わったら、いよいよ古いプロパティとメソッドを削除します。

```typescript
class Book {
  public id: string;
  public title: string;
  public readonly isbn: Isbn; // 完全に値オブジェクトに置き換わった！

  constructor(id: string, title: string, isbn: Isbn) {
    this.id = id;
    this.title = title;
    this.isbn = isbn;
  }
}
```

これでリファクタリングは完了です。`Book` クラスは必ず有効な `Isbn` を持つことが保証されるようになりました。

### データベースのデータはどうする？

このリファクタリングにおいて、データベースのカラムは `string` (VARCHAR) のままで問題ありません。

  * **読み込み時:** リポジトリがデータベースから文字列のISBNを読み込み、`Book` のコンストラクタに渡す際に `new Isbn(stringValue)` のように値オブジェクトを生成します。
  * **書き込み時:** リポジトリが `Book` インスタンスを保存する際に、`book.isbn.value` のように値オブジェクトから中の文字列を取り出してデータベースに保存します。

このように、アプリケーションの内部では値オブジェクトとして安全に扱い、永続化層との境界でプリミティブ型との変換を行うのが一般的です。


