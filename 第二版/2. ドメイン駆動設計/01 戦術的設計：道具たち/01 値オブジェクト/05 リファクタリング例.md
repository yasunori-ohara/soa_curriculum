## 値オブジェクト：適用

「クリーンアーキテクチャのときは`isbn`のメンバーはなかった」という点を踏まえ、より現実に即した形で、**機能追加によってコードがどう変化し、そこからDDDを適用するとどう改善されるか**、というストーリーで見ていきましょう。

-----

### ステージ1：最初のシンプルなCAモデル

最初に作った図書館プロジェクトの`Book`エンティティは、おそらくこのようだったと想像します。

**📁 `entities/book.py` (Initial)**

```python
# ISBNという概念がまだ存在しない、非常にシンプルな状態
from dataclasses import dataclass

@dataclass
class Book:
    id: str
    title: str
    is_loaned: bool = False # 貸出中かどうかのフラグ
```

-----

### ステージ2：機能追加と素朴な実装 (これが今回の『Before』)

ここに、「**蔵書をISBNコードで管理したい**」という新しい要件が追加されたとします。
DDDを意識しない場合、最も手軽な方法は、`Book`エンティティに`isbn`という文字列のプロパティを追加することです。

**📁 `entities/book.py` (Before)**

```python
from dataclasses import dataclass

@dataclass
class Book:
    id: str
    title: str
    isbn: str  # 機能追加！しかし、ただの文字列
    is_loaned: bool = False
```

**📁 `usecases/register_book.py` (Before)**

```python
class RegisterBookUseCase:
    # ...

    def execute(self, title: str, isbn: str):
        # ISBNが正しい形式かのバリデーションロジックがここに必要になる
        if not isbn or len(isbn) != 13 or not isbn.isdigit():
             raise ValueError("ISBNは13桁の数字である必要があります")

        # Bookエンティティを生成して保存
        new_book = Book(
            id=generate_id(),
            title=title,
            isbn=isbn, # ただの文字列として渡される
            is_loaned=False
        )
        self._book_repo.save(new_book)
```

この時点での問題は、`isbn`がただの文字列であるため、**ISBNに関するルール（13桁の数字である、など）がユースケースに記述されてしまう**ことです。今後、ISBNを扱う別のユースケースが増えれば、同じバリデーションコードが重複する原因になります。

-----

### ステージ3：DDDの戦術的設計でリファクタリング (これが『After』)

ここで、ステージ2の状態からDDDの処方箋を適用します。

**1. `Isbn`値オブジェクトを導入する**
まず、ISBNという「概念」を独自の型として定義し、ルールをそこにカプセル化します。

**📁 `domain/value_objects/isbn.py` (New)**

```python
import re
from dataclasses import dataclass

@dataclass(frozen=True)
class Isbn:
    value: str

    def __post_init__(self):
        if not re.match(r"^\d{13}$", self.value):
            raise ValueError("ISBNの形式が正しくありません")
```

**2. `Book`エンティティを、振る舞いを持つ集約ルートとして進化させる**
`Book`はただのデータクラスではなく、自身の状態（貸出中かなど）に責任を持つ、振る舞いを持ったクラスになります。プロパティも値オブジェクトを使うように変更します。

**📁 `domain/aggregates/book.py` (After)**

```python
from domain.value_objects.isbn import Isbn

class Book:
    def __init__(self, id: str, title: str, isbn: Isbn, is_loaned: bool):
        self.id = id
        self.title = title
        self.isbn = isbn # Isbn値オブジェクトを持つ！
        self._is_loaned = is_loaned

    # Factory
    @classmethod
    def register(cls, title: str, isbn: Isbn) -> 'Book':
        return cls(
            id=generate_id(),
            title=title,
            isbn=isbn,
            is_loaned=False
        )

    def is_available(self) -> bool:
        return not self._is_loaned
    
    # ... その他の振る舞い ...
```

**3. ユースケースをリファクタリングする**
ドメインモデルが賢くなったことで、ユースケースはドメインモデルの「利用者」としての役割に専念できます。

**📁 `usecases/register_book.py` (After)**

```python
class RegisterBookUseCase:
    # ...

    def execute(self, title: str, isbn_str: str):
        # ユースケースの責務は、外部のプリミティブな値を
        # ドメイン世界のオブジェクトに変換すること
        try:
            isbn = Isbn(isbn_str)
        except ValueError as e:
            # 不正な値はドメイン層に渡す前にはじく
            raise e

        # Book集約のファクトリメソッドを呼び出すだけ
        # Bookの生成ルールはBook自身が知っている
        new_book = Book.register(title=title, isbn=isbn)
        
        self._book_repo.save(new_book)
```

このように段階的に見ると、DDDのパターンが、機能追加によって複雑化していくコードを、いかに健全で保守性の高い状態に保つための「処方箋」であるかが、より明確にご理解いただけるかと思います。


