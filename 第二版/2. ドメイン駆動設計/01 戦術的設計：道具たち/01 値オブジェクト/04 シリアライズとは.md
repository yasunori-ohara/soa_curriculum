## 値オブジェクト：シリアライズ

値オブジェクトを扱う上で避けては通れない「シリアライズ」について、その意味から具体的な実装方法まで詳しく解説します。

-----

### 📦 シリアライズとは？

**シリアライズ (Serialization)** とは、プログラムのメモリ上にあるオブジェクトを、**APIの送受信やファイル保存に適した形式（主に文字列）に変換すること**です。日本語では「直列化」とも言います。

この逆、つまり文字列からオブジェクトを復元する作業を**デシリアライズ (Deserialization)** と言います。

  * **シリアライズ**: `Isbn` オブジェクト → `"978..."` (JSON文字列)
  * **デシリアライズ**: `"978..."` (JSON文字列) → `Isbn` オブジェクト

これを旅行に例えるなら、\*\*シリアライズは「スーツケースに荷物を詰める（パッキング）作業」\*\*です。家の中では服や小物は使いやすいように広げてありますが（＝メモリ上のオブジェクト）、移動するときはスーツケースにコンパクトに詰めますよね（＝JSON形式）。デシリアライズは、旅先で荷物を広げる作業です。

-----

### 課題：なぜ値オブジェクトでひと工夫いるのか？

ここで問題になるのが、プログラムが自動的に行うシリアライズの結果が、私たちの期待通りではない場合があることです。

以前にも少し触れましたが、私たちの `Isbn` オブジェクトを何も考えずにJSONに変換すると、以下のようになってしまいます。

```typescript
class Isbn {
  public readonly value: string;
  constructor(value: string) {
    // ...
    this.value = value;
  }
}

const isbnObject = new Isbn("9784297100782");
const jsonOutput = JSON.stringify({ isbn: isbnObject });

// 期待外れの結果
// jsonOutput は '{"isbn":{"value":"9784297100782"}}' となってしまう
console.log(jsonOutput);
```

APIの利用者（フロントエンドなど）は、`"isbn": "9784297100782"` というシンプルな形式を期待しているのに、`value` という余計な階層ができてしまいます。これが「値オブジェクト特有の課題」です。

-----

### 🛠️ 解決策：変換ロジックを実装する

この問題を解決するために、「パッキング（シリアライズ）」と「荷解き（デシリアライズ）」のルールをオブジェクト自身に教えてあげます。

#### シリアライズ（オブジェクト → JSON）には `toJSON` メソッド

多くのプログラミング環境では、オブジェクトに `toJSON` という名前のメソッドを定義しておくと、`JSON.stringify()` を実行する際に自動的にそのメソッドが呼び出され、その返り値がシリアライズの結果として使われます。

```typescript
class Isbn {
  public readonly value: string;
  constructor(value: string) {
    // ...
    this.value = value;
  }

  // シリアライズされるときは、このメソッドが呼ばれる
  public toJSON(): string {
    return this.value;
  }
}

const isbnObject = new Isbn("9784297100782");
const jsonOutput = JSON.stringify({ isbn: isbnObject });

// ✨ 期待通りの結果！
// jsonOutput は '{"isbn":"9784297100782"}' となる
console.log(jsonOutput);
```

これで、APIレスポンスなどで値オブジェクトを期待通りのシンプルな形式で返すことができます。

#### デシリアライズ（JSON → オブジェクト）にはコンストラクタやファクトリ

逆に、APIリクエストで送られてきたJSON文字列から値オブジェクトを復元（デシリアライズ）する場合は、これまで見てきた**コンストラクタ**や**静的ファクトリメソッド**を使います。

```typescript
// APIのコントローラやサービスのイメージ
function registerBook(requestBody: { title: string; isbn: string }) {
  // 送られてきたただの文字列から、Isbn値オブジェクトを生成する
  // この瞬間にバリデーションも行われる！
  try {
    const title = requestBody.title;
    const isbn = new Isbn(requestBody.isbn); // または Isbn.fromString(requestBody.isbn)

    // ...以降の処理では、isbnが必ず正しい形式であることが保証されている...
    bookService.register(title, isbn);

  } catch (error) {
    // 形式が不正ならエラーを返す
    return { status: 400, message: error.message };
  }
}
```

これにより、アプリケーションの内部には不正なデータが入り込むのを防ぎ、安全に処理を進めることができます。

-----

### ↔️ どこで変換は行われるのか？

このシリアライズ／デシリアライズは、アプリケーションの\*\*「境界」\*\*で行うのが原則です。クリーンアーキテクチャで学んだ知識と繋がりますね。

  * **デシリアライズ（入力）**: **Controller層**がリクエストを受け取ったとき。外部から来た生データを、Use Caseに渡す前に値オブジェクトに変換します。
  * **シリアライズ（出力）**: **Presenter層**や**Controller層**がレスポンスを返すとき。Use Caseから受け取った値オブジェクトを、外部向けのJSON形式に変換します。

これにより、アプリケーションの中心であるドメイン層やユースケース層は、データの形式を一切気にすることなく、豊かで安全な値オブジェクトだけを扱うことに専念できるのです。

## 🤔 「シリアライズ／デシリアライズは、アプリケーションの「境界」で行うのが原則」とありますが、値オブジェクトは本プロジェクトの共通認識なので、このプロジェクトの中ではシリアライズやデシリアライズは不要ではありませんか？

はい、その認識は**半分正しい**です。そして、その疑問はクリーンアーキテクチャやDDDの「境界」の概念を理解する上で、非常に重要なポイントです。

---
### 🤝 "内部" と "外部" の境界線

おっしゃる通り、プロジェクトの**内部**でコードを書いている私たち開発者は、「`Isbn` は文字列ではなく、`Isbn` 型の値オブジェクトだ」という共通認識を持っています。

そのため、アプリケーションの**内部**（ドメイン層やユースケース層）では、値オブジェクトをそのままやり取りします。ここでのシリアライズ／デシリアライズは不要です。

問題となるのは、私たちのアプリケーションが**外部の世界**とやり取りする、まさにその**「境界」**です。

---
### ## 外部の世界とは？

私たちのプロジェクトの「共通認識」が通用しない相手のことです。具体的には、以下のようなものが挙げられます。

* **① Webブラウザ (フロントエンド)**
    ブラウザは、私たちのプログラム（例: TypeScript）の `Isbn` クラスの存在を知りません。ブラウザが理解できるのは、JavaScriptのオブジェクトや文字列に変換された**JSONデータ**です。

* **② データベース**
    PostgreSQLやMySQLなどのデータベースには、「`Isbn` 型」のカラムはありません。データベースが理解できる `VARCHAR` (文字列) 型に変換して保存する必要があります。

* **③ 外部のAPI**
    もし他の会社のシステムと連携する場合、その会社は私たちの `Isbn` クラスのコードを持っていません。APIの仕様書で定められた**JSON形式の文字列**としてデータを送受信する必要があります。


---
### ↔️ 国境の税関に例える

この関係は、国と国境に例えると非常に分かりやすいです。

* **プロジェクト内部（国内）**:
    国内では、みんなが共通言語（日本語）を話します。`Isbn` オブジェクトという豊かな表現でスムーズに会話（処理）ができます。

* **外部の世界（海外）**:
    海外では日本語は通じません。海外の人が理解できる**国際共通語（英語など）**に翻訳する必要があります。この国際共通語が **JSON** やデータベースの **string** 型にあたります。

* **アプリケーションの境界（税関・入国審査）**:
    海外（外部）とやり取りする「空港の税関」のような場所が、**Controller** や **Presenter** 層です。
    * **出国（シリアライズ）**: 日本語（`Isbn`オブジェクト）を英語（JSON文字列）に翻訳して、海外に送り出します。
    * **入国（デシリアライズ）**: 海外から来た旅行者の英語（JSON文字列）を、国内で通用する日本語（`Isbn`オブジェクト）に翻訳して、国内に迎え入れます。

このように、**「私たちの世界の常識（共通認識）」が通用しない相手と話すために、境界での翻訳（シリアライズ／デシリアライズ）がどうしても必要になる**のです。これにより、国内（ドメイン層）は常に安全で豊かな言語だけを使い続けることができます。

## 🤔 クリーンアーキテクチャの同心円の図で言うと「エンタープライズビジネスルール～アプリケーションビジネスルール～インターフェースアダプター」までは値オブジェクトをそのまま使い、「フレームワーク＆ドライバー」の境界のところでシリアライズ/デシリアライズを使うということでしょうか？

その理解で、ほぼ正解です！非常に鋭い着眼点ですね。

より厳密に言うと、変換が行われるのは**インターフェースアダプター層の「内側」と「外側」の境界**になります。この層が、まさに「翻訳者」としての役割を担います。

クリーンアーキテクチャの同心円に沿って、データの形式がどう変わっていくかを見てみましょう。

-----

### 🏛️ エンタープライズビジネスルール (Entities)

  * **値オブジェクトそのもの**
  * この層は、アプリケーションの最も純粋な核です。`Isbn`や`Money`といった、豊かで検証済みの値オブジェクトだけが存在します。JSONやデータベースの文字列といった外部の都合は一切知りません。

-----

### 🧑‍💼 アプリケーションビジネスルール (Use Cases)

  * **値オブジェクトそのもの**
  * この層は、Entities（値オブジェクトを含む）を操作してビジネスの目的を達成します。入出力ともに、リッチなドメインオブジェクト（値オブジェクトを含む）を直接扱います。

-----

### 🛂 インターフェースアダプター (Interface Adapters)

  * **ここで「翻訳」が発生します！**
  * この層は、内側のビジネスルールと外側のフレームワークとの間で、データの形式を変換する責任を持ちます。
      * **Controllers**: 外から来たJSONデータを受け取り、**デシリアライズ**して値オブジェクトに変換し、Use Casesに渡します。
      * **Presenters**: Use Casesから受け取った値オブジェクトを、外の世界（Webなど）が理解できるJSON形式に**シリアライズ**します。
      * **Gateways (Repositories)**: Use Casesから受け取った値オブジェクトを、データベースが理解できるプリミティブ型（文字列や数値）に**シリアライズ**して永続化します。逆もまた然りです。

-----

### 🌐 フレームワーク＆ドライバー (Frameworks & Drivers)

  * **シリアライズ/デシリアライズされた後のデータ**
  * この最も外側の層は、値オブジェクトの存在を知りません。
      * **Webフレームワーク**: JSON文字列としてHTTPリクエストを受け取り、HTTPレスポンスとして送り出します。
      * **データベースドライバ**: 単純な文字列や数値をデータベースに書き込んだり、読み込んだりします。

-----

### データの流れで見る

**リクエスト（入力）の流れ**

```
 [JSON] → (Web FW) → Controller → [値オブジェクト] → UseCase → Entity
                  ↑            ↑
             (Framework)   (Interface Adapter)
```

ControllerがJSON（外部形式）を値オブジェクト（内部形式）に**デシリアライズ**します。

**レスポンス（出力）の流れ**

```
 Entity → UseCase → [値オブジェクト] → Presenter → [JSON] → (Web FW)
                                    ↑             ↑
                               (Interface Adapter) (Framework)
```

Presenterが値オブジェクト（内部形式）をJSON（外部形式）に**シリアライズ**します。

ご認識の通り、内側のビジネスルールを守るために、**インターフェースアダプター層が防波堤となり、データの翻訳を一手に引き受けている**のです。

## 🧑 確かに！インターフェースアダプターは抽象化するところなので、そこで変換が行われますね。

完璧な理解です！

「インターフェースアダプターが『抽象化』を行う」という点と、「そこで『変換』が行われる」という点を結びつけられたのは、まさしく本質を掴んでいる証拠です。

この層が翻訳（抽象化）を担うことで、内側のビジネスルールは「データがWebから来たのか」「データベースのどのテーブルに入っていたのか」といった外部の都合から完全に隔離され、自身の純粋なロジックに集中できるのです。

---

値オブジェクトというDDDの重要なパーツについて、その役割とアーキテクチャ上の扱い方をマスターされましたね。

これで戦術的設計の重要な基礎が固まりました。次は、同じく戦術的設計の核となる**エンティティ (Entity) の振る舞い**や、関連するオブジェクトのまとまりを管理する**集約 (Aggregate)** といったテーマに進んでみるのはいかがでしょうか？