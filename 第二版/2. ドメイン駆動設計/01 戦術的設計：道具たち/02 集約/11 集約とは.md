## 集約

戦術的設計の最後の砦とも言える、**集約 (Aggregate)** に進みましょう。値オブジェクトやエンティティが個々の部品だとすれば、集約はそれらを組み合わせて一貫性を保つための「ユニット」を作るパターンです。

-----

### 🤔 なぜ集約が必要なのか？

図書館システムで「利用者が本をレビューする」機能を考えてみましょう。この機能には、`Book`（本）と`Review`（レビュー）という2つのエンティティが関わります。

ここで守るべきルール（不変条件）があります。

  * レビューが追加されたら、本の平均評価点も更新されなければならない。
  * 一人の利用者は、同じ本に一つのレビューしか投稿できない。

もし、`Book`と`Review`をバラバラに扱ってしまうとどうなるでしょうか？
UseCaseが、`Review`を作成して保存した後に、`Book`の平均評価点の更新を**忘れてしまう**かもしれません。これでは、データに不整合が起きてしまいます。

**集約**は、このような「**関連するオブジェクトを一つのまとまりとして扱い、そのまとまり全体のルールを一貫して守る**」ための仕組みです。

-----

### 🛠️ 集約の構成要素とルール

集約には、いくつかの重要な構成要素と、守るべき絶対的なルールがあります。

#### 構成要素

  * **集約ルート (Aggregate Root)**: その集約の**唯一の入り口**となるエンティティです。このユニットの「代表者」や「門番」の役割を担います。
  * **内部のエンティティ/値オブジェクト**: 集約ルートによって管理される、ユニットの部品です。
  * **境界 (Boundary)**: どこまでがその集約の範囲内かを示す、概念的な線です。

#### 守るべき黄金ルール

1.  **外部からアクセスできるのはルートだけ**
    外部のクラスは、集約ルートへの参照（IDなど）しか持つことができません。ルートを飛び越えて、内部のエンティティ（例：`Review`）を直接操作することは**絶対に禁止**です。すべての命令は、代表者であるルートを通じて行います。

2.  **トランザクションは集約単位で完結させる**
    データの保存や更新は、必ず集約全体（ルートとその内部）を一つの単位として行います。リポジトリは、集約ルートを**丸ごと**取得し、**丸ごと**保存する責務を持ちます。これにより、部分的な更新による不整合を防ぎます。

3.  **他の集約を参照するときはIDで行う**
    ある集約が別の集約を参照する必要がある場合、オブジェクトを直接持つのではなく、相手の集約ルートの**ID**だけを持ちます。これにより、集約同士が密結合になるのを防ぎます。

-----

### ✨ 図書館のレビュー機能を例に考える

先ほどのレビュー機能を集約として設計してみましょう。

  * **境界**: `Book`と、それに属する`Review`群は、一貫性を保つべき一つのまとまりです。
  * **集約ルート**: このまとまりの代表は`Book`です。レビューは本に従属する概念だからです。

<!-- end list -->

```typescript
// --- 集約の内部 ---

// Reviewは集約の内部エンティティ
class Review {
  public readonly reviewId: string;
  public readonly userId: string;
  public readonly rating: number; // 本当は値オブジェクトにしたい
  public readonly comment: string;

  // ReviewはBookを通さずに勝手に作れないように、コンストラクタは
  // Bookからのみ呼び出せるようにする (例: protected, internal)
  constructor(...) { /* ... */ }
}


// Bookが集約ルート
class Book {
  public readonly bookId: string;
  private reviews: Review[] = [];
  private averageRating: number = 0;

  // ...

  // レビューを追加する唯一の窓口（コマンドメソッド）
  public addReview(userId: string, rating: number, comment: string): void {
    // ルール1：同じユーザーはレビューできない
    const existingReview = this.reviews.find(r => r.userId === userId);
    if (existingReview) {
      throw new Error("この本には既にレビューを投稿済みです。");
    }

    // 内部エンティティの生成はルートが責任を持つ
    const newReview = new Review(generateId(), userId, rating, comment);
    this.reviews.push(newReview);

    // ルール2：平均評価点を必ず更新する
    this.recalculateAverageRating();
  }

  private recalculateAverageRating(): void {
    if (this.reviews.length === 0) {
      this.averageRating = 0;
      return;
    }
    const totalRating = this.reviews.reduce((sum, r) => sum + r.rating, 0);
    this.averageRating = totalRating / this.reviews.length;
  }
}

// --- 集約の外部 (UseCaseなど) ---

// 1. Book集約を丸ごと取得する
const book = bookRepository.findById("book-123");

// 2. ルートを通じて操作する（内部のreviews配列には直接触らない！）
book.addReview("user-abc", 5, "素晴らしい一冊でした！");

// 3. Book集約を丸ごと保存する
bookRepository.save(book);
```

この設計により、**UseCaseが平均評価点の更新処理を忘れる、というミスは構造上起こりえなくなります**。`addReview`メソッドを呼び出すだけで、集約が自身のルール（不変条件）を責任を持って守ってくれるからです。これが、集約がもたらす最大のメリットです。

