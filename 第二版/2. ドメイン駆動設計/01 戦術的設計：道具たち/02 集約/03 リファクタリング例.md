## クリーンアーキテクチャからのリファクタリング例

-----

## ステップ1：DDD適用前・純粋なクリーンアーキテクチャの状態

この時点での目標は、クリーンアーキテクチャの原則（関心の分離、依存性のルール）に従うことです。エンティティはまだ単なるデータ構造であり、ビジネスロジックはすべてユースケースに集中します。

#### エンティティ (データ構造)

**📁 `entities/book.py`**

```python
from dataclasses import dataclass

@dataclass
class Book:
    id: str
    title: str
    status: str  # 'AVAILABLE' or 'LOANED'
```

**📁 `entities/member.py`**

```python
from dataclasses import dataclass

@dataclass
class Member:
    id: str
    name: str
```

**📁 `entities/loan.py`**

```python
from dataclasses import dataclass
from datetime import datetime

# Loanは単なる「貸出記録」のデータ
@dataclass
class Loan:
    id: str
    book_id: str
    member_id: str
    loan_date: datetime
    due_date: datetime
```

#### ユースケース (すべてのビジネスロジックがここに集まる)

**📁 `usecases/lend_book.py` (Before)**

```python
from datetime import datetime, timedelta

class LendBookUseCase:
    def __init__(
        self,
        book_repo: IBookRepository,
        member_repo: IMemberRepository,
        loan_repo: ILoanRepository
    ):
        self._book_repo = book_repo
        self._member_repo = member_repo
        self._loan_repo = loan_repo

    def execute(self, book_id: str, member_id: str):
        # --- 1. データの取得 ---
        book = self._book_repo.find_by_id(book_id)
        member = self._member_repo.find_by_id(member_id)
        
        if not book or not member:
            raise ValueError("本または会員が見つかりません")

        # --- 2. ビジネスルールの検証 (ロジックがここに集中！) ---
        # ルールA：本が貸出可能かチェック
        if book.status == 'LOANED':
            raise ValueError("この本は既に貸出中です")
            
        # ルールB：会員の貸出上限をチェック
        current_loans_count = self._loan_repo.count_by_member(member_id)
        if current_loans_count >= 5:
            raise ValueError("貸出上限数に達しています")

        # --- 3. データの更新 ---
        # 状態を直接変更
        book.status = 'LOANED'
        
        loan_date = datetime.now()
        due_date = loan_date + timedelta(days=14) # 返却期限は2週間後
        
        new_loan = Loan(
            id=generate_id(),
            book_id=book.id,
            member_id=member.id,
            loan_date=loan_date,
            due_date=due_date
        )

        # --- 4. データの保存 ---
        self._book_repo.save(book)
        self._loan_repo.save(new_loan)
```

これが、DDDを適用する前の、リアルなクリーンアーキテクチャの状態です。エンティティはただのデータ入れ物で、`LendBookUseCase`がすべてのルールを知っていて、各リポジトリを操作する責任を負っています。

-----

## ステップ2：DDDの集約を適用したリファクタリング

ここから、ステップ1の状態をリファクタリングします。ユースケースに散らばったビジネスロジックを、あるべき場所（ドメインモデル）に移動させます。

#### 集約 (振る舞いを持つ賢いオブジェクト)

**📁 `domain/aggregates/book.py` (After)**

```python
class Book:
    def __init__(self, id: str, title: str, status: str):
        self.id = id
        self.title = title
        self._status = status # 内部状態は隠蔽

    def is_available(self) -> bool:
        return self._status == 'AVAILABLE'

    # 「貸し出される」という振る舞いを実装
    def lend(self):
        if not self.is_available():
            raise ValueError("この本は既に貸出中です")
        self._status = 'LOANED'
```

**📁 `domain/aggregates/member.py` (After)**

```python
class Member:
    def __init__(self, id: str, name: str):
        self.id = id
        self.name = name

    # 貸出上限に関するルールをMemberが持つ
    def check_loan_limit(self, current_loans_count: int):
        if current_loans_count >= 5:
            raise ValueError("貸出上限数に達しています")
```

**📁 `domain/aggregates/loan.py` (After)**

```python
from datetime import datetime, timedelta

class Loan:
    def __init__(self, id: str, book_id: str, member_id: str, loan_date: datetime, due_date: datetime):
        self.id = id
        self.book_id = book_id
        self.member_id = member_id
        self.loan_date = loan_date
        self.due_date = due_date

    # Loanの生成ルールをファクトリにカプセル化
    @classmethod
    def create(cls, book: Book, member: Member, current_loans_count: int) -> 'Loan':
        # 関連する集約にルールチェックを依頼
        member.check_loan_limit(current_loans_count)
        # book.lend()の中でis_available()がチェックされる
        
        loan_date = datetime.now()
        due_date = loan_date + timedelta(days=14)
        
        return cls(generate_id(), book.id, member.id, loan_date, due_date)
```

#### ユースケース (シンプルになった指揮者)

**📁 `usecases/lend_book.py` (After)**

```python
class LendBookUseCase:
    def __init__(
        self,
        book_repo: IBookRepository,
        member_repo: IMemberRepository,
        loan_repo: ILoanRepository
    ):
        self._book_repo = book_repo
        self._member_repo = member_repo
        self._loan_repo = loan_repo

    def execute(self, book_id: str, member_id: str):
        # 1. 必要な集約や情報を取得する
        book = self._book_repo.find_by_id(book_id)
        member = self._member_repo.find_by_id(member_id)
        current_loans_count = self._loan_repo.count_by_member(member_id)

        # 2. ドメインモデルに仕事をお願いする（if文が消えた！）
        #    Loanの生成と、そのためのルールチェックを依頼
        new_loan = Loan.create(book, member, current_loans_count)
        
        #    Bookの状態変更を依頼
        book.lend()
        
        # 3. 変更があった集約をまとめて保存する
        self._book_repo.save(book)
        self._loan_repo.save(new_loan)
```

この比較で、集約を導入することが、ユースケースのロジックをいかにドメインモデルに移動させ、コード全体をクリーンで安全なものにするかが明確になったかと思います。
