## 集約のリファクタリング例

値オブジェクトの適用が完了した状態をベースに、`LendBookUseCase`を題材として、**集約**のリファクタリングに焦点を当てていきましょう。

ここでのゴールは、**UseCaseに書かれているビジネスロジックを、あるべき場所（ドメインモデル）に移動させる**ことです。

-----

### Before：集約適用前の`LendBookUseCase`

値オブジェクトは導入済みですが、貸出に関するビジネスルール（`if`文）がまだUseCaseに残っている状態です。

**📁 `domain/aggregates/book.py` (Before)**

```python
class Book:
    def __init__(self, id: str, title: str, isbn: Isbn, is_loaned: bool):
        self.id = id
        self.title = title
        self.isbn = isbn
        self._is_loaned = is_loaned

    # 自分の状態を答えることはできるが、状態を変更するロジックはまだない
    def is_available(self) -> bool:
        return not self._is_loaned
```

**📁 `usecases/lend_book.py` (Before)**

```python
class LendBookUseCase:
    def __init__(self, book_repo: IBookRepository, loan_repo: ILoanRepository):
        self._book_repo = book_repo
        self._loan_repo = loan_repo

    def execute(self, book_id: str, user_id: str):
        book = self._book_repo.find_by_id(book_id)
        user_loan_count = self._loan_repo.count_by_user(user_id)

        # ▼▼ ビジネスロジックがここにある ▼▼
        if not book.is_available():
            raise ValueError("この本は貸出中です")
        
        if user_loan_count >= 5:
            raise ValueError("貸出上限は5冊です")
        # ▲▲ ここまで ▲▲

        # UseCaseがBookの状態を直接変更してしまっている
        book._is_loaned = True # これは良くない例
        self._book_repo.save(book)

        # Loanの生成と保存
        loan = Loan(id=generate_id(), book_id=book_id, user_id=user_id)
        self._loan_repo.save(loan)
```

-----

### ✨ After：集約として振る舞いを実装

`Book`と`Loan`を集約として捉え、貸出に関するルールと振る舞いをそれぞれのクラスにカプセル化します。

#### 1\. `Book`集約に状態変更の振る舞いを追加

`Book`自身が「貸し出される」という振る舞いを持つべきです。これにより、UseCaseが`Book`の内部状態 (`_is_loaned`) を直接操作することを防ぎます。

**📁 `domain/aggregates/book.py` (After)**

```python
class Book:
    # ... __init__ と is_available は同じ ...

    # 「貸し出される」という振る舞いをメソッドとして実装
    def lend(self):
        # 自分の状態は自分でチェックする
        if not self.is_available():
            raise ValueError("この本は貸出中です")
        self._is_loaned = True

    def return_back(self):
        self._is_loaned = False
```

#### 2\. `Loan`集約に生成ルールをカプセル化

「貸出上限を超えていないか」というルールは、新しい`Loan`（貸出）を**生成する**ための前提条件です。したがって、このロジックは`Loan`のファクトリメソッドに含めるのが最適です。

**📁 `domain/aggregates/loan.py` (After)**

```python
from domain.aggregates.book import Book

class Loan:
    # ... __init__ は同じ ...

    @classmethod
    def create(cls, book: Book, user_id: str, user_loan_count: int) -> 'Loan':
        # ルール1：貸出上限チェック
        if user_loan_count >= 5:
            raise ValueError("貸出上限は5冊です")
        
        # ルール2：本の貸出可否チェック (Bookの振る舞いを呼び出す)
        if not book.is_available():
            raise ValueError("この本は貸出できません。")
        
        return cls(id=generate_id(), book_id=book.id, user_id=user_id)
```

*(補足: `book.is_available()`のチェックは`book.lend()`内でも行われますが、`Loan.create`の時点で失敗を早期に検出できるため、両方にあっても問題ありません。)*

#### 3\. 生まれ変わった`LendBookUseCase`

ビジネスロジックがドメインモデルに移動したことで、UseCaseは驚くほどシンプルになります。

**📁 `usecases/lend_book.py` (After)**

```python
class LendBookUseCase:
    # ... __init__ は同じ ...

    def execute(self, book_id: str, user_id: str):
        # 1. 必要な情報を集める
        book = self._book_repo.find_by_id(book_id)
        user_loan_count = self._loan_repo.count_by_user(user_id)

        # 2. ドメインモデルに仕事をお願いする（指揮を振る）
        #    - if文が消え、ビジネスの言葉に近いメソッド呼び出しになった
        new_loan = Loan.create(book, user_id, user_loan_count)
        book.lend()

        # 3. 結果を保存する
        self._loan_repo.save(new_loan)
        self._book_repo.save(book)
```

### \#\# まとめ

このリファクタリングにより、

  * **ルールが一元化された**: 貸出上限のルールは`Loan`が、本の状態に関するルールは`Book`が知っている状態になり、知識が適切な場所に配置されました。
  * **UseCaseがシンプルになった**: `if`文が消え、「どのオブジェクトに何をさせるか」を記述するだけの、見通しの良いコードになりました。
  * **安全性が向上した**: 開発者は`Loan.create()`と`book.lend()`を呼び出すだけでよくなり、ルールチェックを忘れるという人為的ミスが構造的に起こりえなくなりました。

これが、集約がもたらす「**ビジネスルールをカプセル化した安全な部品**」としての強力なメリットです。