## 戦術的設計パターン

まずはステップ1「戦術的設計から始める」\*に取り組みましょう。以前作成した「図書館システム」を題材に、DDDの戦術的設計パターンを使ってリファクタリングする形で、DDDの世界に足を踏み入れていきましょう。

-----

## ステップ1: DDDの戦術的設計でリファクタリングする

クリーンアーキテクチャでは、関心の分離に重点を置き、`Entities` はビジネスルールを持つオブジェクトではあるものの、比較的データ構造に近い形で実装されることもあります。DDDの戦術的設計は、この `Entities`（ドメイン層）をより豊かで、表現力のあるものに育てていくアプローチだと考えてください。

### 1. 値オブジェクト (Value Object) の導入：「ただの文字列」から「意味のある型」へ

まず、一番取り入れやすく効果が高いのが**値オブジェクト**です。これは、**値を表す不変（Immutable）なオブジェクト**のことです。

#### どこに使えるか？

図書館システムには、以下のような「ただの型で表現されがちな情報」がありませんでしたか？

  * 本のISBNコード (`String`)
  * 本のタイトル (`String`)
  * 利用者の氏名 (`String`)
  * 貸出日や返却日 (`Date`)

これらを独自の「型」として定義し、その値が持つべきルールをオブジェクト自身に持たせます。

#### ✨ リファクタリング例：本のISBNコード

**Before: 単なる文字列として扱う**

```typescript
// クリーンアーキテクチャのEntity（少し単純化した例）
class Book {
  public readonly id: string;
  public isbn: string; // ただの文字列
  public title: string;

  constructor(id: string, isbn: string, title: string) {
    // バリデーションがここに書かれるか、UseCaseに書かれる
    if (isbn.length !== 13) {
      throw new Error("ISBNは13桁です");
    }
    this.id = id;
    this.isbn = isbn;
    this.title = title;
  }
}
```

**After: `Isbn` 値オブジェクトを導入**

`Isbn`というクラスを作り、ISBNに関する知識（フォーマットなど）をそこに閉じ込めます。

```typescript
// 1. Isbn 値オブジェクトを定義
class Isbn {
  public readonly value: string;

  constructor(value: string) {
    // 値オブジェクトの責務としてバリデーションを行う
    if (!/^\d{13}$/.test(value)) { // 13桁の数字であるか
      throw new Error("ISBNの形式が正しくありません。");
    }
    this.value = value;
  }

  // 値として等しいかを比較するメソッド
  equals(other: Isbn): boolean {
    return this.value === other.value;
  }
}

// 2. BookエンティティがIsbn型を持つように変更
class Book {
  public readonly id: string;
  public isbn: Isbn; // Isbn型を持つ！
  public title: string;

  constructor(id: string, isbn: Isbn, title: string) {
    this.id = id;
    this.isbn = isbn;
    this.title = title;
  }
}

// 利用例
const validIsbn = new Isbn("9784297100782");
// const invalidIsbn = new Isbn("INVALID-ISBN"); // ここでエラーになる！
const book = new Book("book-1", validIsbn, "良いコードとは何か");
```

**💡 ポイント**

  * **不正な値の排除**: `Book`エンティティは、生成された時点で必ず正しい形式の`Isbn`を持つことが保証されます。
  * **意図の明確化**: `isbn: string` よりも `isbn: Isbn` の方が、これがただの文字列ではなく「ISBNコード」であることが一目瞭然です。
  * **ロジックの置き場所**: ISBNに関するルールは全て`Isbn`クラスに集約され、コードの見通しが良くなります。

-----

### 2. 集約 (Aggregate) で一貫性を守る：「まとまり」で考える

次にご質問にあった\*\*集約（Aggregate）\*\*です。これは、**一貫性を保つべきエンティティと値オブジェクトをまとめた単位**であり、DDDの戦術的設計における中核的な概念です。

#### 図書館システムでの集約は？

「BookとLoanでAggregateを作れないか？」というご質問、素晴らしい着眼点です！まさにDDD的な思考の第一歩です。

ここで重要なルールがあります。
**「トランザクションは、常に1つの集約に対してのみ行われるべき」**

これを踏まえて考えてみましょう。

  * **「貸出」という操作**を考えます。この操作は「ある`Book`の状態を『貸出中』に変え」「新しい`Loan`（貸出情報）を作成する」という2つの処理が不可分に行われる必要があります。
  * もし`Book`と`Loan`が別々の集約だと、2つの集約をまたいで更新することになり、トランザクション管理が複雑になります。

そこで、**`Loan`（貸出）を中心とした集約**を考えてみましょう。しかし、`Book`自体も独立して存在し、「蔵書登録」などの操作対象になります。

DDDでは、このような場合、**集約は他の集約をIDで参照する**のが一般的です。

#### ✨ リファクタリング例：貸出処理

**Before: UseCaseにロジックが集中**

UseCaseが`Book`リポジトリと`Loan`リポジトリを操作し、一貫性を保つ責任を持っていました。

```typescript
class LendBookUseCase {
  // ...リポジトリのインジェクションなど

  execute(bookId: string, userId: string) {
    const book = bookRepository.findById(bookId);
    if (book.status === 'LOANED') {
      throw new Error("この本は貸出中です");
    }

    // 1. 本の状態を更新
    book.status = 'LOANED';
    bookRepository.save(book);

    // 2. 貸出情報を作成
    const loan = new Loan(generateId(), bookId, userId, new Date());
    loanRepository.save(loan);
  }
}
```

**After: `Book`集約と`Loan`集約を定義**

`Book`を一つの集約、`Loan`をもう一つの集約として定義し、それぞれの責務を明確にします。

**1. `Book` 集約**
本の状態管理に責任を持ちます。「貸出可能か？」というチェックや、状態変更のロジックを`Book`自身が持ちます。

```typescript
type BookStatus = 'AVAILABLE' | 'LOANED';

class Book { // Bookは集約ルート
  public readonly id: string;
  private status: BookStatus;

  constructor(id: string, status: BookStatus) {
    this.id = id;
    this.status = status;
  }

  // Book自身が貸出可能かを判断する（振る舞い）
  public isAvailable(): boolean {
    return this.status === 'AVAILABLE';
  }

  // 貸し出す（状態変更の振る舞い）
  public markAsLoaned(): void {
    if (!this.isAvailable()) {
      throw new Error("この本は貸出中です");
    }
    this.status = 'LOANED';
  }

  // 返却される（状態変更の振る舞い）
  public markAsAvailable(): void {
    this.status = 'AVAILABLE';
  }
}
```

**2. `Loan` 集約**
「誰が」「どの本を」「いつから」借りているか、という貸出情報そのものに責任を持ちます。

```typescript
class Loan { // Loanも独立した集約ルート
  public readonly id: string;
  public readonly bookId: string; // Bookの実体ではなくIDで参照！
  public readonly userId: string;
  public readonly loanedAt: Date;
  private returnedAt: Date | null;

  constructor(id: string, bookId: string, userId: string, loanedAt: Date) {
    this.id = id;
    this.bookId = bookId;
    this.userId = userId;
    this.loanedAt = loanedAt;
    this.returnedAt = null;
  }

  // ファクトリメソッドで生成をカプセル化
  public static create(book: Book, userId: string): Loan {
      if(!book.isAvailable()) {
          throw new Error("この本は貸出できません。");
      }
      return new Loan(generateId(), book.id, userId, new Date());
  }
}
```

**3. UseCase の役割の変化**
UseCaseは、集約同士を協調させる「オーケストレーター」になります。

```typescript
class LendBookUseCase {
  // ...

  execute(bookId: string, userId: string) {
    // 1. Book集約を取得
    const book = bookRepository.findById(bookId);

    // 2. Loan集約を生成（この中で貸出可能かチェックされる）
    const newLoan = Loan.create(book, userId);

    // 3. Book集約の状態を変更
    book.markAsLoaned();

    // 4. トランザクション内で両方の集約を保存
    transaction.run(() => {
        bookRepository.save(book);
        loanRepository.save(newLoan);
    });
  }
}
```

**💡 ポイント**

  * **集約ルート (Aggregate Root)**: `Book`と`Loan`がそれぞれのまとまりの代表（ルート）です。外部からそのまとまりを操作する際は、必ずルートを経由します。
  * **IDによる参照**: `Loan`は`Book`のインスタンスを直接持つのではなく、`bookId`で参照します。これにより、`Book`と`Loan`の結合が疎になり、お互いを気にせず変更しやすくなります。
  * **エンティティの振る舞い**: `book.isAvailable()`や`book.markAsLoaned()`のように、エンティティ自身がビジネスルールに基づいた振る舞いを持つようになります。これは**ドメイン貧血症モデル**（データしか持たないエンティティ）からの脱却を意味します。
  * **トランザクション境界**: 保存処理は集約ごとに行います。UseCaseは、複数の集約の変更を一つのトランザクションで完了させる責任を持ちます。

-----

### まとめ

今回は、クリーンアーキテクチャで構築した図書館システムを、DDDの**値オブジェクト**と**集約**というパターンを使ってリファクタリングするイメージを掴んでいただきました。

| クリーンアーキテクチャ的 | → | DDD戦術的設計 | 備考 |
| :--- | :-: | :--- | :--- |
| `String`, `Int` などのプリミティブ型 | → | **値オブジェクト (Value Object)** | `Isbn`, `UserName`, `LoanDate` など |
| データ保持が主体のEntity | → | **振る舞いを持つEntity** | 自身の状態は自身のメソッドで変更する |
| UseCaseに集中するビジネスロジック | → | **集約 (Aggregate) にカプセル化** | 一貫性を守る単位でロジックをまとめる |
| Entity間の直接参照 | → | **IDによる参照** | 集約間の結合を疎にする |

このように戦術的設計を適用することで、クリーンアーキテクチャのドメイン層がよりドメインのルールや知識を表現豊かにコードに落とし込んだものになります。

まずはこの感覚に慣れていただくのが良いと思います。もしよろしければ、次は「自動販売機」を題材に、「お金」を値オブジェクトとして扱ったり、「商品在庫」と「投入金額」を集約として考えるリファクタリングにも挑戦してみませんか？

もちろん、次のステップである**戦略的設計**に進む準備ができていれば、そちらの解説に進みます。いかがでしょうか？

