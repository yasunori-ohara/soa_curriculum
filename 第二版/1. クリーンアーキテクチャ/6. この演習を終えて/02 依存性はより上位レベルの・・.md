## 🤔 依存性は、より上位レベルの方針にのみ向けよ

これは、クリーンアーキテクチャの**最も重要なルール**であり、同心円の図が示す「依存性のルール」そのものです。

![クリーンアーキテクチャ・同心円](../クリーンアーキテクチャ・同心円.png)

この図が示す通り、ソースコードの依存関係（`import`文など）の矢印は、必ず円の外側から内側に向かわなければなりません。円をまたぐ矢印が、**決して内側から外側を向くことは許されません。**

  * **上位レベルの方針**: 円の中心に近いもの（`Entities`, `Use Cases`）。これらはビジネスの本質であり、システムの「目的」を定義します。
  * **下位レベルの実装**: 円の外側に近いもの（`Adapters`, `Frameworks`）。これらは、上位レベルの目的を実現するための具体的な「手段」や「道具」です。

このルールはつまり、「**手段や道具（詳細）は、目的（方針）を知ってそれに尽くすべきだが、目的が特定の手段や道具に依存してはならない**」という考え方を強制します。

## 🛠️ 題材との関連（自動販売機）

1.  `ui_layer.py`（**下位レベル**：UIという手段）は、`application/select_item_interactor.py`（**上位レベル**：商品を選択するという目的）を`import`して利用します。（外→内）
2.  `application/select_item_interactor.py`（**上位レベル**）は、`domain/entities.py`（**さらに上位レベル**：商品やお金の概念）を`import`して利用します。（外→内）
3.  しかし、その逆は決してありません。`domain/entities.py`が`application`層や`adapters`層のファイルを`import`することは絶対にありません。

この一方通行の依存関係を徹底することで、システムの核であるビジネスルール（`Entity`や`Use Case`）が、UIやDBといった具体的な技術の詳細から完全に守られるのです。例えば、UIをコンソールからタッチパネルに変更しても、円の内側にあるビジネスルールは一切影響を受けません。

## 🤔 昔は 依存関係がわかるようなモジュール名を付けるのも一苦労でしたが、クリーンアーキテクチャでは この同心円に沿った名前を付ければ、全員が依存関係がわかるようになりそうですね。

はい、まさしくその通りです。

クリーンアーキテクチャが優れている点の一つは、**依存関係のルールが、そのままディレクトリ名やパッケージ名という「共通言語」になる**ことです。


### 共通言語としてのアーキテクチャ

昔のプロジェクトでは、`utils`や`common`、`helpers`といった曖昧な名前のモジュールが作られ、どこからどこへ依存しているのかが分かりにくくなることがよくありました。

しかし、クリーンアーキテクチャでは、同心円の構造に沿ってディレクトリを分けるのが一般的です。

```
/project
├── domain/       # (Entities)
├── application/  # (Use Cases)
├── adapters/     # (Interface Adapters)
└── infrastructure/ # (Frameworks & Drivers)
```

この構造を見た開発者は、全員が瞬時に以下のルールを理解できます。

  * `domain`フォルダ内のコードは、他のどのフォルダも参照（`import`）してはならない。
  * `application`フォルダ内のコードは、`domain`だけを参照できる。
  * `adapters`フォルダ内のコードは、`application`と`domain`を参照できる。

このように、**ディレクトリ構造そのものが「依存性のルール」を雄弁に物語る**ため、開発者が増えても、あるいは久しぶりにコードを読むときでも、「このモジュールはどこに依存して良いのか」という規律が自然と保たれます。

これは、アーキテクチャがチーム全体の**共通の地図**となり、迷子になるのを防いでくれる、非常に強力な効果です。
