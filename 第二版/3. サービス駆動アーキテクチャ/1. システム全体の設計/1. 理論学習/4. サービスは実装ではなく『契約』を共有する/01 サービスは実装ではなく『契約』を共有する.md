## 3. サービスは実装ではなく「契約」を共有する (Services share contract, not implementation)

この原則は、私たちがこの前に詳しく学んできた**OpenAPIとControllerの関係性の核心**をなすものです。


この原則の核心は、**「サービス同士は、ソースコードやデータベースのような『実装の詳細』を共有して連携するのではなく、API仕様のような言語や技術に依存しない『契約』だけを共有して連携すべきである」**という考え方です。

### 🤝 なぜ実装を共有してはいけないのか？

例えば、「注文サービス」と「発送サービス」の両方が、「商品」という概念を扱うとします。
ここで、「商品」クラスを定義した共通ライブラリを作り、両方のサービスで共有してしまうとどうなるでしょうか？

もし「発送サービス」のチームが、発送重量を計算するために「商品」クラスに`weight`（重量）というプロパティを追加してライブラリを更新した場合、その変更は「注文サービス」にも影響します。「注文サービス」は`weight`など全く必要ないにも関わらず、ライブラリの更新に追従しなければならなくなるかもしれません。

このように実装を共有してしまうと、サービス間に**密な結合**が生まれ、片方のサービスの変更がもう片方のサービスを破壊する可能性が生まれます。これでは、独立したデプロイも、サービスの自律性も失われてしまいます。

### 🤝 「契約」を共有するとは？：コンセントの例え

この原則は、家庭の**壁のコンセント**に例えることができます。

電力会社（サービス提供者）と家電メーカー（利用者）は、「日本のコンセントは交流100Vで、この形をしている」という**「契約」**だけを共有しています。



この契約さえ守れば、電力会社は発電方法を火力から水力に変えてもいいし（**実装の変更**）、メーカーはテレビでもドライヤーでも自由に作って繋ぐことができます。メーカーは、発電所のタービンの仕組み（**実装の詳細**）を知る必要は一切ありません。

APIの世界では、この「契約」がまさに**OpenAPI仕様書**にあたります。サービスAがJavaで書かれていようと、サービスBがPythonで書かれていようと、OpenAPIという共通の「契約」を通じて、互いの実装を全く知ることなく、完璧に連携できるのです。

### 🤝 これまでの学習との関連

* **OpenAPI**: この原則で言う**「契約」そのもの**を定義する技術です。
* **ドメイン駆動設計(DDD)**: 「契約」でやり取りされる情報の**語彙と構造**を定義します。境界づけられたコンテキストのユビキタス言語が、OpenAPIの`schemas`（データ定義）の元になります。
* **クリーンアーキテクチャ**: サービス**内部の実装**が、外部に公開する「契約」としっかり分離されることを保証します。`Controller`が契約の窓口となり、内部の実装詳細が外部に漏れ出すことを防ぎます。

### 🤝 まとめ

| 概念 | この原則における役割 |
| :--- | :--- |
| **OpenAPI** | **「契約」そのもの**を形式的に定義する |
| **ドメイン駆動設計** | **「契約」の内容と語彙**をビジネスに基づいて決定する |
| **クリーンアーキテクチャ** | **「実装」が「契約」を遵守し**、内部詳細が漏れないように守る |

この原則を守ることで、サービス間の結合度は最小限に抑えられ、真の技術的多様性と、独立したサービスの進化が可能になるのです。

