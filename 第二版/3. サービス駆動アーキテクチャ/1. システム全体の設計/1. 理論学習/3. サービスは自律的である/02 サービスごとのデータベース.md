## サービスごとのデータベース（Database per Service）

サービスの自律性を実現するための最も重要で基本的な設計パターンです。

これは、**各サービスがそれぞれ自分専用のプライベートなデータベースを所有する**という考え方です。他のサービスは、このデータベースに直接アクセスすることを固く禁じられます。あるサービスのデータが必要な場合は、必ずそのサービスが公開しているAPIを通じて問い合わせなければなりません。


---
### ✨ なぜこのパターンが重要なのか？

このパターンは、サービスの**自律性**と**疎結合**を強力に促進します。

* **真の自律性の実現**
    データベースの構造（スキーマ）は、そのサービスの内部実装の一部です。もし他のサービスがデータベースを直接参照していると、スキーマを少し変更しただけで、依存している全てのサービスが壊れてしまいます。これでは独立したデプロイは不可能です。データベースを完全にプライベートにすることで、サービスチームは他の誰にも気兼ねなく、自分たちのデータベースを自由に変更・進化させることができます。

* **技術選択の自由**
    各サービスが自身のニーズに最適なデータベース技術を選択できます。例えば、ユーザー情報を扱うサービスは信頼性の高い**PostgreSQL（リレーショナルDB）**を、柔軟な商品カタログを扱うサービスは**MongoDB（ドキュメントDB）**を、といったように、目的に応じて最適なツールを選ぶ「ポリグロット・パーシステンス（polyglot persistence）」が実現できます。

* **独立したスケーリング**
    特定のサービス（例えばアクセスが集中する商品サービス）のデータベースだけを独立してスケールアウト（拡張）させることができます。

---
### ✨ 新たに生まれる課題

このパターンは多くの利点をもたらしますが、モノリシックな共有データベースでは存在しなかった、新たな課題も生まれます。

* **複数のサービスにまたがるデータの取得**
    共有データベースなら`JOIN`一発で済んだクエリが実行できなくなります。例えば、「ユーザー情報とそのユーザーの最新の注文情報」を取得したい場合、ユーザーサービスと注文サービスの両方に問い合わせる必要があります。これは一般的に**APIコンポジション**というパターンで解決します。APIゲートウェイやクライアントが、複数のサービスからデータを集めて結合するのです。

* **トランザクション管理の複雑化**
    一つのビジネスプロセスが複数のサービスにまたがる場合（例：「注文の受付」で、注文サービスにデータを書き込み、在庫サービスの在庫を減らす）、データベースをまたいだトランザクションは実現できません。これは**Saga（サーガ）パターン**と呼ばれる、非同期メッセージングを使った高度なトランザクション管理手法で解決する必要があります。

>これらの新たに生まれる課題は、サービスの自律性を追求する上で避けては通れない非常に重要なテーマです。  
>しかし、これらは応用的なパターンであり、その解決策の多くは、この後に学ぶ「コンテナ技術」や、特に「非同期メッセージング」の深い理解を前提としています。  
>そのため、現段階では**「なるほど、データベースを分けると、データの扱いに新しい工夫が必要になるんだな」と頭の片隅に置いておく**だけで大丈夫です。まずは、サービスの自律性を支える基礎的な部品を一つずつ見ていきましょう。

これらの課題はありますが、サービスの自律性を確保するという大きなメリットのために、マイクロサービスアーキテクチャではこの「サービスごとのデータベース」パターンが基本中の基本とされています。