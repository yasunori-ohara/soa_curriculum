## サービス間連携の実装（一貫した学習フロー）

第1部と同じく、「ドメイン層 → アプリケーション層 → インターフェースアダプター層」の順序で、記事詳細情報の取得機能の実装を進めます。

![同心円](../../クリーンアーキテクチャ・同心円.png)

-----

### 👑 1. ドメイン層の実装：変更なし

「記事詳細情報を取得する」という機能は、**外部のサービスから情報を集めてくる**ことが主たる目的であり、記事サービス自身の「記事とは何か」**というビジネスルール（タイトルは100文字以内など）を**変更しません。

したがって、第1部で定義した`Article`エンティティとその他のドメイン層のコードは、**この機能の実装において変更する必要はありません**。

  * **ポイント**: 機能追加によって、システムの核となる層が影響を受けないことは、アーキテクチャの**変更に対する耐性の高さを証明しています**。

-----

### 👑 2. アプリケーション層の実装：新しい「契約」と「司令塔」の定義

アプリケーション層では、新しいユースケースを定義し、そのユースケースが依存する外部サービスとの「契約書」を定義します。

#### **ステップ 2.1：外部サービスとの「契約」（ポート）の定義**

新しいユースケース（司令塔）が他のサービスに命令するために、以下の2つの抽象的な契約（インターフェース）が必要です。

```python
# application/interfaces/user_client.py
# ユーザーサービスと通信するための契約

from abc import ABC, abstractmethod
import uuid
from pydantic import BaseModel

class AuthorDetail(BaseModel):
    user_id: uuid.UUID
    user_name: str
    profile: str

class IUserClient(ABC):
    @abstractmethod
    def get_author_detail(self, author_id: uuid.UUID) -> AuthorDetail:
        """指定された著者IDの詳細情報を取得する"""
        raise NotImplementedError
```

*(補足: コメントサービス用の`ICommentClient`も同様に定義が必要です。)*

#### **ステップ 2.2：新しいユースケース（司令塔）の実装**

次に、これらの契約と、既存のリポジトリ契約を使用して、情報を集約する**オーケストレーション**のロジックを持つユースケースを実装します。

ここで、このユースケースが担う**オーケストレーション**について深く理解しましょう。

-----

### 🎶 【補足】 オーケストレーションとは？

オーケストレーション（Orchestration）とは、システムが特定のビジネス機能（今回の場合は記事詳細の表示）を完了させるために、中央の単一サービス（オーケストレーター）が、他の複数の独立したサービスに対して、**指揮者**のように振る舞い、**順番にAPIコールを制御・調整するパターン**です。

  * **私たちの事例**: `GetArticleDetailUseCase`がオーケストレーターです。
      * **役割**: 記事サービス、ユーザーサービス、コメントサービスの順で情報を要求します。
      * **目的**: クライアントが単一のAPIコールで記事の詳細画面に必要な全ての情報（記事、著者名、コメント）を**同期的に**取得できるように、情報を集約することです。

-----

#### **ユースケースの実装（再掲）**

オーケストレーションロジックを持つユースケースを実装します。

```python
# application/use_cases/get_article_detail.py (オーケストレーションの実装)

# ... (AuthorDetail, CommentDetail, ArticleDetailOutput DTOの定義は省略) ...

class GetArticleDetailUseCase:
    """
    記事詳細情報取得ユースケース。外部サービスとの通信を「契約」を通じて指揮する。
    """
    def __init__(self, article_repo: IArticleRepository, user_client: IUserClient, comment_client: ICommentClient):
        # 3つの契約（インターフェース）に依存し、具象実装を知らない
        self.article_repo = article_repo
        self.user_client = user_client
        self.comment_client = comment_client

    def execute(self, article_id: uuid.UUID) -> ArticleDetailOutput:
        # 1. 記事情報を取得 (自身のDB)
        article = self.article_repo.get_by_id(article_id) 
        if article is None:
            raise ArticleNotFoundError(f"Article ID: {article_id} not found.")

        # 2. 著者情報を取得 (外部サービス - IUserClient契約を通じて)
        author_detail = self.user_client.get_author_detail(article.author_id)
        
        # 3. コメント一覧を取得 (外部サービス - ICommentClient契約を通じて)
        comments = self.comment_client.get_comments_by_article(article_id)

        # 4. 全ての情報を集約して返す
        return ArticleDetailOutput(
            article_id=article.article_id,
            # ... (記事情報)
            author=author_detail,
            comments=comments
        )
```

-----

### 👑 3. インターフェースアダプター層の実装：通訳と玄関口の作成

最後に、アプリケーション層で定義された**抽象的な契約**（インターフェース）を、具体的な技術で実現します。

#### **ステップ 3.1：リポジトリの修正**

既存の`InMemoryArticleRepository`に、`get_by_id`メソッドを**追加**します。

```python
# adapters/repositories/in_memory_article_repository.py (修正・追加)

# ... (既存のsaveメソッドはそのまま) ...

def get_by_id(self, article_id: uuid.UUID) -> Article | None:
    """
    IArticleRepositoryインターフェースに新しく必要となったメソッドを実装
    """
    return self._articles.get(article_id) # 記事が見つかれば返し、なければNoneを返す
```

#### **ステップ 3.2：外部クライアントアダプターの実装**

`IUserClient`という契約を実装する、具体的な\*\*通訳（クライアントアダプター）\*\*を作成します。

```python
# adapters/clients/http_user_client.py (今回はダミーで実装)

# ... (必要なimportは省略) ...

class HttpUserClient(IUserClient):
    def get_author_detail(self, author_id: uuid.UUID) -> AuthorDetail:
        # 実際にはここに requests.get('http://user-service/...'...) のHTTP通信コードが入る
        print(f"--- [ADAPTER] Calling User Service for ID: {author_id} ---")

        # 疎結合のため、外部サービスのエラーも適切にハンドルする必要がある
        if str(author_id) == "00000000-0000-0000-0000-000000000000":
             raise ExternalServiceError("User service reported user not found.")

        # ダミーの著者情報を返す
        return AuthorDetail(user_id=author_id, user_name="オーケスト太郎", profile="...")
```

*(補足: コメントサービス用の`HttpClientCommentClient`も同様に定義が必要です。)*

#### **ステップ 3.3：コントローラー（玄関口）の実装**

FastAPIコントローラーに、設計したエンドポイント（`GET /articles/{articleId}/details`）と、新しいユースケースを呼び出すロジックを追加します。

```python
# adapters/controllers/article_controller.py (修正・追加)

# ... (必要なimportは省略) ...
# 新しいユースケースをインポート
from application.use_cases.get_article_detail import GetArticleDetailUseCase, ArticleDetailOutput 
# DI関数のインポート (main.pyで定義)
from main import get_article_detail_use_case 


@router.get("/articles/{articleId}/details", response_model=ArticleDetailOutput, status_code=200)
def get_article_details(
    articleId: uuid.UUID = Path(...), # パスパラメータ
    # 新しいユースケースに依存性注入
    use_case: GetArticleDetailUseCase = Depends(get_article_detail_use_case)
):
    try:
        # ユースケースを実行
        article_details = use_case.execute(articleId)
        return article_details
    except ArticleNotFoundError:
        raise HTTPException(status_code=404, detail=f"Article ID: {articleId} not found.")
    except Exception as e:
        # 外部サービスのエラーもここで適切にHTTPエラーに変換
        raise HTTPException(status_code=500, detail=f"An error occurred: {str(e)}")
```

#### **ステップ 3.4：全体を繋ぎ合わせる（依存性注入の更新）**

`main.py`で、新しいユースケースとクライアントの具象実装を生成し、全てを繋ぎ合わせます。

```python
# main.py (更新箇所)

# ... (既存のCreateArticleUseCaseのDI設定は省略) ...

# 1. クライアントアダプターのインスタンス化
user_client = HttpUserClient()
comment_client = HttpClientCommentClient() # コメント用もインスタンス化

# 2. 新しいユースケースのインスタンスを生成し、必要な依存関係をすべて注入
get_article_detail_use_case = GetArticleDetailUseCase(
    article_repo=in_memory_repo, # 既存のリポジトリを使い回す
    user_client=user_client,
    comment_client=comment_client
)

# 3. FastAPIにユースケースを渡すための関数
def get_article_detail_use_case() -> GetArticleDetailUseCase:
    return get_article_detail_use_case
```

-----

これで、**第2部：サービス間連携の実装**は完了です。