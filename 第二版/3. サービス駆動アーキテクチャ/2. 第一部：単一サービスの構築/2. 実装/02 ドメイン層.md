## 第1部 ステップ2：個別実装

### 1. ドメイン層の実装：ビジネスの核となるルールを定義する

**ドメイン層**は、クリーンアーキテクチャの中心に位置する、最も重要で神聖な場所です。ここには、ビジネスの本質的なルール（**エンタープライズビジネスルール**）と、そのルールを体現するデータ構造（**エンティティ**）を記述します。

この層を実装する上での絶対的なルールは、\*\*「いかなる外部の技術にも依存しない」\*\*ことです。つまり、FastAPIのようなWebフレームワークや、データベースライブラリのコードを一切`import`しません。純粋なPythonの機能だけで実装します。

#### **「記事（Article）」エンティティの定義**

「記事サービス」の核となる`Article`エンティティを定義します。このクラスは、単なるデータの入れ物ではなく、「記事とは何か」「記事はどうあるべきか」というビジネスルールそのものを表現します。

  * **ビジネスルールの検討**:

      * 記事には、必ず`タイトル`と`本文`がなければならない。
      * `タイトル`には文字数制限（例: 100文字）を設けよう。
      * 記事ID（`article_id`）や著者ID（`author_id`）は、世界中で重複しないように**UUID形式**にしよう。
      * 作成日時（`created_at`）は、一度設定されたら変更されてはならない。
      * 更新日時（`updated_at`）は、記事が更新されるたびに自動で更新されるべきだ。

  * **実装コード (`domain/article.py`)**:

    ```python
    # domain/article.py

    import uuid
    from datetime import datetime, timezone
    from pydantic import BaseModel, Field

    class Article(BaseModel):
        """
        記事エンティティ。ビジネスの核となるデータとルールを定義する。
        """
        # --- 属性の定義 ---
        # Fieldを使って、各属性の制約（ビジネスルール）を定義する

        # article_idは、UUID形式。指定がなければ自動で生成される。
        article_id: uuid.UUID = Field(default_factory=uuid.uuid4)
        
        # author_idは、記事の作成時に必ず指定が必要なUUID。
        author_id: uuid.UUID
        
        # titleは、1文字以上100文字以下の文字列。
        title: str = Field(min_length=1, max_length=100)
        
        # contentは、1文字以上の文字列。
        content: str = Field(min_length=1)

        # created_atは、指定がなければ現在時刻（UTC）が自動で設定される。
        created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

        # updated_atも、指定がなければ現在時刻（UTC）が自動で設定される。
        updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

        class Config:
            # Pydanticモデルの属性に後から値を代入する際の検証を有効にする
            validate_assignment = True

        # ---振る舞い（メソッド）の定義 ---
        # エンティティ自身の状態を変更するロジックは、エンティティのメソッドとして定義する

        def update(self, title: str, content: str):
            """
            記事を更新し、updated_atを自動更新するメソッド。
            このメソッドを通じてのみ、安全に記事を更新できる。
            """
            self.title = title
            self.content = content
            self.updated_at = datetime.now(timezone.utc)
            
            # メソッドチェーンのために自身を返す（任意）
            return self
    ```

#### **実装のポイント**

  * **Pydanticによるビジネスルールの強制**: `Field(min_length=1)`のような記述により、「タイトルは空であってはならない」というビジネスルールをコードで表現しています。もしルールに反するデータで`Article`オブジェクトを作ろうとすると、Pydanticがエラーを発生させ、不正なデータが生まれることを防ぎます。
  * **振る舞いのカプセル化**: 記事の更新ロジックを`update`メソッドにまとめています。重要なのは、`updated_at`がこのメソッド内で自動的に更新される点です。これにより、更新日時を更新し忘れるといった人的ミスを防ぎ、エンティティが常に正しい状態（整合性）を保つことを保証します。
  * **フレームワークからの独立**: この`article.py`ファイルは、FastAPIやデータベースライブラリを一切`import`しておらず、完全に独立しており、このファイル単体でテストすることができます。

-----

### 補足解説：コードの読み解き方

#### **UUID形式とは何か？**

**UUID**は "Universally Unique Identifier" の略で、「**汎用一意識別子**」と訳されます。一言で言うと、\*\*「世界中の誰が生成しても、絶対に重複しないように設計されたID番号」\*\*です。この「誰にもお伺いを立てずに安全なIDを生成できる」という特性が、サービスが自律的に動くSOAと非常に相性が良いのです。

#### **Pydanticによる宣言的プログラミング**

このコードは、Pydanticというライブラリの強力な機能に支えられています。

  * **なぜ`if`文が不要なのか？**: `Field(max_length=100)`のように、あるべき姿（**What**）を**宣言**するだけで、Pydanticが裏側で必要なチェック処理（**How**）を全て自動的に実行してくれるからです。これにより、ビジネスルールを宣言することに集中でき、コードがクリーンになります。
  * **`BaseModel`**: このクラスを継承することで、Pydanticのデータ検証機能が有効になります。
  * **`default_factory`**: オブジェクトが新しく作られる**たびに**関数を実行してデフォルト値を生成させることができます。これにより、全ての記事がユニークなIDを持つことを保証します。
  * **`lambda`と`timezone.utc`**: `lambda:`はPythonで1行の簡単な関数を作るための構文です。`timezone.utc`と組み合わせることで、「現在時刻を\*\*世界標準時(UTC)\*\*で取得する」という処理を`default_factory`に渡しています。
  * **`Config`と`validate_assignment`**: `validate_assignment = True`と設定することで、オブジェクトが作られた後で属性に値を代入しようとした際にも、再度バリデーションが実行されるようになり、より堅牢性が増します。

-----

これで、サービスの心臓部であるドメイン層が完成しました。
