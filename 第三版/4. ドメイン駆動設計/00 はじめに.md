# 第4部：DDD（ドメイン駆動設計）

## 第0章：はじめに ― クリーンアーキテクチャから、さらに“内側”へ



## 🎯 この章の目的

この章では、**クリーンアーキテクチャの内側（EntityやUseCase）を強化する方法**として、
**ドメイン駆動設計（DDD：Domain Driven Design）**を学びます。

DDD は「クラスを整理する技法」ではなく、
**ソフトウェアを“現実の言葉”で構造化するための考え方**です。

> クリーンアーキテクチャが “層のルール（依存の方向）” を整えるものなら、
> DDD は “意味のルール（言葉の境界）” を整えるものです。

---

## 🧭 なぜ DDD が必要なのか？

これまでのクリーンアーキテクチャでは、

* **「層の独立」**（UI・DB・ビジネスロジックの分離）
* **「依存性逆転（DIP）」**（中核ロジックが外側を知らない）

を通じて、構造的な整理ができました。

しかし実際の開発では、こうした**構造のきれいさ**だけではうまくいかない場面があります。

| 現場で起きる問題                                | クリーンアーキだけでは解決しにくい理由                   |
| --------------------------------------- | ------------------------------------- |
| 「予約」「キャンセル」「空き」「会員」などの**言葉の意味が人によって違う** | ソフトウェアの分割が**技術基準**で決まってしまう（UI/DB単位など） |
| 同じ「予約」でも部署ごとに**少しずつルールが違う**             | 一枚岩の「ドメインモデル」にするとすぐ破綻する               |
| 機能を増やすたびに影響範囲が拡大する                      | 「言葉の境界」が曖昧だから独立できない                   |

こうした混乱を防ぐために、DDDは「**言葉（ユビキタス言語）を軸に設計する**」という視点を導入します。

---

## 💬 ユビキタス言語（Ubiquitous Language）とは？

DDDの最も重要な考え方です。
開発者・企画者・テスターなど、**関係者全員が共通して使う言葉**を指します。

> Ubiquitous（ユビキタス）＝「どこにでも通じる」
> Language（ランゲージ）＝「言葉・語彙・用語」

このユビキタス言語によって、

* 「予約を**確定**する」と「予約を**仮登録**する」を区別
* 「空き」は「会議室が使われていない状態」であり、「メンバーが空いている状態」とは違う
* 「キャンセル」は「削除」ではなく、「無効化（記録を残す）」

といった**業務上の言葉の意味を明確化**します。

この「意味の区切り」がそのまま後の「**システムの分割（境界づけ）**」になります。

---

## 🧩 DDDの全体像（概念マップ）

DDDには多くの専門用語がありますが、まずは大きく分けて下の２段階で理解します。

### 第1段階：言葉で構造を決める（戦略的設計）

| 用語                                 | 意味                  | 学ぶ章     |
| ---------------------------------- | ------------------- | ------- |
| **ユビキタス言語**                        | 全員が共有する言葉の辞書        | 第1章     |
| **境界づけられたコンテキスト**（Bounded Context） | 言葉の意味が統一される「囲い」     | 第1章     |
| **コンテキストマップ**                      | 境界同士の関係（依存・翻訳など）を整理 | 第1章～第3章 |

> この段階で、**どこでどんな用語が通じるか**を明確にします。
> ソフトウェアの分割は **技術ではなく言葉の単位で** 行います。

---

### 第2段階：プログラムで意味を守る（戦術的設計）

| 用語                        | 意味                      | 学ぶ章     |
| ------------------------- | ----------------------- | ------- |
| **エンティティ（Entity）**        | 一意のIDとライフサイクルを持つもの      | 第2章     |
| **値オブジェクト（Value Object）** | 値そのものが意味を持ち、等価性で判断されるもの | 第2章     |
| **集約（Aggregate）**         | 整合性を一緒に保つオブジェクトのまとまり    | 第3章     |
| **集約ルート（Aggregate Root）** | 集約を代表する「入口」             | 第3章     |
| **ドメインサービス**              | どのエンティティにも属さないビジネスロジック  | 第3章     |
| **リポジトリ（Repository）**     | 集約を永続化・取得するための“窓口”      | 第3章～第4章 |

> この段階で、クリーンアーキテクチャの **Entity層** と **UseCase層** に DDD の要素を統合します。
> つまり、**CAの枠組みの中でDDDの概念を活かす** 形になります。

---

## 🧠 DDDとクリーンアーキテクチャの関係

| 観点        | クリーンアーキテクチャ              | DDD                |
| --------- | ------------------------ | ------------------ |
| **目的**    | 依存の方向を整理し、層を独立させる        | 言葉の意味を整理し、領域を独立させる |
| **分割の単位** | 技術的な層（UI・UseCase・Entity） | 意味的な境界（予約・会員・部屋など） |
| **着目点**   | “どこからどこに依存するか”           | “どの言葉がどこで通じるか”     |
| **出発点**   | コード構造                    | 言葉と業務理解            |
| **成果物**   | クラス図・依存関係                | ドメインモデル・コンテキストマップ  |

> クリーンアーキが「**設計の土台**」、DDDが「**設計の意味づけ**」。
> ２つを組み合わせることで「人間に理解できるアーキテクチャ」になります。

---

## 📘 本教材（DDD編）の構成

| 章                             | 内容                | 到達目標               |
| ----------------------------- | ----------------- | ------------------ |
| **第1章：ユビキタス言語と境界づけられたコンテキスト** | 言葉の整理とシステム分割      | 用語の区切りでシステムを分けられる  |
| **第2章：値オブジェクトとエンティティ**        | 「型で意味を守る」設計       | 値オブジェクトの活用方法を理解    |
| **第3章：集約と集約ルート**              | 整合性を保つ設計          | 集約単位でのモデリングを体験     |
| **第4章：リポジトリとドメインサービス**        | クリーンアーキの構造に統合     | DDDとCAを接続できる       |
| **第5章：設計例 ― 会議室予約ドメインモデル**    | DDDの成果を図とコードでまとめる | 「意味で分割された」完成例を理解する |

---

## 💡 DDDがもたらす効果

| 項目                 | 効果                           |
| ------------------ | ---------------------------- |
| **変更に強い**          | 機能追加が「言葉の単位」で独立するため、影響範囲が小さい |
| **コミュニケーションが明確**   | 開発者と業務担当者が同じ言葉を使う            |
| **ソースコードがドキュメント化** | クラス名や型名がそのまま業務用語になる          |
| **テストが書きやすい**      | 値オブジェクトや集約で、ロジックが局所化される      |

---

## ⚙ DDDを学ぶときの注意点

* DDDは「高級なアーキテクチャ」ではなく、「**考え方の道具箱**」。
* **全機能に適用しようとしない**（重要なドメイン＝中核部分に絞る）。
* 現場では、**クリーンアーキ＋DDDの組み合わせ**が最も実践的。
* **難しい言葉を避けて説明できる**ようになるのがゴール。

---

## 📍この章のまとめ

| 要点              | 内容                                    |
| --------------- | ------------------------------------- |
| **DDDとは**       | 現実の言葉（ユビキタス言語）でソフトウェアを構造化する考え方        |
| **目的**          | 技術ではなく意味でシステムを分ける                     |
| **学ぶ順序**        | 言葉（UL）→ 境界（BC）→ 型（VO）→ 整合性（Aggregate） |
| **クリーンアーキとの関係** | CAの枠の中にDDDの概念を入れると、構造と意味が両立できる        |

---

次の章（**第1章：ユビキタス言語と境界づけられたコンテキスト**）では、
実際に「予約アプリの言葉」を整理しながら、
**“言葉の区切り＝システムの区切り”** を作っていきます。

---

次回（第1章）では：

* 会議室予約の用語集テンプレート
* グルーピングとコンテキスト分割
* コンテキストマップ（言葉の依存関係図）
  を図と表で提示します。

