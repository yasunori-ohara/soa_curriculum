## 第3章：契約テストとマイクロサービスCI統合

## 🎯 この章の目的

1. **契約テスト（Contract Test）**の概念と役割を理解する
2. **マイクロサービス間の変更を安全に検証**する方法を学ぶ
3. **CIパイプラインに契約テストを組み込む**構成を設計できるようにする

---

## 🧩 1. なぜ契約テストが必要か

マイクロサービス開発では、サービス同士がAPIでやり取りを行います。

**サービス構造例（単純化）**

```
Reservation Service → Member Service → Payment Service
```

💡 問題：
サービスAがAPI仕様を変更すると、サービスBが**突然動かなくなる**。
単体テストでは検出できないこの種の問題を防ぐために、
**契約テスト（Contract Test）**を導入します。

---

## 🧩 2. 契約テストの基本構造

契約テストは、以下の2つの立場で構成されます。

| 立場           | 役割        | 呼び方                   |
| ------------ | --------- | --------------------- |
| **Consumer** | APIを呼び出す側 | 例：Reservation Service |
| **Provider** | APIを提供する側 | 例：Member Service      |

💡 契約（Contract）とは：
Consumer が「こういうリクエストを送る」と宣言し、
Provider が「それにこう応答する」と保証する約束。

---

## 🧩 3. 契約テストの仕組み（Pactの例）

**Pact** は代表的な契約テストフレームワークです。
Consumer側で契約（期待）を定義し、Provider側でその契約を検証します。

💻 Consumerテスト例：

```python
# consumer/tests/test_member_contract.py
from pact import Consumer, Provider
import requests

pact = Consumer("reservation_service").has_pact_with(
    Provider("member_service"),
    pact_dir="./pacts"
)

@pact.given("Member with ID 1 exists")
@pact.upon_receiving("a request for member details")
@pact.with_request("GET", "/members/1")
@pact.will_respond_with(200, body={"id": 1, "name": "Taro"})
def test_get_member_contract():
    with pact:
        response = requests.get("http://localhost:8080/members/1")
        assert response.json()["name"] == "Taro"
```

💻 Provider側の検証：

```python
# provider/tests/test_member_provider.py
from pact import Verifier

def test_provider_against_contract():
    verifier = Verifier(provider="member_service")
    output, logs = verifier.verify_pacts("./pacts/reservation_service-member_service.json")
    assert "0 failures" in output
```

結果：
両サービスが同じ契約に基づいて動作することを自動的に検証できる。

---

## 🧩 4. 契約ファイル（Pactファイル）の役割

Consumerテストを実行すると、**Pactファイル**が生成されます。
これは「Consumerの期待仕様」をJSONとして保存したものです。

💡 例：

```json
{
  "consumer": { "name": "reservation_service" },
  "provider": { "name": "member_service" },
  "interactions": [
    {
      "description": "a request for member details",
      "request": { "method": "GET", "path": "/members/1" },
      "response": { "status": 200, "body": { "id": 1, "name": "Taro" } }
    }
  ]
}
```

このファイルを **Provider側リポジトリに自動連携** し、
Providerが変更を加えたときに検証が走るようにします。

---

## 🧩 5. Pact Brokerによる契約共有

現場では、複数チームが並行で開発します。
そのため、契約ファイルを共有・管理する仕組みとして
**Pact Broker** を利用します。

**構成イメージ（テキスト版）**

```
[Consumer（予約サービス）]
    │ Pactファイル登録
    ▼
  Pact Broker（契約の保管庫）
    ▲
    │ 検証要求
    ▼
[Provider（会員サービス）]
```

💡 Pact Brokerの役割：

* 契約ファイルの履歴管理
* Provider検証結果の可視化
* Webhookによる自動通知

---

## 🧩 6. CI統合の流れ

契約テストをCI/CDに組み込むことで、
**サービス間の変更検証を自動化**できます。

**一般的なGitHub Actions構成：**

```
1. Consumer側で契約テストを実行 → Pactファイル生成  
2. Pactファイルを Pact Broker に登録  
3. Provider側のCIが自動で契約を取得  
4. Providerがその契約に対してテスト実行  
5. 結果をBrokerに返却 → 成否を可視化
```

💻 Consumer側ワークフロー例：

```yaml
name: Consumer Tests
on: [push]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Run Consumer Contract Tests
        run: pytest consumer/tests
      - name: Publish Pact
        run: pact-broker publish ./pacts --consumer-app-version=$GITHUB_SHA
```

💻 Provider側ワークフロー例：

```yaml
name: Provider Verification
on: [push]
jobs:
  verify:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Verify Pact Contracts
        run: pact-broker can-i-deploy --pacticipant=member_service --version=$GITHUB_SHA
```

これにより、Providerがリリースされる前に
「Consumerとの互換性」が自動チェックされます。

---

## 🧩 7. 契約テスト導入のベストプラクティス

| 項目      | ベストプラクティス                    |
| ------- | ---------------------------- |
| 契約の粒度   | API単位で定義（過剰に細かくしない）          |
| スキーマ管理  | OpenAPIと整合性を保つ               |
| バージョニング | 契約ファイルにAPIバージョンを埋め込む         |
| CI統合    | Consumer→Provider検証をワークフロー化  |
| 可視化     | Pact BrokerやReport Portalを活用 |

契約テストは **「人間の調整コストを自動化する」** テストです。
チーム間調整のストレスを減らす最も効果的な手法です。

---

## 🧩 8. 契約テストの限界と補完策

契約テストは強力ですが、万能ではありません。

| 限界               | 対策                               |
| ---------------- | -------------------------------- |
| 外部APIの実データ依存     | モックAPIやSandbox環境を用意する            |
| 複雑な状態依存（例：予約→決済） | E2Eテストで最終確認を補う                   |
| 非同期イベント（Kafkaなど） | Event Contract Test（AsyncAPI）を導入 |

原則：

> 「状態を持たないAPI」は契約テストで十分。
> 「状態をまたぐ操作」はE2Eや統合テストで補う。

---

## ✅ まとめ

| 要点          | 内容                      |
| ----------- | ----------------------- |
| 契約テスト       | サービス間APIの整合を自動で保証       |
| Pact        | Consumer/Providerモデルで動作 |
| Pact Broker | 契約共有と結果管理の中枢            |
| CI統合        | GitHub Actions等で自動検証    |
| ベストプラクティス   | 粒度・バージョン・可視化を意識する       |

---

## 🔜 次章予告：「第4章　テストデータ生成と環境制御」

次章では、テストを確実に再現できるようにするための
**データ生成・環境再構築・コンテナ統合**の設計を扱います。
「**誰がいつ実行しても同じ結果になるテスト環境**」を作ります。

