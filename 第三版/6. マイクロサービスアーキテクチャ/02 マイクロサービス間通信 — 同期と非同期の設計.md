## 第2章：マイクロサービス間通信 — 同期と非同期の設計

## 🎯 この章の目的

* 同期通信（API呼び出し）と非同期通信（イベント駆動）の違いを理解する
* どちらを使うべきかを判断できるようにする
* 疎結合を保ちながら信頼性を確保する方法を学ぶ
* 通信エラーや遅延への耐性を設計に組み込む

---

## 1. サービス間通信の2つの方式

マイクロサービスでは、複数のサービスが連携して機能を実現します。
通信には、次の2つの方式があります。

| 通信方式      | タイミング           | 代表技術                       | 主な用途      |
| --------- | --------------- | -------------------------- | --------- |
| **同期通信**  | 即時（リクエスト→レスポンス） | REST / gRPC                | 情報照会・即時処理 |
| **非同期通信** | 後続処理（イベント通知）    | Kafka / RabbitMQ / SNS/SQS | 更新通知・連鎖処理 |

---

### 図：同期通信（Request / Response）

```
Reservation Service
    ↓  HTTPリクエスト
Member Service
    ↑  HTTPレスポンス
```

* 呼び出し元が相手の応答を待つ
* 即時に結果を得たい処理に向いている

---

### 図：非同期通信（Event-driven）

```
Reservation Service
    ↓  イベント発行（例：ReservationCreated）
Event Broker（Kafka / RabbitMQ など）
    ↓
    ├→ Member Service（履歴更新）
    └→ Room Service（空室更新）
```

* 発行元と購読者が直接つながらない
* 複数のサービスが同じイベントを購読できる

---

## 2. 同期通信（Request/Response型）

**定義：**
クライアントがリクエストを送り、サーバーがレスポンスを返す通信方式。
代表的なのはREST APIとgRPC。

---

### 呼び出し例：Reservation → Member

```python
import requests

class MemberGateway:
    def get_member(self, member_id: int):
        url = f"http://member-service:8000/members/{member_id}"
        response = requests.get(url)
        response.raise_for_status()
        return response.json()
```

**流れ：**

1. Reservation ServiceがMember ServiceにHTTPリクエストを送る
2. Member Serviceがレスポンスを返す
3. Reservation Serviceが結果を使って次の処理を実行

---

### メリットとデメリット

| メリット         | デメリット            |
| ------------ | ---------------- |
| 即時結果を得られる    | 相手が遅い・落ちていると停止   |
| 実装が簡単で分かりやすい | 障害伝播が起こりやすい      |
| デバッグが容易      | タイムアウトやリトライ設計が必要 |

---

### 信頼性を高める設計パターン

* Timeout（応答が遅い場合に中断）
* Retry with Backoff（再試行間隔を伸ばしてリトライ）
* Circuit Breaker（失敗が続くと一時遮断）
* Fallback（キャッシュや既存データを使用）

---

## 3. 非同期通信（Event-driven型）

**定義：**
サービスが「イベント（出来事）」を発行し、他サービスが購読して処理する方式。

---

### 例：Reservation完了イベントを通知する

```python
# 発行側（Reservation）
from kafka import KafkaProducer
import json

producer = KafkaProducer(bootstrap_servers="kafka:9092")
event = {"type": "ReservationCreated", "reservation_id": 42}
producer.send("reservation-events", json.dumps(event).encode("utf-8"))
```

```python
# 購読側（Member）
from kafka import KafkaConsumer
import json

consumer = KafkaConsumer("reservation-events", bootstrap_servers="kafka:9092")
for msg in consumer:
    event = json.loads(msg.value)
    if event["type"] == "ReservationCreated":
        print("Member Service received:", event["reservation_id"])
```

---

### メリットとデメリット

| メリット          | デメリット          |
| ------------- | -------------- |
| 発行者と購読者が疎結合   | イベント順序・重複処理が課題 |
| 落ちても再処理できる    | 処理タイミングが非同期になる |
| 新しい購読者を追加しやすい | デバッグ・トレースが難しい  |

---

### イベントスキーマ例

```json
{
  "event": "ReservationCreated",
  "version": "1.0",
  "payload": {
    "reservation_id": 42,
    "member_id": 1,
    "room_id": 3
  }
}
```

* イベントも「契約」としてバージョン管理する
* 新しい項目追加時は後方互換を維持する

---

## 4. 同期と非同期の使い分け

| 条件       | 推奨方式  | 理由             |
| -------- | ----- | -------------- |
| 即時に結果が必要 | 同期通信  | 成功・失敗をすぐに判定したい |
| 遅延してもよい  | 非同期通信 | 分散処理で安定化できる    |
| 1対多の処理   | 非同期通信 | イベントで拡張が容易     |
| 一貫性が重要   | 同期通信  | トランザクションが取りやすい |

---

## 5. ハイブリッド構成の例

```
① Reservation → Member：同期通信（会員有効性チェック）
② Reservation → Room：同期通信（空室確認）
③ Reservation → Event Broker：非同期イベント発行（ReservationCreated）
④ Member / Room / Notification：非同期で購読・更新・通知
```

**ポイント：**

* 即時判定が必要な部分は同期通信
* その後の副作用的な処理（履歴更新・通知）は非同期通信
  → パフォーマンスと安定性を両立できる構成

---

## 6. 冪等性（べきとうせい）

**定義：**

> 同じ操作を何度行っても結果が変わらない性質。

```python
if event["reservation_id"] in processed_ids:
    return  # すでに処理済み
processed_ids.add(event["reservation_id"])
```

* 各イベントやリクエストに一意なIDを付ける
* 再送されても二重登録されないようにする

---

## 7. 可観測性（Observability）

サービスが増えると、「どこで何が起きたか」が分かりづらくなります。
そのため、全通信に共通のトレースIDを付与します。

```
trace_id=abc123
↓
Reservation → Member → Room
↓
ログ・メトリクス・トレースを同じIDで記録
```

→ OpenTelemetryやElastic APMで可視化可能。

---

## 8. 通信設計のまとめ

| 観点     | ベストプラクティス                               |
| ------ | --------------------------------------- |
| 同期通信   | タイムアウト・リトライ・サーキットブレーカを導入                |
| 非同期通信  | 冪等性・スキーマ契約・再処理設計を重視                     |
| 契約管理   | OpenAPI（REST）／AvroまたはJSON Schema（Event） |
| トレーシング | trace_idで全通信を一元追跡                       |
| 設計指針   | 即時処理＝同期、拡張性＝非同期を原則とする                   |

---

## 9. よくあるアンチパターン

| アンチパターン         | 問題点             |
| --------------- | --------------- |
| 他サービスのDBを直接参照   | 疎結合を破壊する（SOA違反） |
| 呼び出し連鎖（A→B→C→D） | 遅延・障害の伝播が起きる    |
| 無制限リトライ         | システム全体に負荷をかける   |
| イベントの乱発         | ログが膨れ、パフォーマンス低下 |

---

## 10. まとめ

| 要点   | 内容                                 |
| ---- | ---------------------------------- |
| 通信方式 | 同期（REST/gRPC）と非同期（イベント）の2系統        |
| 設計判断 | 即時性・依存関係・整合性で選択                    |
| 信頼性  | Timeout・Retry・Circuit Breakerで耐障害化 |
| 冪等性  | 再送・重複を許容する仕組み                      |
| 可観測性 | trace_id で全通信経路を追跡可能にする            |

---

## 🔜 第3章予告：「マイクロサービスのテスト戦略とCI/CD」

次章では、サービス間通信を前提にした**テスト戦略**を学びます。
ユニットテスト・契約テスト・統合テスト・E2Eテストの4層構造と、
それをCI/CDパイプラインで自動化する仕組みを構築します。

