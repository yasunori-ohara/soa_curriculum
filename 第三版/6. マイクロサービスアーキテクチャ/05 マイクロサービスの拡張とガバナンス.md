## 第5章：マイクロサービスの拡張とガバナンス


## 🎯 この章の目的

1. サービス数が増えても混乱しない**運用体制（ガバナンス）**を設計する
2. **APIバージョン管理**と**サービスディスカバリ**の基本を理解する
3. **セキュリティ／ポリシー統制**をサービス単位で考える
4. 「全体を束ねる仕組み」と「各サービスの自律性」のバランスを学ぶ

---

## 🧩 1. 拡張フェーズに入ったマイクロサービスの課題

マイクロサービスを導入した直後は快適でも、
サービスが10、20と増えていくと下記のような問題が表面化します。

| 問題の種類   | 内容                |
| ------- | ----------------- |
| サービス探索  | どのAPIがどこにあるか分からない |
| バージョン管理 | 旧版APIを使い続けて混乱     |
| 認証統一    | 各サービスで認証方式がバラバラ   |
| 設定管理    | 環境変数やURLの変更が全体に波及 |
| 責務不明確   | 「誰がどこまで直せるか」が曖昧   |

💡 これらを解決するのが「**ガバナンス設計**」です。

---

## 🧩 2. APIバージョン管理の原則

📘 サービスが長く運用されると、APIを改修しても
古いクライアントを壊さないための配慮が必要になります。

### 💻 よくある方式

| 方式      | 例                                     | 特徴                  |
| ------- | ------------------------------------- | ------------------- |
| パス指定型   | `/api/v1/reservations`                | 一番シンプル。多くのRESTで採用。  |
| ヘッダ型    | `Accept: application/vnd.app.v2+json` | バージョン管理を通信ヘッダで制御。   |
| サブドメイン型 | `v2.api.example.com`                  | API GatewayやDNSで制御。 |

💡 **原則**

> 新しいバージョンは“追加”で提供し、
> 古いAPIは「非推奨（deprecated）」を明示したうえで段階的に廃止する。

---

## 🧩 3. サービスディスカバリ（Service Discovery）

📘 マイクロサービスでは「サーバの場所が固定でない」ことが多く、
コンテナ再起動やスケーリングでアドレスが変わります。

そこで必要なのが **サービスディスカバリ機構** です。

🧩 構成イメージ：

```
[Client] → [Service Discovery] → [Reservation Service]
                          ↑
                [Member Service], [Payment Service]
```

💡 主な実装例：

| 種類                 | 説明                            |
| ------------------ | ----------------------------- |
| Consul             | サービス登録とヘルスチェックが可能             |
| Eureka             | Netflix OSS由来、Spring Cloudで標準 |
| Kubernetes Service | クラスタ内DNSで自動解決                 |

⚙️ **ルール**：

* サービス登録・解除を自動化する（手動登録はミスの元）
* 一意なサービス名（例：`reservation-svc`）で呼び出す
* 健康状態（Health Check）を常時監視する

---

## 🧩 4. API Gatewayによる統制と統一

💡 サービスが増えるほど、外部クライアントが直接アクセスするのは危険です。
それを防ぐのが **API Gateway**。

🧩 概念図：

```
[Client] 
   ↓
[API Gateway] ─→ [Reservation Service]
               ├→ [Member Service]
               └→ [Payment Service]
```

📘 Gatewayの主な役割：

| 機能         | 内容                     |
| ---------- | ---------------------- |
| 認証・認可      | JWTやOAuthによる統一的なアクセス制御 |
| ルーティング     | URLに応じて正しいサービスへ転送      |
| ロギング／レート制限 | 不正アクセス・過負荷を防止          |
| バージョン管理    | `/v1/` `/v2/` の切替を集約制御 |

💡 代表的ツール：**Kong**, **NGINX**, **Traefik**, **AWS API Gateway**

---

## 🧩 5. セキュリティと認可（Authorization）

⚙️ サービス単位でも **共通の認証基盤** を用いるべきです。
最も一般的なのが「OAuth 2.0」＋「OpenID Connect (OIDC)」。

🧩 フロー例：

```
[Client] → [Auth Provider] → [Access Token発行]
     ↓
[API Gateway] → [各サービス（トークン検証）]
```

💡 原則：

1. 各サービスはユーザー情報を保持しない（トークンで判断）
2. アクセストークンの有効期限を短く保つ（例：15分）
3. 認可は「最小権限（Least Privilege）」で行う

⚠️ 注意：
トークンの検証処理をすべてのサービスに直接書くと重複が増えるため、
**共通ミドルウェア**として切り出すのが望ましいです。

---

## 🧩 6. コンフィグ管理（Configuration Management）

💡 環境ごとに異なる設定を、
**集中管理**しないとデプロイごとに混乱が起こります。

📘 管理方法の例：

| 方式       | 説明                                |
| -------- | --------------------------------- |
| 環境変数     | 最も基本。Docker/K8sでも利用可。             |
| 設定ファイル   | `.yaml` や `.json` を各環境で切替。        |
| コンフィグサーバ | Spring Cloud Config や Vaultで集中管理。 |

🧩 設計ポイント：

```
・認証情報やAPIキーはSecretとして保護
・設定はリロード可能にする（再起動不要）
・共通設定と個別設定を分離
```

💡 Kubernetesを使う場合は `ConfigMap` と `Secret` を組み合わせると良いです。

---

## 🧩 7. ポリシーとガバナンス設計

📘 サービス全体の品質を守るためには、
「守るべき共通ルール（ポリシー）」を明確にします。

🧩 例：

| ポリシー項目  | 内容                            |
| ------- | ----------------------------- |
| 命名規則    | サービス名は短く、一貫性を持つ（例：`room-svc`） |
| API設計方針 | OpenAPI 3.0準拠、必ずバージョン明記       |
| ログ形式    | JSON Lines形式で統一               |
| リリース管理  | CI/CD経由でのみ本番反映可               |
| セキュリティ  | TLS必須、通信はすべて暗号化               |

💡 これらは「チーム文化」として共有されるべき内容です。
文書化し、「**Architecture Decision Record（ADR）**」として管理するのが良い実践です。

---

## 🧩 8. CI/CDパイプラインによる運用自動化

💻 パイプラインの構成例：

```
[Source Code]
   ↓
[Build & Test]
   ↓
[Docker Build & Push]
   ↓
[Kubernetes Deploy]
   ↓
[Monitoring & Alert]
```

📘 自動化ポイント：

* PR作成時にユニットテストを自動実行
* mainブランチへのマージで自動デプロイ
* 本番・検証環境をブランチで切替
* デプロイ後は可観測性ツールで確認

💡 これにより、「リリースが怖くない」開発体制が整います。

---

## 🧩 9. 組織レベルのガバナンス

📘 技術だけでなく、チーム体制も拡張に合わせて変化します。

🧩 構成例：

```
[Platform Team] ─→ 共通基盤（CI/CD, Observability, API Gateway）
[Domain Team A] ─→ Reservation, Room
[Domain Team B] ─→ Member, Payment
```

💡 原則：

* 共通基盤は「内製サービス」として運用
* 各チームは自ドメインのAPI契約を自律的に管理
* 他チームへの依存はOpenAPI契約を通じてのみ行う

⚠️ 注意：
共通基盤チームが「承認ゲート」化すると開発スピードが落ちます。
自律性と標準化のバランスを意識しましょう。

---

## ✅ まとめ

| 要点          | 内容                |
| ----------- | ----------------- |
| APIバージョン管理  | 後方互換を保ちながら段階的に更新  |
| サービスディスカバリ  | 自動登録とヘルスチェックで安定通信 |
| API Gateway | アクセス制御と共通機能の統合    |
| セキュリティ      | トークンベース認証＋最小権限    |
| コンフィグ管理     | 環境差分を集中制御         |
| ポリシー        | 共通ルールとADRで可視化     |
| ガバナンス       | 組織・技術の両面で自律と統制を両立 |

---

## 🔜 次章予告：「テスト戦略と自動化（End-to-End / Contract / CI）」

次章では、マイクロサービスを安全に進化させるための
**自動テスト戦略**を扱います。
ユニット、統合、契約、E2E、そしてCI/CDパイプラインまで、
「変更しても壊れない設計」を実現します。

