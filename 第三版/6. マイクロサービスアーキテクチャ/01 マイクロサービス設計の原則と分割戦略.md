## 第1章：マイクロサービス設計の原則と分割戦略

この章では、「どう分けるか」「どこまでを1サービスにするか」という
- マイクロサービス設計の一番難しい部分に焦点を当てます。

単なる技術的分割ではなく、**ビジネスの言葉と境界を揃える**という視点を中心に進めます。

## 🎯 この章の目的

* マイクロサービスの**適切な分割単位**を理解する
* **ドメイン駆動設計（DDD）**の概念をもとに「自然な境界」を引けるようにする
* 「分けすぎ」「つなぎすぎ」のバランスを学ぶ
* クリーンアーキテクチャとの関係を整理する

---

## 1. マイクロサービス分割の基本原則

マイクロサービスの設計で最も重要なのは、
「**技術ではなく、ビジネスの言葉で分ける**」ということです。

---

### 📘 原則1：ビジネスの境界に合わせて分ける

* 「ユーザー管理」「予約」「決済」など、
  **ドメインごとに分割**します。
* システム上のクラス構造や画面単位ではなく、
  **業務概念のまとまり（ドメイン）**を基準にします。

**例（会議室予約システム）**

```
Reservation Service ・・・ 予約作成／取消
Member Service      ・・・ 会員登録／認証
Room Service        ・・・ 会議室管理／空き照会
```

---

### 📘 原則2：データの所有者を明確にする

* 各サービスは自分のデータを完全に所有します。
* 他サービスのDBを直接読んではいけません。
* 必要ならAPIを通して問い合わせます。

```
✗  Reservation → SELECT * FROM member_db.members
〇  Reservation → GET /members/{id}
```

---

### 📘 原則3：独立してリリースできること

* どのサービスも**単独でデプロイできること**が理想です。
* 他サービスの変更に引きずられないよう、
  契約（OpenAPI）を明示し、バージョン管理します。

```
Reservation v1.2  → Member v1.0 と通信可
Member v2.0  → 後方互換を維持して段階移行
```

---

## 2. 分割単位を決める3つの軸

マイクロサービスは、次の3つの視点で分けると理解しやすいです。

| 軸         | 説明            | 例              |
| --------- | ------------- | -------------- |
| **ビジネス軸** | ドメインごとの業務機能   | 予約、会員、部屋、支払いなど |
| **データ軸**  | データの独立性と整合性範囲 | 各サービスが独自DBを持つ  |
| **チーム軸**  | 組織・責務の境界      | チームごとに独立開発     |

**まとめ：**

> 分割は「機能」だけでなく、「データ」「人」の視点も合わせる。
> この3つの軸がそろうと、自然に“独立したサービス”になる。

---

## 3. 分割戦略①：ドメイン境界での分割（DDD由来）

DDDの**境界づけられたコンテキスト（Bounded Context）**を
マイクロサービスの分割単位とするのが最も自然です。

**概念図：**

```
Reservation BC（予約）
  ↑
  │  API契約（OpenAPI / gRPC など）
  ↓
Member BC（会員）

```

**説明：**

* 境界づけられたコンテキストは、「この言葉はこの中でだけ有効」という領域。
* 例えば、"User" という言葉は Reservation では「予約者」、
  Member では「会員」として異なる意味を持つ。

**効果：**

* 各コンテキスト（サービス）が独自のモデルを持てる
* モデルの衝突が減る（例："User" の意味が混ざらない）

---

## 4. 分割戦略②：依存方向での分割（Clean Architecture対応）

クリーンアーキテクチャの「依存は内へ」という原則を
サービス単位に拡張して考えます。

```
外側：Web API / DB / 外部連携（不安定）
内側：ドメインルール / UseCase（安定）
```

**考え方：**

* 安定したドメインごとに分け、外側の技術依存を局所化する。
* これにより、外側の変更（DBやWebフレームワーク）に影響されにくくなる。

**例：**

```
Reservation Service（FastAPI→Flaskに変更）
→ 他サービスには一切影響なし
```

---

## 5. 分割戦略③：変更頻度による分割

変更頻度が違うものは別サービスにします。

| 頻繁に変わる           | あまり変わらない    |
| ---------------- | ----------- |
| 予約ロジック（UI/業務ルール） | 会員認証（認証API） |
| レポート出力           | 決済記録        |

**理由：**

> 頻繁に変わるものを別にしておくと、デプロイの影響範囲を小さくできる。

---

## 6. 分割しすぎ問題とその兆候

| 症状                | 問題の兆候             |
| ----------------- | ----------------- |
| サービス数が多すぎて管理できない  | 境界が細かすぎる          |
| API呼び出しが連鎖的に発生する  | 本来一つのドメインを分けすぎている |
| データ同期が難しい         | データ分離が設計レベルで不自然   |
| チームが増えすぎて調整コストが高い | 組織分割に合わせていない      |

**目安：**

> 「1チームで責任を持って動かせる範囲」が1マイクロサービスのサイズ。
> チームを単位に分けるのが安全です。

---

## 7. サービス分割の演習（実例）

**課題：**
あなたが開発するのは「自動車シェアリングシステム」です。
次の業務から、マイクロサービス候補を3〜5個に分けてみましょう。

* 会員登録／認証
* 車両予約
* 車両位置追跡（GPS）
* 決済・請求
* 走行履歴・燃料残量管理

**考えるヒント：**

* 誰がこのデータを「所有」するか？
* どの機能が「独立リリース」できるか？
* どこで「別チーム」が動いていると自然か？

（解答例は後章で扱います）

---

## 8. 分割後の共通基盤（Cross-Cutting Concerns）

サービスを分けた後でも、共通で扱うべきものがあります。

| 項目         | 説明                      |
| ---------- | ----------------------- |
| ログ／トレーシング  | すべてのサービスから共通形式で記録       |
| 認証／認可      | API GatewayやIDプロバイダで一元化 |
| メトリクス      | 全サービスの状態を可視化            |
| コンフィグ管理    | 環境変数やSecretを集中管理        |
| サービスディスカバリ | 各サービスのアドレスを自動解決         |

**これらは“共通基盤チーム”の責務**として設けるのが一般的です。

---

## 9. クリーンアーキテクチャとの関係整理

| 概念   | クリーンアーキテクチャ              | マイクロサービスアーキテクチャ |
| ---- | ------------------------ | --------------- |
| 境界   | Entity / UseCase / Infra | サービス間（API契約）    |
| 依存方向 | 内向き（技術→ルール）              | 横方向（契約に基づく連携）   |
| 安定性  | 内側ほど安定                   | サービス間で独立        |
| 目的   | 内部の変更に強くする               | 全体の変更に強くする      |

**まとめ：**

> クリーンアーキは「1サービスの中を整える」構造、
> マイクロサービスは「サービス間を分ける」構造。
> 両者を組み合わせることで、内外ともに強い設計になる。

---

## 10. まとめ

| 要点   | 内容                        |
| ---- | ------------------------- |
| 基本原則 | ビジネス境界、データ所有、独立リリース       |
| 分割軸  | ビジネス・データ・チームの3軸で考える       |
| 戦略   | DDDの境界づけ＋変更頻度＋依存方向        |
| 注意点  | 分けすぎない、共有DBを避ける           |
| 結果   | 各チームが独立して安全に開発・運用できる構造になる |

---

## 🔜 第2章予告：「マイクロサービス間通信 — 同期と非同期の設計」

次章では、分割されたサービス間の通信を設計します。
REST/gRPCによる**同期通信**と、メッセージングによる**非同期通信（イベント駆動）**を比較し、
どのように「疎結合」を維持するかを具体的に学びます。


