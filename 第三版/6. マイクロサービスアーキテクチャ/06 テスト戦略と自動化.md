## 第6章：テスト戦略と自動化（End-to-End / Contract / CI）


## 🎯 この章の目的

1. マイクロサービスにおける**テスト階層構造**を理解する
2. **契約テスト（Contract Test）**と**統合テスト（Integration Test）**の違いを整理する
3. CI/CDパイプラインで**自動化可能なテスト構成**を作る
4. 「壊れない変更」を実現するための運用パターンを学ぶ

---

## 🧩 1. テスト構造の全体像

マイクロサービスは、1つの大きなシステムではなく、
複数の独立サービスの協調で動く構造です。

そのため、「どの範囲をテストするか」を明確にしないと、
テストが重複したり、抜け落ちたりします。

📘 テスト階層構造（テストピラミッド）：

　E2Eテスト（End-to-End）　→　UI/API全体
　契約テスト（Contract）　　→　サービス間の境界
　統合テスト（Integration）　→　DB・外部連携
　ユニットテスト（Unit）　　→　ドメイン・ユースケース

💡 原則：

> 「下に行くほど速く・安定」「上に行くほど遅く・信頼性高い」
> 各層のテストは**目的が異なる**ため、置き換えではなく**補完関係**にある。

---

## 🧩 2. ユニットテスト ― 小さく・速く・確実に

📘 最も内側のテストは「関数・クラス単位」での確認です。
対象はドメイン層・ユースケース層。

💻 例（pytest想定）：

```python
def test_calculate_fee_discount():
    fee = Fee(base_price=1000, discount_rate=0.2)
    assert fee.total() == 800
```

💡 ポイント：

* I/O（DB・API）を含めない
* モックやフェイクで依存を除外
* 1件あたり100ms以内で実行可能にする

---

## 🧩 3. 統合テスト ― コンポーネントの結合確認

📘 「Repository」「Gateway」「外部API接続」など、
複数モジュールの連携を確認します。

💻 例：

```python
def test_save_and_load_member(tmp_path):
    repo = SqliteMemberRepository(tmp_path / "test.db")
    member = Member(id=1, name="Taro")
    repo.save(member)
    loaded = repo.find_by_id(1)
    assert loaded.name == "Taro"
```

💡 統合テストは「一部の依存だけ実物」を使うのが基本。
Docker ComposeやTestcontainersを利用すると、
実際のDBを立ち上げてテスト可能です。

---

## 🧩 4. 契約テスト（Contract Test）

📘 サービス間通信（APIやイベント）で、
**依存先の変更が壊れないこと**を保証するテストです。

💡 目的：

> 「Aサービスが想定するAPIレスポンス」と
> 「Bサービスが実際に返すレスポンス」が一致していることを検証する。

📘 構成イメージ：

　Consumer Service ←→ Provider Service
　　｜　　　　　　　　　　｜
　Contract Test　Provider Verification

💻 例（PactによるConsumer側テスト）：

```python
from pact import Consumer, Provider

pact = Consumer("ReservationClient").has_pact_with(Provider("MemberService"))

def test_member_contract(pact):
    pact.given("Member exists").upon_receiving("a valid request").with_request(
        "GET", "/members/1"
    ).will_respond_with(200, body={"id": 1, "name": "Taro"})

    with pact:
        response = requests.get(pact.uri + "/members/1")
        assert response.json()["id"] == 1
```

📘 Provider側では、この契約を読み込み、
実際のAPIを起動して**契約どおりのレスポンスが返るか**を確認します。

💡 Pact、Spring Cloud Contract、Dreddなどのツールが広く使われます。

---

## 🧩 5. E2Eテスト（End-to-End Test）

📘 システム全体を通して動作確認を行うテスト。
実際のユーザー操作を模倣して、すべてのサービスが連携して動作するかを確認します。

📘 構成イメージ：

　User → Frontend → API Gateway → 各マイクロサービス群

💻 例：Playwright / Cypress などのテストコード

```javascript
test('予約フロー', async ({ page }) => {
  await page.goto('http://localhost:3000');
  await page.click('text=新規予約');
  await page.fill('input[name="member"]', 'Taro');
  await page.click('text=予約確定');
  await expect(page.locator('text=予約完了')).toBeVisible();
});
```

💡 E2Eテストは**1件の成功が全体の保証になる**。
ただし遅く・不安定になりがちなので、
主要シナリオ（Happy Path）中心に限定します。

---

## 🧩 6. CI/CDパイプラインへの組み込み

💻 一般的なGitHub Actionsの例：

```yaml
name: CI
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      - run: pip install -r requirements.txt
      - run: pytest --maxfail=1 --disable-warnings -q
```

🧠 追加フェーズ：

　1. Unit / Integration Tests → push 時に実行
　2. Contract Tests → main マージ前に実行
　3. E2E Tests → staging 環境で定期実行

💡 成熟した組織では、「テストがすべて通れば自動デプロイ」まで自動化します。

---

## 🧩 7. テストデータと環境分離

📘 マイクロサービスでは、テスト用データの一貫性を保つのが難しくなります。

💡 原則：

| 分離対象     | 内容                            |
| -------- | ----------------------------- |
| DB       | テスト専用DBを用意（本番共有禁止）            |
| メッセージキュー | テストトピックを分ける（`topic_test_...`） |
| 認証       | テスト用トークンを固定発行                 |
| 外部連携     | モックサーバ（WireMockなど）を使用         |

📘 TestcontainersやLocalStackを使えば、
クラウド連携のテストもローカルで再現可能です。

---

## 🧩 8. 自動テスト運用の成熟度モデル

📘 テストの自動化レベルを以下の段階で考えると分かりやすいです。

| レベル | 状況             | 特徴               |
| --- | -------------- | ---------------- |
| Lv1 | 手動テスト中心        | E2Eのみ、人の操作確認     |
| Lv2 | CIでユニットテスト自動化  | 開発初期で導入しやすい      |
| Lv3 | 契約テスト導入        | サービス間変更の安全性UP    |
| Lv4 | ステージングでE2E定期実行 | 回帰検証自動化          |
| Lv5 | フル自動化（CD）      | コード変更→本番反映まで自動保証 |

💡 現場ではLv3〜Lv4を実現できると、安定した運用が可能です。

---

## ✅ まとめ

| 要点     | 内容                                        |
| ------ | ----------------------------------------- |
| テスト階層  | Unit → Integration → Contract → E2E の補完構造 |
| 契約テスト  | サービス間のAPI契約を保証                            |
| E2Eテスト | シナリオ全体を自動検証                               |
| CI/CD  | 全テスト通過後に自動デプロイ                            |
| 環境分離   | 本番と独立したテスト環境を維持                           |
| 成熟度    | 自動化レベルを段階的に上げる                            |

---

## 🔜 次章予告：「マイクロサービスの品質・信頼性とリカバリ設計」

次章では、テスト自動化を踏まえて
**「壊れたときにどう立て直すか」**を扱います。
フォールトトレランス、サーキットブレーカー、リトライ戦略など、
マイクロサービスの**信頼性設計（Resilience Design）**に進みます。

