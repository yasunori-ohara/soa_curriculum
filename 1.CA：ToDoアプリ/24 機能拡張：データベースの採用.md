# 23 機能拡張：データベースの採用

# 🗄 保存処理の差し替え：

`InMemoryTodoRepository` → `PostgresTodoRepository`


## 🧭 この章の目的

この章では、Todoの保存先を「メモリ上のリスト」から「本物のデータベース（PostgreSQLなど）」に差し替える方法を説明します。

いままで使ってきた `InMemoryTodoRepository` は揮発性（プログラム終了とともに消える）でしたが、ここでは永続化できる本気のリポジトリ実装を導入します。

![クリーンアーキテクチャ](../クリーンアーキテクチャ.png)

---

## 📂 フォルダ構成（おさらい＋拡張）

これまでの構成では、永続化の具体的な実装は `infrastructure/` に置いていました。

```text
clean_architecture_todo/
├─ core/
│   ├─ domain/
│   │   ├─ todo.py                 # <E> Entity
│   │   ├─ repository.py           # <I> TodoRepository (抽象インターフェース)
│   │   └─ errors.py
│   │
│   └─ usecase/
│       ├─ interactor/
│       │   └─ create_todo.py      # TodoUseCase
│       └─ boundary/
│           ├─ input_boundary.py
│           ├─ output_boundary.py
│           └─ dto.py
│
├─ interface_adapters/
│   ├─ presenters/
│   │   └─ todo_presenter.py
│   ├─ controllers/
│   │   └─ todo_controller.py
│   └─ views/
│       ├─ view_console.py
│       ├─ view_gui.py
│       ├─ view_web.py
│       └─ view_fastapi.py
│
├─ infrastructure/
│   └─ repositories/
│       ├─ in_memory_todo_repository.py      # メモリ保持版 (学習用)
│       └─ postgres_todo_repository.py       # ← 新規: DB版 (本章で追加)
│
└─ main.py
```

ポイントはココ👇

* `core/domain/repository.py` には抽象インターフェース `TodoRepository` が定義されている
  → UseCaseは「このインターフェース」を知っていればよい

* 各種具体実装は `infrastructure/repositories/` にぶら下げる

  * `in_memory_todo_repository.py`（これまでの学習用: メモリ保持）
  * `postgres_todo_repository.py`（今回追加する本番寄り: DB利用）

つまり、**core側（内側）は抽象だけ持ち、具体は外側に生える**という構造を徹底します。

---

## 🔁 なぜ保存処理の差し替えが「簡単」なのか？

> 💡 クリーンアーキテクチャでは、永続化の戦略は「詳細」扱いです。

* `TodoUseCase` は「TodoRepository」という抽象インターフェースだけに依存します
  （`core/domain/repository.py` にあるやつ）
* そのインターフェースを満たすクラスなら、どんな保存方法でも差し替え可能です

  * メモリのリストに保存する実装
  * SQLiteに保存する実装
  * PostgreSQLに保存する実装
  * 外部REST APIに投げて保存する実装 …など

つまり、`InMemoryTodoRepository` を `PostgresTodoRepository` に入れ替えるだけで、**UseCase・Presenter・Controller・View には一切変更が発生しません。**

これは、プロダクトの寿命（ビジネスロジック）と、技術の寿命（インフラ・DB選定）を分離できている、ということでもあります。

---

## ✅ PostgreSQL版 Repository 実装（SQLAlchemy使用）

以下は、`TodoRepository` を SQLAlchemy で実装した例です。

このクラスは `infrastructure/repositories/postgres_todo_repository.py` に配置します。

```python
# --------------------------------------------------------------------
# File: infrastructure/repositories/postgres_todo_repository.py
# Layer: Infrastructure（具体的なデータ保存方法）
#
# 目的:
#   - core/domain/repository.py の TodoRepository 抽象インターフェースを
#     PostgreSQLやSQLiteなどのRDBMSで実装する。
#
# 役割:
#   - TodoエンティティをDBに保存・取得する。
#   - IDの採番など、永続化まわりの詳細はこの層で完結させる。
#
# 依存:
#   - core.domain.todo.Todo （Entity）
#   - core.domain.repository.TodoRepository （抽象）
#
# C言語イメージ:
#   - DBは「外部デバイス」扱い。
#   - ここはそのデバイスドライバ。UseCaseからは関数ポインタ経由で呼ばれる感じ。
# --------------------------------------------------------------------

from typing import List
from sqlalchemy import create_engine, Column, Integer, String, Boolean
from sqlalchemy.orm import declarative_base, sessionmaker, Session

from core.domain.todo import Todo
from core.domain.repository import TodoRepository

Base = declarative_base()


class TodoRecord(Base):
    """
    DBテーブルに対応するORMモデル。
    これはEntity(Todo)とは別物で、「DBでの保存形式」を表す。
    """
    __tablename__ = "todos"

    id = Column(Integer, primary_key=True, autoincrement=True)
    title = Column(String, nullable=False)
    completed = Column(Boolean, nullable=False, default=False)


class PostgresTodoRepository(TodoRepository):
    """
    TodoRepository の実装クラス（RDBMS版）。
    SQLAlchemyを使ってDBへ接続・保存・取得を行う。
    """

    def __init__(self, db_url: str = "sqlite:///todo.db"):
        """
        db_url は実運用では PostgreSQL のURL
        例: "postgresql+psycopg2://user:password@localhost:5432/todo_db"
        学習用途としてはSQLiteのURLでも同じインターフェースで試せる。
        """
        self.engine = create_engine(db_url, echo=False, future=True)
        Base.metadata.create_all(self.engine)
        self.SessionLocal = sessionmaker(bind=self.engine, expire_on_commit=False)

    def save(self, todo: Todo) -> Todo:
        """
        TodoをDBに保存し、永続化された状態のTodoを返す。
        - 新規追加の場合: DB側でIDが採番される
        - 既存タスクの更新の場合: 既存レコードを上書きする
        """
        session: Session = self.SessionLocal()
        try:
            if todo.id == 0:
                # 新規作成（まだIDがない）
                record = TodoRecord(
                    title=todo.title,
                    completed=todo.completed,
                )
                session.add(record)
                session.commit()
                session.refresh(record)

                # DBで採番されたIDをEntity側へ反映
                todo.id = record.id
            else:
                # 既存の更新
                record = session.get(TodoRecord, todo.id)
                if record is None:
                    # DB上に存在しないIDを渡されたケース：
                    # ここでは新規扱いしてもいいし、例外にしてもいい
                    # シンプルに例外にしておく
                    raise ValueError(f"Todo with id={todo.id} not found in DB.")

                record.title = todo.title
                record.completed = todo.completed
                session.commit()

        finally:
            session.close()

        return todo

    def find_all(self) -> List[Todo]:
        """
        DBに保存されているTodoをすべて取得して、
        ドメインエンティティのリストとして返す。
        """
        session: Session = self.SessionLocal()
        try:
            records = session.query(TodoRecord).all()
            return [
                Todo(
                    id=r.id,
                    title=r.title,
                    completed=r.completed,
                )
                for r in records
            ]
        finally:
            session.close()
```

### いくつかの重要ポイント

* `TodoRecord` と `Todo` は別物です

  * `TodoRecord` … DBのテーブル1行を表すデータ構造（インフラ側の都合）
  * `Todo` … ビジネスルールそのもの（ドメイン側の都合）

  これを明確に分けることで、「DBの都合でドメインルールが汚染される」ことを防ぎます。

* `PostgresTodoRepository` は `TodoRepository` を実装しているだけ
  → つまり `TodoUseCase` から見ると、`InMemoryTodoRepository` と同じインターフェースです。
  → UseCaseはどちらが注入されても同じように使える＝差し替えが簡単。

* ID採番はこの層の責務

  * `todo.id == 0` の場合、新規なのでDBにINSERTしてDB側のIDを取得
  * そのIDを `Todo` Entityに書き戻す
  * UseCaseやEntityに「採番ロジック」を持たせないのがポイントです。

---

## 🛡 この層の鉄則

> 技術を使いこなせ、だがビジネスルールを汚すな。

* Repository実装（インフラ層）は、DBクエリ・ID採番・セッション管理のような**技術の詳細**を引き受ける
* ビジネス上の判断（「どのタイトルが有効か」「完了状態への遷移ルール」など）は一切しない
  → それは Entity や UseCase の責務
* どのDBを使うか（PostgreSQL / SQLite / DynamoDB / APIで外部SaaSに投げるなど）は、**この層で完結**するべきで、内側の層に漏れてはいけない

---

## 🔧 `main.py` での差し替え例（DB版）

ここまでずっと、`main.py` は「アプリ全体の部品を組み立てる場所（Composition Root）」でした。

`InMemoryTodoRepository` を `PostgresTodoRepository` に置き換えるだけで、アプリはそのままDB対応になります。

```python
# main.py （DB版で動かしたい場合の例）

from core.usecase.boundary.dto import TodoViewModel
from core.usecase.interactor.create_todo import TodoUseCase
from interface_adapters.presenters.todo_presenter import TodoPresenter
from interface_adapters.controllers.todo_controller import TodoController
from interface_adapters.views.view_console import ConsoleView
from infrastructure.repositories.postgres_todo_repository import PostgresTodoRepository

def main():
    # ViewModel（PresenterとViewが共有する表示用の状態）
    view_model = TodoViewModel()

    # RepositoryをPostgreSQL/SQLite対応版に差し替える
    # db_url はSQLiteを例にしているが、PostgreSQLのURLに置き換え可能
    repository = PostgresTodoRepository(db_url="sqlite:///todo.db")
    # 例: PostgreSQLなら
    # repository = PostgresTodoRepository(
    #     db_url="postgresql+psycopg2://user:password@localhost:5432/todo_db"
    # )

    # Presenter（UseCaseの結果をViewModel向けメッセージに整形）
    presenter = TodoPresenter(view_model)

    # UseCase（ビジネスロジック本体）
    use_case = TodoUseCase(presenter, repository)

    # Controller（Viewからのユーザー入力をUseCaseに橋渡し）
    controller = TodoController(use_case)

    # View（今回はConsole版を例に起動。GUIやWebに差し替えてもOK）
    view = ConsoleView(controller, view_model)

    # 実行
    view.run()


if __name__ == "__main__":
    main()
```

見てのとおり、差し替えているのは `repository = ...` のたった1行だけです。

* UseCaseは同じ
* Presenterは同じ
* Controllerは同じ
* Viewも同じでOK（もちろんGUIやWeb版に変えることもできます）
* ViewModelも同じ

これは、アプリが**「保存先の技術」ではなく「ビジネス上の意味」にフォーカスしている**ことを示します。

---

## 🧠 まとめ

* `core/domain/repository.py` は「アプリがビジネス的に必要とする保存の契約（インターフェース）」
* `infrastructure/repositories/*.py` は「その契約を、具体的な技術で満たす実装」

  * メモリ版 → `InMemoryTodoRepository`
  * DB版 → `PostgresTodoRepository`
* どの保存先を使うかは `main.py` で選ぶだけ。内側は汚さない。

> 言い換えると：
> **ビジネスは変わらない。技術はいつでも交換できる。**
> これがクリーンアーキテクチャの、現場で一番ありがたい部分です。
