# 11 テスト

# 🧪 テスト：Use Case（TodoInteractor）の検証

## 🧭 この章の目的

この章では、`TodoInteractor`（Use Case）のテストコードを作成します。

クリーンアーキテクチャの最大のメリットの一つは、**ビジネスロジックを、UIやデータベースから完全に切り離してテストできる**ことです。

![クリーンアーキテクチャ](https://www.notion.so../%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3.png)

---

## ✅ テストの目的

このテストでは、以下の点を検証します：

- `TodoInteractor`は、渡されたタイトルで正しく`Todo`エンティティを生成するか？
- `TodoInteractor`は、生成した`Todo`を`Repository`に保存するように依頼するか？
- `TodoInteractor`は、処理結果を`Presenter`に渡すように依頼するか？

> 💡 このテストのために、本物のデータベースやUI（コンソール画面）は一切不要です。
> 

---

## 🧩 テスト用の「偽物」部品（モック／スパイ）

Use Caseをテストするには、PresenterとRepositoryが必要ですが、**本物ではなくテスト用の偽物（テストダブル）**を使います。

```python
# --------------------------------------------------------------------
# File: tests/test_doubles.py
# Layer: Test（テストダブルの定義）
# --------------------------------------------------------------------

from typing import Dict, List, Optional
from boundaries import TodoOutputBoundary, TodoDataAccessInterface
from data_structures import TodoOutputData
from domain.todo import Todo

# --------------------------------------------------------------------
# Presenterの偽物（スパイ）
# --------------------------------------------------------------------
class SpyTodoPresenter(TodoOutputBoundary):
    """
    Presenterの偽物。本物の代わりにUse Caseに渡される。
    presentメソッドが呼ばれたかどうか、そして何が渡されたかを記録する役割を持つ。
    """
    def __init__(self):
        self.called_with_output_data: Optional[TodoOutputData] = None

    def present(self, output_data: TodoOutputData):
        print(f"[SpyPresenter] presentが呼ばれました。データ: {output_data}")
        self.called_with_output_data = output_data

# --------------------------------------------------------------------
# DataAccessの偽物（フェイク）
# --------------------------------------------------------------------
class FakeInMemoryDataAccess(TodoDataAccessInterface):
    """
    DataAccessの偽物。本物のDBの代わりにメモリ上の辞書を使う。
    テストの準備段階で好きなデータを仕込んだり、テスト実行後に
    データがどうなったかを確認したりできる。
    """
    def __init__(self, initial_todos: List[Todo] = None):
        self._database: Dict[int, Todo] = {}
        if initial_todos:
            for todo in initial_todos:
                self._database[todo.id] = todo

    def save(self, todo: Todo) -> Todo:
        print(f"[FakeDataAccess] saveが呼ばれました。データ: {todo}")
        if todo.id == 0:
            todo.id = max(self._database.keys(), default=0) + 1
        self._database[todo.id] = todo
        return todo

    def find_all(self) -> List[Todo]:
        return list(self._database.values())

    def find_by_id(self, id: int) -> Optional[Todo]:
        return self._database.get(id)

```

---

## 🔍 テストコード本体

```python
# --------------------------------------------------------------------
# File: tests/test_todo_usecase.py
# Layer: Test（Use Caseの単体テスト）
# --------------------------------------------------------------------

import unittest
from application.todo_UseCase import TodoUseCase
from data_structures import TodoInputData
from domain.todo import Todo
from tests.test_doubles import SpyTodoPresenter, FakeInMemoryDataAccess

class TestTodoInteractor(unittest.TestCase):
    def test_add_new_todo_successfully(self):
        """
        新しいTODOを正常に追加できるケースのテスト
        """

        # 1. Arrange（準備）
        spy_presenter = SpyTodoPresenter()
        fake_data_access = FakeInMemoryDataAccess()
        interactor = TodoUseCase(spy_presenter, fake_data_access)
        input_data = TodoInputData(title="新しいタスク")

        # 2. Act（実行）
        interactor.execute(input_data)

        # 3. Assert（検証）

        # --- Presenterが正しく呼ばれたか？ ---
        self.assertIsNotNone(spy_presenter.called_with_output_data)
        self.assertEqual(spy_presenter.called_with_output_data.title, "新しいタスク")
        self.assertEqual(spy_presenter.called_with_output_data.id, 1)

        # --- Repositoryが正しく保存したか？ ---
        saved_todos = fake_data_access.find_all()
        self.assertEqual(len(saved_todos), 1)
        self.assertEqual(saved_todos[0].title, "新しいタスク")
        self.assertEqual(saved_todos[0].id, 1)

if __name__ == "__main__":
    unittest.main()

```

---

## 🧠 テストの意図

- Presenterは **OutputDataを受け取り、ViewModelに渡す責務** を果たしているか
- Repositoryは **Entityを保存する責務** を果たしているか
- Use Caseは **ビジネスロジックを正しく指揮しているか**
- UIやDBに依存せず、**純粋なロジックだけを検証できるか**

---

## 🛡 この章の鉄則

> テストは、ロジックを隔離してこそ意味がある。
> 
- Use Caseは、UIやDBに依存しないからこそ、**高速・安定・信頼性の高いテストが可能**になる。
- テストダブル（Spy/Fake）を使うことで、**副作用を持たない安全な検証**ができる。
- テストが失敗したとき、原因が明確になる（UIやDBのせいではない）。

---

この章で、クリーンアーキテクチャの**テスト容易性**が実感できたと思います。

次は、**ユースケースの追加（例：削除・更新）**や、**UIの差し替え（GUI/Web）**に進むことができます。どちらをご希望ですか？