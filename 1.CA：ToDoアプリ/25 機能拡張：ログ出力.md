# 24 機能拡張：ログ出力

# 🪵 ログ出力の差し替え
### `print()` → `logging`



## 🧭 この章の目的

この章では、アプリケーション内のログ出力を、学習用の `print()` から、
実務向けの **`logging` モジュール** に置き換えます。

これにより：

* ログの出力レベル（DEBUG / INFO / WARNING / ERROR）が使えるようになる
* ファイル保存や外部監視サービス（例：Sentry, Datadog, CloudWatch）への連携も容易になる
* printの乱用による出力の煩雑化を防ぎ、保守性が上がる

![クリーンアーキテクチャ](../クリーンアーキテクチャ.png)

---

## 📂 フォルダ構成（正式対応版）

```text
clean_architecture_todo/
├─ core/
│   ├─ domain/
│   │   ├─ todo.py
│   │   ├─ repository.py
│   │   └─ errors.py
│   │
│   └─ usecase/
│       ├─ interactor/
│       │   └─ create_todo.py
│       └─ boundary/
│           ├─ input_boundary.py
│           ├─ output_boundary.py
│           └─ dto.py
│
├─ interface_adapters/
│   ├─ presenters/
│   │   └─ todo_presenter.py        # ← logging導入
│   ├─ controllers/
│   │   └─ todo_controller.py       # ← logging導入
│   └─ views/
│       ├─ view_console.py
│       ├─ view_gui.py
│       ├─ view_web.py
│       └─ view_fastapi.py
│
├─ infrastructure/
│   └─ repositories/
│       ├─ in_memory_todo_repository.py
│       └─ postgres_todo_repository.py
│
├─ logs/
│   └─ app.log                      # ← ログ出力先（任意）
│
└─ main.py                          # ← ログ設定（logging.basicConfig）追加
```

> 🗒️ 補足
> ログ設定（フォーマット・レベル・ファイル出力など）は **`main.py`** に集中させます。
> 各層は `getLogger(__name__)` で取得して使うだけに留めるのが鉄則です。

---

## 🔁 なぜログ技術の差し替えが簡単なのか？

> 💡 クリーンアーキテクチャでは、ログ技術も「詳細」に分類されます。

* **UseCase / Entity / Presenter / Controller** は「printの使い方」すら知らない
  → ログ処理は一貫して外部の仕組み（logging）に任せられる
* **main.py での設定変更** により、

  * print出力 → コンソールログ
  * コンソールログ → ファイルログ
  * ファイルログ → 外部SaaSログ
    といった切替が容易です。
* 各層は「getLogger()を呼ぶだけ」なので、依存関係を汚さない。

---

## ✅ Presenter の修正版（例）

```python
# File: interface_adapters/presenters/todo_presenter.py
import logging
from core.usecase.boundary.output_boundary import TodoOutputBoundary
from core.usecase.boundary.dto import TodoViewModel, TodoOutputData

logger = logging.getLogger(__name__)

class TodoPresenter(TodoOutputBoundary):
    """
    UseCaseの結果をViewModel向けのテキストに整形する。
    """

    def __init__(self, view_model: TodoViewModel):
        self._view_model = view_model

    def present(self, output_data: TodoOutputData):
        display_text = f"TODOを追加しました: {output_data.title} (ID={output_data.id})"
        self._view_model.display_text = display_text

        # 変更前: print(f"Presenter: ViewModelを更新しました → '{display_text}'")
        logger.info(f"ViewModelを更新 → '{display_text}'")
```

---

## ✅ Controller の修正版（例）

```python
# File: interface_adapters/controllers/todo_controller.py
import logging
from core.usecase.boundary.input_boundary import TodoInputBoundary

logger = logging.getLogger(__name__)

class TodoController:
    """
    Viewから受け取った入力をUseCaseに渡す。
    """

    def __init__(self, use_case: TodoInputBoundary):
        self._use_case = use_case

    def add_todo(self, title: str):
        # 変更前: print(f"Controller: Use Caseを呼び出します (Input: {title})")
        logger.info(f"UseCaseを呼び出します (Input: {title})")

        input_data = {"title": title}
        self._use_case.execute(input_data)
```

---

## ✅ main.py の修正版（ログ設定追加）

```python
# File: main.py
import logging
from core.usecase.boundary.dto import TodoViewModel
from core.usecase.interactor.create_todo import TodoUseCase
from interface_adapters.presenters.todo_presenter import TodoPresenter
from interface_adapters.controllers.todo_controller import TodoController
from interface_adapters.views.view_console import ConsoleView
from infrastructure.repositories.in_memory_todo_repository import InMemoryTodoRepository

def setup_logging():
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s [%(name)s] %(levelname)s: %(message)s",
        handlers=[
            logging.FileHandler("logs/app.log", encoding="utf-8"),
            logging.StreamHandler()
        ]
    )

def main():
    setup_logging()
    logger = logging.getLogger(__name__)
    logger.info("=== アプリケーション起動 ===")

    view_model = TodoViewModel()
    repository = InMemoryTodoRepository()
    presenter = TodoPresenter(view_model)
    use_case = TodoUseCase(presenter, repository)
    controller = TodoController(use_case)
    view = ConsoleView(controller, view_model)

    view.run()
    logger.info("=== アプリケーション終了 ===")

if __name__ == "__main__":
    main()
```

---

## 🧩 ログレベルの推奨運用ルール

| レベル        | 用途の例                                 |
| ---------- | ------------------------------------ |
| `DEBUG`    | デバッグ時にのみ見たい内部状態（開発時限定）               |
| `INFO`     | 通常の操作・ビジネス処理（Presenter・Controllerなど） |
| `WARNING`  | 想定外の入力だが処理継続可能な状態                    |
| `ERROR`    | 例外的状況。Userに伝える前にエラー記録                |
| `CRITICAL` | アプリ継続不能な重大障害（DB接続喪失など）               |

---

## 🛡 この章の鉄則

> ログは記録せよ、だが責務を越えるな。

* ログは「観察と記録」に徹する
  → ビジネス判断やUI描画には関与しない
* ログ出力はアーキテクチャ的に**最外層**に閉じる（mainで設定し、各層では呼ぶだけ）
* printの削除は段階的に進める（print→logger.info→logger.debugへ移行）

---

## 🧠 まとめ

| 項目     | 変更前                      | 変更後              |
| ------ | ------------------------ | ---------------- |
| ログ出力方法 | print文                   | loggingモジュール     |
| 出力先    | 標準出力のみ                   | コンソール＋ファイル       |
| フォーマット | 単純文字列                    | タイムスタンプ＋ロガー名＋レベル |
| 設定場所   | 各クラス内                    | main.py（集中管理）    |
| 利用箇所   | Presenter, Controller など | 同じ。責務不変。         |

> 💬 クリーンアーキテクチャでは「観測（ログ）」も依存の内側に入れない。
> つまり、技術が変わっても内側は**無変更で動き続ける**。
