# 23 機能拡張：データベースの採用

# 🗄 保存処理の差し替え：`InMemoryTodoDataAccess` → `PostgresTodoDataAccess`

## 🧭 この章の目的

この章では、保存処理を **メモリ上の辞書から本物のデータベース（PostgreSQL）に差し替える**方法を解説します。

この差し替えによって、アプリケーションは永続的なデータ保存が可能になります。

![クリーンアーキテクチャ](../クリーンアーキテクチャ.png)

---

## 🔁 なぜ保存処理の差し替えが「簡単」なのか？

> 💡 クリーンアーキテクチャを採用したからこそ、保存技術の変更が容易になっています。
> 
- `UseCase` は `TodoDataAccessInterface` にのみ依存しており、具体的な保存方法（メモリかDBか）を知りません。
- `InMemoryTodoDataAccess` を `PostgresTodoDataAccess` に置き換えるだけで、**他の層には一切変更が不要**です。
- これは、技術変更に強く、長期運用に耐える設計が実現されている証拠です。

---

## ✅ PostgreSQL版 DataAccess の構成（SQLAlchemy使用）

```python
# --------------------------------------------------------------------
# File: adapters/data_access_postgres.py
# Layer: Interface Adapters（Data Access）
#
# 目的:
#   - TodoDataAccessInterface を PostgreSQL で実装する。
#   - SQLAlchemy を使って DB に保存・取得する。
#
# C言語との比較:
#   - DBアクセスは「ファイルI/O」や「外部装置との通信」に近い。
#   - SQLAlchemy は「構造体と関数ポインタをまとめたORMライブラリ」。
# --------------------------------------------------------------------

from sqlalchemy import create_engine, Column, Integer, String
from sqlalchemy.orm import declarative_base, sessionmaker
from domain.todo import Todo
from boundaries import TodoDataAccessInterface

Base = declarative_base()

class TodoRecord(Base):
    """
    DBテーブルに対応するORMモデル。
    """
    __tablename__ = "todos"

    id = Column(Integer, primary_key=True)
    title = Column(String)
    completed = Column(Integer)  # 0 or 1

class PostgresTodoDataAccess(TodoDataAccessInterface):
    """
    PostgreSQL版のDataAccess。SQLAlchemyを使ってDB操作を行う。
    """

    def __init__(self, db_url="sqlite:///todo.db"):  # SQLiteで代用可能
        self.engine = create_engine(db_url, echo=False)
        Base.metadata.create_all(self.engine)
        self.Session = sessionmaker(bind=self.engine)

    def save(self, todo: Todo) -> Todo:
        session = self.Session()

        if todo.id == 0:
            # 新規追加
            record = TodoRecord(title=todo.title, completed=int(todo.completed))
            session.add(record)
            session.commit()
            todo.id = record.id
        else:
            # 更新
            record = session.query(TodoRecord).get(todo.id)
            if record:
                record.title = todo.title
                record.completed = int(todo.completed)
                session.commit()

        session.close()
        return todo

    def find_all(self) -> list[Todo]:
        session = self.Session()
        records = session.query(TodoRecord).all()
        todos = [Todo(id=r.id, title=r.title, completed=bool(r.completed)) for r in records]
        session.close()
        return todos

```

---

## 🛡 このクラスの鉄則

> 技術を使いこなせ、だがロジックには口を出すな。
> 
- DataAccessは「保存・取得の技術的実装」に集中する
- ビジネス判断や表示整形は一切行わない
- 技術が変わっても、インターフェースを守れば他の層はそのままで済む

---

## 🔧 `main.py` での差し替え例（PostgreSQL版）

```python
# --- PostgreSQL版DataAccessを使う場合 ---
from adapters.data_access_postgres import PostgresTodoDataAccess

# ...（Presenter, Controller, ViewModelなどの生成は同じ）

data_access = PostgresTodoDataAccess()
use_case = TodoUseCase(presenter, data_access)

```