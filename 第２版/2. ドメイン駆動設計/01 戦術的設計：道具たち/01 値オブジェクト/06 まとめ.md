## 値オブジェクト：まとめ

### ✅ テストが驚くほど簡単になる

値オブジェクトは、それ単体でルールが完結していて、他の部品（リポジトリや外部サービスなど）に一切依存しません。そのため、テストが非常にシンプルかつ高速になります。

**比較してみましょう**

  * **Before (UseCaseで検証)**:
    ISBNの検証ロジックをテストするためには、`RegisterBookUseCase`をインスタンス化し、場合によってはモック（偽物）のリポジトリを準備して…といった手間がかかります。

  * **After (値オブジェクトで検証)**:
    `Isbn`クラスのテストは、純粋にそのクラスだけを見ればOKです。

    ```python
    # tests/value_objects/test_isbn.py
    import pytest
    from domain.value_objects.isbn import Isbn

    def test_正しいISBNで生成できる():
        # これが成功すればOK
        Isbn("9784297100782")

    def test_不正なISBNではValueErrorが発生する():
        with pytest.raises(ValueError):
            Isbn("INVALID-ISBN") # 文字数が違う、数字でないなど
    ```

    このように、ビジネスのコアなルールを、小さく、独立した部品としてピンポイントでテストできるため、品質に絶大な自信を持つことができます。

-----

### ✅ UseCaseが「本来の仕事」に集中できる

値オブジェクトを導入することで、UseCaseは「ISBNのフォーマットとは何か？」といった**細かな知識**から解放されます。

UseCaseの本来の仕事は、**「どのリポジトリからデータを取得し、どのドメインオブジェクト（エンティティや集約）のどの振る舞いを呼び出し、結果をどう保存するか」という、アプリケーションのワークフローを指揮する**ことです。

値オブジェクトがない場合、UseCaseは指揮者の仕事に加えて、個々の演奏者（値）の楽器がチューニングされているか（値が正しいか）までチェックする、雑務の多いマネージャーのようになってしまいます。

値オブジェクトは、自分の正しさを自分で証明してくれる**専門家**のようなものです。UseCaseは、安心して専門家に仕事を任せ、自分は全体の指揮という本来の仕事に集中できるのです。