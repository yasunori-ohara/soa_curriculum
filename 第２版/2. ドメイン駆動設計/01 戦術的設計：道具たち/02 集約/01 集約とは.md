## 集約とは

題材は「`Book`クラスにレビュー機能を追加する」シナリオに絞り、言語は**Python**に統一し、実際に動作する完全なコードで示します。

-----

### なぜ集約が必要なのか？：不整合を防ぐため

まず、シンプルな`Book`と`Review`のクラスがあるとします。

```python
# --- DDD適用前の素朴なクラス ---
from dataclasses import dataclass, field
from typing import List

@dataclass
class Review:
    user_id: str
    rating: int
    comment: str

@dataclass
class Book:
    title: str
    reviews: List[Review] = field(default_factory=list)
    average_rating: float = 0.0
```

ここで、「レビューを追加する」という機能を考えます。このとき守るべきルールは、「**レビューが追加されたら、必ず本の平均評価点も更新されなければならない**」です。

集約を使わない場合、このロジックはユースケース（またはサービス層）に書かれます。

```python
def add_review_use_case(book: Book, user_id: str, rating: int, comment: str):
    # 1. レビューを作成して追加する
    new_review = Review(user_id, rating, comment)
    book.reviews.append(new_review)
    print(f"レビューを追加しました: {comment}")

    # 2. 平均評価点を再計算する
    total_rating = sum(r.rating for r in book.reviews)
    book.average_rating = total_rating / len(book.reviews)
    print(f"本の平均評価点を更新しました: {book.average_rating:.2f}")

# 利用例
book = Book(title="Learning DDD")
add_review_use_case(book, "user1", 5, "素晴らしい！")
add_review_use_case(book, "user2", 3, "まあまあかな。")
```

このコードは一見問題なく動きます。しかし、**平均評価点の計算処理（ステップ2）を開発者が忘れてしまったらどうなるでしょうか？** レビューだけが追加され、データに不整合が起きてしまいます。

-----

## 集約とは：「一貫性を守る」責任者

**集約 (Aggregate)** とは、`Book`と`Review`のように関連性の強いオブジェクト群を一つの「まとまり」として扱い、そのまとまり全体のルール（**不変条件**）が必ず守られることを保証する設計パターンです。

その「まとまり」の代表者（門番）を**集約ルート (Aggregate Root)** と呼びます。

このシナリオでは、`Book`が集約ルートとなり、`Review`の追加から平均評価点の更新まで、**すべての責任を`Book`クラス自身が負います**。

### Pythonによる集約の実装例

以下が、集約パターンを適用してリファクタリングしたコードです。

```python
from typing import List

class Review:
    """
    集約の「内部エンティティ」。
    規約として、このクラスはBookクラスの中からのみインスタンス化されるべき。
    """
    def __init__(self, user_id: str, rating: int, comment: str):
        # レーティングのバリデーションなど、値のルールはここに書ける
        if not 1 <= rating <= 5:
            raise ValueError("評価は1から5の間でなければなりません")
        self.user_id = user_id
        self.rating = rating
        self.comment = comment

class Book:  # Bookが集約ルート
    def __init__(self, title: str):
        self.title = title
        # アンダースコア(_)で始まるプロパティは「内部用」という紳士協定
        self._reviews: List[Review] = []
        self._average_rating: float = 0.0

    @property
    def average_rating(self) -> float:
        """平均評価点は外部から読み取りのみ可能にする"""
        return self._average_rating

    def _recalculate_average_rating(self):
        """平均評価点の計算ロジック。集約の内部にカプセル化されている。"""
        if not self._reviews:
            self._average_rating = 0.0
            return
        
        total_rating = sum(r.rating for r in self._reviews)
        self._average_rating = total_rating / len(self._reviews)

    def add_review(self, user_id: str, rating: int, comment: str):
        """
        レビューを追加するための唯一の公式な窓口。
        このメソッドを呼び出すだけで、必ず一貫性が保たれる。
        """
        # ルールチェック: 同じユーザーはレビューできない
        if any(r.user_id == user_id for r in self._reviews):
            raise ValueError("この本には既にレビューを投稿済みです。")

        # Reviewの生成もBookの責任範囲
        new_review = Review(user_id, rating, comment)
        self._reviews.append(new_review)
        
        # 不変条件の維持: 平均評価点を必ず更新する
        self._recalculate_average_rating()
        
        print(f"レビューを追加し、平均評価点を更新しました: {self._average_rating:.2f}")


# --- 集約を利用する側のコード ---
book_aggregate = Book(title="Learning DDD")

# 利用側は「レビューを追加する」というビジネスの意図を伝えるだけ
# 内部で何が起きているか（平均点の計算など）を知る必要はない
book_aggregate.add_review("user1", 5, "素晴らしい！")
book_aggregate.add_review("user2", 4, "とても参考になった。")

# book_aggregate._reviews.append(...) のような直接操作は規約違反！
```

### 🐍 Pythonにおける「紳士協定」

このコードのポイントは、`_reviews`や`_average_rating`のように、プロパティ名の先頭にアンダースコア`_`を付けている点です。

C++やJavaと異なり、Pythonには外部からのアクセスを完全に禁止する`private`機能がありません。そのため、アンダースコアを付けることで、\*\*「これはクラスの内部で使うためのものなので、外部から直接アクセスしないでくださいね」**という**紳士協定（規約）\*\*を示します。

この規約に従い、利用者は`book_aggregate.add_review()`という公式なメソッド（門）だけを使うことで、集約は自身のルールと一貫性を守ることができるのです。