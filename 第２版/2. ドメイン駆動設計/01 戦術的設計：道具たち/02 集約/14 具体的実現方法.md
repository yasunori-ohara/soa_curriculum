## 集約：具体的な実現方法

## ❓ 集約の説明の時に下記のコードがありました。この constructor のあいまいな部分が言語によって変わるということですね。

```typescript
// --- 集約の内部 ---

// Reviewは集約の内部エンティティ
class Review {
  public readonly reviewId: string;
  public readonly userId: string;
  public readonly rating: number; // 本当は値オブジェクトにしたい
  public readonly comment: string;

  // ReviewはBookを通さずに勝手に作れないように、コンストラクタは
  // Bookからのみ呼び出せるようにする (例: protected, internal)
  constructor(...) { /* ... */ }
}
```

---
### 📁 はい、そのコメントは集約のルールをコードで強制するための、非常に重要かつ少しトリッキーな部分を指しています。ご質問ありがとうございます。

このコメントの意図は、「**`Review`は`Book`の一部品なのだから、`Book`の許可なく勝手にインスタンス化（`new`）されてはいけない**」というルールを、言語の機能を使ってどうにか実現したい、ということです。

-----

### なぜ勝手に作れてはダメなのか？

もし、UseCaseなどで`Book`を通さずに`new Review(...)`ができてしまうと、`Book`が知らないレビューが勝手に作られ、本の平均評価点の更新が行われないなど、集約が守るべきルールが簡単に破られてしまいます。

-----

### 言語による実現方法の違い

コメントに「(例: protected, internal)」と書きましたが、これは言語によって最適な実現方法が異なるためです。

#### 理想的な実現方法 (C\#の`internal` / Javaのパッケージプライベート)

C\#の`internal`やJavaのパッケージプライベートといったアクセス修飾子は、「同じモジュール（ライブラリ）内からはアクセスできるが、外からはアクセスできない」という可視性を実現できます。

`Book`と`Review`を同じドメインモデルのモジュールに配置し、`Review`のコンストラクタを`internal`に設定すれば、「`Book`は`new Review()`できるが、UseCaseなどモジュールの外側からは`new Review()`できない」という、まさに理想的な状態を作り出せます。

#### TypeScript/JavaScriptでの現実的な実現方法

残念ながら、TypeScriptやJavaScriptには、この`internal`に直接対応するアクセス修飾子がありません。

  * `private`: クラスの中からしか呼べないので、`Book`から`new Review()`ができません。
  * `protected`: サブクラスからしか呼べないので、これも使えません。

そこで、TypeScript/JavaScriptでは、**モジュールの仕組みを利用して可視性を制御する**のが一般的です。

**📁 ファイル構成による制御の例**

1.  まず、`review.ts`で`Review`クラスを定義し、`export`します。コンストラクタは`public`にしておきます。

    ```typescript
    // src/domain/book/review.ts
    export class Review {
      // ...
      // このコンストラクタはBookから呼ばれることを意図している
      constructor(...) { /* ... */ }
    }
    ```

2.  `book.ts`で`Book`クラスを定義し、`Review`を`import`して使います。

    ```typescript
    // src/domain/book/book.ts
    import { Review } from './review'; // 同じモジュール内なのでimportできる

    export class Book {
      // ...
      public addReview(...) {
        const newReview = new Review(...); // BookはReviewを生成できる
        this.reviews.push(newReview);
        // ...
      }
    }
    ```

3.  **ここがポイントです**。このドメインモデルを外部に公開するための窓口となるファイル（通称バレルファイル `index.ts`）を作ります。

    ```typescript
    // src/domain/book/index.ts

    // 集約ルートであるBookだけを外部に公開する
    export { Book } from './book';

    // Reviewクラスは意図的に公開しない！
    ```

**結果どうなるか**

  * **UseCaseなど外部のコード**:
    `import { Book } from 'src/domain/book';` はできます。
    しかし、`import { Review } from 'src/domain/book';` はできません。`Review`は公開されていないからです。
    これにより、外部のコードは`Review`クラスの存在を直接知ることができず、`new Review()`を呼び出すことが物理的に困難になります。

このように、TypeScriptなどでは**言語のアクセス修飾子だけに頼るのではなく、モジュールの公開範囲（export）を制御することで**、集約の内部を外部から隠蔽し、ルールを守らせるというアプローチを取ります。

## 🏰 集約の実現方法を C++とPythonを使って示してください。

DDDの集約をC++とPythonで実装する例を示します。両言語の思想の違いから、ルールの強制方法がどう異なるかに注目すると、より理解が深まります。

C++は**コンパイラによる静的なチェック**でルールを厳格に強制するのに対し、Pythonは**命名規則などの規約**に基づいてプログラマの規律に委ねるアプローチを取ります。

-----

### C++：アクセス制御と`friend`による厳格な実現 ☢️

C++では、**`private`アクセス修飾子**と\*\*`friend`宣言\*\*を組み合わせることで、「集約ルートだけが内部エンティティを生成できる」というルールをコンパイルレベルで完全に強制できます。

#### 実装のポイント

  * **`Review`クラス**: コンストラクタを`private`にし、外部から直接`new`できないようにします。
  * **`friend`宣言**: `Review`クラス内で`Book`クラスを`friend`（友達）として宣言します。これにより、`Book`クラスだけが`Review`の`private`なコンストラクタを呼び出す特別な許可を得ます。

#### コード例

`book.hpp`

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <stdexcept>

// 前方宣言: Reviewクラスの中でBookクラスを参照するために必要
class Book;

// Reviewは集約の内部エンティティ
class Review {
private:
    // Bookクラスだけがこのコンストラクタを呼べる
    Review(int reviewId, int userId, int rating, const std::string& comment)
        : reviewId_(reviewId), userId_(userId), rating_(rating), comment_(comment) {}

    int reviewId_;
    int userId_;
    int rating_;
    std::string comment_;

public:
    int getUserId() const { return userId_; }

    // Bookクラスを友達として宣言
    friend class Book;
};

// Bookは集約ルート
class Book {
private:
    int bookId_;
    std::string title_;
    std::vector<Review> reviews_; // 内部データはprivate

    // 内部でのみ使用するヘルパーメソッド
    void recalculateAverageRating() {
        // 平均評価点を再計算するロジック...
        std::cout << "Average rating recalculated." << std::endl;
    }

public:
    Book(int bookId, const std::string& title) : bookId_(bookId), title_(title) {}

    // 外部に公開された、レビューを追加するための唯一のメソッド
    void addReview(int userId, int rating, const std::string& comment) {
        // ルールチェック: 同じユーザーはレビューできない
        for (const auto& review : reviews_) {
            if (review.getUserId() == userId) {
                throw std::runtime_error("User has already reviewed this book.");
            }
        }
        
        // friendなので、Reviewのprivateコンストラクタを呼び出せる
        reviews_.emplace_back(reviews_.size() + 1, userId, rating, comment);
        
        // 不変条件の維持: 平均評価点を必ず更新する
        recalculateAverageRating();
    }
};
```

`main.cpp`

```cpp
#include "book.hpp"

int main() {
    Book book(1, "Learning DDD");

    // ✅ 正しい使い方: ルートを通じて操作する
    try {
        book.addReview(101, 5, "Excellent!");
    } catch (const std::exception& e) {
        std::cerr << e.what() << std::endl;
    }

    // ❌ 不正な使い方: コンパイルエラーになる！
    // 'Review::Review' is private within this context
    // Review review(2, 202, 4, "This will not compile.");

    return 0;
}
```

このC++の例では、ルールに反するコードはコンパイルすら通らないため、設計者の意図が極めて強力に保護されます。

-----

### Python：命名規則とモジュールによる規約的な実現 🐍

Pythonには厳格な`private`が存在せず、「アンダースコア (`_`) で始まる名前は内部用」という紳士協定（規約）でカプセル化を表現します。

#### 実装のポイント

  * **命名規約**: 内部データ（`_reviews`）の先頭にアンダースコアを付け、外部から直接触るべきではないことを示唆します。
  * **モジュール管理**: 実際のプロジェクトでは、`Book`クラスのみをパッケージの外部に公開し、`Review`クラスは公開しないことで、外部からの直接利用を困難にします。（下記コードは簡潔さのため同一ファイルに記載）

#### コード例

```python
from __future__ import annotations
from typing import List

# Reviewは集約の内部エンティティ
# 規約として、このクラスはBookクラスの中からのみインスタンス化されるべき
class Review:
    def __init__(self, review_id: int, user_id: int, rating: int, comment: str):
        self.review_id = review_id
        self.user_id = user_id
        self.rating = rating
        self.comment = comment

# Bookは集約ルート
class Book:
    def __init__(self, book_id: int, title: str):
        self.book_id = book_id
        self.title = title
        # アンダースコアで始まるプロパティは「内部用」という規約
        self._reviews: List[Review] = []
        self._average_rating: float = 0.0

    # 内部でのみ使用するヘルパーメソッド
    def _recalculate_average_rating(self):
        # 平均評価点を再計算するロジック...
        print("Average rating recalculated.")

    # 外部に公開された、レビューを追加するための唯一のメソッド
    def add_review(self, user_id: int, rating: int, comment: str):
        # ルールチェック: 同じユーザーはレビューできない
        if any(r.user_id == user_id for r in self._reviews):
            raise ValueError("User has already reviewed this book.")

        new_review_id = len(self._reviews) + 1
        new_review = Review(new_review_id, user_id, rating, comment)
        self._reviews.append(new_review)

        # 不変条件の維持: 平均評価点を必ず更新する
        self._recalculate_average_rating()


# --- 利用例 ---
book = Book(1, "Learning DDD")

# ✅ 正しい使い方: ルートを通じて操作する
try:
    book.add_review(101, 5, "Excellent!")
except ValueError as e:
    print(e)

# ❌ 不正な使い方: 文法的には可能だが、規約違反
# このようなコードを書くべきではない
# 1. 内部データに直接アクセス
book._reviews.append(Review(2, 202, 1, "This breaks the rule!"))
# 2. Bookを通さずにReviewをインスタンス化
# rogue_review = Review(3, 303, 3, "Also against the convention.")

# ルール違反の操作をした場合、平均評価点の更新が行われず、データが不整合な状態になる
```

Pythonの例では、ルール違反のコードも文法的には実行できてしまいます。しかし、`_`の付いたプロパティに触れることは「自己責任」であり、集約のルールを破る行為だと開発者間で合意することで、設計の一貫性を保ちます。

-----

### \#\# まとめ：思想の違い

| | C++ | Python |
| :--- | :--- | :--- |
| **強制力** | **コンパイラ**による静的で**厳格**な強制 | **規約**による動的で**紳士協定的**な強制 |
| **アプローチ** | 「できないようにする」 | 「すべきでないと示す」 |

どちらのアプローチもDDDの集約パターンを実現できますが、その背景にある言語の設計思想が、コードの表現方法に大きく影響していることが分かります。

## ❓ DDDの集約パターンのメリットは理解できますが、実装は少し面倒になる感じですね。

はい、おっしゃる通りです。その感覚は非常に的確で、多くの開発者が最初に感じることです。

単純にデータを更新するだけの実装に比べ、集約パターンを適用すると、守るべきルールが増え、書くべきコードも多くなるため、たしかに「面倒」に感じられます。

しかし、これは**「どこで面倒を見るか」**という設計上の重要な**トレードオフ**なのです。

---
## 複雑さの置き場所を変える

集約は、コードの複雑さをなくす魔法ではありません。**複雑さを、あちこちに分散させるのではなく、ドメインモデルの一箇所に封じ込める**ためのパターンです。

| 観点 | 集約なし (手続き的な実装) | ✨ 集約あり (DDDの実装) |
| :--- | :--- | :--- |
| **実装の面倒さ** | **一見、楽に見える** | **最初は面倒** |
| **利用側のコード** | `review`を保存し、`book`の平均点も更新…と、**毎回複数の操作が必要で複雑** | `book.addReview()`を呼ぶだけで**非常にシンプル** |
| **ビジネスルール** | UseCaseやServiceなど、**あちこちに散らばる**（暗黙的） | 集約の中に**一元管理される**（明示的） |
| **安全性** | ルールの更新漏れなど、**不整合が起きやすい** | 集約がルールを守るので**安全** |

集約なしの実装は、最初のうちは楽に進みます。しかし、システムの規模が大きくなるにつれて、あちこちに散らばったビジネスルールを管理するのが非常に困難になり、やがて破綻します。

集約は、最初に少しだけ手間をかけて**「ビジネスルールをカプセル化した安全な部品」**を作っておくことで、その後のアプリケーション開発を圧倒的に楽で安全にするための投資なのです。

---
## ☕️ カプセル式コーヒーマシンに例える

この関係は、カプセル式のコーヒーマシンに似ています。

* **面倒な実装 (Aggregate)**:
    マシン内部の構造は非常に複雑です。お湯の温度管理、圧力、抽出時間など、美味しいコーヒーを淹れるための専門知識（＝ビジネスルール）がすべてカプセル化されています。このマシンを開発するのは大変です。

* **シンプルな利用 (UseCase)**:
    しかし、利用者はその複雑さを一切知る必要がありません。ただ好きなカプセルをセットしてボタンを押すだけです。誰がやっても、必ず一貫した品質の美味しいコーヒー（＝整合性の取れた結果）が出てくることが**保証**されています。



集約を実装する手間は、この「便利なマシンを開発するコスト」です。一度作ってしまえば、あとは誰でも安全・簡単に使えるようになり、長期的な開発効率とシステムの安定性は劇的に向上します。


