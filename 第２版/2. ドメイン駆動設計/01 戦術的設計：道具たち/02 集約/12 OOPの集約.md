## ❓ OOPでの集約との関係は？

同じ「集約」という言葉が使われるため混乱しやすいのですが、両者は似て非なるものです。

結論から言うと、DDDの集約は、OOP（UML）の集約の考え方をベースにしつつ、**ドメインのルールを強制するため**に、**より強力で厳密なルールを追加した**特別なパターンです。

-----

### OOPの集約 vs DDDの集約

両者の違いを比較してみましょう。

#### OOPにおける集約 (Aggregation)

UMLなどで白抜きのひし形で表現される「集約（Aggregation）」は、"has-a"（〜を持つ）の関係を表す、比較的緩やかな「全体と部分」の関係です。

  * **目的**: オブジェクトの**構造**を表現すること。

  * **特徴**:

      * 部分（`Review`）は、全体（`Book`）から独立したライフサイクルを持つことができます。つまり、`Book`がなくなっても`Review`は存在し続ける、というモデリングも可能です。
      * カプセル化は**強制されません**。外部のクラスが `book.getReviews()` のようなメソッドで`Review`のリストを取得し、その中の一つの`Review`を直接変更する、といった操作ができてしまいます。

    <!-- end list -->

    ```typescript
    // OOPの集約では、このような操作ができてしまう可能性がある
    const reviews = book.getReviews();
    const firstReview = reviews[0];
    firstReview.setRating(999); // 本の平均評価点は更新されない！ルールが破綻
    ```

#### DDDにおける集約 (Aggregate)

DDDの集約は、データの**一貫性**を守るための「トランザクションの境界」を定義します。

  * **目的**: ビジネスルール（不変条件）を**強制**し、データの一貫性を保つこと。

  * **特徴**:

      * 内部のエンティティ（`Review`）のライフサイクルは、集約ルート（`Book`）によって完全に管理されます。`Book`が削除されれば、それに属する`Review`もすべて削除されます。（これはOOPの**コンポジション（Composition）**、黒塗りのひし形、の考え方に近いです。）
      * カプセル化が**厳格に強制されます**。外部から内部のオブジェクトを直接操作することは絶対にできず、すべての操作は集約ルートのメソッドを通じて行わなければなりません。

    <!-- end list -->

    ```typescript
    // DDDの集約では、操作はルート経由のみ
    // book.getReviews()[0].setRating(999); // ← このような直接操作はできない

    // 必ずルートのメソッドを呼び出す
    book.updateReviewRating("review-001", 5); // この中で評価点の更新と平均点の再計算が必ず行われる
    ```

-----

### \#\# まとめ表

| 観点 | OOPの集約 (Aggregation) | DDDの集約 (Aggregate) |
| :--- | :--- | :--- |
| **主目的** | 構造の表現 | **一貫性の維持**、**ルールの強制** |
| **ライフサイクル** | 部分は独立して存在可能 | 部分は全体（ルート）に**完全に依存** |
| **カプセル化** | 緩やか（直接アクセス可能） | **厳格**（ルート経由が必須） |
| **トランザクション** | 意識しない | **集約単位**で行うことが前提 |
| **関連するOOP概念** | 集約 (Aggregation) | **コンポジション (Composition)** に近い |

ですので、「BookとReviewはOOPでいう集約」という認識は間違いではありませんが、DDDではそこに「**Bookを門番として、Reviewに関する全ての変更ルールを絶対に守らせる**」という、より強力な責務を追加したもの、と理解すると良いでしょう。

