## DDDを最初にみたとき「要求仕様書とか要件仕様書とかがコードになって管理できるのかな？」と思ったのですが、そのようなことはできますか？

はい、その直感は非常に鋭く、DDDが目指す理想の一つを捉えています。

DDDを徹底すると、**仕様書の一部、特に「ビジネスルール」に関する部分が、コードとして管理できるようになる**、と考えるのが最も正確です。

-----

## 仕様書とコードの関係性

従来の開発では、仕様書とコードは分離していました。

  * **仕様書**: WordやExcelで書かれた、人間が読むための「ルールブック」。
  * **コード**: プログラマーが書いた、コンピューターが実行するための「命令書」。

この2つは別々に管理されるため、「仕様書は更新したけど、コードに反映し忘れた」「コードは直したけど、仕様書が古いまま」といった問題が頻繁に発生し、仕様書が形骸化する原因となっていました。

DDD、特にユビキタス言語を徹底すると、この関係が変わります。

### コードになる部分（ビジネスルール）

私たちが先ほど見た「プレミアム会員の割引ルール」のコードは、もはや単なる命令書ではありません。

```python
# このコードは「ビジネスルール」そのものである
if customer.is_premium_member() and \
   room_type.is_standard() and \
   reservation.is_early_bird():
    
    return room_type.base_rate.apply_discount(percent=10)
```

この`if`文は、要求仕様書に書かれるべき**ビジネスルールそのもの**です。しかも、これはただの文章ではなく、**実際に動作し、自動テストが可能な、実行可能な仕様書**です。

### コードになりにくい部分（目的や非機能要件）

一方で、仕様書に含まれるすべての情報がコードになるわけではありません。

  * **ビジネスの目的**: 「顧客満足度を向上させ、リピート率を5%上げる」といった、機能の背景にある目的。
  * **非機能要件**: 「レスポンスタイムは0.5秒以内」「月間100万PVに耐える」といった性能やセキュリティに関する要件。
  * **UI/UXデザイン**: 画面の見た目や操作感。

これらの情報は、別途ドキュメントとして管理する必要があります。

-----

## 「リビングドキュメント」という考え方 🌿

この「コードが仕様書の一部になる」という考え方をさらに推し進めたのが、**リビングドキュメント (Living Documentation)** という概念です。

これは、**振る舞い駆動開発 (Behavior-Driven Development, BDD)** と呼ばれるプラクティスと組み合わせることで実現されます。BDDでは、テストコードをビジネスに関わる人が読める自然言語に近い形式で記述します。

#### BDDによる「実行可能な仕様書」の例

Gherkinという記法で書かれたテストシナリオです。これは**仕様書そのもの**ですが、同時に**自動テストとして実行可能**です。

```gherkin
# features/discount.feature

機能: プレミアム会員の割引

  シナリオ: プレミアム会員が通常客室を早期予約すると割引が適用される
    前提 "プレミアム会員" の "顧客" が存在する
    かつ "通常" の "客室タイプ" があり、基本料金は "10000円" である
    かつ その予約は "早期割引" の対象である
    もし 最終的な宿泊料金を計算すると
    ならば 最終的な宿泊料金は "9000円" になるべきである
```

このテストが成功している限り、「プレミアム会員の早期割引ルールが正しく実装されている」ことが**自動的に証明され続けます**。

-----

## 結論

DDDを実践することで、要求仕様書が完全になくなるわけではありません。
しかし、その中で最も複雑で、最も変更が多く、最もバグの原因となりやすい\*\*「ビジネスルール」の仕様を、コードとテストの中に閉じ込め、常に最新で正しいことが保証された「生きたドキュメント（リビングドキュメント）」として管理できる\*\*ようになります。

これは、形骸化したドキュメントに悩まされがちな従来の開発と比べて、革命的な進歩と言えるでしょう。