# 🔄 UIの変更: Djangoへの換装

この章では、クリーンアーキテクチャの真価を体験します。これまで作成してきたコンソールアプリケーションの**UI部分だけを、WebフレームワークであるDjangoに差し替えます。**

この作業の最も重要なポイントは、**ドメイン層とアプリケーション層（`UseCase`）のコードには一切手を加えない**ということです。ビジネスの核心部分はそのままに、ユーザーとの接点であるUIだけをプラグのように交換できることを体感しましょう。

## 🎯 この章の目的

  * UIが「詳細」であり、ビジネスルールから独立していることを証明する。
  * `Adapters`層の役割（内側の世界と外側の世界を繋ぐ翻訳）を深く理解する。
  * 依存性反転の原則により、UI技術の変更がビジネスロジックに影響を及ぼさないことを実践で示す。

## ✅ 変更・追加が必要なファイル

UIという「詳細」に関わるファイルだけが変更対象です。

  * `adapters/`
      * `django_views.py` (New✨): DjangoのViewとControllerの役割を担う、新しいファイル。
      * `django_presenter.py` (New✨): Djangoのテンプレートエンジンにデータを渡すための、新しいPresenter。
  * `django_project/` (New✨):
      * `urls.py`: URLとViewを紐付ける設定ファイル。
      * `templates/checkout.html`: 画面表示のためのHTMLテンプレートファイル。
  * `main.py` → `manage.py`: アプリケーションの起動方法がDjangoの作法に変わります。

## ❌ 変更が**不要**なファイル

これこそがクリーンアーキテクチャの核心です。以下のファイルは**一行も変更しません。**

  * **`domain/entities.py`**
  * **`application/use_cases/check_out_book.py`**
  * **`application/boundaries.py`**
  * **`application/data_structures.py`**
  * `adapters/data_access.py` (DBはそのままインメモリを使うため変更不要)

## 💻 ソースコードの詳細解説

### 1. Django用の新しいPresenter

`UseCase`からの`OutputData`を、Djangoのテンプレートエンジンが理解できる`dict`（辞書）形式に変換する、新しいPresenterを用意します。

```python
# adapters/django_presenter.py

from typing import Dict, Any
from application.boundaries import CheckOutBookOutputBoundary
from application.data_structures import CheckOutBookOutputData

# -----------------------------------------------------------------------------
# Django Presenter
# - クラス図の位置: Presenter
# - 同心円図の位置: Adapters (外側の円)
# -----------------------------------------------------------------------------
class DjangoCheckOutBookPresenter(CheckOutBookOutputBoundary):
    """Djangoのテンプレートエンジンに渡すためのContext（辞書）を生成するPresenter"""
    _context: Dict[str, Any] = {}

    def present(self, output_data: CheckOutBookOutputData):
        due_date_str = output_data.due_date.strftime('%Y年%m月%d日')
        display_text = (
            f"貸出処理が完了しました。\n"
            f"書籍: 『{output_data.book_title}』, "
            f"会員: {output_data.member_name}様, "
            f"返却期限: {due_date_str}"
        )
        # テンプレートに渡すための辞書を更新する
        self._context['message'] = display_text

    def get_context(self) -> Dict[str, Any]:
        return self._context
```

### 2. DjangoのView (Controllerの役割も兼ねる)

Djangoでは、`View`関数がユーザーからのHTTPリクエストを受け付け、`Controller`のように`UseCase`を呼び出し、レスポンスを返す役割を担います。

```python
# adapters/django_views.py

from django.shortcuts import render
from .django_presenter import DjangoCheckOutBookPresenter
from adapters.data_access import (
    InMemoryBookDataAccess, InMemoryMemberDataAccess, InMemoryLoanDataAccess
)
from application.use_cases.check_out_book import CheckOutBookUseCase
from application.data_structures import CheckOutBookInputData

# -----------------------------------------------------------------------------
# Django View
# - クラス図の位置: View + Controller
# - 同心円図の位置: Adapters (外側の円)
# -----------------------------------------------------------------------------
def checkout_view(request):
    """
    DjangoのView関数。HTTPリクエストを受け取り、レスポンスを返す。
    この関数が、リクエスト毎の「ミニComposition Root」の役割を果たす。
    """
    context = {}
    if request.method == 'POST':
        try:
            # --- ここで依存関係を組み立てる（DI）---
            presenter = DjangoCheckOutBookPresenter()
            book_repo = InMemoryBookDataAccess()
            member_repo = InMemoryMemberDataAccess()
            loan_repo = InMemoryLoanDataAccess()
            use_case = CheckOutBookUseCase(presenter, book_repo, member_repo, loan_repo)
            
            # 1. Viewからの生データをInputDataに変換
            input_data = CheckOutBookInputData(
                book_id=int(request.POST.get('book_id')),
                member_id=int(request.POST.get('member_id'))
            )
            
            # 2. UseCaseを呼び出す
            use_case.handle(input_data)
            
            # 3. Presenterから結果（Context）を取得
            context = presenter.get_context()

        except Exception as e:
            context['message'] = f"エラー: {e}"

    # HTMLテンプレートを描画してユーザーに返す
    return render(request, 'checkout.html', context)
```

  * **ミニComposition Root**: Webフレームワークでは、リクエストごとにこの`checkout_view`関数が呼ばれます。その中で`UseCase`や`Presenter`をインスタンス化しており、`main.py`が担っていた**部品の組み立て**の役割を、この関数がリクエスト単位で実行している点が重要です。

### 3. HTMLテンプレートとURL設定

ユーザーが操作する画面と、その画面にアクセスするためのURLを定義します。

```html
<!DOCTYPE html>
<html>
<head>
    <title>書籍貸出システム</title>
</head>
<body>
    <h1>書籍貸出</h1>
    <form method="post">
        {% csrf_token %}
        書籍ID: <input type="text" name="book_id"><br>
        会員ID: <input type="text" name="member_id"><br>
        <button type="submit">貸出実行</button>
    </form>

    {% if message %}
    <h2>処理結果</h2>
    <pre>{{ message }}</pre>
    {% endif %}
</body>
</html>
```

```python
# django_project/urls.py
from django.urls import path
from adapters.django_views import checkout_view

urlpatterns = [
    path('checkout/', checkout_view, name='checkout'),
]
```

## 🛡️ この章の鉄則

UIはあくまで詳細であり、交換可能な部品に過ぎません。

> **UIは詳細である。ビジネスルールに触れるな。 (The UI is a detail. Do not touch the business rules.)**

  * コンソールからWebアプリへの大きな変更にもかかわらず、**ビジネスの核心部分は一行も変更されませんでした。**
  * これは、`UseCase`が具体的なUI技術（`print`や`HTML`）ではなく、抽象的な`Boundary`（インターフェース）にのみ依存しているからです。
  * この構造により、将来UIをスマートフォンアプリやデスクトップアプリに変更することになったとしても、同じビジネスロジックを再利用できます。これこそが、クリーンアーキテクチャがもたらす**保守性と拡張性の高さ**なのです。