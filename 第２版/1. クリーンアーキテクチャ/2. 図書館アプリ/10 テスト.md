# 🧪 テスト: アーキテクチャの真価

テストコードは、このアーキテクチャの真価を最も雄弁に物語るものです。

`UseCase`のテストコードを作成し、UIやデータベースといった「詳細」から完全に独立して、ビジネスロジックだけを純粋に検証できる様子を見ていきましょう。

## 🎯 この章の目的

これから書くテストは、以下の点のみを検証します。

  * 貸出可能な会員と本が指定された場合、正しく貸出処理が完了し、**貸出記録(`Loan`)が作成されるか？**
  * 貸出中の本を貸し出そうとした場合、正しくエラーになり、**状態が一切変更されないか？**

このテストのために、**本物のデータベースや、本物のUI（コンソール画面）は一切必要ありません。**

## 🎭 「偽物」の部品（テストダブル）を準備する

テスト対象の`CheckOutBookUseCase`は、`Presenter`と3種類の`Repository`に依存しています。テストでは、これらの本物の代わりに、テストのためだけに作られた「偽物」のクラス（テストダブル）を使います。

```python
# tests/doubles.py

from typing import Dict, List, Optional

# 内側の世界の「境界」「データ構造」「Entity」にのみ依存する
from application.boundaries import (
    CheckOutBookOutputBoundary, BookDataAccessInterface,
    MemberDataAccessInterface, LoanDataAccessInterface
)
from application.data_structures import CheckOutBookOutputData
from domain.entities import Book, Member, Loan

# -----------------------------------------------------------------------------
# Presenterの偽物（スパイ）
# - 役割: メソッドが呼ばれたか、どんな引数で呼ばれたかを記録する
# -----------------------------------------------------------------------------
class SpyCheckOutBookPresenter(CheckOutBookOutputBoundary):
    def __init__(self):
        self.called_with_output_data: Optional[CheckOutBookOutputData] = None

    def present(self, output_data: CheckOutBookOutputData):
        self.called_with_output_data = output_data

# -----------------------------------------------------------------------------
# DataAccessの偽物（フェイク）
# - 役割: 本物のDBの代わりに、メモリ上でデータを管理する
# -----------------------------------------------------------------------------
class FakeBookDataAccess(BookDataAccessInterface):
    def __init__(self, initial_books: List[Book] = None):
        self._database = {b.id: b for b in initial_books} if initial_books else {}
    def find_by_id(self, book_id: int) -> Optional[Book]:
        return self._database.get(book_id)
    def save(self, book: Book) -> Book:
        self._database[book.id] = book
        return book

class FakeMemberDataAccess(MemberDataAccessInterface):
    def __init__(self, initial_members: List[Member] = None):
        self._database = {m.id: m for m in initial_members} if initial_members else {}
    def find_by_id(self, member_id: int) -> Optional[Member]:
        return self._database.get(member_id)

class FakeLoanDataAccess(LoanDataAccessInterface):
    def __init__(self):
        self._database: Dict[int, Loan] = {}
        self._next_id = 1
        self.save_was_called = False # saveが呼ばれたかを記録するフラグ

    def save(self, loan: Loan) -> Loan:
        self.save_was_called = True
        if loan.id is None:
            loan.id = self._next_id
            self._next_id += 1
        self._database[loan.id] = loan
        return loan
```

## 🔬 テストコード本体

成功ケース（ハッピーパス）と失敗ケース（サッドパス）の両方をテストします。

```python
# tests/application/use_cases/test_check_out_book.py
import pytest

# --- テスト対象と偽物クラスをインポート ---
from application.use_cases.check_out_book import CheckOutBookUseCase
from application.data_structures import CheckOutBookInputData
from domain.entities import Book, Member, BookStatus
from tests.doubles import (
    SpyCheckOutBookPresenter, FakeBookDataAccess,
    FakeMemberDataAccess, FakeLoanDataAccess
)

def test_貸出が成功するシナリオ():
    """成功ケース：貸出可能な本を正常に貸し出せる"""
    # 1. Arrange (準備)
    # テスト用のEntityと、それらを初期データとして持つ偽物リポジトリを用意
    available_book = Book(id=1, title="テスト駆動開発", author="Kent Beck")
    active_member = Member(id=1, name="Alice")
    
    spy_presenter = SpyCheckOutBookPresenter()
    fake_book_repo = FakeBookDataAccess(initial_books=[available_book])
    fake_member_repo = FakeMemberDataAccess(initial_members=[active_member])
    fake_loan_repo = FakeLoanDataAccess() # Loanリポジトリも用意

    # テスト対象のUseCaseを、偽物の部品を注入して生成
    use_case = CheckOutBookUseCase(
        presenter=spy_presenter,
        book_repository=fake_book_repo,
        member_repository=fake_member_repo,
        loan_repository=fake_loan_repo # Loanリポジトリも注入
    )
    input_data = CheckOutBookInputData(book_id=1, member_id=1)

    # 2. Act (実行)
    use_case.handle(input_data)

    # 3. Assert (検証)
    # ✅ Presenterが正しいデータで呼ばれたか？
    assert spy_presenter.called_with_output_data is not None
    assert spy_presenter.called_with_output_data.book_title == "テスト駆動開発"
    
    # ✅ 本の状態が正しく「貸出中」に更新されたか？
    updated_book = fake_book_repo.find_by_id(1)
    assert updated_book.status == BookStatus.CHECKED_OUT

    # ✅ 新しい貸出記録(Loan)が永続化されたか？
    assert fake_loan_repo.save_was_called is True

def test_貸出中の本を貸し出そうとすると失敗する():
    """失敗ケース：貸出中の本を貸し出そうとするとエラーになる"""
    # 1. Arrange (準備)
    # 最初から「貸出中」の本を用意
    checked_out_book = Book(id=2, title="リファクタリング", status=BookStatus.CHECKED_OUT, author="")
    active_member = Member(id=1, name="Alice")

    spy_presenter = SpyCheckOutBookPresenter()
    fake_book_repo = FakeBookDataAccess(initial_books=[checked_out_book])
    fake_member_repo = FakeMemberDataAccess(initial_members=[active_member])
    fake_loan_repo = FakeLoanDataAccess()

    use_case = CheckOutBookUseCase(spy_presenter, fake_book_repo, fake_member_repo, fake_loan_repo)
    input_data = CheckOutBookInputData(book_id=2, member_id=1)

    # 2. Act (実行) & 3. Assert (検証)
    # ✅ UseCaseを実行すると、Book Entity内のルールによってValueErrorが発生することを検証
    with pytest.raises(ValueError, match="は現在貸出中です"):
        use_case.handle(input_data)
    
    # ✅ 状態が変化していないことを検証
    # Presenterは呼ばれていないはず
    assert spy_presenter.called_with_output_data is None
    # 貸出記録は作成されていないはず
    assert fake_loan_repo.save_was_called is False
```

## 👍 なぜこれが「楽」なのか？

1.  **完全な独立性**: `UseCase`のロジックをテストするために、UIやデータベースの実装は一切不要です。すべて偽物の部品で代用できます。
2.  **高速実行**: メモリ上だけで完結するため、テストは一瞬で終わります。
3.  **信頼性**: 失敗ケースのテストでは、「`Presenter`が呼ばれなかったこと」や「DBの状態が変化しなかったこと」まで正確に検証できます。これにより、意図しない副作用（バグ）がないことを高い信頼性で保証できます。

## 🐍 PythonとC言語の比較（初心者の方へ）

  * **Python (オブジェクト指向)**: `UseCase`のコンストラクタに**偽物のオブジェクトを注入**するだけで、テスト環境を簡単に構築できます。これは依存性の注入（DI）というテクニックの強力な利点です。
  * **C言語 (手続き型)**: ビジネスロジック関数が、DBアクセス関数を直接呼び出している場合、それらを分離するのは困難です。テストのために**関数ポインタ**を使ったり、コンパイル時に `#ifdef TEST` のような**プリプロセッサ**で処理を切り替えたりするなど、複雑な工夫が必要になります。

## 🛡️ テストにおける鉄則

クリーンアーキテクチャにおけるテストの考え方は、この一言に集約されます。

> **ビジネスをテストせよ、技術をテストするな。 (Test the business, not the technology.)**

  * `UseCase`のテストは、**ビジネスルールが正しいか**だけを検証します。
  * `DataAccess`のテストは、**DBとの接続やSQLが正しいか**だけを検証します。
  * UIが正しく表示されるかは、また別のUIテストの責務です。

このように**関心事を分離**することで、各テストはシンプルかつ高速になり、ソフトウェア全体の品質を効率的に高めることができるのです。