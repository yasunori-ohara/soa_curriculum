# 🔩 DBの変更: MongoDBへの換装

この章では、クリーンアーキテクチャがもたらすもう一つの強力な利点を体験します。これまでインメモリの辞書で代用してきたデータ永続化の仕組みを、**NoSQLデータベースであるMongoDBに差し替えます。**

この作業の最も重要なポイントは、データベース技術を根本から変更するにもかかわらず、**ビジネスロジックやUI層のコードには一切手を加えない**ということです。データベースは交換可能な「詳細」に過ぎない、という事実を体感しましょう。

## 🎯 この章の目的

  * データベースが「詳細」であり、プラグのように交換可能な部品であることを証明する。
  * `DataAccessInterface`が、`UseCase`を具体的なデータ保存技術から隔離する、強力な防波堤として機能することを理解する。
  * 依存性反転の原則により、中核となるビジネスロジックがデータベースに依存せず、逆にデータベースの実装がビジネス層の定義した抽象（インターフェース）に依存する、という関係を実践で示す。

## ✅ 変更・追加が必要なファイル

データ永続化という「詳細」に直接関わるファイルだけが変更対象です。

  * `adapters/mongo_data_access.py` (New✨): MongoDBとのやり取りを専門に行う、新しい`DataAccess`クラス群を格納するファイル。
  * `main.py` (Composition Root): 新しい`MongoDataAccess`クラスをインスタンス化するために、ほんの数行だけ修正します。

## ❌ 変更が**不要**なファイル

これこそがクリーンアーキテクチャの核心です。アプリケーションの心臓部である以下のファイルは、**一行も変更しません。**

  * **`domain/entities.py`**
  * **`application/use_cases/check_out_book.py`**
  * **`application/boundaries.py`**
  * **`application/data_structures.py`**
  * UI関連のすべてのファイル (`presenter.py`, `controller.py`, `view.py`)

## 💻 ソースコードの詳細解説

### 1. 新しいMongoDB用Data Accessアダプター

以前と同じ`DataAccessInterface`を実装しますが、内部では`pymongo`ライブラリを使ってMongoDBと通信する、新しいクラスを作成します。この層の重要な責務は、アプリケーションの`Entity`オブジェクトと、MongoDBのドキュメント形式（辞書）との間の\*\*「翻訳」\*\*です。

```python
# adapters/mongo_data_access.py

from pymongo import MongoClient
from typing import Optional

# このアダプターは、内側の世界のEntityと「境界」に依存する
from domain.entities import Book, Member, Loan, BookStatus
from application.boundaries import (
    BookDataAccessInterface, MemberDataAccessInterface, LoanDataAccessInterface
)

MONGO_CONNECTION_STRING = "mongodb://localhost:27017/"
DB_NAME = "library_db"

# -----------------------------------------------------------------------------
# MongoDB DataAccess
# - クラス図の位置: DataAccess
# - 同心円図の位置: Adapters (Gateways)
# -----------------------------------------------------------------------------
class MongoBookDataAccess(BookDataAccessInterface):
    """BookDataAccessInterfaceのMongoDB版実装"""
    def __init__(self):
        self.client = MongoClient(MONGO_CONNECTION_STRING)
        self.db = self.client[DB_NAME]
        self.collection = self.db['books']

    def _to_entity(self, doc: dict) -> Optional[Book]:
        """MongoDBのドキュメント(dict)をBook Entityに変換する"""
        if not doc:
            return None
        return Book(
            id=doc['_id'],
            title=doc['title'],
            author=doc['author'],
            status=BookStatus(doc['status']) # Enumも復元
        )

    def _to_document(self, book: Book) -> dict:
        """Book EntityをMongoDBのドキュメント(dict)に変換する"""
        return {
            '_id': book.id,
            'title': book.title,
            'author': book.author,
            'status': book.status.value # Enumは文字列として保存
        }

    def find_by_id(self, book_id: int) -> Optional[Book]:
        document = self.collection.find_one({'_id': book_id})
        return self._to_entity(document)

    def save(self, book: Book) -> Book:
        document = self._to_document(book)
        # upsert=Trueで、IDが存在すれば更新、なければ挿入する
        self.collection.update_one(
            {'_id': book.id},
            {'$set': document},
            upsert=True
        )
        return book

# （同様にMongoMemberDataAccessとMongoLoanDataAccessクラスを実装...）
```

### 2. Composition Rootの更新

もう一つの変更点は、「組立工場」である`main.py`です。ここでインスタンス化する`DataAccess`クラスを、古いインメモリ版から新しいMongoDB版に差し替えるだけです。

```python
# main.py (変更箇所をハイライト)

# ... 他のimport文 ...

# --- NEW: InMemory実装の代わりに、MongoDB実装をインポート ---
from adapters.mongo_data_access import (
    MongoBookDataAccess, MongoMemberDataAccess, MongoLoanDataAccess
)
# --- OLD: こちらはもう不要 ---
# from adapters.data_access import (
#     InMemoryBookDataAccess, InMemoryMemberDataAccess, InMemoryLoanDataAccess
# )

# ...

def main():
    # ...
    
    # [Data Access] を生成
    # ここのクラス名を差し替えるだけ。他のコードは一切変更不要！
    book_data_access = MongoBookDataAccess()
    member_data_access = MongoMemberDataAccess()
    loan_data_access = MongoLoanDataAccess()

    # [Use Case] を生成
    # UseCaseは、注入されるリポジトリの実装が変更されたことを全く知らない。
    # DataAccessInterfaceという契約を満たしてさえいれば、何でも受け入れる。
    use_case = CheckOutBookUseCase(
        presenter=presenter,
        book_repository=book_data_access,
        member_repository=member_data_access,
        loan_repository=loan_data_access
    )
    
    # ... 以降のコードは全く同じ ...
```

これだけです。Composition Rootのわずか数行を変更するだけで、アプリケーションのデータ永続化方法を完全に変更できました。`UseCase`は、その変更に全く気づいていません。

## 💡 ユニットテストでDataAccessの正しさを証明する

MongoDB実装をテストする際も、実際のDBに接続する必要はありません。`mongomock`のようなライブラリを使えば、メモリ上でMongoDBの動作をシミュレートできます。

```python
# tests/adapters/test_mongo_data_access.py の例
import mongomock

def test_MongoBookDataAccessは本の保存と検索ができる():
    # 1. Arrange (準備): mongomockで偽のDB接続を作成し、DataAccessに注入
    mock_client = mongomock.MongoClient()
    book_repo = MongoBookDataAccess()
    book_repo.client = mock_client # 本物の接続の代わりに偽物を注入

    new_book = Book(id=99, title="テスト駆動開発", author="ケント・ベック")

    # 2. Act (実行): 新しい本を保存し、その後IDで検索する
    book_repo.save(new_book)
    found_book = book_repo.find_by_id(99)

    # 3. Assert (検証): 保存した本と、検索結果が一致するか確認
    assert found_book is not None
    assert found_book.title == "テスト駆動開発"
```

## 🛡️ この章の鉄則

データベースはシステムの中心ではなく、あくまで周辺的な関心事です。

> **データベースは詳細である (The database is a detail.)**

  * 私たちの`UseCase`は、抽象（`DataAccessInterface`）にのみ依存します。SQLやNoSQL、あるいはファイルシステムに関する知識を一切持ちません。
  * `DataAccess`アダプターの仕事は、`UseCase`からの抽象的な要求（`save`など）を、特定の技術の具体的な言語（MongoDBの`update_one`など）に**翻訳**することです。
  * この分離により、データベース技術に関する決定を後回しにしたり、後から最小限の影響で変更したりすることが可能になります。これは、長期的なソフトウェアメンテナンスにおいて、絶大な経済的メリットをもたらします。