## 🤔 方針(Policy)と詳細(Detail)の分離とは？

これは、**「何をするか／なぜそれをするか（目的）」**と**「どうやってそれを実現するか（手段）」**を、ソースコードのレベルで完全に切り離す設計原則です。

* **方針 (Policy)**: システムの**目的**そのものです。ビジネスルールやアプリケーションの振る舞いを定義します。これはシステムの核であり、頻繁に変わるべきではありません。
* **詳細 (Detail)**: 方針を実現するための具体的な**手段**です。UI、データベース、外部ライブラリ、ネットワーク通信、ハードウェアといった、技術的な実装を指します。これらは時間と共に変化しやすい要素です。

この分離は、**「目的は手段に依存すべきではない」**という考えに基づいています。

### 例え話：社長と部長の関係

この関係は、企業の社長と部長の関係に似ています。

* **社長 (方針)**: 「今期の売上を10%向上させる」という経営方針を決定します。
* **部長 (詳細)**: その方針を受け、「Web広告キャンペーンを展開する」「実店舗でセールを行う」といった具体的な戦術（手段）を考案し、実行します。

ここで重要なのは依存関係です。部長は社長の方針に従いますが、**社長は部長の具体的な戦術には依存しません**。もしWeb広告担当の部長が退職し、テレビCMを得意とする新しい部長に交代しても、社長の「売上を10%向上させる」という**方針は何も変わらない**のです。

### クリーンアーキテクチャにおける分離

この「社長と部長」の関係を、クリーンアーキテクチャの同心円に当てはめてみましょう。

* **方針 (Policy) = 内側の円 (`Entities`, `Use Cases`)**
    * **`Entity`**: 最も高レベルな方針。「本は貸出中でなければ貸し出せない」「投入金額は価格以上でなければならない」といった、ビジネスの普遍的な**ルール**を定義します。
    * **`Use Case`**: アプリケーションレベルの方針。「本を貸し出す」という目的のために、「会員を検証し、本の在庫を確認し、結果を保存する」という**業務フロー**を定義します。

* **詳細 (Detail) = 外側の円 (`Adapters`, `Frameworks`)**
    * **`DataAccess`**: *どうやって*データを保存するか（PostgreSQLにSQLで書き込む）。
    * **`Presenter`**: *どうやって*結果を表示するか（コンソールに整形済み文字列で表示する）。
    * **`HardwareAdapter`**: *どうやって*商品を排出するか（特定のモータードライバを制御する）。
    * **`View`**: *どうやって*ユーザー入力を受け付けるか（キーボード入力を待つ）。

`UseCase`（方針）は、`DataAccessInterface`という抽象的な「契約」を通じて「保存せよ」と指示するだけです。その指示を`InMemoryDataAccess`（詳細）が実行しようが、`PostgresDataAccess`（別の詳細）が実行しようが、`UseCase`のコードは一切変わりません。

### なぜこの分離が重要なのか？

この分離を徹底することで、計り知れないメリットが生まれます。

1.  **変更の分離**
    「詳細」は頻繁に変わります。データベースをMySQLからPostgreSQLへ移行したり、UIをコンソールからWebアプリへ変更したりすることはよくあります。方針と詳細を分離しておけば、このような**技術的な変更が、システムの核であるビジネスルールに一切影響を与えなくなります**。修正箇所は、該当する`Adapter`の差し替えだけで済みます。

2.  **決定の遅延**
    システムの開発を始める際、**「どのデータベースを使うか」「どのWebフレームワークを使うか」といった「詳細」の決定を、後回しにできます**。まず、システムの最も重要な部分である`Entity`と`UseCase`を、簡単な`InMemoryAdapter`を使って開発し、完全にテストすることができます。そして、プロジェクトの後半で最適な技術を選定すれば良いのです。

3.  **独立したテスト**
    方針（`UseCase`）は、詳細（`DataAccess`, `Hardware`など）から独立しているため、テスト用の偽物（モックやフェイク）と簡単に差し替えることができます。これにより、**ビジネスロジックだけを抜き出して、高速かつ確実にテストすることが可能に**なります。

この「方針と詳細の分離」こそが、クリーンアーキテクチャが目指す、変化に強く、長寿命なソフトウェアを実現するための最も根源的な考え方なのです。