# 🧪 テスト: アーキテクチャの真価

このアーキテクチャの強力な利点である「テストの容易性」を実感していただくために、`SelectItemUseCase`のテストコードを作成します。

これまでの章でも各部品のテストは見てきましたが、この章は`UseCase`という、複数の部品を指揮する「頭脳」のテストです。特に、**物理的なハードウェアが一切なくても、ロジックのテストが完結する**点にご注目ください。

## 🎯 この章の目的

これから書くテストは、以下の点のみを検証します。

  * 投入金額が十分で在庫もある場合、正しく商品が排出され、お釣りが計算されるか？
  * 投入金額が不足している場合、正しくエラーになるか？
  * 在庫が切れている場合、正しくエラーになるか？

このテストのために、本物の自動販売機のハードウェアも、UIも、データベースも一切必要ありません。

## 🎭 「偽物」の部品（テストダブル）を準備する

テスト対象の`SelectItemUseCase`は、`Presenter`, `Repository`, `Hardware`に依存しています。テストでは、これらの本物の代わりに、テストのためだけに作られた「偽物」のクラス（テストダブル）を使います。

```python
# tests/doubles.py

from typing import Dict, List, Optional

# 内側の世界の「境界」「データ構造」「Entity」にのみ依存する
from application.boundaries import (
    SelectItemOutputBoundary, ItemDataAccessInterface, HardwareInterface
)
from application.data_structures import SelectItemOutputData
from domain.entities import Item

# -----------------------------------------------------------------------------
# Presenterの偽物（スパイ）
# - 役割: メソッドが呼ばれたか、どんな引数で呼ばれたかを記録する
# -----------------------------------------------------------------------------
class SpySelectItemPresenter(SelectItemOutputBoundary):
    def __init__(self):
        self.called_with_output_data: Optional[SelectItemOutputData] = None

    def present(self, output_data: SelectItemOutputData):
        self.called_with_output_data = output_data

# -----------------------------------------------------------------------------
# DataAccessの偽物（フェイク）
# - 役割: 本物のDBの代わりに、メモリ上でデータを管理する
# -----------------------------------------------------------------------------
class FakeItemDataAccess(ItemDataAccessInterface):
    def __init__(self, initial_items: List[Item] = None):
        self._database = {item.slot_id: item for item in initial_items} if initial_items else {}
    def find_by_slot_id(self, slot_id: str) -> Optional[Item]:
        return self._database.get(slot_id)
    def save(self, item: Item) -> Item:
        self._database[item.slot_id] = item
        return item

# -----------------------------------------------------------------------------
# Hardwareの偽物（スパイ）
# - 役割: ハードウェアへの指示が出されたか、その内容を記録する
# -----------------------------------------------------------------------------
class SpyHardware(HardwareInterface):
    def __init__(self):
        self.dispensed_slot: Optional[str] = None
        self.returned_change: Optional[int] = None

    def dispense_item(self, slot_id: str):
        self.dispensed_slot = slot_id
    def return_change(self, amount: int):
        self.returned_change = amount
```

## 🔬 テストコード本体

成功ケースと、2つの主要な失敗ケースをテストします。（`pytest`フレームワークを使用）

```python
# tests/application/use_cases/test_select_item.py
import pytest

# --- テスト対象と偽物クラスをインポート ---
from application.use_cases import SelectItemUseCase
from application.data_structures import SelectItemInputData
from domain.entities import Item, PaymentManager
from tests.doubles import SpySelectItemPresenter, FakeItemDataAccess, SpyHardware

def test_成功ケース_正常に商品を購入できる():
    # 1. Arrange (準備)
    payment_manager = PaymentManager(current_amount=200)
    item = Item(slot_id="A1", name="お茶", price=160, stock=5)
    
    spy_presenter = SpySelectItemPresenter()
    fake_repo = FakeItemDataAccess(initial_items=[item])
    spy_hardware = SpyHardware()

    use_case = SelectItemUseCase(spy_presenter, fake_repo, spy_hardware)
    input_data = SelectItemInputData(slot_id="A1")

    # 2. Act (実行)
    use_case.handle(input_data, payment_manager)

    # 3. Assert (検証)
    # ✅ Presenterが正しいデータ（商品名とお釣り40円）で呼ばれたか？
    assert spy_presenter.called_with_output_data is not None
    assert spy_presenter.called_with_output_data.item_name == "お茶"
    assert spy_presenter.called_with_output_data.change == 40
    
    # ✅ Hardwareが正しく指示されたか？
    assert spy_hardware.dispensed_slot == "A1"
    assert spy_hardware.returned_change == 40
    
    # ✅ 在庫が1つ減ったか？
    assert fake_repo.find_by_slot_id("A1").stock == 4
    
    # ✅ 投入金額がリセットされたか？
    assert payment_manager.current_amount == 0

def test_失敗ケース_投入金額不足():
    # 1. Arrange
    payment_manager = PaymentManager(current_amount=100) # 100円だけ投入
    item = Item(slot_id="A1", name="お茶", price=160, stock=5)
    
    use_case = SelectItemUseCase(SpySelectItemPresenter(), FakeItemDataAccess([item]), SpyHardware())
    input_data = SelectItemInputData(slot_id="A1")

    # 2. Act & 3. Assert
    # ✅ 金額不足でValueErrorが発生することを検証
    with pytest.raises(ValueError, match="金額が60円不足しています"):
        use_case.handle(input_data, payment_manager)
```

## 👍 なぜこれが「楽」なのか？

1.  *ハードウェア不要*: このテストを実行するために、物理的な自動販売機はもちろん、その動作を模倣する複雑なシミュレーターも一切不要です。ビジネスロジックの検証が、開発者のPC上だけで完結します。
2.  *高速実行*: メモリ上だけで完結するため、テストは一瞬で終わります。
3.  *副作用の検証*: 失敗ケースのテストでは、「`Presenter`が呼ばれなかったこと」「ハードウェアが動作しなかったこと」「在庫や投入金額が変化しなかったこと」まで正確に検証できます。

## 🐍 PythonとC言語の比較（初心者の方へ）

  * Python (オブジェクト指向): `UseCase`のコンストラクタに\_偽物のオブジェクトを注入\_するだけで、テスト環境を簡単に構築できます。これは\_依存性の注入（DI）\_というテクニックの強力な利点です。
  * C言語 (手続き型): ビジネスロジック関数が、DBアクセス関数を直接呼び出している場合、それらを分離するのは困難です。テストのために\_関数ポインタ\_を使ったり、コンパイル時に `#ifdef TEST` のような\_プリプロセッサ\_で処理を切り替えたりするなど、複雑な工夫が必要になります。

## 🛡️ テストにおける鉄則

クリーンアーキテクチャにおけるテストの考え方は、この一言に集約されます。

> *ビジネスをテストせよ、技術をテストするな。 (Test the business, not the technology.)*

  * `UseCase`のテストは、\_ビジネスルールが正しいか\_だけを検証します。
  * `DataAccess`のテストは、\_DBとの接続やSQLが正しいか\_だけを検証します。
  * UIが正しく表示されるかは、また別のUIテストの責務です。

このように\_関心事を分離\_することで、各テストはシンプルかつ高速になり、ソフトウェア全体の品質を効率的に高めることができるのです。