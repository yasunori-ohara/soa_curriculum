## 🤔 何かしらのバグで商品在庫数に不整合が生じた場合はどうするのでしょうか？

それとも不整合が生じない仕組みをどこかにおいておくのでしょうか？
その問いは、分散アーキテクチャの**最も重要で、最も難しい核心**を突いています。素晴らしい着眼点です。

結論から言うと、その両方です。**「不整合が生じにくい仕組み」**を基本としつつ、万が一の**「不整合を検知・修正する仕組み」**も用意します。

---
### 👏 原則：「真実の管理者」は一人だけ (Single Source of Truth)

まず、最も重要な原則は**「あるデータに対する”真実”を知っている（変更する権限を持つ）サービスは、システム全体でただ一つだけ」**と決めることです。これを**Single Source of Truth (SSoT)**の原則と呼びます。

ご質問の「商品在庫数」の例で言うと、システム内に**「在庫サービス (Inventory Service)」**という、在庫数の管理だけを責務とするサービスを立てます。

* **入荷（増）**: 商品が入荷したとき、その情報を**在庫サービスにのみ**伝えます。在庫サービスだけが、在庫数を増やすことができます。
* **売れた（減）**: 顧客が商品を注文したとき、「注文サービス」は注文を受け付けますが、**在庫数を直接変更することはしません**。代わりに、「商品Aが1個売れました」というイベント（通知）を**在庫サービスに送ります**。その通知を受けて、在庫サービスが自身のデータベースの在庫数を減らします。



つまり、「注文サービス」や「発送サービス」は、自分たちの関心事（価格や重量）に合わせて`Product`クラスを独自に持ちますが、**「在庫数」という”真実”については、常に「在庫サービス」にお伺いを立てる**のです。

---
### 👏 不整合が生じにくい仕組み

このSSoTの原則を守ることで、複数のサービスが勝手に在庫数を書き換えて不整合が起きる、という事態を防ぎます。しかし、これだけでは不十分です。注文処理の途中で通信エラーが起きたらどうなるでしょうか？

そこで、以下のような仕組みを導入します。

### 1. 予約パターン (Reservation Pattern)

顧客が商品をカートに入れ、決済画面に進んだとします。このとき、「注文サービス」はまだ注文を確定させません。

1.  まず、「注文サービス」は「在庫サービス」に対して**「商品Aを1個、10分間だけ予約（確保）してください」**とAPIでリクエストを送ります。
2.  「在庫サービス」は、在庫があればその分を「予約中」のステータスにして、「予約成功しました」と返します。在庫がなければ「予約失敗」と返します。
3.  「注文サービス」は、「予約成功」の返事を受け取って初めて、顧客に決済処理を促します。もし予約に失敗したら、「申し訳ありません、在庫がなくなりました」と表示します。

この「まず予約する」というワンクッションを置くことで、「決済したのに在庫がなかった」という最悪の事態が起きる確率を劇的に減らすことができます。

### 2. イベント駆動による確実な通知

注文が確定したら、「注文サービス」は「注文確定イベント」というメッセージをメッセージブローカー（郵便システム）に送ります。
「在庫サービス」はそのメッセージを受け取って在庫を減らす処理をしますが、もし処理に失敗しても、メッセージブローカーが**「処理が成功するまで何度も再送する」**といった仕組み（配信保証）を備えています。これにより、通知が失われて在庫が減らない、という事態を防ぎます。

---
### 👏 それでも不整合が起きた場合の対処法

上記のような仕組みを導入しても、ネットワークの瞬断や稀なバグなど、100%不整合を防ぐことは不可能です。そこで、不整合が起きることを**前提**とした仕組みも用意します。

* **補償トランザクション (Sagaパターン)**: もし「在庫サービス」での在庫削減に最終的に失敗した場合、「注文サービス」は注文をキャンセルし、顧客への返金処理を行う、といった**「取り消し処理（補償）」**を実行します。一連の処理全体で、最終的に辻褄が合うように調整します。

* **定期的な棚卸し (Reconciliation)**: 現実世界の商店が定期的に棚卸しをして在庫数を確認するように、システムでも夜間バッチなどで**定期的にデータの整合性をチェック**するプログラムを動かします。もし物理的な在庫とデータに不整合が見つかれば、アラートを上げて人手による修正を促したり、自動で修正したりします。

---
このように、分散アーキテクチャでは、単一のデータベースが提供してくれていたような**絶対的な一貫性（Strong Consistency）**を手放す代わりに、**「最終的には辻褄が合う（Eventual Consistency）」**という考え方を受け入れ、様々なパターンを組み合わせてデータの信頼性を担保していくのです。

### これは、モノリシックな開発からSOAへ移行する際の、最も大きなパラダイムシフトの一つです。

