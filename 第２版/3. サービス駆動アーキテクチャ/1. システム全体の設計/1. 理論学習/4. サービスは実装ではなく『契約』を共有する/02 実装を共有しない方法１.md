## 実装を共有しない方法

これはサービスを疎結合に保つための、DDD（ドメイン駆動設計）の考え方を応用した非常に重要な設計パターンです。

共通ライブラリを作らない場合、**各サービスが、自分自身の目的に合わせて、それぞれ独自の「商品」クラス（またはデータ構造）を定義します**。

つまり、「注文サービス用の商品クラス」と「発送サービス用の商品クラス」の2つが、それぞれ独立して存在することになります。

-----

### なぜ同じ「商品」を別々に定義するのか？

これは、DDDで言う「境界づけられたコンテキスト（Bounded Context）」の考え方に基づきます。同じ「商品」という言葉でも、コンテキスト（文脈）によってその意味や関心事が全く異なるからです。

  * **「注文サービス」のコンテキストにおける`Product`**

      * **関心事:** 価格、表示名、商品説明など、顧客が注文を決定するために必要な情報。
      * **クラス定義（例）:**
        ```python
        # order_service/models.py
        class Product:
            def __init__(self, id: str, name: str, price: float, image_url: str):
                self.id = id
                self.name = name
                self.price = price
                self.image_url = image_url
        ```

  * **「発送サービス」のコンテキストにおける`Product`**

      * **関心事:** 重量、寸法、壊れ物指定など、物理的に商品を梱包・発送するために必要な情報。
      * **クラス定義（例）:**
        ```python
        # shipping_service/models.py
        class Product:
            def __init__(self, id: str, weight_kg: float, height_cm: float, is_fragile: bool):
                self.id = id
                self.weight_kg = weight_kg
                self.height_cm = height_cm
                self.is_fragile = is_fragile
        ```

ご覧の通り、両者で「商品」が持つべきデータが全く異なります。「注文サービス」は商品の重さを知りませんし、「発送サービス」は商品の価格を知る必要がありません。共通のクラスを作ると、互いに不要な情報を持つことになり、結合度が高まってしまいます。

-----

### では、どうやってサービス間で情報を連携するのか？

**APIを通じて、必要最小限の情報（特にID）だけを渡す**ことで連携します。

例えば、「注文が確定し、発送準備に入る」というシナリオを考えます。

1.  **注文サービス**は、顧客の注文を受け付けます。
2.  注文が確定したら、**発送サービス**に対して「この注文を発送してください」というリクエストをAPI経由で送ります。
3.  このとき、「注文サービス」が持っている`Product`オブジェクトを丸ごと送ることは**しません**。
4.  代わりに、発送に必要な`productId`と`quantity`（数量）だけを送ります。
    ```json
    // 注文サービスから発送サービスへのリクエスト例
    {
      "orderId": "ORDER-98765",
      "shippingAddress": "...",
      "items": [
        { "productId": "P123", "quantity": 1 },
        { "productId": "P456", "quantity": 2 }
      ]
    }
    ```
5.  リクエストを受け取った**発送サービス**は、受け取った`productId`（例: "P123"）を元に、**自分自身のデータベース**から発送に必要な情報（重量や寸法）を検索して、梱包や送料計算の処理を進めます。

-----

### このアプローチの利点

  * **自律性の維持**: 「発送サービス」は、`weight`の単位をkgからgに変えるなど、自身の`Product`定義を自由に変更できます。その変更は「注文サービス」に一切影響しません。
  * **関心の分離**: 各サービスは、自身のビジネスロジックに本当に必要なデータだけを持つため、モデルがシンプルで理解しやすくなります。

このように、各サービスが自身のコンテキストに合わせてモデルを定義し、サービス間の通信では安定したIDを交換することで、サービス全体の疎結合と自律性を維持するのです。