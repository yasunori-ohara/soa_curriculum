## インターフェースアダプター層の実装

この層の役割は、アプリケーションのコア（ドメイン層・アプリケーション層）と、外部の世界（Web、データベースなど）の間の**通訳**をすることです。アプリケーション層で定義したインターフェースの、具体的な実装クラスを作成します。

![同心円](../../クリーンアーキテクチャ・同心円.png)

### 👑 ステップ1：リポジトリの具象実装

まず、`IArticleRepository`インターフェースの具体的な実装クラスを作成します。今回はデータベースの代わりに、メモリ上にデータを保存するシンプルなリポジトリを実装します。

```python
# adapters/repositories/in_memory_article_repository.py

import uuid
from domain.article import Article
from application.interfaces.article_repository import IArticleRepository

class InMemoryArticleRepository(IArticleRepository):
    """
    IArticleRepositoryインターフェースのインメモリでの具象実装。
    テストや簡単な動作確認に利用できる。
    """
    def __init__(self):
        # 記事を保存するための、メモリ上の辞書
        self._articles: dict[uuid.UUID, Article] = {}

    def save(self, article: Article) -> None:
        """
        IArticleRepositoryインターフェースで定義されたsaveメソッドを実装する。
        """
        print(f"--- Saving article {article.article_id} to in-memory store ---")
        self._articles[article.article_id] = article
        print(f"--- Article saved successfully ---")
```

このクラスは`IArticleRepository`という「契約書」通りに`save`メソッドを実装しています。

### 👑 ステップ2：コントローラーの実装

次に、FastAPIを使ってHTTPリクエストを受け付ける`Controller`を実装します。この`Controller`は、アプリケーション層で定義した`ICreateArticleUseCase`**インターフェース**に依存します。

```python
# adapters/controllers/article_controller.py

import uuid
from fastapi import APIRouter, Depends, HTTPException
from pydantic import BaseModel

# ユースケースの「インターフェース」と入力DTOをインポート
from application.interfaces.create_article_use_case import ICreateArticleUseCase, CreateArticleInput

# DI（依存性注入）のための設定をインポート（後ほどmain.pyで定義）
from main import get_create_article_use_case

router = APIRouter()

# --- API層のデータモデル（リクエストとレスポンス）を定義 ---
class CreateArticleRequest(BaseModel):
    title: str
    content: str

class ArticleResponse(BaseModel):
    article_id: uuid.UUID
    author_id: uuid.UUID
    title: str
    content: str
    
    class Config:
        from_attributes = True # ORMオブジェクトなどからPydanticモデルへの変換を許可

# --- エンドポイントの実装 ---
@router.post("/articles", response_model=ArticleResponse, status_code=201)
def create_article(
    request: CreateArticleRequest,
    # 認証機能からユーザーIDを取得したと仮定するダミーのID
    author_id: uuid.UUID = uuid.uuid4(), 
    # FastAPIのDI機能を使って、ユースケースの「インターフェース」に依存する
    use_case: ICreateArticleUseCase = Depends(get_create_article_use_case)
):
    try:
        # APIリクエストをユースケースの入力DTOに変換
        input_data = CreateArticleInput(
            author_id=author_id,
            title=request.title,
            content=request.content
        )
        # ユースケースを実行
        created_article = use_case.execute(input_data)
        return created_article
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
```

### 👑 全てを繋ぎ合わせる（依存性注入）

最後に、これまで作った部品（具象クラス）を全て繋ぎ合わせる「配線工事」をアプリケーションのエントリーポイントである`main.py`で行います。

```python
# main.py

from fastapi import FastAPI, Depends

# --- 各層の部品をインポート ---
# adapters
from adapters.controllers import article_controller
from adapters.repositories.in_memory_article_repository import InMemoryArticleRepository
# application
from application.use_cases.create_article import CreateArticleUseCase
from application.interfaces.create_article_use_case import ICreateArticleUseCase

# --- FastAPIアプリケーションのインスタンス化 ---
app = FastAPI()

# =================================================================
# === 依存性注入（DI）コンテナの役割を果たす部分 ===
# =================================================================

# 1. 具象リポジトリのインスタンスを生成（アプリケーション全体で一つ）
in_memory_repo = InMemoryArticleRepository()

# 2. 具象ユースケースのインスタンスを生成し、具象リポジトリを注入
create_article_use_case = CreateArticleUseCase(article_repository=in_memory_repo)

# 3. FastAPIに「どのインターフェースにどの実装を渡すか」を教えるための関数
def get_create_article_use_case() -> ICreateArticleUseCase:
    return create_article_use_case

# =================================================================

# --- ルーターの登録 ---
# FastAPIは、article_controller内の Depends(get_create_article_use_case) を見つけると、
# 上記で定義した関数を呼び出し、その戻り値をcontrollerに渡してくれる。
app.include_router(article_controller.router)

```

`main.py`は、アプリケーション全体で唯一、`InMemoryArticleRepository`や`CreateArticleUseCase`といった**全ての具象クラスを知っている**場所です。この場所で全ての部品を組み立て、`Controller`が抽象（インターフェース）を要求してきたら、組み立て済みの具象（インスタンス）を渡す、という設定を行っています。

-----

以上で、実装は完了です。各層がインターフェースを介して綺麗に分離され、依存性のルールが完全に守られている状態になりました。
