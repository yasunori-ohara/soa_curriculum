## アプリケーション層の実装：ユースケースを定義する

ドメイン層という心臓部が完成しましたので、次にその心臓を使って具体的なタスクを実行する「頭脳」にあたる、**2. アプリケーション層の実装**に進みます。

**アプリケーション層**は、クリーンアーキテクチャの外から2番目の層です。この層の役割は、ユーザーがシステムに対して行いたい具体的な操作（＝**ユースケース**）を定義することです。

![同心円](../../クリーンアーキテクチャ・同心円.png)

ドメイン層のエンティティをオーケストラのように指揮して、一つのまとまったタスクを完了させます。

### 🐢 アプリケーション層のルール

  * **ドメイン層にのみ依存**: アプリケーション層は、ドメイン層のエンティティやビジネスルールを利用しますが、それ以外の外側の層（WebフレームワークやDBなど）のことは一切知りません。
  * **関心事の分離**: 一つのユースケースクラスは、一つのタスク（例：「記事を作成する」）にのみ責任を持ちます。

今回は、「新しい記事を作成する」というユースケースを実装します。

### 🐢 ステップ1：リポジトリのインターフェースを定義する

ユースケースは、「作成した記事を永続化（保存）する」という役割を誰かにお願いする必要があります。しかし、アプリケーション層は具体的なデータベース技術を知るべきではありません。

そこで、クリーンアーキテクチャの原則に従い、まず\*\*「リポジトリ」**というデータ永続化の役割を**インターフェース（抽象的な契約）\*\*として定義します。これは、内側（アプリケーション層）から外側（インフラ層）への依存を逆転させるための「出口」の契約です。

```python
# application/interfaces/article_repository.py

from abc import ABC, abstractmethod
from domain.article import Article

class IArticleRepository(ABC):
    """
    Articleリポジトリのインターフェース。
    アプリケーション層は、このインターフェースにのみ依存する。
    """
    
    @abstractmethod
    def save(self, article: Article) -> None:
        """
        記事を永続化する。
        """
        raise NotImplementedError
```

この`IArticleRepository`は、「`save`という名前のメソッドがあり、それは`Article`オブジェクトを受け取ります」ということだけを定義した、純粋な「契約書」です。

### 🐢 ステップ2：コントローラーのインターフェースを定義する

同様に、ユースケースは外側の層（インターフェースアダプター層）から呼び出される必要があります。そのための「入り口」の契約として、ユースケース自身のインターフェース（入力境界 - Input Boundary）を定義します。

```python
# application/interfaces/create_article_use_case.py

import uuid
from abc import ABC, abstractmethod
from pydantic import BaseModel, Field
from domain.article import Article

class CreateArticleInput(BaseModel):
    """
    記事作成ユースケースの入力データ構造（DS）。
    このインターフェースの一部として定義する。
    """
    author_id: uuid.UUID
    title: str = Field(min_length=1, max_length=100)
    content: str = Field(min_length=1)

class ICreateArticleUseCase(ABC):
    """
    記事作成ユースケースのインターフェース（入力境界）。
    """
    
    @abstractmethod
    def execute(self, input_data: CreateArticleInput) -> Article:
        """ユースケースを実行する"""
        raise NotImplementedError
```

これにより、ユースケースは「私はこの`ICreateArticleUseCase`という契約書通りに呼び出されます」と表明できます。

### 🐢 ステップ3：ユースケースを実装する

定義した2つのインターフェースを使って、「記事を作成する」ユースケースを実装します。このユースケースは、`IArticleRepository`に**依存し**、`ICreateArticleUseCase`を**実装**します。

```python
# application/use_cases/create_article.py

from domain.article import Article
from application.interfaces.article_repository import IArticleRepository
from application.interfaces.create_article_use_case import ICreateArticleUseCase, CreateArticleInput

class CreateArticleUseCase(ICreateArticleUseCase):
    """
    記事作成ユースケースの具象実装。
    ICreateArticleUseCaseインターフェースを実装する。
    """
    
    def __init__(self, article_repository: IArticleRepository):
        """
        コンストラクタで、リポジトリのインターフェースに依存する。
        """
        self.article_repository = article_repository

    def execute(self, input_data: CreateArticleInput) -> Article:
        """
        ユースケースを実行する。

        1. ドメインエンティティを生成する
        2. リポジトリを使って永続化する
        3. 結果を返す
        """
        # 1. 入力データを使って、ドメイン層のArticleエンティティを生成する
        #    このとき、Articleクラスに定義されたビジネスルール（文字数制限など）が
        #    Pydanticによって自動的に検証される。
        article = Article(
            author_id=input_data.author_id,
            title=input_data.title,
            content=input_data.content
        )

        # 2. リポジトリのインターフェースを通じて、永続化を依頼する
        #    ユースケースは、この先で何が起きるか（DBに書き込まれるかなど）を知らない。
        self.article_repository.save(article)

        # 3. 生成されたArticleエンティティをそのまま返す
        return article
```

### 🐢 実装のポイント

  * **依存性逆転の法則の実践**: `CreateArticleUseCase`は、具体的なDB実装ではなく、抽象的な`IArticleRepository`インターフェースにのみ依存しています。
  * **DTOによる境界の明確化**: `CreateArticleInput`という入力専用のデータ構造を定義することで、ユースケースが必要とする情報を明確にしています。
  * **インターフェースによる責務の明確化**: `CreateArticleUseCase`が`ICreateArticleUseCase`を実装することで、このクラスがアプリケーションへの「入力ポート」としての責務を持つことがコード上で明確に表現されます。
  * **ドメイン層のオーケストレーション**: ユースケースは複雑なビジネスロジックは含まず、ドメインエンティティ(`Article`)を生成し、リポジトリ(`save`)を呼び出すという、\*\*オーケストレーション（指揮）\*\*に徹しています。

-----

これで、アプリケーションのビジネスロジックを担うアプリケーション層が、インターフェースを使って綺麗に定義されました。ドメイン層とアプリケーション層は、まだWebの世界のことを何も知りません。