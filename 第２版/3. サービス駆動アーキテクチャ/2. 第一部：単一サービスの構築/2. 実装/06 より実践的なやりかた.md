## 実践的な（Pragmatic）パターンへのリファクタリング

これまでは、`Controller`と`Use Case`の間にインターフェースを挟むことで、両者を完全に分離しました。

しかし、`Controller`が`Use Case`を呼び出す矢印（外→内）は、元々クリーンアーキテクチャの依存性のルールに違反していません。そのため、FastAPIのような依存性注入（DI）が得意なフレームワークを使う場合、このインターフェースは**省略可能**です。

インターフェースを省略することで、コードの量を減らし、よりシンプルで見通しの良い構造にすることができます。

### 📜 リファクタリングの手順

1.  **`Use Case`のインターフェースを削除する**
    `application/interfaces/create_article_use_case.py` ファイルを削除します。
2.  **入力DTOを`Use Case`ファイルに移動する**
    インターフェースファイルにあった`CreateArticleInput`を、`Use Case`の具象クラスファイル内に移します。
3.  **`Controller`の依存先を具象クラスに変更する**
    `Controller`が、インターフェースではなく`Use Case`の具象クラスを直接`import`し、依存するように変更します。

### 📜 修正後のコード

以下が、リファクタリング後の主要なファイルです。

#### **1. ユースケースの実装（修正後）**

`ICreateArticleUseCase`を実装しなくなり、`CreateArticleInput`を自身で定義するようになります。

```python
# application/use_cases/create_article.py

import uuid
from pydantic import BaseModel, Field
from domain.article import Article
from application.interfaces.article_repository import IArticleRepository

# --- 変更点 ---
# CreateArticleInputをこのファイルで定義する
class CreateArticleInput(BaseModel):
    author_id: uuid.UUID
    title: str = Field(min_length=1, max_length=100)
    content: str = Field(min_length=1)
# -------------

# --- 変更点 ---
# ICreateArticleUseCaseの継承をやめる
class CreateArticleUseCase:
# -------------
    """記事作成ユースケース"""
    
    def __init__(self, article_repository: IArticleRepository):
        self.article_repository = article_repository

    def execute(self, input_data: CreateArticleInput) -> Article:
        article = Article(
            author_id=input_data.author_id,
            title=input_data.title,
            content=input_data.content
        )
        self.article_repository.save(article)
        return article
```

#### **2. コントローラーの実装（修正後）**

依存先が`ICreateArticleUseCase`から`CreateArticleUseCase`に変わります。

```python
# adapters/controllers/article_controller.py
# (importなどは省略)

# --- 変更点 ---
# ユースケースの「具象クラス」と、その中にある入力DTOをインポート
from application.use_cases.create_article import CreateArticleUseCase, CreateArticleInput
# -------------

# ... (routerなどの定義は同じ) ...

@router.post("/articles", response_model=ArticleResponse, status_code=201)
def create_article(
    request: CreateArticleRequest,
    author_id: uuid.UUID = uuid.uuid4(),
    
    # --- 重要な変更点 ---
    # 依存先がインターフェースから具象クラスに変わる
    use_case: CreateArticleUseCase = Depends(get_create_article_use_case)
    # -------------
):
    # ... (try-exceptブロックの中身は変更なし) ...
```

#### **3. 依存性注入の設定（修正後）**

`main.py`のDI設定関数も、返す型のアノテーションを具象クラスに変更します。

```python
# main.py (一部抜粋)

from application.use_cases.create_article import CreateArticleUseCase
# ... (インスタンスの生成は同じ) ...

# --- 変更点 ---
# 返す型のアノテーションを具象クラスに変更
def get_create_article_use_case() -> CreateArticleUseCase:
# -------------
    return create_article_use_case
```

### 📜 トレードオフのまとめ

| | 厳格なパターン | 実践的なパターン（今回） |
| :--- | :--- | :--- |
| **利点** | ・`Controller`と`Use Case`が完全に分離<br>・原則に最も忠実 | ・コード量（ファイル数）が少ない<br>・シンプルで理解しやすい |
| **欠点** | ・コード量が増え、構造がやや複雑になる | ・`Controller`が`Use Case`の具象クラスに直接依存する |

`Controller`と`Use Case`が1対1で対応することが多い一般的なWeb API開発では、この実践的なパターンが「簡潔さ」と「十分な分離」のバランスが取れた、非常に良い落としどころとして広く採用されています。

-----

以上で、**第1部：単一サービスの実装**は完了です。
クリーンアーキテクチャの厳格なパターンと実践的なパターンの両方を体験し、高品質なコンポーネントを一つ作り上げました。

次は、いよいよ**第2部**として、このコンポーネントを他のサービスと連携させる「サービス間連携の実装」に進んでいきます。