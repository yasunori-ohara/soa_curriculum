## 第2章：値オブジェクトとエンティティ


## 🎯 この章の目的

* 「**型で意味を守る設計**」の考え方を理解する
* **値オブジェクト（Value Object）** と **エンティティ（Entity）** の違いを体験する
* 不正な値を受け取らないプログラムを設計できるようにする

---

## 🧩 1. 「型で意味を守る」とは？

DDDでは、「値をただのデータとして扱わない」ことが基本です。

| 悪い例                                                                              | 問題点                |
| -------------------------------------------------------------------------------- | ------------------ |
| `start = datetime(2025, 10, 20, 13, 0)`<br>`end = datetime(2025, 10, 20, 11, 0)` | 開始時刻が終了より後でも通ってしまう |
| `email = "abc"`                                                                  | メールアドレスではない文字列でも通る |
| `capacity = -5`                                                                  | 定員がマイナスでも通ってしまう    |

→ **こうした不整合を“型”で防ぐ**のがDDDの値オブジェクトです。

---

## 🧱 2. 値オブジェクト（Value Object）

### 🧠 定義

> 値そのものが意味を持ち、不変（immutable）で、等価性によって比較されるオブジェクト。

### 特徴

* **不変**（作ったら変わらない）
* **自己検証**（内部で正しさをチェック）
* **同値性**（内容が同じなら同じとみなす）

---

### 📘 例1：TimeRange（時間範囲）

```python
from dataclasses import dataclass
from datetime import datetime

@dataclass(frozen=True)
class TimeRange:
    start: datetime
    end: datetime

    def __post_init__(self):
        if not (self.start < self.end):
            raise ValueError("TimeRange: start < end でなければなりません。")

    def overlaps(self, other: "TimeRange") -> bool:
        """時間帯が重なっているか判定"""
        return self.start < other.end and other.start < self.end
```

> 💬 DDDでは、このように**自分の中で不整合を防ぐ責任**を持たせます。
> つまり、「ルールをUseCaseで書かず、型に閉じ込める」発想です。

---

### 📘 例2：Email（メールアドレス）

```python
from dataclasses import dataclass
import re

@dataclass(frozen=True)
class Email:
    value: str

    def __post_init__(self):
        pattern = r"^[\w\.-]+@[\w\.-]+\.\w+$"
        if not re.match(pattern, self.value):
            raise ValueError(f"Email: 不正な形式です -> {self.value}")
```

> 📖 どこでも `"xxx@gmail.com"` という生文字列を使う代わりに、
> **Email型で“意味”を固定**しておくと、どの層でも安全です。

---

### 📘 例3：Capacity（定員）

```python
from dataclasses import dataclass

@dataclass(frozen=True)
class Capacity:
    value: int

    def __post_init__(self):
        if self.value <= 0:
            raise ValueError("Capacity: 定員は1以上である必要があります。")

    def can_accept(self, num_people: int) -> bool:
        return num_people <= self.value
```

> これで、UseCaseやEntityで「定員チェック」のコードを毎回書く必要がなくなります。

---

### ✅ 演習①：自分のドメインで値オブジェクトを考えてみよう

| 値オブジェクト名       | 意味（どんな値を守る？） | ルール（どんな検証が必要？） |
| -------------- | ------------ | -------------- |
| TimeRange      | 開始と終了の時間     | start < end    |
| Email          | メールアドレス文字列   | 正規表現に一致する      |
| Capacity       | 定員           | value > 0      |
| MemberName（例）  | 会員の氏名        | 空文字禁止、最大長100文字 |
| PhoneNumber（例） | 電話番号         | 数字のみ、長さは10〜11桁 |

> 💡 ポイント：**「型に責任を持たせる」＝プログラム全体が安全になる。**

---

## 🧱 3. エンティティ（Entity）

### 🧠 定義

> 一意のIDを持ち、ライフサイクルを持つオブジェクト。
> 値が変わっても、IDが同じなら“同じもの”とみなす。

| 要素     | 説明                    |
| ------ | --------------------- |
| **ID** | 同一性を識別するためのキー         |
| **属性** | 値オブジェクトで構成される         |
| **操作** | 集約ルール（不変条件）を守るためのメソッド |

---

### 📘 例：Reservation（予約エンティティ）

```python
from dataclasses import dataclass
from datetime import datetime
from typing import Optional

@dataclass
class Reservation:
    id: int
    member_id: int
    room_id: int
    time_range: TimeRange
    attendees: int
    canceled_at: Optional[datetime] = None

    def cancel(self):
        if self.canceled_at is not None:
            raise ValueError("すでにキャンセル済みです。")
        self.canceled_at = datetime.now()

    def is_active(self) -> bool:
        return self.canceled_at is None
```

> 💬 Reservationは「時間範囲」と「人数」をValue Objectで持ち、
> 自分で「キャンセル済みかどうか」を判断できます。

---

### 📘 例：Room（会議室エンティティ）

```python
from dataclasses import dataclass

@dataclass
class Room:
    id: int
    name: str
    capacity: Capacity
```

> 会議室の定員チェックを `Capacity` に委譲することで、
> `Room` 自体は「部屋を表す」責務に集中できます。

---

### 📘 例：Member（会員エンティティ）

```python
from dataclasses import dataclass

@dataclass
class Member:
    id: int
    name: str
    email: Email
```

> 会員のメールアドレス検証は `Email` に委譲済み。
> こうして「エンティティは状態を持つが、値の正しさは型が守る」構造になります。

---

### ✅ 演習②：自分のドメインでエンティティを定義してみよう

| エンティティ名     | 識別子（ID）        | 含まれる値オブジェクト         | 操作（メソッド）              |
| ----------- | -------------- | ------------------- | --------------------- |
| Reservation | reservation_id | TimeRange, Capacity | cancel(), is_active() |
| Room        | room_id        | Capacity            | ー                     |
| Member      | member_id      | Email               | ー                     |
| （例）Payment  | payment_id     | Amount, PaymentDate | refund(), mark_paid() |

> 💡 DDDでは「値オブジェクトが型のルールを守り、エンティティが振る舞いを守る」。

---

## ⚙ 4. Entity と Value Object の違い（比較表）

| 観点  | エンティティ（Entity）  | 値オブジェクト（Value Object） |
| --- | --------------- | --------------------- |
| 同一性 | IDで判断           | 値で判断                  |
| 不変性 | 可変（状態変化あり）      | 不変（作成後は変更不可）          |
| 責務  | ライフサイクルを持ち、動作する | 値の正しさを保証する            |
| 例   | 予約、会員、部屋        | 時間範囲、メール、定員、金額        |

---

## 🧪 5. テストで確認する

### 📘 例：pytestでのValue Objectテスト

```python
import pytest
from datetime import datetime
from domain.value_objects import TimeRange

def test_time_range_valid():
    t1 = TimeRange(datetime(2025,1,1,9), datetime(2025,1,1,10))
    assert t1.start.hour == 9

def test_time_range_invalid():
    with pytest.raises(ValueError):
        TimeRange(datetime(2025,1,1,10), datetime(2025,1,1,9))
```

> 💡 ルールを型に閉じ込めると、**テストは単純明快**になります。

---

## 🧩 6. クリーンアーキテクチャとの接続

```
[UseCase層]
    ↑   予約を作る／キャンセルする
[Domain層]
    ├── Reservation（Entity）
    ├── TimeRange, Email, Capacity（Value Object）
    └── 不変条件（集約ルール）を守る
```

> クリーンアーキでいう **Entity層＝DDDのDomain層**。
> この「中核（Core Domain）」を守るのがDDDの目的です。

---

## ✅ 7. まとめ

| 要点          | 内容                             |
| ----------- | ------------------------------ |
| **値オブジェクト** | 不変・自己検証・等価性。値の意味を型で守る。         |
| **エンティティ**  | IDで同一性を持ち、状態を持つ。               |
| **使い分け**    | 値の意味を守るのがVO、動作を持つのがEntity。     |
| **効果**      | バグがUseCaseやController層に伝染しにくい。 |
| **CAとの関係**  | Domain層をDDD化し、意味と構造を両立。        |

---

## 🎓 演習③：自分の言葉を型にしてみよう

1. まず、ユビキタス言語一覧から「ルールを持つ言葉」を探す
2. それを Value Object にする
3. それを使う Entity を設計してみる

> 例）
>
> * 「開始時間」「終了時間」→ `TimeRange`
> * 「定員」→ `Capacity`
> * 「会員」→ `Member`（Entity）
> * 「予約」→ `Reservation`（Entity）

---

## 🔜 次章予告：第3章「集約と集約ルート」

次はいよいよDDDの中核、「**整合性を保つかたまり＝集約（Aggregate）**」に進みます。

扱うテーマ：

* 集約とは何か（境界の中での整合性）
* 集約ルートの役割
* 複数エンティティの連携（Room と Reservation の関係）
* 「トランザクションの範囲」をどう決めるか
* 実装例と演習

---

この章（値オブジェクト＋エンティティ）で紹介した `TimeRange`, `Email`, `Capacity`, `Reservation` をベースに、
次章では「それらをどう一つの整合性のまとまり（Aggregate）にするか」を扱います。

