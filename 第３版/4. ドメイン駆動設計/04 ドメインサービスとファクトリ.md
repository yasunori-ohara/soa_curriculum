## 第4章：ドメインサービスとファクトリ

この章は、前章までに作った **集約を“横につなぐ”設計** を扱います。
DDDの世界で「複数の集約をどう協調させるか？」を学ぶ重要な章です。

## 🎯 この章の目的

1. 集約をまたぐロジックを「**ドメインサービス**」として整理する
2. オブジェクト生成のルールを「**ファクトリ（Factory）**」として管理する
3. 「**どの責務をどこに置くべきか**」を判断できるようになる

---

## 🧩 1. 集約をまたぐロジックの問題

たとえば、会議室予約アプリでこんなルールを考えてみましょう：

> * 会員が無効なら予約できない
> * 予約する部屋が満員なら予約できない
> * 予約が重複してはいけない

これらのルールを **Reservation** エンティティにすべて書いてしまうとどうなるでしょう？

### ❌ 問題

* `Reservation` が `Member` と `Room` の内部構造を知ってしまう
* 「集約間の依存」が発生し、変更が連鎖する
* テストが複雑になる

そこで登場するのが「**ドメインサービス（Domain Service）**」です。

---

## 🧠 2. ドメインサービス（Domain Service）とは？

### 🔍 定義

> **複数の集約にまたがる業務ルール**を表現するクラス。
> 状態（フィールド）は持たず、**振る舞い（メソッド）**だけを持つ。

---

### 📘 図：集約とドメインサービスの関係

```
+------------------------+
|  MemberAggregate       |
+------------------------+
         ↑
         |
         | uses
         |
+------------------------+
|  ReservationService    | ← 複数集約をまとめて扱う
+------------------------+
         |
         ↓
+------------------------+
|  RoomAggregate         |
+------------------------+
```

> 各集約を「サービスを通じて」協調させます。
> サービスは**ドメイン層に属します（UseCase層ではない）**。

---

## ⚙ 3. 実装例：ReservationService

```python
# domain/service/reservation_service.py
from domain.reservation import Reservation
from domain.value_objects import TimeRange
from domain.room import Room
from domain.member import Member

class ReservationService:
    """複数集約（Member, Room, Reservation）にまたがるドメインルール"""

    def can_reserve(self, member: Member, room: Room, time_range: TimeRange, existing: list[Reservation]) -> bool:
        if not member.is_active:
            return False
        if not room.capacity.can_accept(1):  # 仮：空席が1以上
            return False
        for r in existing:
            if r.overlaps(Reservation(0, member, room, time_range, 1)):
                return False
        return True
```

> ✅ **特徴：**
>
> * `ReservationService` は状態を持たず、判断ロジックのみを提供。
> * 「予約可能か？」というドメイン上の判断を1か所に集約。
> * `Reservation`、`Member`、`Room` の関係を整理して保つ。

---

### 📘 使う側（UseCase）

```python
# usecase/create_reservation.py
from domain.service.reservation_service import ReservationService
from usecase.contracts.reservation_repository import ReservationRepository

class CreateReservationUseCase:
    def __init__(self, repo: ReservationRepository, service: ReservationService):
        self.repo = repo
        self.service = service

    def execute(self, member, room, time_range, attendees):
        existing = self.repo.find_by_room(room.id)
        if not self.service.can_reserve(member, room, time_range, existing):
            raise ValueError("予約条件を満たしていません。")

        reservation = Reservation(
            id=self.repo.next_id(),
            member=member,
            room=room,
            time_range=time_range,
            attendees=attendees,
        )
        self.repo.save(reservation)
        return reservation
```

> **UseCaseは「制御」だけ。**
> **ビジネスルールはServiceに任せる。**

---

## 🧩 4. ファクトリ（Factory）とは？

### 🧠 定義

> **複雑な生成手続きをまとめる“生成専用クラス”**。
> 「正しい状態のオブジェクトを一発で作る」ことに責任を持つ。

---

### 📘 例：ReservationFactory

```python
# domain/factory/reservation_factory.py
from domain.reservation import Reservation
from domain.value_objects import TimeRange

class ReservationFactory:
    """予約生成のルールを集中管理する"""

    def create(self, new_id: int, member, room, time_range: TimeRange, attendees: int):
        # ValueObjectが正しさを保証している前提で、組み合わせを統合
        return Reservation(
            id=new_id,
            member=member,
            room=room,
            time_range=time_range,
            attendees=attendees
        )
```

> 💡 **Factoryは「正しい初期状態」だけを作る責任者。**
> UseCaseやControllerが直接 `Reservation()` を呼ばないようにします。

---

## 🧩 5. Service と Factory の使い分け

| 種類                 | 役割        | 状態 | 使う場所              |
| ------------------ | --------- | -- | ----------------- |
| **Entity**         | 単体のルールを守る | あり | 集約内               |
| **Value Object**   | 値の正しさを守る  | 不変 | 集約内               |
| **Domain Service** | 集約を横断して判断 | なし | ドメイン層             |
| **Factory**        | 正しい生成を保証  | なし | ドメイン層（UseCaseで利用） |

> 🧠 原則：「データに関するルール → Entity / VO」「関係に関するルール → Service」

---

## 🧪 6. テスト例：ReservationServiceのテスト

```python
from datetime import datetime
from domain.service.reservation_service import ReservationService
from domain.value_objects import TimeRange
from domain.room import Room, Capacity
from domain.member import Member, Email
from domain.reservation import Reservation

def test_can_reserve_false_when_overlap():
    svc = ReservationService()
    room = Room(1, "A", Capacity(10))
    member = Member(1, "Taro", Email("taro@example.com"))

    r1 = Reservation(1, member, room, TimeRange(datetime(2025,1,1,9), datetime(2025,1,1,10)), 2)
    r2_range = TimeRange(datetime(2025,1,1,9,30), datetime(2025,1,1,10,30))
    result = svc.can_reserve(member, room, r2_range, [r1])

    assert result is False
```

> ✅ 集約横断ルールは `DomainService` に集約することで、
> **テスト単位が明確に（UseCase依存なし）** になります。

---

## 🎓 演習①：自分のドメインで整理してみよう

| ロジック   | 扱う集約                      | 種類                  | 説明      |
| ------ | ------------------------- | ------------------- | ------- |
| 予約可能判定 | Reservation, Room, Member | Domain Service      | 集約横断ルール |
| 新規予約生成 | Reservation               | Factory             | 生成ルール   |
| メール送信  | Member                    | Application Service | ドメイン外処理 |

> 💬 「ビジネス上の判断」か「生成の手続き」かで分類すると整理しやすいです。

---

## 🧱 7. クリーンアーキテクチャとの対応図

```
[UseCase層]             ← 制御を行う
    ↓
[Domain層]
 ├── Entity / VO        ← 意味を守る
 ├── Domain Service     ← 集約横断ロジック
 └── Factory            ← 生成のルール
```

> DDDの **Domain層 = クリーンアーキのEntity層** に相当します。
> そこに Service / Factory が加わることで「ビジネス全体を内包」できます。

---

## ✅ 8. まとめ

| 要点                 | 内容                               |
| ------------------ | -------------------------------- |
| **Domain Service** | 集約を横断する判断・計算のためのクラス。状態は持たない。     |
| **Factory**        | 正しい初期状態の生成を担う。                   |
| **UseCaseとの関係**    | UseCaseは制御のみ。ドメインルールはServiceへ委譲。 |
| **CAとの関係**         | Entity層の内部がより表現力豊かになる。           |
| **テスト性**           | ルール単位の独立テストが可能になる。               |

---

## 🎓 演習②：ドメインルールの棚卸し

次の表を埋めて、どの責務をどこに置くかを整理してみましょう。

| ドメインルール      | 集約内で完結？ | 複数集約にまたがる？ | 生成時に必要？ | 配置先                           |
| ------------ | ------- | ---------- | ------- | ----------------------------- |
| Roomの定員を超えない | ✅       | ❌          | ❌       | Room(Entity)                  |
| Memberが有効である | ❌       | ✅          | ❌       | ReservationService            |
| 予約IDを払い出す    | ❌       | ❌          | ✅       | ReservationFactory            |
| 予約完了メールを送信   | ❌       | ✅          | ❌       | Application Service（UseCase外） |

---

## 🔜 次章予告：第5章「リポジトリと永続化（DDD版）」

これまでに扱ったドメインの世界（純粋ロジック）を、
次は「**永続化（DB）にどう橋をかけるか**」に進めます。

扱うテーマ：

* DDDにおけるRepositoryの正しい位置づけ
* 集約単位での保存・再構築
* Infrastructure層との依存関係整理（DIPの再確認）
* テストダブル（InMemoryRepository）の作成と契約テスト


