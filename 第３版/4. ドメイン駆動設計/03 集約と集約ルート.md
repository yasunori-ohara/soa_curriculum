## 第3章：集約と集約ルート

## 🎯 この章の目的

1. **「集約（Aggregate）」の考え方**を理解する
2. **集約ルート（Aggregate Root）** の役割を理解する
3. **一貫性を保つ範囲（トランザクション境界）**を自分で決められるようにする

---

## 🧭 1. 集約（Aggregate）とは？

DDDでは、ドメインモデルを小さなかたまりに分けて管理します。
それを **集約（Aggregate）** と呼びます。

> 💡 **集約 = 一貫性を保つための小さな世界**

たとえば、「会議室予約」システムには次のような関連があります：

```
Member ─┐
        │予約する
        ▼
     Reservation ────→ Room
```

このとき、次のようなルールがあるとします：

* 予約は「存在する部屋」に対してのみ作れる
* 同じ部屋・時間帯で重複して予約できない
* 会員が無効になっていたら予約できない

これらのルールを、システム全体で常に守るのは大変です。
そこで、**整合性を保つ単位を「集約」としてまとめる**のです。

---

## 🧩 2. 集約の構造（Aggregate構成図）

```
+-------------------------------------------------+
| Aggregate: ReservationAggregate                 |
|-------------------------------------------------|
|  Root Entity: Reservation                       |
|-------------------------------------------------|
|  Related Entities: Room, Member (参照のみ)       |
|-------------------------------------------------|
|  不変条件:                                       |
|   - Roomの空き時間と重複しない                    |
|   - Memberが有効である                           |
|   - TimeRangeが正しい（ValueObjectで保証）        |
+-------------------------------------------------+
```

> 集約の中には「**ルート（Root）**」となるエンティティが1つあります。
> これが「代表者」として外部から参照されます。

---

## 🧱 3. 集約ルート（Aggregate Root）

### 🧠 定義

> 集約全体を代表し、外部から直接アクセスされる唯一のエンティティ。

| 観点        | 集約ルート  | 集約内エンティティ |
| --------- | ------ | --------- |
| 外部からの参照   | 許可される  | 許可されない    |
| 一貫性ルールの中心 | 担う     | ルートに従う    |
| 保存・更新の単位  | Save単位 | 一緒に保存される  |

---

### 📘 例：Reservationを集約ルートとする

```python
from dataclasses import dataclass
from datetime import datetime
from typing import Optional, List
from domain.value_objects import TimeRange
from domain.room import Room
from domain.member import Member

@dataclass
class Reservation:
    id: int
    member: Member
    room: Room
    time_range: TimeRange
    attendees: int
    canceled_at: Optional[datetime] = None

    def cancel(self):
        if self.canceled_at:
            raise ValueError("すでにキャンセル済みです。")
        self.canceled_at = datetime.now()

    def overlaps(self, other: "Reservation") -> bool:
        """同じ部屋の予約が重なっているか確認"""
        return self.room.id == other.room.id and self.time_range.overlaps(other.time_range)
```

> Reservationは「部屋」「時間」「会員」を参照しながら、
> **重複・キャンセルのルールを一貫して管理するルート**になっています。

---

## ⚙ 4. 集約の不変条件（Invariants）

集約を設計する最大の目的は「**不変条件を守る範囲を決める**」ことです。

| 不変条件                    | どこで守る？               |
| ----------------------- | -------------------- |
| `TimeRange.start < end` | ValueObject（型）       |
| 同じRoomで時間帯が重ならない        | ReservationAggregate |
| Memberが有効であること          | ReservationAggregate |
| Capacityを超えない           | Room（内部）             |

> 🧠 **原則：ルールは最も内側で守る。**

---

## 📐 5. 集約の分け方（境界を決めるコツ）

| 判定の質問                       | YESなら別集約にする |
| --------------------------- | ----------- |
| それが別のトランザクションで更新される可能性があるか？ | ✅           |
| それが別のライフサイクルを持っているか？        | ✅           |
| 同時変更の必要がないか？                | ✅           |

### 📊 例：分割結果

| 集約名                      | 集約ルート       | 含まれるもの                 | 備考               |
| ------------------------ | ----------- | ---------------------- | ---------------- |
| **ReservationAggregate** | Reservation | Reservation, TimeRange | Room・Memberは参照のみ |
| **RoomAggregate**        | Room        | Room, Capacity         | 設備情報など           |
| **MemberAggregate**      | Member      | Member, Email          | 会員属性管理           |

> 💬 「同時に更新しないものは別集約」と覚えるとシンプルです。

---

## 🧩 6. トランザクション境界とリポジトリ

各集約は、**自分専用のリポジトリ（Repository）** を持ちます。
これは第2章で見た `ReservationRepository`, `RoomRepository`, `MemberRepository` に対応します。

```
UseCase → ReservationRepository → ReservationAggregate
```

> ✅ **1集約 = 1トランザクション単位**
> UseCaseは、集約単位で完結する処理に限定します。

---

## 🧪 7. 集約ルートのテスト（例）

```python
from datetime import datetime, timedelta
from domain.value_objects import TimeRange
from domain.room import Room, Capacity
from domain.member import Member, Email
from domain.reservation import Reservation

def test_overlap_reservations():
    room = Room(id=1, name="A", capacity=Capacity(10))
    member = Member(id=1, name="Taro", email=Email("taro@example.com"))

    r1 = Reservation(1, member, room, TimeRange(
        datetime(2025,1,1,9), datetime(2025,1,1,10)), 5)
    r2 = Reservation(2, member, room, TimeRange(
        datetime(2025,1,1,9,30), datetime(2025,1,1,10,30)), 5)

    assert r1.overlaps(r2)
```

> 集約ルートに「整合性を守るメソッド」を集めることで、
> テストが「ルール単位」で書けるようになります。

---

## 🎓 演習①：自分の集約を描いてみよう

| 集約名                  | 集約ルート       | 内部要素                    | 不変条件         |
| -------------------- | ----------- | ----------------------- | ------------ |
| ReservationAggregate | Reservation | TimeRange, Room, Member | Roomごとに重複禁止  |
| RoomAggregate        | Room        | Capacity                | Capacity > 0 |
| MemberAggregate      | Member      | Email                   | Email形式が正しい  |

> 💡 集約を「業務ルールを守るための壁」と考えると理解しやすいです。

---

## 🧱 8. 集約の粒度の考え方

### 小さすぎると…

* ルールが散らばる
* 複数のトランザクションを跨ぐ処理が増える

### 大きすぎると…

* 更新競合が増える
* データの整合性確保が難しくなる

> 🎯 目標は「**1回の操作で守るべき一貫性の最小単位**」。

---

## 🧭 9. 集約と他の概念の関係

| 概念                 | 位置づけ           | この章での扱い                    |
| ------------------ | -------------- | -------------------------- |
| **Value Object**   | 集約内部で使う「値のルール」 | TimeRange, Capacity, Email |
| **Entity**         | 集約内部の構成要素      | Reservation, Room, Member  |
| **Aggregate Root** | 集約全体の代表        | Reservation                |
| **Repository**     | 集約を保存・取得する窓口   | ReservationRepository      |

---

## 🧩 10. クリーンアーキテクチャとの対応図

```
[UseCase] ← InputBoundary
    ↓
[Repository契約]
    ↓
[Domain層]
 ├── Aggregate Root（Reservation）
 ├── Value Objects（TimeRange, Capacity, Email）
 └── 不変条件を内部で保証
```

> **UseCaseは集約の中身を知らない。**
> 集約は、「ルールを守るミニドメイン」として閉じています。

---

## ✅ まとめ

| 要点                | 内容                      |
| ----------------- | ----------------------- |
| **集約（Aggregate）** | 一貫性を保つ単位。関連エンティティをまとめる。 |
| **集約ルート**         | 集約を代表し、外部から唯一アクセスできる。   |
| **ルールの場所**        | 不変条件はできるだけ集約の中に閉じ込める。   |
| **リポジトリ**         | 1集約＝1リポジトリ。トランザクション単位。  |
| **設計の狙い**         | データ整合性と変更容易性の両立。        |

---

## 🎓 演習②：境界線を引いてみよう（コンテキスト×集約）

| コンテキスト      | 集約                   | ルート         | ルール例        |
| ----------- | -------------------- | ----------- | ----------- |
| Scheduling  | ReservationAggregate | Reservation | 同室・同時刻の重複禁止 |
| RoomCatalog | RoomAggregate        | Room        | 定員 > 0      |
| Identity    | MemberAggregate      | Member      | メール重複禁止     |

> 💬 こうして整理した集約が、次のSOA段階で**サービスの最小単位**になります。

---

## 🔜 次章予告：第4章「ドメインサービスとファクトリ」

次章では、集約をまたぐロジック（例：予約作成時にRoomとMemberを同時に参照する処理）を
**ドメインサービス（Domain Service）**として整理し、
さらに**Factoryパターン**で「生成のルール」を扱います。

扱うテーマ：

* 集約を横断する業務ルールの扱い方
* 生成を一元管理するFactoryの設計
* テストしやすいドメインロジックの分離方法


