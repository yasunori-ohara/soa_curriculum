## 第4章：テストデータ生成と環境制御


## 🎯 この章の目的

1. **再現性のあるテスト環境**を作る方法を理解する
2. **テストデータの自動生成・リセット**を仕組み化する
3. **Docker・CI環境で同じテストが動く構成**を実現する

---

## 🧩 1. テストの再現性とは？

📘 「再現性」とは、

> **誰が・いつ・どの環境で実行しても、同じ結果になること。**

💡 これが崩れると、

* 「ローカルでは通ったのにCIで落ちる」
* 「昨日は動いていたのに今日は壊れた」
  という状況になります。

**原因の例：**

| 原因        | 説明                |
| --------- | ----------------- |
| データが残っている | テストDBに前回の結果が残存    |
| 時間依存      | 今日の日付・時刻で動作が変わる   |
| 並行実行      | テスト間で同じリソースを触る    |
| 外部依存      | 外部APIやネットワーク状態に依存 |

---

## 🧩 2. テストデータのリセット戦略

📘 各テストを実行するたびに、
**クリーンなデータ状態に戻す**のが基本です。

### 💡 戦略1：In-Memoryデータベース

* SQLiteの `:memory:` モードを使う
* pytestで `setup/teardown` に組み込む

```python
import sqlite3, pytest

@pytest.fixture
def conn():
    conn = sqlite3.connect(":memory:")
    yield conn
    conn.close()
```

---

### 💡 戦略2：Dockerでテスト用DBを起動

* `docker-compose.test.yml` を用意して
  テスト前にコンテナを立ち上げる
* テスト完了後、自動で削除

```yaml
version: "3"
services:
  db:
    image: postgres:15
    environment:
      POSTGRES_DB: test_db
      POSTGRES_USER: test_user
      POSTGRES_PASSWORD: test_pass
    ports:
      - "5433:5432"
```

テスト実行時：

```bash
docker compose -f docker-compose.test.yml up -d
pytest
docker compose -f docker-compose.test.yml down -v
```

---

### 💡 戦略3：フィクスチャデータの再利用

* サンプルデータをYAMLやJSONで定義し、
  テストごとに読み込み直す

```python
import json

def load_fixture(path):
    with open(path) as f:
        return json.load(f)

def test_load_sample():
    data = load_fixture("tests/fixtures/member.json")
    assert data["name"] == "Taro"
```

---

## 🧩 3. 疑似データ生成ツールの活用

📘 テストデータは「量」よりも「多様性」が重要です。
**Faker** を使えば、現実的な疑似データを自動生成できます。

💻 例：

```python
from faker import Faker
fake = Faker("ja_JP")

def test_fake_member():
    name = fake.name()
    email = fake.email()
    print(name, email)
```

💡 利点：

* 名前・住所・電話番号・日時などを自動生成
* 実データを使わずに安全にテスト可能
* Faker Seedを固定すると再現性も担保可能

---

## 🧩 4. 外部サービスのモック化

📘 再現性を崩す最大の要因が「外部依存」です。
API・メール・通知などは **モックサーバー** に置き換えます。

💡 モックサーバーの方法：

| 手法      | ツール例                            | 特徴          |
| ------- | ------------------------------- | ----------- |
| ローカルモック | `pytest-mock` / `unittest.mock` | 関数レベルでの置換   |
| HTTPモック | `responses` / `httpretty`       | APIレスポンスを再現 |
| サービスモック | `WireMock` / `MockServer`       | 複数APIを一括模倣  |

💻 例（responsesを使用）：

```python
import responses, requests

@responses.activate
def test_api_call():
    responses.add(responses.GET, "https://api.example.com/member/1",
                  json={"id": 1, "name": "Taro"}, status=200)
    resp = requests.get("https://api.example.com/member/1")
    assert resp.json()["name"] == "Taro"
```

---

## 🧩 5. 時刻・乱数の固定化

📘 テストが時間に依存していると再現性が失われます。
Pythonなら `freezegun` を使って時刻を固定できます。

💻 例：

```python
from freezegun import freeze_time
from datetime import datetime

@freeze_time("2025-01-01 10:00:00")
def test_time_dependent():
    assert datetime.now().hour == 10
```

💡 同様に、乱数は `random.seed(0)` で固定します。

---

## 🧩 6. CIでの環境制御

📘 CI/CDでは「環境ごとの差異」が最大の敵です。
**Docker化＋環境変数の明示**が再現性を保つ鍵です。

💻 例（GitHub Actions用設定）：

```yaml
name: Test Suite
on: [push]
jobs:
  test:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15
        ports: ['5432:5432']
        env:
          POSTGRES_USER: test_user
          POSTGRES_PASSWORD: test_pass
          POSTGRES_DB: test_db
    steps:
      - uses: actions/checkout@v4
      - name: Install dependencies
        run: pip install -r requirements.txt
      - name: Run tests
        run: pytest
```

💡 この構成で：

* すべてのテストは同じDocker上で実行
* 外部環境差異（OS・DB設定・依存ライブラリ）を除去

---

## 🧩 7. データ・環境再現のベストプラクティス

| 観点    | ベストプラクティス            |
| ----- | -------------------- |
| DB    | テスト開始前に完全リセットする      |
| データ生成 | Fakerで多様データ＋Seed固定   |
| 外部API | モックで完全隔離             |
| 時刻    | freezegunで固定         |
| CI環境  | Docker上で統一実行         |
| 再現性   | “昨日動いたテストが今日も動く” を保証 |

💡 「環境の再現性」が確立すると、
「失敗＝本当にバグ」の状態を作り出せます。

---

## ✅ まとめ

| 要点    | 内容                            |
| ----- | ----------------------------- |
| 再現性   | テストは誰が・どこで・いつ動かしても同じ結果に       |
| データ戦略 | In-memory / Fixture / Faker活用 |
| モック   | 外部依存を切り離す                     |
| 時刻固定  | freezegunで時間差を排除              |
| CI制御  | Docker＋環境変数で統一                |
| 成果    | 信頼できる自動テスト基盤の完成               |

---

## 🔜 次章予告：「第5章　自動テストの可視化とレポート連携」

次章では、自動テストの結果を「見える化」します。
JUnit XML・Allure・GitHub Actionsログなどを活用し、
**失敗原因をチームで即共有できるテスト基盤**を構築します。

