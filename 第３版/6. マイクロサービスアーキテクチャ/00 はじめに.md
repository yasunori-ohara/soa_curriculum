# 第6部：マイクロサービスアーキテクチャ

## 第0章：はじめに — 小さく分けて、大きくつなぐ

この第6部では、これまでに作った
- SOA（サービス指向アーキテクチャ） をさらに発展させ、
- 「**実運用レベルで独立稼働・独立スケールできる構造**」にしていくのが目的です。

マイクロサービスは、SOAの概念を現代クラウドに合わせて具体化したものです。
クリーンアーキテクチャとSOAを理解してきた今だからこそ、
マイクロサービスの「なぜ」「どう」が自然に理解できる段階です。

## 🎯 この章の目的

* マイクロサービスアーキテクチャ（MSA）の基本概念を理解する
* SOAとの違いと関係を明確にする
* なぜ「独立デプロイ」が重要なのかを学ぶ
* 第6部の全体像（設計・通信・運用・観測）を把握する


## 1. マイクロサービスとは何か？

マイクロサービスアーキテクチャ（Microservices Architecture）は、
システムを**独立した小さなサービス群**として構成し、
それぞれを個別に**開発・テスト・デプロイ・スケール**できるようにした設計思想です。

**構造イメージ：**

```
Reservation Service   → 独立したアプリ
Member Service        → 独立したアプリ
Room Service          → 独立したアプリ
```

各サービスは独自の：

* データベース
* デプロイ環境
* 開発チーム
  を持ちます。

---

## 2. SOAとの違い

| 観点   | SOA               | マイクロサービス          |
| ---- | ----------------- | ----------------- |
| 定義   | 契約によるサービス分割       | 独立稼働・独立スケールを重視    |
| 連携方式 | 多様（REST, MQ, ESB） | 主にHTTP/gRPCなど軽量通信 |
| データ  | 共有DBの可能性あり        | サービスごとにDBを分離      |
| デプロイ | 一括または部分更新         | 各サービスを独立デプロイ      |
| 運用単位 | システム単位            | サービス単位（チーム単位）     |
| テスト  | 契約テスト中心           | 契約＋監視・ヘルスチェック含む   |

**まとめ：**

> SOAが「論理的分割」であるのに対し、
> マイクロサービスは「物理的・運用的分割」です。

---

## 3. MSAの3つの核心原則

1. **独立性（Autonomy）**
   　各サービスは独立して開発・テスト・デプロイできる。
   　→ 他サービスに依存せずにリリース可能。

2. **疎結合（Loose Coupling）**
   　サービス間は明示的な契約（API）でつながるだけ。
   　→ 実装変更が他に波及しない。

3. **自己完結性（Self-Contained）**
   　各サービスが自分のデータとロジックを完全に持つ。
   　→ 共有DBを避け、一貫性は最小限の範囲で保つ。

---

## 4. マイクロサービスの構造（内部と外部）

```
Reservation Service
 ├─ クリーンアーキ構造（Entity / UseCase / Infra）
 ├─ 独自DB（reservation.db）
 ├─ API (OpenAPI / gRPC)
 ├─ CI/CDパイプライン
 └─ コンテナ (Docker)
```

同様に Member, Room も独立して存在します。

**特徴：**

* 内部ではクリーンアーキテクチャで整え、
* 外部ではSOA（OpenAPI）でつなぐ。
* さらに、運用面では **Docker / Kubernetes / CI/CD** により独立性を確立します。

---

## 5. マイクロサービスの「チーム構造」

マイクロサービスは**技術構造**ではなく、
**組織構造（チーム分割）**と密接に関係します。

| サービス        | チーム  | 責務            |
| ----------- | ---- | ------------- |
| Reservation | チームA | 予約管理・空き照会     |
| Member      | チームB | 会員管理・状態管理     |
| Room        | チームC | 部屋管理・キャパシティ設定 |

**特徴：**

* 各チームが**自分のサービスを完全に所有（Ownership）**。
* チームごとに**独自の技術選択・開発ペース**を維持できる。

---

## 6. サービス間連携の仕組み（APIとイベント）

マイクロサービスでは、連携手段が2系統あります。

| 種類                | 内容                  | 例                                 |
| ----------------- | ------------------- | --------------------------------- |
| **同期通信（API呼び出し）** | リアルタイム連携（REST/gRPC） | 予約作成時に会員有効性を確認                    |
| **非同期通信（イベント発行）** | 状態変化を通知（Pub/Sub）    | 予約作成時に「ReservationCreated」イベントを発行 |

**設計方針：**

* 「必要なときに即座に知りたい」→ REST / gRPC
* 「後で知ればよい（イベント通知）」→ メッセージング

---

## 7. データ分離と一貫性の考え方

マイクロサービスでは、各サービスが独自DBを持ちます。
そのため、「全体整合性」ではなく「最終整合性（Eventual Consistency）」を採用します。

**例：Reservation作成フロー**

1. Reservation Service が予約を作成
2. イベント `ReservationCreated` を発行
3. Room Service がイベントを受けて空き状況を更新
4. Member Service が予約履歴を記録

**特徴：**

* トランザクションをまたがない（分散トランザクションを避ける）
* イベントで結果整合性を保つ

---

## 8. コンテナ化とデプロイ戦略

| 構成要素                  | 目的                |
| --------------------- | ----------------- |
| **Docker**            | 各サービスを独立実行可能な形にする |
| **Kubernetes（K8s）**   | サービス群をスケーラブルに管理   |
| **CI/CDパイプライン**       | ビルド・テスト・デプロイを自動化  |
| **Service Discovery** | 各サービスのアドレス解決を自動化  |
| **API Gateway**       | 外部からの統一的な入口を提供    |

**例：サービス起動構成（docker-compose.yml）**

```yaml
services:
  member:
    build: ./member
    ports: ["8001:8000"]
  room:
    build: ./room
    ports: ["8002:8000"]
  reservation:
    build: ./reservation
    ports: ["8003:8000"]
    depends_on: [member, room]
```

**ポイント：**

> すべてのサービスがDocker上で独立稼働し、
> コンテナオーケストレーションでスケール可能。

---

## 9. マイクロサービスの課題と対策

| 課題             | 対策                                       |
| -------------- | ---------------------------------------- |
| サービス数の増加による複雑化 | サービスカタログで契約と依存関係を一元管理                    |
| 通信遅延や障害        | Circuit Breaker（遮断器）パターンで制御              |
| ログが分散          | 統合ログ基盤（ELK Stack, OpenTelemetry）を導入      |
| テストの難化         | 契約テスト＋統合テストで保証                           |
| 運用監視           | Health Check / Metrics / Tracingで可観測性を確保 |

---

## 10. まとめ

| 要点   | 内容                              |
| ---- | ------------------------------- |
| 基本概念 | マイクロサービスはSOAを実運用レベルに進化させた形      |
| 独立性  | 各サービスが独立して開発・テスト・デプロイできる        |
| データ  | サービスごとにDBを分離し、最終整合性を保つ          |
| 通信   | REST/gRPC（同期）＋ イベント（非同期）        |
| 運用   | Docker / K8s / CI/CD / サービスカタログ |
| 効果   | 柔軟性・スケーラビリティ・チーム独立性の向上          |

---

## 🔜 第1章予告：「マイクロサービス設計の原則と分割戦略」

次章では、

* マイクロサービスをどの粒度で分けるか
* チーム・データ・ドメインの対応関係をどう決めるか
* クリーンアーキテクチャとどう組み合わせるか

を、具体的な設計パターン（境界づけ・依存分離・分散整合性モデル）を交えて解説します。


