## 第4章：運用・監視・トレーシング ― 可観測性（Observability）の設計


## 🎯 この章の目的

1. マイクロサービスの運用段階で発生する問題を、リアルタイムに把握できるようにする
2. ログ、メトリクス、トレーシングの３つの観測軸を理解する
3. 「問題を再現しなくても原因がわかる」状態を設計する

---

## 🧩 1. 可観測性（Observability）とは

💡 可観測性とは、「**システムの内部状態を外から見えるようにする能力**」です。
マイクロサービスでは、複数の小さなサービスが同時に動くため、
どこで遅延が起きているか・どのAPIが失敗したかがわからなくなることがあります。

可観測性は、その「見えない内部」を可視化して、
**迅速な原因特定と復旧**を可能にします。

---

## 🧩 2. 可観測性を支える3つの柱

🧠 ３つの観測軸を覚えましょう。

```
ログ（Logs）       → 何が起こったか
メトリクス（Metrics） → 状態を数値で見る
トレーシング（Tracing） → どこを通って処理されたか
```

| 軸      | 内容               | 目的          |
| ------ | ---------------- | ----------- |
| ログ     | 各サービスの詳細な記録      | 例外や警告を確認    |
| メトリクス  | CPU、メモリ、リクエスト数など | 状態変化を定量的に把握 |
| トレーシング | サービス間リクエストの流れ    | ボトルネックの特定   |

---

## 🧩 3. ログ設計 ― 「読める」ログを書く

💡 ログは人間にも機械にもわかる形式で書く必要があります。

良いログ設計のポイント：

```
[時刻] [サービス名] [リクエストID] [レベル] メッセージ
```

💻 例：

```
2025-10-19T12:01:22Z  reservation-service  [req:abc123]  INFO  Created reservation ID=512
```

⚠️ 注意：

* ただの `print()` ログでは、マイクロサービス全体の流れは追えません。
* `リクエストID` や `トレースID` を一貫して渡す設計にすることが重要です。

---

## 🧩 4. メトリクス ― 状態を数字で見る

🧩 メトリクスは「システムの健康診断」です。
CPU使用率やレスポンス時間など、一定間隔で数値を記録します。

💻 例（Prometheusのメトリクス定義）：

```python
from prometheus_client import Counter

request_count = Counter(
    'reservation_requests_total', 
    'Number of reservation requests'
)
```

💡 可観測性を高めるには、「成功率」「遅延」「エラー率」を
**サービス単位で記録する**ことがポイントです。

---

## 🧩 5. トレーシング ― リクエストの通り道を追う

🧩 サービス間通信が多いマイクロサービスでは、
「どの経路で遅延が発生しているのか」を見つけるのが困難です。

そこで使うのが **分散トレーシング**。
リクエストが通過するたびに「トレースID」を付与して追跡します。

💻 例：

```
[trace-id:xyz789]
  Member Service   → OK (15ms)
  Reservation Svc  → OK (41ms)
  Payment Svc      → ERROR (Timeout)
```

💡 OpenTelemetry や Jaeger、Zipkin などのツールを用いることで、
このトレースをグラフとして可視化できます。

---

## 🧩 6. アラートとSLO（Service Level Objective）

⚙️ 運用では「いつ異常を検知し、どう対応するか」が重要です。

🧠 基本的な考え方：

```
SLO（目標） → SLI（実測） → アラート条件
```

💡 例：

| 項目     | 目標（SLO） | 実測（SLI） | 対応          |
| ------ | ------- | ------- | ----------- |
| API成功率 | 99.9%以上 | 99.7%   | アラート発報・原因調査 |
| 応答時間   | 500ms以内 | 620ms   | 負荷状況の分析     |

⚠️ 注意：
アラートは「行動につながるもの」だけに絞りましょう。
むやみに通知すると、運用者が“アラート疲れ”を起こします。

---

## 🧩 7. 可観測性を設計段階で組み込む

💡 可観測性は“あとづけ”ではなく、設計時点から考慮します。

🧠 サービス設計時に決めておくべき項目：

```
・共通ログフォーマット（時刻・トレースID必須）
・共通メトリクス命名規則
・リクエストIDの伝搬方式
・アラート閾値の共通基準
・監視ダッシュボード（Grafanaなど）
```

✅ これらを「Observability設計書」として明文化しておくと、
チームが変わっても運用ルールが守られます。

---

## 🧩 8. 実践ツールの組み合わせ例

💻 一般的なOSS構成：

```
ログ        → ELKスタック（Elasticsearch / Logstash / Kibana）
メトリクス  → Prometheus + Grafana
トレーシング → Jaeger（またはOpenTelemetry）
```

🧩 全体の構成イメージ：

```
各サービス ─→ OpenTelemetry ─→ Prometheus ─→ Grafana（可視化）
             └→ Jaeger（トレーシング表示）
             └→ Elasticsearch（ログ検索）
```

💡 これにより、「異常の発生源」「頻度」「影響範囲」が
即座に把握できる体制が作れます。

---

## 🧩 9. チーム運用での注意点

⚠️ よくある失敗：

| 問題          | 原因              | 対策              |
| ----------- | --------------- | --------------- |
| ログが統一されていない | 各チームが独自フォーマット   | 共通ライブラリで統一      |
| メトリクスが乱立    | 命名規則がない         | チーム間レビューを導入     |
| トレースが途切れる   | リクエストIDが引き継がれない | Middlewareで自動伝搬 |
| アラート過多      | 閾値が適当           | “行動可能なアラート”に限定  |

💡 可観測性は「チーム文化」で維持されます。
ルールではなく、**日常的なレビューと共有**が鍵です。

---

## ✅ まとめ

| 要点      | 内容                                        |
| ------- | ----------------------------------------- |
| 可観測性    | 内部状態を外部から観測できる設計                          |
| ログ      | 事実を残す・トレースIDで結ぶ                           |
| メトリクス   | 状態を数値で把握する                                |
| トレーシング  | リクエスト経路を可視化する                             |
| SLO/SLI | 目標と実測を定義しアラートに結びつける                       |
| 実装      | Prometheus / Grafana / JaegerなどOSSを組み合わせる |

---

## 🔜 次章予告：「マイクロサービスの拡張とガバナンス」

次章では、サービス数が増えたときにどのように管理するかを扱います。
APIバージョン管理、サービスディスカバリ、セキュリティ、ポリシー統制など、
「成長しても崩れないマイクロサービス運用構造」を学びます。

