## 第7章：品質・信頼性とリカバリ設計（Resilience Design）

## 🎯 この章の目的

1. サービスが障害に強くなる「**フォールトトレランス設計**」を理解する
2. 通信・依存障害を防ぐ「**サーキットブレーカー／リトライ戦略**」を学ぶ
3. 障害を検知・回復するための「**自己修復メカニズム**」を設計する
4. 「止まらないマイクロサービス」を実現するための実践パターンを習得する

---

## 🧩 1. マイクロサービスの信頼性設計とは？

マイクロサービスは「分ける」ことによって可用性を高めますが、
同時に**通信経路が増える＝障害点も増える**というリスクを持ちます。

📘 基本原則：

| 設計の目的             | 対応する手法     |
| ----------------- | ---------- |
| サービスが落ちても全体は止まらない | フォールトトレランス |
| 一部の失敗を局所化する       | サーキットブレーカー |
| 一時的なエラーを回復        | リトライ戦略     |
| 状態を自動復旧           | セルフヒーリング   |
| 全体の挙動を観測可能にする     | 可観測性（前章参照） |

💡 信頼性設計とは「障害を防ぐこと」ではなく、

> 「障害が起きてもサービスを継続できるようにする」ための工夫。

---

## 🧩 2. フォールトトレランス（Fault Tolerance）の基本

📘 フォールトトレランスとは、**一部の構成要素が壊れても全体が動く**ように設計することです。

💡 代表的な手法：

| 分類       | 内容           | 例                              |
| -------- | ------------ | ------------------------------ |
| 冗長化      | 予備サーバを常時起動   | ReplicaSet, AutoScaling        |
| フェイルオーバー | 障害時に自動切替     | Load Balancer, Leader Election |
| デグレード動作  | 機能を一部制限して継続  | 「予約照会のみ利用可」など                  |
| キャッシュ活用  | 一時的に古いデータで対応 | Redis, CDN                     |

📘 例（フェイルオーバー構成イメージ）：

　User
　↓
　Load Balancer
　↓
　Service A（Active） ←→ Service A’（Standby）

💡 Kubernetesでは、ReplicaSetやLiveness Probeによって
自動的にフォールトトレランス構成を実現できます。

---

## 🧩 3. サーキットブレーカー（Circuit Breaker）

📘 サーキットブレーカーとは、
「失敗を検知したら一時的に呼び出しを遮断する」仕組みです。

💡 目的：

> 依存先サービスの障害が**連鎖的に波及することを防ぐ**。

📘 状態の推移：

　Closed（通常状態）
　　↓（失敗が連続）
　Open（呼び出し停止）
　　↓（一定時間経過後）
　Half-Open（試行復帰）
　　↓（成功）
　Closedへ戻る

💻 疑似コード例：

```python
if breaker.state == "open":
    raise ServiceUnavailable()
try:
    result = call_api()
    breaker.record_success()
except:
    breaker.record_failure()
    if breaker.failure_count > 5:
        breaker.open()
```

📘 実装例：
Resilience4j（Java）、Hystrix（旧Netflix OSS）、Python CircuitBreaker、Istio RetryPolicyなど。

---

## 🧩 4. リトライ戦略（Retry Strategy）

📘 リトライは「一時的な通信エラー」を自動で再試行する戦略です。
ただし、無制限リトライは逆効果になります。

💡 設計ポイント：

| ポイント  | 内容                           |
| ----- | ---------------------------- |
| 回数制限  | 最大3回までなど制限を設ける               |
| バックオフ | 再試行間隔を徐々に伸ばす（例：1s → 2s → 4s） |
| ジッター  | 再試行のタイミングをランダム化して輻輳を防ぐ       |
| 区別    | 400系（クライアントエラー）はリトライしない      |

📘 実装イメージ：

　API呼び出し
　→ 失敗
　→ 1秒後リトライ
　→ 2秒後リトライ
　→ 成功 or 諦め

💡 「サーキットブレーカー＋リトライ」は対になる設計です。

> リトライが多すぎると障害が拡大するため、ブレーカーが安全弁になります。

---

## 🧩 5. タイムアウトとフェイルファスト

📘 「相手が遅い」も立派な障害です。
タイムアウトを明示的に設定し、待ちすぎないことが重要です。

💡 原則：

| 項目        | 推奨設定          |
| --------- | ------------- |
| HTTPリクエスト | 1〜3秒以内にタイムアウト |
| DBクエリ     | 2〜5秒以内        |
| メッセージ処理   | リトライ間隔＋上限を設定  |

📘 フェイルファスト（Fail Fast）とは、

> 「異常を検知したら即座に失敗を返す」設計思想。
> 長時間ブロックよりも、**早く諦めて上位層で代替する**方がシステム全体に優しい。

---

## 🧩 6. バルクヘッド（Bulkhead）パターン

📘 バルクヘッドとは、**障害を隔離**して影響範囲を最小化する設計です。
船の防水区画に由来します。

📘 イメージ：

　Service全体
　├── スレッドプールA：Reservation処理
　├── スレッドプールB：Notification処理
　└── スレッドプールC：Analytics処理

💡 これにより、Analyticsが遅延してもReservationには影響しません。

---

## 🧩 7. セルフヒーリング（Self-Healing）

📘 セルフヒーリングとは、障害発生後に**自動で回復**する仕組みを指します。

💡 実例：

| 対象      | 自動修復手段                     |
| ------- | -------------------------- |
| コンテナ停止  | Kubernetes の RestartPolicy |
| メモリリーク  | Liveness Probe による再起動      |
| 不達メッセージ | Dead Letter Queue（DLQ）で再送  |
| 状態異常    | ヘルスチェック＋オートスケール            |

📘 原則：

> 「人が復旧に入る前に、機械が1回直す」
> 手動対応は最終手段とする。

---

## 🧩 8. 冗長性とスケーリングの設計

📘 信頼性を上げるには「単一障害点（Single Point of Failure）」をなくすことが重要。

💡 典型パターン：

| 対象         | 対策                         |
| ---------- | -------------------------- |
| APIサーバ     | 水平スケール（Auto Scaling Group） |
| DB         | マスタ＋レプリカ構成                 |
| キャッシュ      | シャーディング＋フェイルオーバー           |
| メッセージブローカー | クラスタリング構成                  |

📘 Kubernetesやクラウド環境では、これらの構成を**YAML設定だけで実現**できます。

---

## 🧩 9. カオスエンジニアリング（Chaos Engineering）

📘 信頼性設計の最終段階は「壊して確かめる」こと。
カオスエンジニアリングとは、**意図的に障害を発生させて**耐性を検証する手法です。

💡 代表的な実践：

| 手法                    | 内容                     |
| --------------------- | ---------------------- |
| Chaos Monkey          | ランダムにサーバを落とす（Netflix発） |
| Gremlin               | ネットワーク遅延・CPU負荷を注入      |
| Istio Fault Injection | Kubernetes上で遅延やエラーを模擬  |

📘 目的：

> 想定外の障害でも全体が「優雅に劣化（Graceful Degradation）」することを確認する。

---

## ✅ まとめ

| 要点              | 内容              |
| --------------- | --------------- |
| フォールトトレランス      | 障害に強い冗長化・自動切替設計 |
| サーキットブレーカー      | 依存障害の波及を防ぐ安全弁   |
| リトライ戦略          | 一時的な失敗からの回復     |
| タイムアウト／フェイルファスト | 長時間待機を避けて速く失敗   |
| バルクヘッド          | 処理を分離して影響範囲を最小化 |
| セルフヒーリング        | 自動回復による安定稼働     |
| カオスエンジニアリング     | 実際に壊して耐性を検証     |

---

## 🔜 次章予告：「第8章　まとめと発展 ― サービスアーキテクチャの未来」

次章では、クリーンアーキテクチャ、DDD、SOA、そしてマイクロサービスを
一貫した流れで振り返り、
「**アーキテクチャの進化がどこへ向かうか**」を整理します。

