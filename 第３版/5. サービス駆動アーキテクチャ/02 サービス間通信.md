## 第2章：サービス間通信（REST / gRPC / 非同期）

この章では、前章で定義した「サービス間契約（OpenAPI）」をもとに、
実際にサービス間で**どのように通信を行うか**を理解します。
REST・gRPC・非同期（メッセージング）の3方式を、
設計・技術・アーキテクチャの観点から比較して整理します。

## 🎯 この章の目的

* サービス間通信の3つの方式（REST / gRPC / 非同期）を理解する
* サービス間呼び出しの構造を把握する
* それぞれの方式の使い分け方と設計上の注意点を学ぶ

---

## 1. サービス間通信の基本構造

各サービスは内部的にはクリーンアーキテクチャ構造を持っていますが、
サービス同士の通信は外部API（契約）を通じて行われます。

**通信の流れ（概念）：**

```
[Reservation Service]
   ↓  REST / gRPC / Message
[Member Service]
   ↓
[Room Service]
```

**説明：**

* Reservation Service は、Member / Room への問い合わせを行う。
* その際、直接関数呼び出しではなく「ネットワーク越しの通信」でやりとりする。
* この「通信方式」をどう選ぶかがSOA設計の鍵になります。

---

## 2. 通信方式の3種類

| 通信方式             | 通信形態                      | 特徴                  | 適した用途               |
| ---------------- | ------------------------- | ------------------- | ------------------- |
| **REST**         | HTTP + JSON               | シンプルで標準的。多くの環境で使える。 | Webシステム全般、非リアルタイム通信 |
| **gRPC**         | HTTP/2 + Protocol Buffers | 高速・型安全・双方向通信も可能。    | 高頻度API、内部マイクロサービス間  |
| **非同期（メッセージング）** | Pub/Sub / キュー             | 非同期・疎結合。送信と受信を分離。   | 通知・イベント駆動処理・バッチ通信   |

---

## 3. REST通信（最も基本的な方式）

### 構造

```
Reservation Service → (HTTP GET /members/{id}) → Member Service
```

### メリット

* 実装が簡単（HTTPライブラリだけで利用可能）
* OpenAPIで設計・テストが容易
* JSON形式で人間にも読みやすい

### デメリット

* テキストベースなので通信量が多い
* 双方向通信には向かない
* 呼び出しのたびにHTTP接続が発生

### Pythonでの例

```python
import requests

def get_member_info(member_id: int):
    url = f"http://member-service:8000/members/{member_id}"
    response = requests.get(url)
    if response.status_code == 200:
        return response.json()
    else:
        raise Exception("Member not found")
```

**ポイント：**

> RESTは最も理解しやすく、教育用や業務システムでまず採用される通信方式。

---

## 4. gRPC通信（高速・型安全なRPC）

### 構造

```
Reservation Service ⇄ Member Service（gRPC over HTTP/2）
```

### 特徴

* Protocol Buffers（.proto）による明確な型定義
* HTTP/2を利用したバイナリ通信（軽量で高速）
* 双方向ストリーミング対応（リアルタイム処理も可能）

### メリット

* 高速でスケーラブル
* 型安全（コンパイル時に通信定義を検証可能）
* サービス間契約を.protoファイルで共有できる

### デメリット

* 開発環境構築にやや手間（コード生成が必要）
* ブラウザなど一部環境では直接利用できない

### gRPCの定義例（member.proto）

```proto
syntax = "proto3";

service MemberService {
  rpc GetMember (MemberRequest) returns (MemberReply);
}

message MemberRequest {
  int32 id = 1;
}

message MemberReply {
  int32 id = 1;
  string name = 2;
  string email = 3;
  bool is_active = 4;
}
```

**ポイント：**

> gRPCは、マイクロサービス間での**内部通信**に特に適しています。
> OpenAPIに対応する「型付き通信の契約」を実現します。

---

## 5. 非同期通信（Pub/Sub、メッセージング）

### 構造

```
Reservation Service → publish "ReservationCreated" → Message Queue
Room Service → subscribe "ReservationCreated"
```

### 特徴

* サービス間の**同期的な依存**をなくす
* キューやトピックを介してメッセージを送受信
* RabbitMQ、Kafka、AWS SNS/SQS などが代表的

### メリット

* 相手が一時的に停止していても処理を継続可能
* サービスの独立性が高い
* イベント駆動アーキテクチャ（EDA）に発展可能

### デメリット

* 呼び出しタイミングが制御しにくい
* 処理順序の保証が難しい場合がある
* 実装が複雑化しやすい（特に再送・冪等性管理）

### Pythonでの疑似例

```python
# Reservation Service: publish message
message = {
  "event": "ReservationCreated",
  "reservation_id": 1001,
  "room_id": 7
}
message_bus.publish("reservation.events", message)

# Room Service: subscribe to events
def on_reservation_created(message):
    print(f"Room {message['room_id']} booked.")

message_bus.subscribe("reservation.events", on_reservation_created)
```

**ポイント：**

> 非同期通信は「つながらなくても進む」仕組みを作る。
> 大規模システムやIoT分野で多用されます。

---

## 6. 通信方式の比較まとめ

| 比較項目    | REST           | gRPC             | 非同期メッセージング         |
| ------- | -------------- | ---------------- | ------------------ |
| データ形式   | JSON           | Protocol Buffers | JSON / Avroなど      |
| 通信方向    | 一方向            | 双方向も可            | 非同期（Pub/Sub）       |
| パフォーマンス | 中              | 高                | 中〜高                |
| 実装難易度   | 低              | 中                | 高                  |
| 主な用途    | 外部API公開        | 内部サービス通信         | イベント駆動処理           |
| 契約定義    | OpenAPI (YAML) | .proto           | JSON Schema / Avro |

**結論：**

* **外部向けAPI → REST**
* **内部向けAPI → gRPC**
* **イベント連携 → 非同期メッセージング**

---

## 7. 設計上の注意点

1. **サービス間の再試行（Retry）**

   * ネットワーク遅延や一時エラーを考慮して再送設計を行う
2. **冪等性（Idempotency）**

   * 同じリクエストを複数回送っても結果が変わらないようにする
3. **タイムアウト**

   * 外部サービス呼び出しには明示的なタイムアウト設定を入れる
4. **フォールバック**

   * 呼び出し失敗時に代替ルート（キャッシュ・別サービス）を検討する
5. **監視とトレース**

   * サービス間通信にはトレースIDを付与し、可視化ツール（Jaeger等）で追跡する

---

## 8. サービス間通信の設計パターン

| パターン名                                               | 概要                     | 利点          |
| --------------------------------------------------- | ---------------------- | ----------- |
| **API Composition**                                 | 複数サービスの結果を統合して返す       | RESTでよく使われる |
| **Command Query Responsibility Segregation (CQRS)** | コマンド（更新）とクエリ（参照）を分ける   | メッセージングに適合  |
| **Event-Driven Architecture (EDA)**                 | 変更をイベントとして発行し、他サービスが反応 | 疎結合で柔軟性が高い  |

---

## 9. 学習の進め方（演習案）

**演習1：REST呼び出しの実装練習**

* `Reservation Service` から `Member Service` をRESTで呼び出すスクリプトを作成

**演習2：gRPC通信の試作**

* `.proto` ファイルを作成し、gRPCサーバ／クライアントを構築

**演習3：非同期通信のシミュレーション**

* 簡易メッセージキューを使い、イベント通知を試す

---

## 10. まとめ

| 要点         | 内容                       |
| ---------- | ------------------------ |
| 通信方式の目的    | サービス間で契約に基づいてデータをやり取りする  |
| REST       | 最も広く使われるシンプルなHTTP通信方式    |
| gRPC       | 高速・型安全でマイクロサービスに最適       |
| 非同期メッセージング | 疎結合でイベント駆動型に向く           |
| 設計ポイント     | 冪等性・再送・トレース・フォールバックを考慮   |
| 推奨方針       | 外部はREST、内部はgRPC、イベントは非同期 |

---

## 🔜 次章予告：第3章「契約テストとサービスカタログ」

次章では、OpenAPIや.protoで定義した**契約（Contract）**に対して、
サービス実装が正しく準拠しているかを確認する
**契約テスト（Contract Test）**の考え方を学びます。

併せて、組織的にサービス契約を管理する「**サービスカタログ**」の仕組みも紹介します。


