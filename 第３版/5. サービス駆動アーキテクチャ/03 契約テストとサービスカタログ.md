## 第3章：契約テストとサービスカタログ

この章では、前章で定義したサービス間の「契約（Contract）」が
**実装と常に一致していることを保証する仕組み**を学びます。
加えて、組織全体でAPI契約を**一元管理する仕組み（サービスカタログ）**についても解説します。

## 🎯 この章の目的

* 契約テスト（Contract Test）の考え方と目的を理解する
* OpenAPIやgRPCの契約に対してテストを行う方法を学ぶ
* サービスカタログを使った契約の一元管理の仕組みを理解する

---

## 1. 契約テストとは何か

**定義：**
サービス間通信の**契約（API仕様）**が、
**実際の実装と一致しているかを検証するテスト**です。

**目的：**

* サービス間の整合性を保証する
* 契約変更による不具合を早期に検知する
* チーム間で独立して開発しても、安全に連携できるようにする

---

### 例（考え方）

```
Reservation Service → Member Service の呼び出し
```

* Reservation側が想定する `GET /members/{id}` のレスポンスが
  Member側の実装と違っていないかを検証する。

**もし不一致が起きると…**

* Reservation Service が `is_active` フィールドを期待しているのに、
  Member Service がレスポンスからそれを削除していたら通信が失敗します。

契約テストはこのような「見えない破壊的変更」を防ぐための仕組みです。

---

## 2. 契約テストの種類

| 種類                     | テスト対象                        | 概要               |
| ---------------------- | ---------------------------- | ---------------- |
| **Consumer Test（利用側）** | 呼び出す側（例：Reservation Service） | 契約に基づいたモックAPIで検証 |
| **Provider Test（提供側）** | 提供する側（例：Member Service）      | 契約通りのレスポンスを返すか検証 |

**説明：**

* Consumerは「このAPIがこう返ってくる前提で動作する」ことを確認
* Providerは「契約仕様どおりにレスポンスしている」ことを保証

両方の観点を合わせることで、安全に連携ができます。

---

## 3. OpenAPIを使った契約テスト

**前提：**
各サービスのOpenAPI仕様（例：`member.yaml`）が定義済み。

### (1) Consumer側のテスト例（利用側）

```python
from openapi_core import create_spec
from openapi_core.validation.response.validators import ResponseValidator
from openapi_spec_validator import validate_spec
import requests
import yaml

# OpenAPI定義をロード
spec = create_spec(yaml.safe_load(open("member.yaml")))

# Member Serviceの実レスポンスを取得
resp = requests.get("http://localhost:8000/members/1")

# レスポンスの検証
validator = ResponseValidator(spec)
result = validator.validate(resp)
assert not result.errors, f"Contract violation: {result.errors}"
```

**目的：**

* 実際のHTTPレスポンスがOpenAPIの契約定義に適合しているかを確認する。
* 不一致（フィールド欠落・型不整合など）があれば失敗。

---

### (2) Provider側のテスト例（提供側）

```python
from openapi_core import create_spec
from openapi_core.validation.request.validators import RequestValidator
import yaml
from fastapi.testclient import TestClient
from app import app  # Member Serviceの実装

spec = create_spec(yaml.safe_load(open("member.yaml")))
validator = RequestValidator(spec)
client = TestClient(app)

# OpenAPI仕様に定義されたパラメータでリクエスト
response = client.get("/members/1")

# スキーマ検証
result = validator.validate(response.request)
assert response.status_code == 200
```

**ポイント：**

* Provider（サービス実装）が契約定義と一致しているかをテストする。
* これにより、APIの破壊的変更を防げる。

---

## 4. gRPCでの契約テスト（protoファイル）

gRPCでは、`.proto` ファイルが契約の役割を果たします。

### Consumer側テストの例（擬似コード）

```python
import grpc
from generated import member_pb2, member_pb2_grpc

def test_grpc_contract():
    channel = grpc.insecure_channel("localhost:50051")
    stub = member_pb2_grpc.MemberServiceStub(channel)
    response = stub.GetMember(member_pb2.MemberRequest(id=1))
    assert isinstance(response.name, str)
    assert isinstance(response.is_active, bool)
```

**説明：**

* `.proto` に基づき自動生成されたクライアントコードを利用。
* 「通信できるか」だけでなく「返り値の型が契約どおりか」を確認する。

---

## 5. 契約テストをCIに組み込む

**一般的な手順：**

1. OpenAPI（または.proto）ファイルをリポジトリに含める
2. CIパイプラインでProvider / Consumer両方のテストを実行
3. 契約が変更された場合、下位互換性をチェック
4. 問題があればマージをブロック

**CI例（GitHub Actions YAML抜粋）：**

```yaml
name: Contract Test
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: pip install openapi-core openapi-spec-validator
      - run: pytest tests/contract
```

**効果：**

> 契約テストを自動化することで、「破壊的変更」を本番前に防げます。

---

## 6. サービスカタログとは

**定義：**
組織内のすべてのサービスの「契約仕様（API）」を一元的に管理する仕組み。

**目的：**

* サービス間依存を可視化
* 各サービスの契約をバージョン管理
* 新しいチームが既存APIを再利用しやすくする

---

### サービスカタログの例（構造）

```
/service-catalog/
 ├─ reservation/
 │   └─ reservation.yaml
 ├─ member/
 │   └─ member.yaml
 ├─ room/
 │   └─ room.yaml
 └─ index.yaml   ← サービス一覧と依存関係を定義
```

**index.yaml の例：**

```yaml
services:
  - name: Reservation
    version: 1.2.0
    contract: ./reservation/reservation.yaml
    depends_on:
      - Member
      - Room

  - name: Member
    version: 1.0.1
    contract: ./member/member.yaml

  - name: Room
    version: 1.1.0
    contract: ./room/room.yaml
```

**説明：**

* 各サービスのAPI契約を明示し、依存関係を一覧化。
* 自動テストやAPIドキュメント生成に活用できる。

---

## 7. 契約変更時のバージョン管理

| 変更内容            | バージョンの上げ方    | 説明              |
| --------------- | ------------ | --------------- |
| 後方互換あり（追加）      | マイナーバージョンアップ | 例：1.2 → 1.3     |
| 後方互換なし（削除・構造変更） | メジャーバージョンアップ | 例：1.3 → 2.0     |
| バグ修正            | パッチバージョンアップ  | 例：1.2.1 → 1.2.2 |

**ルール：**

> 常に **Semantic Versioning（セマンティックバージョニング）** に基づくこと。
> 契約が変わるたびに、テストとカタログを更新する。

---

## 8. 契約テストのメリットまとめ

| 観点      | 効果                 |
| ------- | ------------------ |
| 変更検出    | 契約の破壊的変更を早期に検知     |
| 安定性     | サービス間連携が安定する       |
| チーム独立性  | サービスごとに独立開発が可能     |
| 自動化     | CI/CDで契約整合性を常にチェック |
| ドキュメント性 | サービス仕様を常に最新に保てる    |

---

## 9. サービスカタログ運用のポイント

* すべてのサービスが自分の契約ファイルを管理する
* index.yamlで依存関係を明示する
* 自動生成ツール（例：Swagger UI, Redocly）で閲覧可能にする
* 社内ポータルでAPI仕様を検索・再利用できるようにする

**説明：**

> サービスカタログは「組織の契約リポジトリ」。
> API設計の再利用性と透明性を高めます。

---

## 10. まとめ

| 要点                      | 内容                              |
| ----------------------- | ------------------------------- |
| 契約テスト                   | サービス間契約（OpenAPIや.proto）を検証するテスト |
| Consumer / Provider テスト | 利用側・提供側の両面で整合性を確認               |
| CI統合                    | 契約の破壊的変更を自動検出                   |
| サービスカタログ                | 全API契約を一元管理する仕組み                |
| 成果                      | サービス連携の信頼性・透明性・再利用性が向上する        |

---

## 🔜 次章予告：第4章「SOA × クリーンアーキテクチャの統合」

次章では、SOAで分割された各サービス（Reservation, Member, Room）が、
内部的にクリーンアーキテクチャ構造（Entity, UseCase, Interface, Infra）を持ち、
外部的にAPI契約（OpenAPI）でつながる全体構造を設計します。

扱うテーマ：

* サービス内層構造（DDD + Clean Architecture）
* サービス間接続（OpenAPI Contract）
* 統合構成図とチーム開発モデル


